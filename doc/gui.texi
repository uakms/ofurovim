@ifset JA  @c ----------- v -----------  JA  -*- tab-width: 8 -*-
@node gui.txt, , , 目次
@unnumbered グラフィカルユーザーインターフェイス (GUI)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*gui.txt*       For Vim version 8.1.  Last change: 2018 Mar 06


		  VIM REFERENCE MANUAL    by Bram Moolenaar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
*gui.txt*       For Vim バージョン 8.1.  Last change: 2018 Mar 06


                VIMリファレンスマニュアル    by Bram Moolenaar
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Vim's Graphical User Interface				*gui* *GUI*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui}
@anchor{GUI}
@cindex gui
@cindex GUI
Vim のグラフィカルユーザーインターフェイス
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. Starting the GUI		|gui-start|
2. Scrollbars			|gui-scrollbars|
3. Mouse Control		|gui-mouse|
4. Making GUI Selections	|gui-selections|
5. Menus			|menus|
6. Extras			|gui-extras|
7. Shell Commands		|gui-shell|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .5 .5
@item 1. GUI の開始 @tab |@ref{gui-start}|
@item 2. スクロールバー @tab |@ref{gui-scrollbars}|
@item 3. マウス制御 @tab |@ref{gui-mouse}|
@item 4. GUI選択の作成 @tab |@ref{gui-selections}|
@item 5. メニュー @tab |@ref{menus}|
@item 6. 付記 @tab |@ref{gui-extras}|
@item 7. シェルコマンド @tab |@ref{gui-shell}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Other GUI documentation:
|gui_x11.txt|	For specific items of the X11 GUI.
|gui_w32.txt|	For specific items of the Win32 GUI.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
他の GUI ドキュメント:
@multitable @columnfractions .3 .7
@item |@ref{gui_x11.txt}| @tab X11 GUI に特有の項目について。
@item |@ref{gui_w32.txt}| @tab Win32 GUI に特有の項目について。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{Vi does not have any of these commands}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{Vi にはこれらのコマンドはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
1. Starting the GUI				*gui-start* *E229* *E233*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-start}
@anchor{E229}
@anchor{E233}
@cindex gui-start
@erindex E229
@erindex E233
@section 1. GUIの開始
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
First you must make sure you actually have a version of Vim with the GUI code
included.  You can check this with the ":version" command, it says "with xxx
GUI", where "xxx" is MacVim, X11-Motif, X11-Athena, Photon, GTK2, GTK3, etc., or
"MS-Windows 32 bit GUI version".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
まずは Vim が GUI に対応したバージョンであるか確認する必要がある。それは "@command{:version}" コマンドで調べることができる。その出力が "with xxx GUI" または "MS-Windows 32 bit GUI version" を含んでいれば問題ない。ここで "xxx" は MacVim, X11-Motif, X11-Athena, Photon, GTK2, GTK3 などである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
How to start the GUI depends on the system used.  Mostly you can run the
GUI version of Vim with:
    gvim [options] [files...]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
どのように GUI で起動するかは使用しているシステムに依存する。たいていはこのようにして GUI 版の Vim を実行できる:
@verbatim
gvim [options] [files...]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The X11 version of Vim can run both in GUI and in non-GUI mode.  See
|gui-x11-start|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim の X11 バージョンは GUI と GUI でないモードの両方で実行することができる。|@ref{gui-x11-start}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			*gui-init* *gvimrc* *.gvimrc* *_gvimrc* *$MYGVIMRC*
The gvimrc file is where GUI-specific startup commands should be placed.  It
is always sourced after the |vimrc| file.  If you have one then the $MYGVIMRC
environment variable has its name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-init}
@anchor{gvimrc}
@anchor{.gvimrc}
@anchor{_gvimrc}
@anchor{$MYGVIMRC}
@cindex gui-init
@cindex gvimrc
@cindex .gvimrc
@cindex _gvimrc
@vindex $MYGVIMRC
gvimrc は GUI 固有の初期化コマンドを書くためのファイルである。gvimrc は常にファイル |@ref{vimrc}| の後に読み込まれる。環境変数 @env{$MYGVIMRC} があると、その値が gvimrc の代わりに使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the GUI starts up initializations are carried out, in this order:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
GUI の初期化は次の順序で行われる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The 'term' option is set to "builtin_gui" and terminal options are reset to
  their default value for the GUI |terminal-options|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
オプション '@option{term}' が "@var{builgin_gui}" に設定され、端末の設定が GUI 用の初期値に設定される。|@ref{terminal-options}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- If the system menu file exists, it is sourced.  The name of this file is
  normally "$VIMRUNTIME/menu.vim".  You can check this with ":version".  Also
  see |$VIMRUNTIME|.  To skip loading the system menu include 'M' in
  'guioptions'.				*buffers-menu* *no_buffers_menu*
  The system menu file includes a "Buffers" menu.  If you don't want this, set
  the "no_buffers_menu" variable in your .vimrc (not .gvimrc!): >
	:let no_buffers_menu = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item システムのメニューファイルがあればそれが読み込まれる。このファイルの名前は通常 "$VIMRUNTIME/menu.vim" である。"@command{:version}" でこれを確認できる。|@ref{$VIMRUNTIME}| も参照。システムのメニューの読み込みを省略するには '@option{guioptions}' に '@var{M}' を含める。
@anchor{buffers-menu}
@anchor{no_buffers_menu}
@cindex buffers-menu
@cindex no_buffers_menu
システムのメニューファイルはメニュー項目 "Buffers" (バッファ) の定義も含んでいる。これを必要としないなら、ユーザーの .vimrc (.gvimrc ではない！) で "no_buffers_menu" を設定する:
@example
:let no_buffers_menu = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
< NOTE: Switching on syntax highlighting also loads the menu file, thus
  disabling the Buffers menu must be done before ":syntax on".
  The path names are truncated to 35 characters.  You can truncate them at a
  different length, for example 50, like this: >
	:let bmenu_max_pathlen = 50
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
構文強調表示を有効にするとメニューファイルも読み込まれるため、メニュー項目 Buffers (バッファ) を無効にするのは "@command{:syntax on}" の前にする。メニューに表示されるバッファの名前は 35 文字で切り詰められる。違う長さで切り詰めるなら、例えば 50 文字にするなら、次のようにする:
@example
:let bmenu_max_pathlen = 50
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- If the "-U {gvimrc}" command-line option has been used when starting Vim,
  the {gvimrc} file will be read for initializations.  The following
  initializations are skipped.  When {gvimrc} is "NONE" no file will be read
  for initializations.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item Vim を起動するときのコマンドライン引数に "-U @{gvimrc@}" が指定されると、@{gvimrc@} ファイルが初期化のために読み込まれ、以下の初期化処理は省略される。@{gvimrc@} が "NONE" の場合は、どの初期化ファイルも読み込まれない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- For Unix and MS-Windows, if the system gvimrc exists, it is sourced.  The
  name of this file is normally "$VIM/gvimrc".  You can check this with
  ":version".  Also see |$VIM|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item Unix と MS-Windows では、システムの gvimrc が存在するなら、それが読み込まれる。このファイルの名前は通常 "$VIM/gvimrc" である。"@command{:version}" でこれを確認できる。|@ref{$VIM}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The following are tried, and only the first one that exists is used:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 次のものを試して、最初に見つかったものが使用される:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
  - If the GVIMINIT environment variable exists and is not empty, it is
    executed as an Ex command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item GVIMINIT 環境変数が存在し空でないなら、それが Ex コマンドとして実行される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
  - If the user gvimrc file exists, it is sourced.  The name of this file is
    normally "$HOME/.gvimrc".  You can check this with ":version".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ユーザーの gvimrc ファイルが存在するなら、それが読み込まれる。このファイルの名前は通常 "$HOME/.gvimrc" である。"@command{:version}" でこれを確認できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
  - For Win32, $HOME is set by Vim if needed, see |$HOME-windows|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item Win32 では、必要であれば Vim によって @env{$HOME} が設定される。|@ref{$HOME-windows}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
  - When a "_gvimrc" file is not found, ".gvimrc" is tried too.  And vice
    versa.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "_gvimrc" ファイルが見つからないときには、".gvimrc" も試される。逆のときも同様である。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
  The name of the first file found is stored in $MYGVIMRC, unless it was
  already set.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@env{$MYGVIMRC} が設定されていないならば、@env{$MYGVIMRC} に最初に見つかったファイルの名前が代入される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- If the 'exrc' option is set (which is NOT the default) the file ./.gvimrc
  is sourced, if it exists and isn't the same file as the system or user
  gvimrc file.  If this file is not owned by you, some security restrictions
  apply.  When ".gvimrc" is not found, "_gvimrc" is tried too.  For Macintosh
  and DOS/Win32 "_gvimrc" is tried first.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 'exrc' オプションが設定されていて (これは標準設定ではない)、./.gvimrc ファイルが存在し、それがシステム、あるいはユーザーの gvimrc ファイルではないなら、それが読み込まれる。このファイルがユーザーの所有しているものでないなら、いくつかのセキュリティ上の制限が適用される。".gvimrc" が見つからないときには、"_gvimrc" も試される。Macintosh と DOS/Win32 では、"_gvimrc" が最初に試される。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
NOTE: All but the first one are not carried out if Vim was started with
"-u NONE" or "-u DEFAULTS" and no "-U" argument was given, or when started
with "-U NONE".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
Vim を起動するときに、"-U" 引数を指定せずに "-u NONE" もしくは "-U NONE" を指定するか、あるいは "-U NONE" を指定して起動すると、最初のもの以外は全て実行されない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
All this happens AFTER the normal Vim initializations, like reading your
.vimrc file.  See |initialization|.
But the GUI window is only opened after all the initializations have been
carried out.  If you want some commands to be executed just after opening the
GUI window, use the |GUIEnter| autocommand event.  Example: >
	:autocmd GUIEnter * winpos 100 50
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらは全て、ユーザーの @file{.vimrc} ファイルを読み込む、というような、通常の Vim の初期化の後に実行される。|@ref{initialization}| を参照。

しかし、GUI ウィンドウは全ての初期化が実行された後に開かれる。GUI ウィンドウを開いた直後にいくつかのコマンドを実行したいなら、オートコマンドの |@ref{GUIEnter}| イベントを使用する。例えば:
@example
:autocmd GUIEnter * winpos 100 50
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use the gvimrc files to set up your own customized menus (see |:menu|)
and initialize other things that you may want to set up differently from the
terminal version.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カスタマイズしたメニュー (|@ref{:menu}| を参照) をセットアップしたり、CUI 版とは異なった初期化をするために、@file{gvimrc} ファイルを使用することができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Recommended place for your personal GUI initializations:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザーの個人的な GUI 初期化ファイルを置くのに推奨される場所:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	Unix and Mac OS X   $HOME/.gvimrc or $HOME/.vim/gvimrc
	OS/2		    $HOME/.gvimrc, $HOME/vimfiles/gvimrc
			    or $VIM/.gvimrc
	MS-DOS and Win32    $HOME/_gvimrc, $HOME/vimfiles/gvimrc
			    or $VIM/_gvimrc
	Amiga		    s:.gvimrc, home:.gvimrc, home:vimfiles:gvimrc
			    or $VIM/.gvimrc
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item Unix と Mac OS X @tab $HOME/.gvimrc, $HOME/.vim/gvimrc
@item OS/2 @tab $HOME/.gvimrc, $HOME/vimfiles/gvimrc, $VIM/.gvimrc
@item MS-DOS と Win32 @tab $HOME/_gvimrc, $HOME/vimfiles/gvimrc, $VIM/_gvimrc
@item Amiga @tab s:.gvimrc, home:.gvimrc, home:vimfiles:gvimrc, $VIM/.gvimrc
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The personal initialization files are searched in the order specified above
and only the first one that is found is read.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
個人的な初期化ファイルは上記の順に検索され、最初に見つかったものだけが読み込まれる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are a number of options which only have meaning in the GUI version of
Vim.  These are 'guicursor', 'guifont', 'guipty' and 'guioptions'.  They are
documented in |options.txt| with all the other options.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
GUI 版の Vim でだけ意味を持つオプションがある。'@option{guicursor}', '@option{guifont}', '@option{guipty}', '@option{guioptions}' である。それらは他の全てのオプションと共に |@ref{options.txt}| で説明されている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If using the Motif or Athena version of the GUI (but not for the GTK+ or
Win32 version), a number of X resources are available.  See |gui-resources|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
GUI の Motif か Athena バージョン (GTK+ や Win32 バージョンではない) を使用しているならば、多くの X のリソースが有効である。|@ref{gui-resources}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Another way to set the colors for different occasions is with highlight
groups.  The "Normal" group is used to set the background and foreground
colors.  Example (which looks nice): >

	:highlight Normal guibg=grey90
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末の設定をする以外に文字の色を設定する方法はハイライトを設定することである。ハイライトの "Normal" グループは背景色と前景色を設定するために用いられる。(ナイスな) 例:
@example
:highlight Normal guibg=grey90
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "guibg" and "guifg" settings override the normal background and
foreground settings.  The other settings for the Normal highlight group are
not used.  Use the 'guifont' option to set the font.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"guibg" と "guifg" の設定は通常の背景と前景の設定よりも優先される。ハイライトの Normal グループに対するその他の設定は使用されない。フォントを設定するには '@option{guifont}' を使用する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Also check out the 'guicursor' option, to set the colors for the cursor in
various modes.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
モード別にカーソルの色を設定するには、'@option{guicursor}' オプションを参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim tries to make the window fit on the screen when it starts up.  This avoids
that you can't see part of it.  On the X Window System this requires a bit of
guesswork.  You can change the height that is used for the window title and a
task bar with the 'guiheadroom' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は起動時に、スクリーンに合わせてウィンドウの位置を調整しようとする。これはウィンドウの一部が隠れてしまわないようにするためである。X Window System では、これは少し憶測を必要とする。'@option{guiheadroom}' オプションでウィンドウタイトルとタスクバーに用いられる高さを変更することができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:winp* *:winpos* *E188*
:winp[os]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{:winp}
@anchor{:winpos}
@anchor{E188}
@pindex :winp
@pindex :winpos
@erindex E188
@item :winp[os]
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Display current position of the top left corner of the GUI vim
		window in pixels.  Does not work in all versions.
		Also see |getwinpos()|, |getwinposx()| and |getwinposy()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
GUI vim ウィンドウの左上隅の現在の位置をピクセルで表示する。全てのバージョンで機能する訳ではない。|@ref{getwinpos()}|, |@ref{getwinposx()}| と |@ref{getwinposy()}| も参照のこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:winp[os] {X} {Y}							*E466*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E466}
@erindex E466
@item :winp[os] @{X@} @{Y@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Put the GUI vim window at the given {X} and {Y} coordinates.
		The coordinates should specify the position in pixels of the
		top left corner of the window.  Does not work in all versions.
		Does work in an (new) xterm |xterm-color|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
与えられた @{X@} と @{Y@} の座標に GUI vim ウィンドウを移動する。座標はウィンドウの左上隅の位置をピクセル単位で指定する。全てのバージョンで機能する訳ではない。(新しい) xterm で機能する |@ref{xterm-color}|。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When the GUI window has not been opened yet, the values are
		remembered until the window is opened.  The position is
		adjusted to make the window fit on the screen (if possible).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

GUI ウィンドウがまだ開いていないとき、この値はウィンドウが開かれるまで保留される。位置はスクリーンに合うように調整される(可能なら)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						    *:win* *:winsize* *E465*
:win[size] {width} {height}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:win}
@anchor{:winsize}
@anchor{E465}
@pindex :win
@pindex :winsize
@erindex E465
@item :win[size] @{width@} @{height@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Set the window height to {width} by {height} characters.
		Obsolete, use ":set lines=11 columns=22".
		If you get less lines than expected, check the 'guiheadroom'
		option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{width@} (幅) と @{height@} (高さ) を指定してウィンドウの大きさを設定する。このコマンドは古いコマンド (Obsolete) なので、"@command{:set lines=11 columns=22}" を使用するようにすること。

期待したよりも高さが低くなるなら、'@option{guiheadroom}' オプションを確認すること。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you are running the X Window System, you can get information about the
window Vim is running in with these commands: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
X Window System では、これらのコマンドで Vim のウィンドウの情報を得られる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:!xwininfo -id $WINDOWID
	:!xprop -id $WINDOWID
	:execute '!xwininfo -id ' . v:windowid
	:execute '!xprop -id ' . v:windowid
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:!xwininfo -id $WINDOWID
:!xprop -id $WINDOWID
:execute '!xwininfo -id ' . v:windowid
:execute '!xprop -id ' . v:windowid
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*gui-IME* *iBus*
Input methods for international characters in X that rely on the XIM
framework, most notably iBus, have been known to produce undesirable results
in gvim. These may include an inability to enter spaces, or long delays
between typing a character and it being recognized by the application.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-IME}
@anchor{iBus}
@cindex gui-IME
@cindex iBus
X で各国の文字を入力するためのインプットメソッドで XIM フレームワークに依るもの、特に iBus は、gvim で使用すると不具合が起こることが知られている。スペースを入力できなかったり、キーを押してからそれがアプリケーションに届くまで大きな遅延が発生したりする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
One workaround that has been successful, for unknown reasons, is to prevent
gvim from forking into the background by starting it with the |-f| argument.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
対処療法としては gvim の起動引数に |@ref{-f}| を付けてフォークをしないようにすると症状は出なくなる。理由は不明だが。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
2. Scrollbars						*gui-scrollbars*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-scrollbars}
@cindex gui-scrollbars
@section 2. スクロールバー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are vertical scrollbars and a horizontal scrollbar.  You may
configure which ones appear with the 'guioptions' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
垂直スクロールバーと水平スクロールバーがある。'@option{guioptions}' オプションでどれが表示されるかを設定することができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The interface looks like this (with ":set guioptions=mlrb"):
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このような外観になっている (設定が ":set guioptions=mlrb" のとき):
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		       +------------------------------+ `
		       | File  Edit		 Help | <- Menu bar (m) `
		       +-+--------------------------+-+ `
		       |^|			    |^| `
		       |#| Text area.		    |#| `
		       | |			    | | `
		       |v|__________________________|v| `
 Normal status line -> |-+ File.c	       5,2  +-| `
 between Vim windows   |^|""""""""""""""""""""""""""|^| `
		       | |			    | | `
		       | | Another file buffer.     | | `
		       | |			    | | `
		       |#|			    |#| `
 Left scrollbar (l) -> |#|			    |#| <- Right `
		       |#|			    |#|    scrollbar (r) `
		       | |			    | | `
		       |v|			    |v| `
		       +-+--------------------------+-+ `
		       | |< ####		   >| | <- Bottom `
		       +-+--------------------------+-+    scrollbar (b) `
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
                      +------------------------------+
                      | ファイル 編集         ヘルプ | <- メニューバー(m)
                      +-+--------------------------+-+
                      |^|                          |^|
                      |#| テキストエリア           |#|
                      | |                          | |
                      |v|__________________________|v|
Vim ウィンドウ間の -> |-+ File.c              5,2  +-|
通常のステータス行    |^|""""""""""""""""""""""""""|^|
                      | |                          | |
                      | | 別のファイルバッファ     | |
                      | |                          | |
                      |#|                          |#|
左スクロールバー(l)-> |#|                          |#| <- 右
                      |#|                          |#|    スクロールバー(r)
                      | |                          | |
                      |v|                          |v|
                      +-+--------------------------+-+
                      | |< ####                   >| | <- 下
                      +-+--------------------------+-+    スクロールバー(b)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Any of the scrollbar or menu components may be turned off by not putting the
appropriate letter in the 'guioptions' string.  The bottom scrollbar is
only useful when 'nowrap' is set.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
スクロールバーやメニューバーは '@option{guioptions}' から対応する文字を取り除くことで無効にできる。下スクロールバーは '@option{nowrap}' が設定されているときだけ有用である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
VERTICAL SCROLLBARS					*gui-vert-scroll*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-vert-scroll}
@cindex gui-vert-scroll
@unnumberedsubsec 垂直スクロールバー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Each Vim window has a scrollbar next to it which may be scrolled up and down
to move through the text in that buffer.  The size of the scrollbar-thumb
indicates the fraction of the buffer which can be seen in the window.
When the scrollbar is dragged all the way down, the last line of the file
will appear in the top of the window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
各 Vim ウィンドウはとなりにスクロールバーを持っていて、上下にスクロールしてそのバッファ内のテキストの表示を移動できる。スクロールバーのつまみのサイズはウィンドウに見えているバッファの割合を示している。スクロールバーがずっと下方にドラッグされると、ファイルの最後の行はウィンドウの最上部に表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If a window is shrunk to zero height (by the growth of another window) its
scrollbar disappears.  It reappears when the window is restored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ウィンドウが (他のウィンドウの拡大によって) 高さゼロに縮小されると、そのスクロールバーは表示されなくなる。それはウィンドウが復元されるときに再び表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If a window is vertically split, it will get a scrollbar when it is the
current window and when, taking the middle of the current window and drawing a
vertical line, this line goes through the window.
When there are scrollbars on both sides, and the middle of the current window
is on the left half, the right scrollbar column will contain scrollbars for
the rightmost windows.  The same happens on the other side.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ウィンドウを縦分割しているとき、カレントウィンドウだけがスクロールバーを利用できる。そして、複数のウィンドウの真ん中のウィンドウを操作しているときは、スクロールバーは間のウィンドウを飛び越えて作用する。

両側にスクロールバーがあるときに、複数のウィンドウの真ん中のカレントウィンドウが左半分に面していると、右側のスクロールバーは右端のウィンドウに影響する。左右が逆でも同様。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
HORIZONTAL SCROLLBARS					*gui-horiz-scroll*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-horiz-scroll}
@cindex gui-horiz-scroll
@unnumberedsubsec 水平スクロールバー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The horizontal scrollbar (at the bottom of the Vim GUI) may be used to
scroll text sideways when the 'wrap' option is turned off.  The
scrollbar-thumb size is such that the text of the longest visible line may be
scrolled as far as possible left and right.  The cursor is moved when
necessary, it must remain on a visible character (unless 'virtualedit' is
set).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
(Vim GUI の最下段の) 水平スクロールバーは、'@option{wrap}' オプションがオフのときに、テキストを横にスクロールするために使用する。スクロールバーのつまみのサイズは、左右にスクロールして一番長い行のテキストを全て表示できるくらいである。必要に応じてカーソルが移動するとき、カーソルは表示されている文字の上にとどまる ('@option{virtualedit}' が設定されていなければ)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Computing the length of the longest visible line takes quite a bit of
computation, and it has to be done every time something changes.  If this
takes too much time or you don't like the cursor jumping to another line,
include the 'h' flag in 'guioptions'.  Then the scrolling is limited by the
text of the current cursor line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
一番長い行を計算するのは多少の処理時間を必要とする。そしてそれは何かが変更されるときに毎回行われる。その時間が多すぎるようだったり、他の行へのカーソルジャンプを好まないなら、'@option{guioptions}' に '@var{h}' を含めると、スクロールはカーソルのある行の長さに制限される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*athena-intellimouse*
If you have an Intellimouse and an X server that supports using the wheel,
then you can use the wheel to scroll the text up and down in gvim.  This works
with XFree86 4.0 and later, and with some older versions when you add patches.
See |scroll-mouse-wheel|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{athena-intellimouse}
@cindex athena-intellimouse
インテリマウスを持っていて、X サーバーがホイールをサポートしているなら、gvim でテキストを上下にスクロールするのにホイールを使うことができる。これは XFree86 4.0 以降のバージョンで機能する。古いバージョンでもパッチを当てれば利用可能になる。|@ref{scroll-mouse-wheel}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For older versions of XFree86 you must patch your X server.  The following
page has a bit of information about using the Intellimouse on Linux as well as
links to the patches and X server binaries (may not have the one you need
though):
    http://www.inria.fr/koala/colas/mouse-wheel-scroll/
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
古いバージョンの XFree86 では X サーバーにパッチを当てなくてはならない。以下のページにはパッチとXサーバーのバイナリへのリンクに加えて、Linux 上でインテリマウスを使用することについて多少の情報がある (けれども必要とするものはないかもしれない):

@url{http://www.inria.fr/koala/colas/mouse-wheel-scroll/}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
3. Mouse Control					*gui-mouse*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-mouse}
@cindex gui-mouse
@section 3. マウス制御
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The mouse only works if the appropriate flag in the 'mouse' option is set.
When the GUI is switched on, and 'mouse' wasn't set yet, the 'mouse' option is
automatically set to "a", enabling it for all modes except for the
|hit-enter| prompt.  If you don't want this, a good place to change the
'mouse' option is the "gvimrc" file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マウスは、'@option{mouse}' オプションに適切なフラグが設定されている場合にだけ機能する。GUI に切り替わるときに、'@option{mouse}' がまだ設定されていなければ、'@option{mouse}' オプションは自動的に "@var{a}" に設定され、|@ref{hit-enter}| プロンプトを除いて全てのモードで有効になる。これを望まないならば、"@file{gvimrc}" ファイルで '@option{mouse}' オプションを変更する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Other options that are relevant:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関連する他のオプション:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
'mousefocus'	window focus follows mouse pointer |gui-mouse-focus|
'mousemodel'	what mouse button does which action
'mousehide'	hide mouse pointer while typing text
'selectmode'	whether to start Select mode or Visual mode
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item '@option{mousefocus}' @tab マウスポインタが乗っているウィンドウをカレントウィンドウにする |@ref{gui-mouse-focus}|
@item '@option{mousemodel}' @tab マウスのボタンがどのような動作をするか
@item '@option{mousehide}' @tab テキストを入力している間マウスポインタを隠す
@item '@option{selectmode}' @tab 選択時に選択モードとビジュアルモードのどちらを使うか
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A quick way to set these is with the ":behave" command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
素早くこれらを設定するには "@command{:behave}" コマンドで行う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:behave* *:be*
:be[have] {model}	Set behavior for mouse and selection.  Valid
			arguments are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{:behave}
@anchor{:be}
@pindex :behave
@pindex :be
@item :be[have] @{model@}
マウスと選択の動作を設定する。有効な引数は:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			   mswin	MS-Windows behavior
			   xterm	Xterm behavior
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item mswin @tab MS-Windows の動作
@item xterm @tab Xterm の動作
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			Using ":behave" changes these options:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:behave}" を使用するとこれらのオプションが変更される:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			option		mswin			xterm	~
			'selectmode'	"mouse,key"		""
			'mousemodel'	"popup"			"extend"
			'keymodel'	"startsel,stopsel"	""
			'selection'	"exclusive"		"inclusive"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .4 .3
@headitem オプション @tab mswin @tab xterm
@item '@option{selectmode}' @tab "mouse,key" @tab ""
@item '@option{mousemodel}' @tab "popup" @tab "extend"
@item '@option{keymodel}' @tab "startsel,stopsel" @tab ""
@item '@option{selection}' @tab "exclusive" @tab "inclusive"
@end multitable
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In the $VIMRUNTIME directory, there is a script called |mswin.vim|, which will
also map a few keys to the MS-Windows cut/copy/paste commands.  This is NOT
compatible, since it uses the CTRL-V, CTRL-X and CTRL-C keys.  If you don't
mind, use this command: >
	:so $VIMRUNTIME/mswin.vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
$VIMRUNTIME ディレクトリの中に、MS-Windows にあるような cut/copy/paste 機能のためのキーマッピングを設定する |@ref{mswin.vim}| と呼ばれるスクリプトがある。これは、@kbd{CTRL-V}、@kbd{CTRL-X}、@kbd{CTRL-C} キーを用いるので、標準の操作と互換性がなくなってしまう。それでも構わないなら、このコマンドで使用する:
@example
:so $VIMRUNTIME/mswin.vim
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For scrolling with a wheel on a mouse, see |scroll-mouse-wheel|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マウスのホイールでスクロールするには、|@ref{scroll-mouse-wheel}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
3.1 Moving Cursor with Mouse				*gui-mouse-move*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-mouse-move}
@cindex gui-mouse-move
@unnumberedsubsec 3.1 マウスによるカーソルの移動
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Click the left mouse button somewhere in a text buffer where you want the
cursor to go, and it does!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カーソルを持って行きたいテキストバッファのどこかでマウスの左ボタンをクリックすると、カーソルはそこに行く！
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This works in	    when 'mouse' contains ~
Normal mode	    'n' or 'a'
Visual mode	    'v' or 'a'
Insert mode	    'i' or 'a'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .5 .5
@headitem 動作するモード @tab '@option{mouse}' が以下を含んでいるとき
@item ノーマルモード @tab 'n' または 'a'
@item ビジュアルモード @tab 'v' まはた 'a'
@item 挿入モード @tab 'i' または 'a'
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Select mode is handled like Visual mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
選択モードはビジュアルモードのように扱われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You may use this with an operator such as 'd' to delete text from the current
cursor position to the position you point to with the mouse.  That is, you hit
'd' and then click the mouse somewhere.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
現在のカーソル位置からマウスで指示する位置までのテキストを削除するために 'd' のようなオペレータと共にこれを使用してもよい。つまり、'd' を入力してからどこかをマウスでクリックする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*gui-mouse-focus*
The 'mousefocus' option can be set to make the keyboard focus follow the
mouse pointer.  This means that the window where the mouse pointer is, is the
active window.  Warning: this doesn't work very well when using a menu,
because the menu command will always be applied to the top window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-mouse-focus}
@cindex gui-mouse-focus
'@option{mousefocus}' オプションを設定してキーボードフォーカスがマウスポインタに追従するようにできる。これはマウスポインタが乗っているウィンドウがアクティブウィンドウになることを意味する。
@quotation
@strong{警告:} @*
メニューをうまく利用できなくなる。メニューを使用したときに、そのメニューに設定されたコマンドは常に一番上のウィンドウに適用されてしまうだろう。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you are on the ':' line (or '/' or '?'), then clicking the left or right
mouse button will position the cursor on the ':' line (if 'mouse' contains
'c', 'a' or 'A').
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
('@option{mouse}' が '@var{c}', '@var{a}', '@var{A}' のどれかを含んでいるなら) コマンドラインモードや検索モード中にマウスの左ボタンか右ボタンをクリックすることで、コマンドラインの行のクリックした位置にカーソルを移動できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In any situation the middle mouse button may be clicked to paste the current
selection.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
どのような状況でも、マウスの中ボタンをクリックして、現在の選択を貼り付けることができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
3.2 Selection with Mouse				*gui-mouse-select*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-mouse-select}
@cindex gui-mouse-select
@unnumberedsubsec 3.2 マウスによる選択
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The mouse can be used to start a selection.  How depends on the 'mousemodel'
option:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マウスを使って選択を開始できる。どのように使用するかは '@option{mousemodel}' オプションに依存する:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
'mousemodel' is "extend": use the right mouse button
'mousemodel' is "popup":  use the left mouse button, while keeping the Shift
key pressed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item '@option{mousemodel}' が "@var{extend}" である: @tab マウスの右ボタンを使用する。
@item '@option{mousemodel}' が "@var{popup}" である: @tab @key{Shift} キーを押しながら、マウスの左ボタンを使用する。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If there was no selection yet, this starts a selection from the old cursor
position to the position pointed to with the mouse.  If there already is a
selection then the closest end will be extended.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
選択を開始するときには、カーソルの位置からマウスで指示した位置までが選択される。すでに選択されている状態で選択の操作をすると、選択範囲が拡張される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If 'selectmode' contains "mouse", then the selection will be in Select mode.
This means that typing normal text will replace the selection.  See
|Select-mode|.  Otherwise, the selection will be in Visual mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{selectmode}' が "@var{mouse}" を含んでいるなら、選択モードが使用される。これは選択中に入力した文字で選択範囲が置き換えられることを意味する。|@ref{Select-mode}| を参照。そうでなければ、ビジュアルモードが使用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Double clicking may be done to make the selection word-wise, triple clicking
makes it line-wise, and quadruple clicking makes it rectangular block-wise.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ダブルクリックで単語の選択、トリプルクリックで行の選択、クワドルプルクリック (4 回クリック) で矩形ブロックを選択することができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
See |gui-selections| on how the selection is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
どのように選択が用いられるかに関しては |@ref{gui-selections}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
3.3 Other Text Selection with Mouse		*gui-mouse-modeless*
						*modeless-selection*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-mouse-modeless}
@anchor{modeless-selection}
@cindex gui-mouse-modeless
@cindex modeless-selection
@unnumberedsubsec 3.3 マウスによる他のテキスト選択
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
A different kind of selection is used when:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のときには異なる選択方法が使われる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- in Command-line mode
- in the Command-line window and pointing in another window
- at the |hit-enter| prompt
- whenever the current mode is not in the 'mouse' option
- when holding the CTRL and SHIFT keys in the GUI
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item コマンドラインモード
@item コマンドラインウィンドウを使用中に他のウィンドウを指したとき
@item |@ref{hit-enter}| プロンプト
@item 現在のモードが '@option{mouse}' オプションで指定されていないときはいつでも
@item GUI で @key{CTRL} キーと @key{SHIFT} キーを同時に押しているとき
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Since Vim continues like the selection isn't there, and there is no mode
associated with the selection, this is called modeless selection.  Any text in
the Vim window can be selected.  Select the text by pressing the left mouse
button at the start, drag to the end and release.  To extend the selection,
use the right mouse button when 'mousemodel' is "extend", or the left mouse
button with the shift key pressed when 'mousemodel' is "popup".
The selection is removed when the selected text is scrolled or changed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
テキストが選択されていても、選択されていないかのように、あるいは、選択に関連したモードが存在しないかのように、Vim が通常の動作を継続するので、これはモードレス選択と呼ばれる。Vim ウィンドウの中のどんなテキストでも選択することができる。

開始点でマウスの左ボタンを押すことでテキストを選択し、終点までドラッグして離す。選択を延長するには、'@option{mousemodel}' が "@var{extend}" のときにはマウスの右ボタンを使用し、'@option{mousemodel}' が "@var{popup}" のときにはシフトキーを押しながらマウスの左ボタンを使用する。

選択したテキストが変更されると、選択は解除される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
On the command line CTRL-Y can be used to copy the selection into the
clipboard.  To do this from Insert mode, use CTRL-O : CTRL-Y <CR>.  When
'guioptions' contains a or A (default on X11), the selection is automatically
copied to the "* register.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインでは @kbd{CTRL-Y} で選択範囲をクリップボードにコピーできる。挿入モード中にコピーするには @kbd{CTRL-O} を使い @kbd{CTRL-Y <CR>} とする。'@option{guioptions}' に a か A が含まれるとき (X11 では既定でそうなっている) は、選択範囲が自動的にレジスタ "* にコピーされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The middle mouse button can then paste the text.  On non-X11 systems, you can
use CTRL-R +.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マウス中ボタンでテキストを貼り付けられる。X11 以外のシステムでは @kbd{CTRL-R +} を使えば貼り付けられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
3.4 Using Mouse on Status Lines				*gui-mouse-status*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-mouse-status}
@cindex gui-mouse-status
@unnumberedsubsec 3.4 ステータス行でのマウスの使用
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Clicking the left or right mouse button on the status line below a Vim
window makes that window the current window.  This actually happens on button
release (to be able to distinguish a click from a drag action).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim ウィンドウの下のステータス行でマウスの左ボタンか右のボタンをクリックすることでそのウィンドウがカレントウィンドウになる。これはボタンを放したときに起こる (クリックとドラッグの操作を区別するため)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
With the left mouse button a status line can be dragged up and down, thus
resizing the windows above and below it.  This does not change window focus.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
左ボタンを使ってステータス行を上下にドラッグすると、ウィンドウのサイズを上下に変更できる。この操作ではそのウィンドウはカレントウィンドウにならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The same can be used on the vertical separator: click to give the window left
of it focus, drag left and right to make windows wider and narrower.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ウィンドウの垂直の区切りも同様に機能する。クリックした区切りの左のウィンドウがカレントウィンドウになる。左右にドラッグするとウィンドウの幅を変更できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
3.5 Various Mouse Clicks				*gui-mouse-various*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-mouse-various}
@cindex gui-mouse-various
@unnumberedsubsec 3.5 様々なマウスクリック
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
    <S-LeftMouse>	Search forward for the word under the mouse click.
			When 'mousemodel' is "popup" this starts or extends a
			selection.
    <S-RightMouse>	Search backward for the word under the mouse click.
    <C-LeftMouse>	Jump to the tag name under the mouse click.
    <C-RightMouse>	Jump back to position before the previous tag jump
			(same as "CTRL-T")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item <S-LeftMouse> @tab マウスクリックで単語を前方検索する。'@option{mousemodel}' が "@var{popup}" のときには、これは選択を開始するか、あるいは延長する。
@item <S-RightMouse> @tab マウスクリックで単語を後方検索する。
@item <C-LeftMouse> @tab マウスクリックでタグ名へジャンプする。
@item <C-RightMouse> @tab 直前のタグジャンプの前の位置に戻る ("@kbd{CTRL-T}" と同じ)。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
3.6 Mouse Mappings					*gui-mouse-mapping*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-mouse-mapping}
@cindex gui-mouse-mapping
@unnumberedsubsec 3.6 マウスマッピング
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The mouse events, complete with modifiers, may be mapped.  Eg: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
修飾キー付きのマウスイベントをマッピングすることもできる。例えば:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   :map <S-LeftMouse>     <RightMouse>
   :map <S-LeftDrag>      <RightDrag>
   :map <S-LeftRelease>   <RightRelease>
   :map <2-S-LeftMouse>   <2-RightMouse>
   :map <2-S-LeftDrag>    <2-RightDrag>
   :map <2-S-LeftRelease> <2-RightRelease>
   :map <3-S-LeftMouse>   <3-RightMouse>
   :map <3-S-LeftDrag>    <3-RightDrag>
   :map <3-S-LeftRelease> <3-RightRelease>
   :map <4-S-LeftMouse>   <4-RightMouse>
   :map <4-S-LeftDrag>    <4-RightDrag>
   :map <4-S-LeftRelease> <4-RightRelease>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:map <S-LeftMouse>     <RightMouse>
:map <S-LeftDrag>      <RightDrag>
:map <S-LeftRelease>   <RightRelease>
:map <2-S-LeftMouse>   <2-RightMouse>
:map <2-S-LeftDrag>    <2-RightDrag>
:map <2-S-LeftRelease> <2-RightRelease>
:map <3-S-LeftMouse>   <3-RightMouse>
:map <3-S-LeftDrag>    <3-RightDrag>
:map <3-S-LeftRelease> <3-RightRelease>
:map <4-S-LeftMouse>   <4-RightMouse>
:map <4-S-LeftDrag>    <4-RightDrag>
:map <4-S-LeftRelease> <4-RightRelease>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
These mappings make selection work the way it probably should in a Motif
application, with shift-left mouse allowing for extending the visual area
rather than the right mouse button.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのマッピングは、Motif アプリケーションの作法にしたがって、選択領域を拡張するために、マウスの右ボタンを使わずに、@key{Shift} キーを押しながら左ボタンを押す方法を設定している。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Mouse mapping with modifiers does not work for modeless selection.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
修飾キーを使ったマウス操作のマッピングはモードレス選択では機能しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
3.7 Drag and drop						*drag-n-drop*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{drag-n-drop}
@cindex drag-n-drop
@unnumberedsubsec 3.7 ドラッグ＆ドロップ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can drag and drop one or more files into the Vim window, where they will
be opened as if a |:drop| command was used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim ウィンドウに 1 つ、あるいは複数のファイルをドラッグ＆ドロップすることができる。ファイルは |@ref{:drop}| コマンドを使ったときのように開かれる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you hold down Shift while doing this, Vim changes to the first dropped
file's directory.  If you hold Ctrl Vim will always split a new window for the
file.  Otherwise it's only done if the current buffer has been changed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@key{Shift} キーを同時に押していると、Vim はカレントディレクトリをドロップされた最初のファイルがあるディレクトリに変更する。@key{Ctrl} キーを同時に押していると、ファイルを開くためにウィンドウを分割する。押してなければカレントバッファが変更されていないときだけファイルは開かれる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can also drop a directory on Vim.  This starts the explorer plugin for
that directory (assuming it was enabled, otherwise you'll get an error
message).  Keep Shift pressed to change to the directory instead.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ディレクトリを Vim にドロップすることもできる。この操作は explorer プラグインでそのディレクトリを開く (それが利用可能だと想定している。無理ならエラーが表示されるだろう)。@key{Shift} キーを同時に押していれば、ディレクトリを開かずに、カレントディレクトリをそのディレクトリに変更する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If Vim happens to be editing a command line, the names of the dropped files
and directories will be inserted at the cursor.  This allows you to use these
names with any Ex command.  Special characters (space, tab, double quote and
'|'; backslash on non-MS-Windows systems) will be escaped.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインを編集中なら、ドロップされたファイルやディレクトリの名前がカーソル位置に挿入される。これは Ex コマンドでそれらの名前を使うのに便利である。特別な文字 (スペース、タブ、ダブルクォート、'|'、MS-Windows 以外ではバックスラッシュも) はエスケープされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
4. Making GUI Selections				*gui-selections*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-selections}
@cindex gui-selections
@section 4. GUI選択の作成
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*quotestar*
You may make selections with the mouse (see |gui-mouse-select|), or by using
Vim's Visual mode (see |v|).  If 'a' is present in 'guioptions', then
whenever a selection is started (Visual or Select mode), or when the selection
is changed, Vim becomes the owner of the windowing system's primary selection
(on MS-Windows the |gui-clipboard| is used; under X11, the |x11-selection| is
used - you should read whichever of these is appropriate now).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{quotestar}
@cindex quotestar
マウス (|@ref{gui-mouse-select}| を参照) か、あるいは Vim のビジュアルモード (|@ref{v}| を参照) を使用して、選択を作成できる。'@option{guioptions}' に '@var{a}' が指定されているなら、いつ選択 (ビジュアルモードや選択モード) が開始されるとしても、あるいは選択が変更されるとしても、Vim がウィンドウシステムの主要な選択の所有者になる (MS-Windows では |@ref{gui-clipboard}| が用いられる。X11 では |@ref{x11-selection}| が用いられる。ここの説明は両方に共通している)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*clipboard*
There is a special register for storing this selection, it is the "*
register.  Nothing is put in here unless the information about what text is
selected is about to change (e.g. with a left mouse click somewhere), or when
another application wants to paste the selected text.  Then the text is put
in the "* register.  For example, to cut a line and make it the current
selection/put it on the clipboard: >

	"*dd
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{clipboard}
@cindex clipboard
選択を保存するための特別なレジスタがある。それは "* レジスタである。どのテキストが選択されているかという情報が (例えばマウスの左ボタンをクリックするなどして) 変更されるか、あるいは他のアプリケーションが選択されたテキストを貼り付けようとしない限りここには何も書き出されない。使用されるときにはテキストは "* レジスタに書き出される。例えば、行を切り取って、それを現在の選択にして、クリップボードにそれを書き出すためには次のようにする:
@example
"*dd
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Similarly, when you want to paste a selection from another application, e.g.,
by clicking the middle mouse button, the selection is put in the "* register
first, and then 'put' like any other register.  For example, to put the
selection (contents of the clipboard): >

	"*p
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
同様に、例えば、マウスの中ボタンをクリックするなどして、他のアプリケーションから選択を貼り付けるときには、選択は始めに "* レジスタに書き出され、それから他のレジスタと同じように挿入される。例えば、選択(クリップボードの内容)を貼り付けるには:
@example
"*p
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When using this register under X11, also see |x11-selection|.  This also
explains the related "+ register.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
X11 でこのレジスタを使うには、|@ref{x11-selection}| も参照。これは深く関連した "+ レジスタについても説明している。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that when pasting text from one Vim into another separate Vim, the type
of selection (character, line, or block) will also be copied.  For other
applications the type is always character.  However, if the text gets
transferred via the |x11-cut-buffer|, the selection type is ALWAYS lost.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ある Vim から他の独立した Vim にテキストを貼り付けたいときには、選択のタイプ (文字、行あるいは矩形) もコピーされることに注意する。他のアプリケーションについては、タイプは常に文字である。|@ref{x11-cut-buffer}| を介して得たテキストでも、その選択のタイプは常に失われる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the "unnamed" string is included in the 'clipboard' option, the unnamed
register is the same as the "* register.  Thus you can yank to and paste the
selection without prepending "* to commands.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{clipboard}' オプションに "@var{unnamed}" 文字列が含まれているときには、無名レジスタは "* レジスタと同じである。したがってコマンドの前に "* を付けずに選択をコピーし貼り付けることができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
5. Menus						*menus*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{menus}
@cindex menus
@section 5. メニュー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For an introduction see |usr_42.txt| in the user manual.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
まずはユーザーマニュアルの |@ref{usr_42.txt}| を御覧ください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
5.1 Using Menus						*using-menus*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{using-menus}
@cindex using-menus
@unnumberedsubsec 5.1 メニューの使用
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Basically, menus can be used just like mappings.  You can define your own
menus, as many as you like.
Long-time Vim users won't use menus much.  But the power is in adding your own
menus and menu items.  They are most useful for things that you can't remember
what the key sequence was.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
基本的には、メニューは単にマッピングのように使用することができる。自分のメニューを好きなだけたくさん定義することができる。

長い間 Vim ユーザーはメニューを十分に使用してこなかった。しかし自分のメニューやメニュー項目を追加することは大きな力を秘めている。ある一連のキー操作を覚えられないようなときに最も便利である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For creating menus in a different language, see |:menutrans|.
If you don't want to use menus at all, see |'go-M'|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
別の言語用にメニューを作成するには、|@ref{:menutrans}| を参照。
メニューをまったく使いたくない場合は、|@ref{'go-M'}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*menu.vim*
The default menus are read from the file "$VIMRUNTIME/menu.vim".  See
|$VIMRUNTIME| for where the path comes from.  You can set up your own menus.
Starting off with the default set is a good idea.  You can add more items, or,
if you don't like the defaults at all, start with removing all menus
|:unmenu-all|.  You can also avoid the default menus being loaded by adding
this line to your .vimrc file (NOT your .gvimrc file!): >
	:let did_install_default_menus = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{menu.vim}
@cindex menu.vim
標準のメニューは "$VIMRUNTIME/menu.vim" ファイルから読み込まれる。パスがどこを指すかについては |@ref{$VIMRUNTIME}| を参照。ユーザーは自分のメニューを設定することができる。その際に標準のメニューを利用するのはいい考えである。メニューに項目を追加したり、あるいは、標準のメニューが気に入らなければ、全てのメニューを取り除くことができる |@ref{:unmenu-all}|。@file{.vimrc} ファイル (@file{.gvimrc} ファイルではない！) にこの行を追加することで標準のメニューが読み込まれないようにすることもできる:
@example
:let did_install_default_menus = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
If you also want to avoid the Syntax menu: >
	:let did_install_syntax_menu = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
メニュー項目の Syntax (シンタックス) も無効にしたいなら:
@example
:let did_install_syntax_menu = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The first item in the Syntax menu can be used to show all available filetypes
in the menu (which can take a bit of time to load).  If you want to have all
filetypes already present at startup, add: >
	:let do_syntax_sel_menu = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Syntax メニューの最初の項目 @{訳注:「対応形式をメニューに表示」@} を使うと、利用可能な全てのファイルタイプをメニューに表示できる (読み込みに少し時間がかかるかもしれない)。起動時に全てのファイルタイプが表示されているようにしたければ次の行を加える:
@example
:let do_syntax_sel_menu = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The following menuitems show all available color schemes, keymaps and compiler
settings:
	Edit > Color Scheme ~
	Edit > Keymap ~
	Tools > Set Compiler ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下のメニュー項目は、利用可能なすべてのカーラースキーム、キーマップおよびコンパイラ設定を表示する:
@example
Edit > Color Scheme
Edit > Keymap
Tools > Set Compiler
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
However, they can also take a bit of time to load, because they search all
related files from the directories in 'runtimepath'.  Therefore they are
loaded lazily (by the |CursorHold| event), or you can also load them manually.
If you want to have all these items already present at startup, add: >
	:let do_no_lazyload_menus = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
しかしながら、'@option{runtimepath}' 内のディレクトリから関連するファイルをすべて検索するので読み込みに多少時間がかかる。したがって、それらは (イベント |@ref{CursorHold}| によって) 遅れて読み込まれる、もしくは手動で読み込むこともできる。

すでに存在するすべての項目を起動時に読み込んでおきたい場合、以下を加える:
@example
:let do_no_lazyload_menus = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that the menu.vim is sourced when `:syntax on` or `:filetype on` is
executed or after your .vimrc file is sourced.  This means that the 'encoding'
option and the language of messages (`:language messages`) must be set before
that (if you want to change them).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:}
menu.vim が読み込まれるのは、`@command{:syntax on}` もしくは `@command{:filetype on}` が実行されたとき、もしくはユーザーの @file{.vimrc} ファイルが読み込まれた後であることに注意。これは、オプション '@option{encoding}' およびメッセージ用の言語 (`@command{:language messages}`) がそれより前に設定されていなければならないということを意味する (もし変更したいのであれば)。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*console-menus*
Although this documentation is in the GUI section, you can actually use menus
in console mode too.  You will have to load |menu.vim| explicitly then, it is
not done by default.  You can use the |:emenu| command and command-line
completion with 'wildmenu' to access the menu entries almost like a real menu
system.  To do this, put these commands in your .vimrc file: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{console-menus}
@cindex console-menus
このドキュメントは GUI の項目であるけれども、CUI 版の Vim でも実際にメニューを使用することができる。そのときには明示的に |@ref{menu.vim}| を読み込まなければならないだろう。それは標準では設定されない。ほぼ実際のメニューシステムのようにメニューの項目にアクセスするために '@option{wildmenu}' を設定して |@ref{:emenu}| コマンドの使用時にコマンドライン補完を使用することができる。これをするには、@file{.vimrc} ファイルに次のコマンドを付加しておく:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:source $VIMRUNTIME/menu.vim
	:set wildmenu
	:set cpo-=<
	:set wcm=<C-Z>
	:map <F4> :emenu <C-Z>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:source $VIMRUNTIME/menu.vim
:set wildmenu
:set cpo-=<
:set wcm=<C-Z>
:map <F4> :emenu <C-Z>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Pressing <F4> will start the menu.  You can now use the cursor keys to select
a menu entry.  Hit <Enter> to execute it.  Hit <Esc> if you want to cancel.
This does require the |+menu| feature enabled at compile time.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
メニューを開始するには<F4>を押す。そのときにはメニューのエントリを選択するためにカーソルキーを使用することができる。それを実行するには @key{<Enter>} を入力する。キャンセルするには @key{<Esc>} を入力する。これはコンパイル時に |@ref{+menu}| 機能を有効にする必要がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*tear-off-menus*
GTK+ 2 and Motif support Tear-off menus.  These are sort of sticky menus or
pop-up menus that are present all the time.  If the resizing does not work
correctly, this may be caused by using something like "Vim*geometry" in the
defaults.  Use "Vim.geometry" instead.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tear-off-menus}
@cindex tear-off-menus
GTK+ 2 と Motif は切取りメニュー (Tear-off メニュー) をサポートする。これは少し変わったメニューで、ポップアップメニューが常に表示されるようなものである。メニューのウィンドウのサイズの変更が正確に機能しないなら、これはリソースに "Vim*geometry" のように設定していることが原因かもしれない。もしそうなら代わりに "Vim.geometry" を使用する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
As to GTK+ 3, tear-off menus have been deprecated since GTK+ 3.4.
Accordingly, they are disabled if gvim is linked against GTK+ 3.4 or later.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
GTK+ 3 では、GTK+ 3.4 から切取りメニューが非推奨となった。よって、GTK+ 3.4 以降とリンクされた gvim ではこの機能は無効化される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The Win32 GUI version emulates Motif's tear-off menus.  Actually, a Motif user
will spot the differences easily, but hopefully they're just as useful.  You
can also use the |:tearoff| command together with |hidden-menus| to create
floating menus that do not appear on the main menu bar.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Win32 GUI バージョンは Motif の切取りメニューをエミュレートする。Motif ユーザーなら簡単に違いを確認できるだろうが、同じように便利に使えると思う。|@ref{:tearoff}| コマンドと |@ref{hidden-menus}| を利用して、メインのメニューバーに項目を作らずに切取りメニューを作ることができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
5.2 Creating New Menus					*creating-menus*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{creating-menus}
@cindex creating-menus
@unnumberedsubsec 5.2 新しいメニューの作成
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*:me*  *:menu*  *:noreme*  *:noremenu*
				*:am*  *:amenu* *:an*      *:anoremenu*
				*:nme* *:nmenu* *:nnoreme* *:nnoremenu*
				*:ome* *:omenu* *:onoreme* *:onoremenu*
				*:vme* *:vmenu* *:vnoreme* *:vnoremenu*
				*:xme* *:xmenu* *:xnoreme* *:xnoremenu*
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:me}
@anchor{:menu}
@anchor{:noreme}
@anchor{:noremenu}
@anchor{:am}
@anchor{:amenu}
@anchor{:an}
@anchor{:anoremenu}
@anchor{:nme}
@anchor{:nmenu}
@anchor{:nnoreme}
@anchor{:nnoremenu}
@anchor{:ome}
@anchor{:omenu}
@anchor{:onoreme}
@anchor{:onoremenu}
@anchor{:vme}
@anchor{:vmenu}
@anchor{:vnoreme}
@anchor{:vnoremenu}
@anchor{:xme}
@anchor{:xmenu}
@anchor{:xnoreme}
@anchor{:xnoremenu}
@anchor{:sme}
@anchor{:smenu}
@anchor{:snoreme}
@anchor{:snoremenu}
@anchor{:ime}
@anchor{:imenu}
@anchor{:inoreme}
@anchor{:inoremenu}
@anchor{:cme}
@anchor{:cmenu}
@anchor{:cnoreme}
@anchor{:cnoremenu}
@anchor{E330}
@anchor{E327}
@anchor{E331}
@anchor{E336}
@anchor{E333}
@anchor{E328}
@anchor{E329}
@anchor{E337}
@anchor{E792}
@pindex :me
@pindex :menu
@pindex :noreme
@pindex :noremenu
@pindex :am
@pindex :amenu
@pindex :an
@pindex :anoremenu
@pindex :nme
@pindex :nmenu
@pindex :nnoreme
@pindex :nnoremenu
@pindex :ome
@pindex :omenu
@pindex :onoreme
@pindex :onoremenu
@pindex :vme
@pindex :vmenu
@pindex :vnoreme
@pindex :vnoremenu
@pindex :xme
@pindex :xmenu
@pindex :xnoreme
@pindex :xnoremenu
@pindex :sme
@pindex :smenu
@pindex :snoreme
@pindex :snoremenu
@pindex :ime
@pindex :imenu
@pindex :inoreme
@pindex :inoremenu
@pindex :cme
@pindex :cmenu
@pindex :cnoreme
@pindex :cnoremenu
@erindex E330
@erindex E327
@erindex E331
@erindex E336
@erindex E333
@erindex E328
@erindex E329
@erindex E337
@erindex E792
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
To create a new menu item, use the ":menu" commands.  They are mostly like
the ":map" set of commands but the first argument is a menu item name, given
as a path of menus and submenus with a '.' between them, e.g.: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しいメニュー項目を作るには、"@command{:menu}" コマンドを使用する。これはほとんど "@command{:map}" のコマンド群と同じだが最初の引数はメニュー項目の名前であり、'.' で区切ったメニューとサブメニューのパスとして与えられる。例えば:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
   :menu File.Save  :w<CR>
   :inoremenu File.Save  <C-O>:w<CR>
   :menu Edit.Big\ Changes.Delete\ All\ Spaces  :%s/[ ^I]//g<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:menu File.Save  :w<CR>
:inoremenu File.Save  <C-O>:w<CR>
:menu Edit.Big\ Changes.Delete\ All\ Spaces  :%s/[ ^I]//g<CR>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This last one will create a new item in the menu bar called "Edit", holding
the mouse button down on this will pop up a menu containing the item
"Big Changes", which is a sub-menu containing the item "Delete All Spaces",
which when selected, performs the operation.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この最後の1つはメニューバーに "Edit" という新しい項目を作る、そしてその上でマウスのボタンを押すと "Big Changes" という項目を含んだメニューが表示されるだろう。"Big Changes" は "Delete All Spaces" という項目を含むサブメニューを持っていて、その項目を選択すると操作が実行される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Special characters in a menu name:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
メニュー名での特殊文字:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	&	The next character is the shortcut key.  Make sure each
		shortcut key is only used once in a (sub)menu.  If you want to
		insert a literal "&" in the menu name use "&&".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item & @tab この文字の次の文字はショートカットキーである。どのショートカットキーも (サブ) メニューの中で 1 度だけしか使用されていないことを確認すること。メニュー名に "&" を入れるには "&&" とする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	<Tab>	Separates the menu name from right-aligned text.  This can be
		used to show the equivalent typed command.  The text "<Tab>"
		can be used here for convenience.  If you are using a real
		tab, don't forget to put a backslash before it!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item <Tab> @tab メニューの名前をそこで区切って以降を右詰めにする。実行する操作をそろえて表示するのに便利である。使いやすいように文字として "<Tab>" をそのまま書けばいいようになっている。本当のTab文字を使用するなら、その前にバックスラッシュを付けること！
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Example: >

   :amenu &File.&Open<Tab>:e  :browse e<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:amenu &File.&Open<Tab>:e  :browse e<CR>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
[typed literally]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[文字通りタイプする]
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
With the shortcut "F" (while keeping the <Alt> key pressed), and then "O",
this menu can be used.  The second part is shown as "Open     :e".  The ":e"
is right aligned, and the "O" is underlined, to indicate it is the shortcut.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

(@key{<Alt>} キーと同時に) ショートカットキーの "F" を押し、それから "O" を押すと、このメニューを使用できる。Openの項目は "@samp{Open     :e}" のように表示される。":e" は右詰めされ、"O" にはショートカットであることを示すために下線が引かれる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The ":amenu" command can be used to define menu entries for all modes at once.
To make the command work correctly, a character is automatically inserted for
some modes:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:amenu}" コマンドは全てのモードで使えるメニューの項目を 1 度に定義することができる。コマンドを正確に機能させるために、いくつかのモード用に自動的に文字が付加される:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	mode		inserted	appended	~
	Normal		nothing		nothing
	Visual		<C-C>		<C-\><C-G>
	Insert		<C-\><C-O>
	Cmdline		<C-C>		<C-\><C-G>
	Op-pending	<C-C>		<C-\><C-G>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .3 .3
@headitem モード @tab 前に付加 @tab 後ろに付加
@item ノーマルモード @tab なし @tab なし
@item ビジュアルモード @tab <C-C> @tab <C-\><C-G>
@item 挿入モード @tab <C-\><C-O> @tab
@item コマンドラインモード @tab <C-C> @tab <C-\><C-G>
@item オペレータ待機モード @tab <C-C> @tab <C-\><C-G>
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Appending CTRL-\ CTRL-G is for going back to insert mode when 'insertmode' is
set. |CTRL-\_CTRL-G|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
後ろに付加される CTRL-\ CTRL-G は '@option{insertmode}' が設定されているときには挿入モードに戻る。|@ref{CTRL-\_CTRL-G}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Example: >

   :amenu File.Next	:next^M
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:amenu File.Next        :next^M
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
is equal to: >

   :nmenu File.Next	:next^M
   :vmenu File.Next	^C:next^M^\^G
   :imenu File.Next	^\^O:next^M
   :cmenu File.Next	^C:next^M^\^G
   :omenu File.Next	^C:next^M^\^G
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
は以下と同じである:
@example
:nmenu File.Next     :next^M
:vmenu File.Next     ^C:next^M^\^G
:imenu File.Next     ^\^O:next^M
:cmenu File.Next     ^C:next^M^\^G
:omenu File.Next     ^C:next^M^\^G
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Careful: In Insert mode this only works for a SINGLE Normal mode command,
because of the CTRL-O.  If you have two or more commands, you will need to use
the ":imenu" command.  For inserting text in any mode, you can use the
expression register: >

   :amenu Insert.foobar   "='foobar'<CR>P
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{注意:} @*
挿入モードでは 1 つのノーマルモードのコマンドに対してだけ機能する。これは @kbd{CTRL-O} の仕様による。2 つ以上のコマンドを使うには、"@command{:imenu}" コマンドを使用する必要がある。どのモードでもテキストを挿入するために式レジスタ ('=' レジスタ) を使用することができる:
@example
:amenu Insert.foobar   "='foobar'<CR>P
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that the '<' and 'k' flags in 'cpoptions' also apply here (when
included they make the <> form and raw key codes not being recognized).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
'@option{cpoptions}' の中の '<' フラグと 'k' フラグが適用される (含まれていたときには、<> による特殊キーの書式や生のキーコードは認識されない)。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that <Esc> in Cmdline mode executes the command, like in a mapping.  This
is Vi compatible.  Use CTRL-C to quit Cmdline mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
コマンドラインモードでの <Esc> はマッピングで使用されたときと同様に (入力をキャンセルするのではなく) コマンドを実行する。これは Vi 互換である。コマンドラインモードを終了するには @kbd{CTRL-C} を使用する。

@{訳注: |@ref{c_<Esc>}| を参照@}
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:menu-<silent>* *:menu-silent*
To define a menu which will not be echoed on the command line, add
"<silent>" as the first argument.  Example: >
	:menu <silent> Settings.Ignore\ case  :set ic<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:menu-<silent>}
@anchor{:menu-silent}
@cindex :menu-<silent>
@cindex :menu-silent
実行したコマンドをコマンドラインに表示しないようなメニューを定義するには、最初の引数に "<silent>" を加える。例:
@example
:menu <silent> Settings.Ignore\ case  :set ic<CR>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The ":set ic" will not be echoed when using this menu.  Messages from the
executed command are still given though.  To shut them up too, add a ":silent"
in the executed command: >
	:menu <silent> Search.Header :exe ":silent normal /Header\r"<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これでこのメニューを使っても ":set ic" はコマンドラインに表示されない。それでも実行したコマンドの出力は表示される。それを表示しないようにするには、":silent" を付けてコマンドを実行する:
@example
:menu <silent> Search.Header :exe ":silent normal /Header\r"<CR>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"<silent>" may also appear just after "<special>" or "<script>".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"<silent>" は "<special>" や "<script>" の直後に書いてもよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*:menu-<special>* *:menu-special*
Define a menu with <> notation for special keys, even though the "<" flag
may appear in 'cpoptions'.  This is useful if the side effect of setting
'cpoptions' is not desired.  Example: >
	:menu <special> Search.Header /Header<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:menu-<special>}
@anchor{:menu-special}
@cindex :menu-<special>
@cindex :menu-special
'@option{cpoptions}' にフラグ "@var{<}" が含まれているときでも、メニューを定義する際には <> 記法で特殊なキーを表すことができる。これは '@option{cpoptions}' の副作用が望ましくない場合に便利である。例:
@example
:menu <special> Search.Header /Header<CR>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"<special>" must appear as the very first argument to the ":menu" command or
just after "<silent>" or "<script>".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"<special>" はコマンド :menu の引数の一番最初か、"<silent>" や "<script>" の直後に書かねばならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:menu-<script>* *:menu-script*
The "to" part of the menu will be inspected for mappings.  If you don't want
this, use the ":noremenu" command (or the similar one for a specific mode).
If you do want to use script-local mappings, add "<script>" as the very first
argument to the ":menu" command or just after "<silent>" or "<special>".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:menu-<script>}
@anchor{:menu-script}
@cindex :menu-<script>
@cindex :menu-script
メニューに指定されたコマンドにはマッピングが適用される。適用しないようにするには、"@command{:noremenu}" コマンド (とそれに類するモード別のコマンド) を使う。スクリプトローカルなマッピングを使うには "@command{:menu}" コマンドの最初の引数、あるいは "<silent>" の次に "<script>" と書く。

@{訳注: これは <SID> で指定した部分だけがマッピングされる。例:
@example
nnoremenu <script> AAA.BBB :echo "<SID>LM" "LM"<CR>
cnoremap <SID>LM 'This is script-local mapping'
cnoremap LM 'This is not used'
@end example
スクリプトファイルでこのように設定し、メニューの AAA.BBB を実行すると
@example
'This is script-local mapping' LM
@end example
と表示される。"<SID>LM" はマッピングされ、"LM" はマッピングされていない。@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*menu-priority*
You can give a priority to a menu.  Menus with a higher priority go more to
the right.  The priority is given as a number before the ":menu" command.
Example: >
	:80menu Buffer.next :bn<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{menu-priority}
@cindex menu-priority
メニューに優先度を与えることができる。より高い優先度を与えられたメニューほど右に配置される。優先度は "@command{:menu}" コマンドの前の数字で与えれられる。例:
@example
:80menu Buffer.next :bn<CR>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The default menus have these priorities:
	File		10
	Edit		20
	Tools		40
	Syntax		50
	Buffers		60
	Window		70
	Help		9999
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
標準のメニューはこれらの優先度を持つ:
@example
File            10
Edit            20
Tools           40
Syntax          50
Buffers         60
Window          70
Help            9999
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When no or zero priority is given, 500 is used.
The priority for the PopUp menu is not used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
優先度を指定しない、あるいはゼロを指定すると、500 が用いられる。ポップアップメニューに対しては優先度は意味を持たない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The Help menu will be placed on the far right side of the menu bar on systems
which support this (Motif and GTK+).  For GTK+ 2 and 3, this is not done
anymore because right-aligning the Help menu is now discouraged UI design.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
対応しているシステム (Motif と GTK+) では、「ヘルプ」メニューはメニューバーの右端に離れて配置される。これは GTK+ 2 と 3 では、もはや認められないユーザーインターフェイスデザインのため行われない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use a priority higher than 9999, to make it go after the Help menu,
but that is non-standard and is discouraged.  The highest possible priority is
about 32000.  The lowest is 1.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ヘルプメニューの後ろに置くために、9999 より高い優先度を使用することができるが、それは非標準であり、推奨しない。優先度の取り得る値は最高で約 32000 である。最低は 1 である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*sub-menu-priority*
The same mechanism can be used to position a sub-menu.  The priority is then
given as a dot-separated list of priorities, before the menu name: >
	:menu 80.500 Buffer.next :bn<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sub-menu-priority}
@cindex sub-menu-priority
同様にサブメニューも配置を指定できる。優先度は、メニュー名の前に、ドット区切りの優先度のリストとして指定する:
@example
:menu 80.500 Buffer.next :bn<CR>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Giving the sub-menu priority is only needed when the item is not to be put
in a normal position.  For example, to put a sub-menu before the other items: >
	:menu 80.100 Buffer.first :brew<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
サブメニューの優先度を与える必要があるのは、項目を配置する位置を指定したいときだけである。例えば、他の項目の前にサブメニューを置くには:
@example
:menu 80.100 Buffer.first :brew<CR>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Or to put a sub-menu after the other items, and further items with default
priority will be put before it: >
	:menu 80.900 Buffer.last :blast<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
あるいは他の項目の後にサブメニューを置いて、標準設定の優先度を持つ項目がその前に置かれるようにするには:
@example
:menu 80.900 Buffer.last :blast<CR>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
When a number is missing, the default value 500 will be used: >
	:menu .900 myMenu.test :echo "text"<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
数字が抜けているときには、標準設定の500が用いられる:
@example
:menu .900 myMenu.test :echo "text"<CR>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The menu priority is only used when creating a new menu.  When it already
existed, e.g., in another mode, the priority will not change.  Thus, the
priority only needs to be given the first time a menu is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
メニューの優先度はメニューを新しく生成するときだけ用いられる。すでにあるとき、例えば、別のモードで定義されていたときには、優先度は変更されない。したがって、優先度はメニューを最初に定義するときだけ与える必要がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
An exception is the PopUp menu.  There is a separate menu for each mode
(Normal, Op-pending, Visual, Insert, Cmdline).  The order in each of these
menus can be different.  This is different from menu-bar menus, which have
the same order for all modes.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例外はポップアップメニューである。各モード (ノーマルモード、オペレータ待機モード、ビジュアルモード、挿入モード、コマンドラインモード) に別々のメニューがある。これらのメニューは順序が異なってもよい。これはメニューバーのメニューとは異なる。メニューバーのメニューは全てのモードで同じ順序である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
NOTE: sub-menu priorities currently don't work for all versions of the GUI.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
サブメニューの優先度は現在全ての GUI のバージョンで機能する訳ではない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*menu-separator* *E332*
Menu items can be separated by a special item that inserts some space between
items.  Depending on the system this is displayed as a line or a dotted line.
These items must start with a '-' and end in a '-'.  The part in between is
used to give it a unique name.  Priorities can be used as with normal items.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{menu-separator}
@anchor{E332}
@cindex menu-separator
@erindex E332
メニューの各項目は特殊なメニュー項目を使って区切ることができる。それはシステムによるが、線や点線として表示される。そのような項目の名前は '-' で始めて '-' で終わるように定義する。間には一意な名前を挟むことができる。普通のメニュー項目と同様に優先度を設定することもできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Example: >
	:menu Example.item1	:do something
	:menu Example.-Sep-	:
	:menu Example.item2	:do something different
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
:menu Example.item1     :do something
:menu Example.-Sep-     :
:menu Example.item2     :do something different
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Note that the separator also requires a rhs.  It doesn't matter what it is,
because the item will never be selected.  Use a single colon to keep it
simple.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
区切りの定義にはコマンドの指定が必要である。そのメニュー項目は選択することができないので、内容はなんでも構わない。ただ単にコロン (:) を 1 つ書いておくだけでいい。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*gui-toolbar*
The toolbar is currently available in the MacVim, Win32, Athena, Motif, GTK+
(X11), and Photon GUI.  It should turn up in other GUIs in due course.  The
default toolbar is setup in menu.vim.  (Note: The MacVim toolbar is modified
in "$VIM/gvimrc".)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-toolbar}
@cindex gui-toolbar
ツールバーは今のところ MacVim, Win32, Athena, Motif, GTK+ (X11), Photon GUI で利用可能である。いずれは他の GUI でも使えるようになるだろう。標準のツールバーは menu.vim で定義されている。(@strong{Note}: MacVim のツールバーは "$VIM/gvimrc" で修正されていることに注意。)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The display of the toolbar is controlled by the 'guioptions' letter 'T'.  You
can thus have menu & toolbar together, or either on its own, or neither.
The appearance is controlled by the 'toolbar' option.  You can choose between
an image, text or both.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

ツールバーの表示は '@option{guioptions}' の文字 'T' によって制御される。したがって、メニューとツールバーを同時に、あるいはどちらかだけを表示することもできるし、両方とも非表示にすることもできる。

表示方法は '@option{toolbar}' オプションで変更できる。画像かテキスト、もしくは両方を表示するかを選択できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*toolbar-icon*
The toolbar is defined as a special menu called ToolBar, which only has one
level.  Vim interprets the items in this menu as follows:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{toolbar-icon}
@cindex toolbar-icon
ツールバーは、1 つのレベルだけを持つ ToolBar と呼ばれる特別なメニューとして定義されている。Vim はこのメニューの項目を以下のように解釈する:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
1)  If an "icon=" argument was specified, the file with this name is used.
    The file can either be specified with the full path or with the base name.
    In the last case it is searched for in the "bitmaps" directory in
    'runtimepath', like in point 3.  Examples: >
	:amenu icon=/usr/local/pixmaps/foo_icon.xpm ToolBar.Foo :echo "Foo"<CR>
	:amenu icon=FooIcon ToolBar.Foo :echo "Foo"<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item 1) "icon=" 引数が与えられたときは、そのファイルが使われる。ファイル名にはフルパスか、ファイル名のみを指定する。後者の場合には、そのファイルは 3) の場合と同じように '@option{runtimepath}' の "@var{bitmaps}" ディレクトリから検索される。例:
@example
:amenu icon=/usr/local/pixmaps/foo_icon.xpm ToolBar.Foo :echo "Foo"<CR>
:amenu icon=FooIcon ToolBar.Foo :echo "Foo"<CR>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<   Note that in the first case the extension is included, while in the second
    case it is omitted.
    If the file cannot be opened the next points are tried.
    A space in the file name must be escaped with a backslash.
    A menu priority must come _after_ the icon argument: >
	:amenu icon=foo 1.42 ToolBar.Foo :echo "42!"<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
最初の例では拡張子も含めている。2 番目の例では拡張子は省略されている。ファイルが開けなければ 2) を試す。ファイル名に空白を含めるにはバックスラッシュでエスケープする。メニューの優先度は icon の引数の後に指定する:
@example
:amenu icon=foo 1.42 ToolBar.Foo :echo "42!"<CR>
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
2)  An item called 'BuiltIn##', where ## is a number, is taken as number ## of
    the built-in bitmaps available in Vim.  Currently there are 31 numbered
    from 0 to 30 which cover most common editing operations |builtin-tools|. >
	:amenu ToolBar.BuiltIn22 :call SearchNext("back")<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 2) 'BuiltIn##' (##は数字である) という名前の項目は Vim で利用可能な組み込みのビットマップの番号##を使用するとみなされる。今のところ、0 から 30 までの 31 個の一般的な編集操作のものが用意されている |@ref{builtin-tools}|:
@example
:amenu ToolBar.BuiltIn22 :call SearchNext("back")<CR>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
3)  An item with another name is first searched for in the directory
    "bitmaps" in 'runtimepath'.  If found, the bitmap file is used as the
    toolbar button image.  Note that the exact filename is OS-specific: For
    example, under Win32 the command >
	:amenu ToolBar.Hello :echo "hello"<CR>
<   would find the file 'hello.bmp'.  Under GTK+/X11 it is 'Hello.xpm'.  With
    GTK+ 2 the files 'Hello.png', 'Hello.xpm' and 'Hello.bmp' are checked for
    existence, and the first one found would be used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 3) 2) 以外の名前を持つ項目は最初に '@option{runtimepath}' の "@var{bitmaps}" ディレクトリから検索される。もしあればそのビットマップファイルがツールバーボタンのイメージとして用いられる。
@quotation
@strong{Note:} @*
正確なファイル名は OS 特有であることに注意する: 例えば、Win32 でのコマンド
@example
:amenu ToolBar.Hello :echo "hello"<CR>
@end example
は、'@file{hello.bmp}' ファイルを検索するだろう。GTK+/X11 では '@file{Hello.xpm}' である。GTK+ 2 では 'Hello.png', 'Hello.xpm', 'Hello.bmp' がチェックされ、最初に見つかったものが使われる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    For MS-Windows and GTK+ 2 the bitmap is scaled to fit the button.  For
    MS-Windows a size of 18 by 18 pixels works best.
    For MS-Windows the bitmap should have 16 colors with the standard palette.
    The light grey pixels will be changed to the Window frame color and the
    dark grey pixels to the window shadow color.  More colors might also work,
    depending on your system.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
MS-Windows と GTK+ 2 ではビットマップはボタンの大きさに合わせて拡大縮小される。MS-Windows では縦 18 横 18 のサイズがちょうどいいだろう。

MS-Windows ではビットマップは 16 色の標準パレットを使った物である。明るい灰色はウィンドウのフレームの色に変更され、暗い灰色はウィンドウの影の色に変更される。システムに依存するが、16 色よりも色が多くても問題ないだろう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
4)  If the bitmap is still not found, Vim checks for a match against its list
    of built-in names.  Each built-in button image has a name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 4) ビットマップがまだ見つからないならば、Vim は組み込みの名前のリストに対して同等のものを探す。どの組み込みのボタンイメージも名前を持っている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    So the command >
	:amenu ToolBar.Open :e
<   will show the built-in "open a file" button image if no open.bmp exists.
    All the built-in names can be seen used in menu.vim.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
だから、コマンド
@example
:amenu ToolBar.Open :e
@end example
は、open.bmp が存在しなければ、組み込みの "open a file" ボタンイメージを表示するだろう。全ての組み込みの名前は menu.vim で用いられているので確認できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
5)  If all else fails, a blank, but functioning, button is displayed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 5) 全てが失敗すると、空白だが、ちゃんと機能する、ボタンが表示される。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*builtin-tools*
nr  Name		Normal action  ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{builtin-tools}
@cindex builtin-tools
@multitable @columnfractions .1 .2 .7
@headitem 番号 @tab 名前 @tab 通常の動作
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
00  New			open new window
01  Open		browse for file to open in current window
02  Save		write buffer to file
03  Undo		undo last change
04  Redo		redo last undone change
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 00 @tab New @tab 新しいウィンドウを開く
@item 01 @tab Open @tab 現在のウィンドウで開くためにファイルをブラウズする
@item 02 @tab Save @tab バッファをファイルに保存する
@item 03 @tab Undo @tab 最後の変更を取り消す
@item 04 @tab Redo @tab 最後の取り消した変更をやり直す
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
05  Cut			delete selected text to clipboard
06  Copy		copy selected text to clipboard
07  Paste		paste text from clipboard
08  Print		print current buffer
09  Help		open a buffer on Vim's builtin help
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 05 @tab Cut @tab 選択されたテキストを削除しクリップボードへ送る
@item 06 @tab Copy @tab 選択されたテキストをクリップボードにコピーする
@item 07 @tab Paste @tab クリップボードからテキストをペーストする
@item 08 @tab Print @tab 現在のバッファを印刷する
@item 09 @tab Help @tab Vim の組み込みのヘルプでバッファを開く
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
10  Find		start a search command
11  SaveAll		write all modified buffers to file
12  SaveSesn		write session file for current situation
13  NewSesn		write new session file
14  LoadSesn		load session file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 10 @tab Find @tab 検索コマンドを開始する
@item 11 @tab SaveAll @tab 全ての修正されたバッファをファイルに保存する
@item 12 @tab SaveSesn @tab 現在の状態をセッションファイルに保存する
@item 13 @tab NewSesn @tab 新しいセッションファイルに保存する
@item 14 @tab LoadSesn @tab セッションファイルを読み込む
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
15  RunScript		browse for file to run as a Vim script
16  Replace		prompt for substitute command
17  WinClose		close current window
18  WinMax		make current window use many lines
19  WinMin		make current window use few lines
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 15 @tab RunScript @tab Vim script として実行するためにファイルをブラウズする
@item 16 @tab Replace @tab 置換コマンドのためのプロンプト
@item 17 @tab WinClose @tab 現在のウィンドウを閉じる
@item 18 @tab WinMax @tab 現在のウィンドウに使用する行数を最大にする
@item 19 @tab WinMin @tab 現在のウィンドウに使用する行数を最小にする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
20  WinSplit		split current window
21  Shell		start a shell
22  FindPrev		search again, backward
23  FindNext		search again, forward
24  FindHelp		prompt for word to search help for
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 20 @tab WinSplit @tab 現在のウィンドウを分割する
@item 21 @tab Shell @tab シェルを開始する
@item 22 @tab FindPrev @tab 後方に再検索する
@item 23 @tab FindNext @tab 前方に再検索する
@item 24 @tab FindHelp @tab ヘルプを検索する単語のためのプロンプト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
25  Make		run make and jump to first error
26  TagJump		jump to tag under the cursor
27  RunCtags		build tags for files in current directory
28  WinVSplit		split current window vertically
29  WinMaxWidth		make current window use many columns
30  WinMinWidth		make current window use few columns
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 25 @tab Make @tab make を実行し最初のエラーにジャンプする
@item 26 @tab TagJump @tab カーソルの下の tag にジャンプする
@item 27 @tab RunCtags @tab 現在のディレクトリのファイルに対して tags を作成する
@item 28 @tab WinVSplit @tab 現在のウィンドウを縦分割する
@item 29 @tab WinMaxWidth @tab 現在のウィンドウの幅を最大化する
@item 30 @tab WinMinWidth @tab 現在のウィンドウの幅を最小化する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*hidden-menus* *win32-hidden-menus*
In the Win32 and GTK+ GUI, starting a menu name with ']' excludes that menu
from the main menu bar.  You must then use the |:popup| or |:tearoff| command
to display it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hidden-menus}
@anchor{win32-hidden-menus}
@cindex hidden-menus
@cindex win32-hidden-menus
Win32 と GTK+ GUI では、']' で始まるメニュー名はメインのメニューバーから除外される。それを表示するには |@ref{:popup}| か |@ref{:tearoff}| コマンドを使用しなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*window-toolbar* *WinBar*
Each window can have a local toolbar.  This uses the first line of the window,
thus reduces the space for the text by one line.  The items in the toolbar
must start with "WinBar".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{window-toolbar}
@anchor{WinBar}
@cindex window-toolbar
@cindex WinBar
各ウィンドウはローカルなツールバーを持つことができる。これはウィンドウの先頭行を使用し、したがってテキスト用の領域は 1 行少なくなる。ツールバー内の項目は "WinBar" で始まらなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Only text can be used.  When using Unicode, special characters can be used to
make the items look like icons.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
テキストのみを使用することができる。Unicode を使用する場合、項目をアイコンのように見せるために特殊文字を使うことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the items do not fit then the last ones cannot be used.  The toolbar does
not wrap.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
項目が収まらない場合、最後の項目は使用することができない。ツールバーは折り返されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that Vim may be in any mode when executing these commands.  The menu
should be defined for Normal mode and will be executed without changing the
current mode. Thus if the current window is in Visual mode and the menu
command does not intentionally change the mode, Vim will remain in Visual
mode.  Best is to use `:nnoremenu` to avoid side effects.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
これらのコマンドを実行しているとき、Vim はどのモードでもありうることに注意。メニューはノーマルモード用に定義されるべきで、かつ現状のモードを変えることなく実行される。したがって、カレントウィンドウがビジュアルモードで、かつメニューコマンドが意図的にモードを変えない場合、Vim はビジュアルモードのままである。もっともよいのは、副作用を避けるために `@command{:nnoremenu}` を使用することである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Example for debugger tools: >
	nnoremenu 1.10 WinBar.Step :Step<CR>
	nnoremenu 1.20 WinBar.Next :Next<CR>
	nnoremenu 1.30 WinBar.Finish :Finish<CR>
	nnoremenu 1.40 WinBar.Cont :Continue<CR>
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デバッガツールの例:
@example
nnoremenu 1.10 WinBar.Step :Step<CR>
nnoremenu 1.20 WinBar.Next :Next<CR>
nnoremenu 1.30 WinBar.Finish :Finish<CR>
nnoremenu 1.40 WinBar.Cont :Continue<CR>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The window toolbar uses the ToolbarLine and ToolbarButton highlight groups.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ウィンドウツールバーは ToolbarLine および ToolbarButton ハイライトグループを使用する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When splitting the window the window toolbar is not copied to the new window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ウィンドウを分割する際、ウィンドウツールバーは新しいウィンドウにはコピーされない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*popup-menu*
In the Win32, GTK+, Motif, Athena and Photon GUI, you can define the
special menu "PopUp".  This is the menu that is displayed when the right mouse
button is pressed, if 'mousemodel' is set to popup or popup_setpos.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{popup-menu}
@cindex popup-menu
Win32, GTK+, Motif, Athena, Photon GUI では、特別なメニュー "PopUp" を定義することができる。これは、'@option{mousemodel}' が popup あるいは popup_setpos に設定されているときに、マウスの右ボタンが押されると表示されるメニューである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Example: >
    nnoremenu 1.40 PopUp.&Paste	"+gP
    menu PopUp
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
nnoremenu 1.40 PopUp.&Paste	"+gP
menu PopUp
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
5.3 Showing What Menus Are Mapped To			*showing-menus*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{showing-menus}
@cindex showing-menus
@unnumberedsubsec 5.3 メニューの定義を表示する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To see what an existing menu is mapped to, use just one argument after the
menu commands (just like you would with the ":map" commands).  If the menu
specified is a submenu, then all menus under that hierarchy will be shown.
If no argument is given after :menu at all, then ALL menu items are shown
for the appropriate mode (e.g., Command-line mode for :cmenu).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
メニューがどのように定義されているかを確認するには、("@command{:map}" コマンドでするのと全く同様に) menu コマンドの後にたった 1 つの引数を指定するだけである。指定されたメニューがサブメニューならば、その階層の下の全てのメニューが表示される。:menu の後に引数を与えなければ、適切なモードに対する全てのメニュー項目が表示される (例えば、コマンドラインモードに対して :cmenu)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Special characters in the list, just before the rhs:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
メニュー項目の一覧には、指定されたコマンドの前に特別な文字が表示される:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*	The menu was defined with "nore" to disallow remapping.
&	The menu was defined with "<script>" to allow remapping script-local
	mappings only.
-	The menu was disabled.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item * @tab そのメニュー項目は再マッピングを避けるために "nore" を付けて定義された
@item & @tab そのメニュー項目は再マッピングをスクリプトローカルに限定するために "<script>" を付けて定義された
@item - @tab そのメニュー項目は非表示である
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that hitting <Tab> while entering a menu name after a menu command may
be used to complete the name of the menu item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
menu コマンドでメニューの名前を入力しているときに @key{<Tab>} を打つと名前が補完される (設定による)。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
5.4 Executing Menus					*execute-menus*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{execute-menus}
@cindex execute-menus
@unnumberedsubsec 5.4 メニューの実行
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:em*  *:emenu* *E334* *E335*
:[range]em[enu] {menu}		Execute {menu} from the command line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:em}
@anchor{:emenu}
@anchor{E334}
@anchor{E335}
@pindex :em
@pindex :emenu
@erindex E334
@erindex E335
@table @asis
@item :[range]em[enu] @{menu@}
コマンドラインから @{menu@} を実行する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
				The default is to execute the Normal mode
				menu.  If a range is specified, it executes
				the Visual mode menu.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

通常はノーマルモードのメニューを実行する。実行範囲が与えられたときは、ビジュアルモードのメニューを実行する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
				If used from <c-o>, it executes the
				insert-mode menu Eg: >
	:emenu File.Exit
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

<c-o> から実行されたときは、挿入モードのメニューを実行する。例:
@example
:emenu File.Exit
@end example
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the console-mode vim has been compiled with WANT_MENU defined, you can
use :emenu to access useful menu items you may have got used to from GUI
mode.  See 'wildmenu' for an option that works well with this.  See
|console-menus| for an example.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
CUI 版の vim を WANT_MENU を定義してコンパイルしたなら、@command{:emenu} を使って GUI のときと同じように便利なメニューを使用できる。その際に '@option{wildmenu}' を設定しておくと便利である。使用例は |@ref{console-menus}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When using a range, if the lines match with '<,'>, then the menu is executed
using the last visual selection.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
範囲を指定するとき、'<,'> と指定すると、最後にビジュアル選択した範囲に対して実行される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
5.5 Deleting Menus					*delete-menus*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{delete-menus}
@cindex delete-menus
@unnumberedsubsec 5.5 メニューの削除
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:unme*  *:unmenu*
						*:aun*   *:aunmenu*
						*:nunme* *:nunmenu*
						*:ounme* *:ounmenu*
						*:vunme* *:vunmenu*
						*:xunme* *:xunmenu*
						*:sunme* *:sunmenu*
						*:iunme* *:iunmenu*
						*:cunme* *:cunmenu*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:unme}
@anchor{:unmenu}
@anchor{:aun}
@anchor{:aunmenu}
@anchor{:nunme}
@anchor{:nunmenu}
@anchor{:ounme}
@anchor{:ounmenu}
@anchor{:vunme}
@anchor{:vunmenu}
@anchor{:xunme}
@anchor{:xunmenu}
@anchor{:sunme}
@anchor{:sunmenu}
@anchor{:iunme}
@anchor{:iunmenu}
@anchor{:cunme}
@anchor{:cunmenu}
@pindex :unme
@pindex :unmenu
@pindex :aun
@pindex :aunmenu
@pindex :nunme
@pindex :nunmenu
@pindex :ounme
@pindex :ounmenu
@pindex :vunme
@pindex :vunmenu
@pindex :xunme
@pindex :xunmenu
@pindex :sunme
@pindex :sunmenu
@pindex :iunme
@pindex :iunmenu
@pindex :cunme
@pindex :cunmenu
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
To delete a menu item or a whole submenu, use the unmenu commands, which are
analogous to the unmap commands.  Eg: >
    :unmenu! Edit.Paste
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
メニュー項目やサブメニュー全体を削除するには、unmap コマンドによく似た unmenu コマンドを使用する。例えば:
@example
:unmenu! Edit.Paste
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This will remove the Paste item from the Edit menu for Insert and
Command-line modes.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは挿入モードとコマンドラインモードでの操作を Edit メニューの項目 Paste から取り除く。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that hitting <Tab> while entering a menu name after an umenu command
may be used to complete the name of the menu item for the appropriate mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
umenu コマンドでメニューの名前を入力しているときに @key{<Tab>} を打つと名前が補完される (設定による)。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To remove all menus use:			*:unmenu-all*  >
	:unmenu *	" remove all menus in Normal and visual mode
	:unmenu! *	" remove all menus in Insert and Command-line mode
	:aunmenu *	" remove all menus in all modes
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:unmenu-all}
@cindex :unmenu-all
全てのメニューを取り除くには次のようにする:
@example
:unmenu *       " ノーマルモードとビジュアルモードの全てのメニューを取り除く
:unmenu! *      " 挿入モードとコマンドラインモードの全てのメニューを取り除く
:aunmenu *      " 全てのモードの全てのメニューを取り除く
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to get rid of the menu bar: >
	:set guioptions-=m
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
メニューバーを非表示にするには:
@example
:set guioptions-=m
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
5.6 Disabling Menus					*disable-menus*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{disable-menus}
@cindex disable-menus
@unnumberedsubsec 5.6 メニューを無効にする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:menu-disable* *:menu-enable*
If you do not want to remove a menu, but disable it for a moment, this can be
done by adding the "enable" or "disable" keyword to a ":menu" command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:menu-disable}
@anchor{:menu-enable}
@cindex :menu-disable
@cindex :menu-enable
メニューを削除するのではなくて、一時的に無効にしたいときは、"@command{:menu}" コマンドに "disable" キーワードを指定する。有効にするには "enable" キーワードを指定する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Examples: >
	:menu disable &File.&Open\.\.\.
	:amenu enable *
	:amenu disable &Tools.*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:menu disable &File.&Open\.\.\.
:amenu enable *
:amenu disable &Tools.*
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The command applies to the modes as used with all menu commands.  Note that
characters like "&" need to be included for translated names to be found.
When the argument is "*", all menus are affected.  Otherwise the given menu
name and all existing submenus below it are affected.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このコマンドは menu コマンド群が影響する各モードに適用される。"&" は翻訳された名前にも適用するために必要である。引数に "*" を使うと、全てのメニューに作用する。そうでなければ、指定したメニュー項目とそのサブメニューに作用する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
5.7 Examples for Menus					*menu-examples*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{menu-examples}
@cindex menu-examples
@unnumberedsubsec 5.7 メニューの例
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here is an example on how to add menu items with menu's!  You can add a menu
item for the keyword under the cursor.  The register "z" is used. >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはメニューを使ってメニュー項目を追加する方法の例である！カーソルの下のキーワードをメニュー項目に追加することができる。作業用にレジスタ "z" を使用している。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  :nmenu Words.Add\ Var		wb"zye:menu! Words.<C-R>z <C-R>z<CR>
  :nmenu Words.Remove\ Var	wb"zye:unmenu! Words.<C-R>z<CR>
  :vmenu Words.Add\ Var		"zy:menu! Words.<C-R>z <C-R>z <CR>
  :vmenu Words.Remove\ Var	"zy:unmenu! Words.<C-R>z<CR>
  :imenu Words.Add\ Var		<Esc>wb"zye:menu! Words.<C-R>z <C-R>z<CR>a
  :imenu Words.Remove\ Var	<Esc>wb"zye:unmenu! Words.<C-R>z<CR>a
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:nmenu Words.Add\ Var           wb"zye:menu! Words.<C-R>z <C-R>z<CR>
:nmenu Words.Remove\ Var        wb"zye:unmenu! Words.<C-R>z<CR>
:vmenu Words.Add\ Var           "zy:menu! Words.<C-R>z <C-R>z <CR>
:vmenu Words.Remove\ Var        "zy:unmenu! Words.<C-R>z<CR>
:imenu Words.Add\ Var           <Esc>wb"zye:menu! Words.<C-R>z <C-R>z<CR>a
:imenu Words.Remove\ Var        <Esc>wb"zye:unmenu! Words.<C-R>z<CR>a
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
(the rhs is in <> notation, you can copy/paste this text to try out the
mappings, or put these lines in your gvimrc; "<C-R>" is CTRL-R, "<CR>" is
the <CR> key.  |<>|)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
(指定するコマンドには <> 記法を使える。このテキストをそのままコピー/ペーストして試してみたり、@file{gvimrc} に書き加えることができる。"<C-R>" は @kbd{CTRL-R} であり、"<CR>" は @key{<CR>} キーである。|@ref{<>}|)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
5.8 Tooltips & Menu tips
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 5.8 ツールチップとメニューチップ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
See section |42.4| in the user manual.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザーマニュアルの |@ref{42.4}| を参照すること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:tmenu* *:tm*
:tm[enu] {menupath} {rhs}	Define a tip for a menu or tool.  {only in
				X11 and Win32 GUI}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{:tmenu}
@anchor{:tm}
@pindex :tmenu
@pindex :tm
@item :tm[enu] @{menupath@} @{rhs@}
メニューやツールバーにチップを定義する。@{X11 と Win32 GUI のみ@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:tm[enu] [menupath]		List menu tips. {only in X11 and Win32 GUI}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :tm[enu] [menupath]
メニューチップを一覧表示する。@{X11 と Win32 GUI のみ@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:tunmenu* *:tu*
:tu[nmenu] {menupath}		Remove a tip for a menu or tool.
				{only in X11 and Win32 GUI}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:tunmenu}
@anchor{:tu}
@pindex :tunmenu
@pindex :tu
@item :tu[nmenu] @{menupath@}
メニューやツールバーのチップを削除する。@{X11 と Win32 GUI のみ@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When a tip is defined for a menu item, it appears in the command-line area
when the mouse is over that item, much like a standard Windows menu hint in
the status bar.  (Except when Vim is in Command-line mode, when of course
nothing is displayed.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
メニューの項目にチップが定義されていて、マウスがその項目の上にあるとき、そのチップがコマンドラインに表示される。それは Windows 標準でステータスバーに表示されるメニューヒントに似ている (Vim がコマンドラインモードのときは除く、そのときはもちろん何も表示されない)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
When a tip is defined for a ToolBar item, it appears as a tooltip when the
mouse pauses over that button, in the usual fashion.  Use the |hl-Tooltip|
highlight group to change its colors.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

ツールバーの項目にチップが定義されているときは、慣習にしたがって、マウスがそのボタンの上で止まったときにツールチップが表示される。その表示に使う色を変更するにはハイライトグループの |@ref{hl-Tooltip}| を設定する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A "tip" can be defined for each menu item.  For example, when defining a menu
item like this: >
	:amenu MyMenu.Hello :echo "Hello"<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
チップはメニューの各項目に定義できる。例えば、次のようにメニュー項目を定義したとき:
@example
:amenu MyMenu.Hello :echo "Hello"<CR>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The tip is defined like this: >
	:tmenu MyMenu.Hello Displays a greeting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のようにチップを定義する:
@example
:tmenu MyMenu.Hello Displays a greeting.
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
And delete it with: >
	:tunmenu MyMenu.Hello
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
そして次のように削除する:
@example
:tunmenu MyMenu.Hello
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Tooltips are currently only supported for the X11 and Win32 GUI.  However, they
should appear for the other gui platforms in the not too distant future.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ツールチップは今のところ X11 と Win32 GUI でサポートされている。近い内に他の GUI 環境でもサポートされるだろう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The ":tmenu" command works just like other menu commands, it uses the same
arguments.  ":tunmenu" deletes an existing menu tip, in the same way as the
other unmenu commands.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:tmenu}" コマンドは他の menu コマンド群と同じように機能し、同じ引数をとる。"@command{:tunmenu}" は他の unmenu コマンド群と同じようにメニューチップを削除する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If a menu item becomes invalid (i.e. its actions in all modes are deleted) Vim
deletes the menu tip (and the item) for you.  This means that :aunmenu deletes
a menu item - you don't need to do a :tunmenu as well.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
メニュー項目が無効になる (例えば、全てのモードでその動作が削除される) ときには、Vim はメニューチップ (と項目) を削除する。つまり @command{:aunmenu} でメニュー項目を削除するときには、@command{:tunmenu} する必要はないということである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
5.9 Popup Menus
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 5.9 ポップアップメニュー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In the Win32, MacVim, and GTK+ GUI, you can cause a menu to popup at the
cursor.  This behaves similarly to the PopUp menus except that any menu tree
can be popped up.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Win32, MacVim と GTK+ GUI では、カーソルの位置にメニューをポップアップ表示することができる。これは「PopUp」メニューと同じように動作し、どんなメニューでも表示することができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This command is for backwards compatibility, using it is discouraged, because
it behaves in a strange way.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このコマンドは後方互換性のために残されていて、使用することは推奨されない。なぜならこのコマンドのふるまいは好ましくないからである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:popup* *:popu*
:popu[p] {name}			Popup the menu {name}.  The menu named must
				have at least one subentry, but need not
				appear on the menu-bar (see |hidden-menus|).
				{only available for Win32, MacVim, and GTK GUI
				or in the terminal when compiled with
				+insert_expand}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{:popup}
@anchor{:popu}
@pindex :popup
@pindex :popu
@item :popu[p] @{name@}
メニュー項目 @{name@} をポップアップ表示する。そのメニューは少なくとも 1 つ以上の項目を持っている必要がある。メニューバーに表示されている必要はない (|@ref{hidden-menus}| を参照)。

@{Vim が Win32, MacVim および GTK GUI、もしくは |@ref{+insert_expand}| 機能付きでコンパイルされたときのみ、ターミナルの中で有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:popu[p]! {name}		Like above, but use the position of the mouse
				pointer instead of the cursor.
				In the terminal this is the last known
				position, which is usually at the last click
				or release (mouse movement is irrelevant).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :popu[p]! @{name@}
上記と同様だが、カーソル位置でなくマウスポインタの位置にメニューを表示する。端末では、これは通常最後クリックした、もしくは話した、最後に分かっている位置でありる (マウスの動きは無関係である)。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Example: >
	:popup File
will make the "File" menu (if there is one) appear at the text cursor (mouse
pointer if ! was used). >

	:amenu ]Toolbar.Make	:make<CR>
	:popup ]Toolbar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:popup File
@end example
とすると "File" メニューを (もしあれば) カーソル位置に表示させる。! が使われたときはマウスポインタの位置に表示させる。
@example
:amenu ]Toolbar.Make    :make<CR>
:popup ]Toolbar
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This creates a popup menu that doesn't exist on the main menu-bar.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはメインのメニューバーにメニュー項目を作らずにポップアップメニューを作成する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that in the GUI the :popup command will return immediately, before a
selection has been made.  In the terminal the commands waits for the user to
make a selection.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
GUI では、@command{:popup} コマンドは選択がなされる前に直ちに終了する。端末の場合はユーザーが選択を行うまで待つ。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that a menu that starts with ']' will not be displayed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
']' で始まるメニュー項目はメニューバーに表示されない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
6. Extras						*gui-extras*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-extras}
@cindex gui-extras
@section 6. 付記
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This section describes other features which are related to the GUI.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このセクションでは GUI に関連したその他の特徴を説明する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- With the GUI, there is no wait for one second after hitting escape, because
  the key codes don't start with <Esc>.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item GUI では、キーコードは <Esc> で始まらないため、エスケープを入力した後に 1 秒待たなくてよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- Typing ^V followed by a special key in the GUI will insert "<Key>", since
  the internal string used is meaningless.  Modifiers may also be held down to
  get "<Modifiers-Key>".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item GUI で @kbd{CTRL-V} に続いて特殊なキーを入力すると "<Key>" のように入力される。そのような特殊なキーは内部で意味を持たないためである。修飾キーを同時に押して "<Modifiers-Key>" を得ることもできる。

@{訳注: 例えば、挿入モードで @kbd{CTRL-V} に続いて @key{Del} キーを押すと "<Del>" (見た通り 5 文字) が入力される。@key{Alt} (@key{META}) キーを押しながら @key{Del} キーを押すと "<M-Del>" が入力される。@key{Shift} キーなら "<S-Del>"。@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- In the GUI, the modifiers SHIFT, CTRL, and ALT (or META) may be used within
  mappings of special keys and mouse events.  E.g.: :map <M-LeftDrag> <LeftDrag>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item GUI では、修飾キーの @key{SHIFT}, @key{CTRL}, @key{ALT} (@key{META}) は特殊キーやマウスイベントのマッピングで使用できる。例えば、:map <M-LeftDrag> <LeftDrag>
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- In the GUI, several normal keys may have modifiers in mappings etc, these
  are <Space>, <Tab>, <NL>, <CR>, <Esc>.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item GUI では、いくつかの普通のキーにマッピング等で修飾キーを付けて使用できる。そのようなキーは @key{<Space>}, @key{<Tab>}, @key{<NL>}, @key{<CR>}, @key{<Esc>} である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- To check in a Vim script if the GUI is being used, you can use something
  like this: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item GUI が使われているかどうかを Vim script 内で調べるには次のようにする:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	if has("gui_running")
	   echo "yes, we have a GUI"
	else
	   echo "Boring old console"
	endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
if has("gui_running")
   echo "yes, we have a GUI"
else
   echo "Boring old console"
endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<							*setting-guifont*
- When you use the same vimrc file on various systems, you can use something
  like this to set options specifically for each type of GUI: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{setting-guifont}
@cindex setting-guifont
@item さまざまなシステム上で同一の @file{vimrc} ファイルを使うときは、次のようにして各 GUI に対する固有のオプションを設定することができる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	if has("gui_running")
	    if has("gui_gtk2")
		:set guifont=Luxi\ Mono\ 12
	    elseif has("x11")
		" Also for GTK 1
		:set guifont=*-lucidatypewriter-medium-r-normal-*-*-180-*-*-m-*-*
	    elseif has("gui_win32")
		:set guifont=Luxi_Mono:h12:cANSI
	    elseif has("gui_macvim")
	        :set guifont=DejaVu\ Sans\ Mono:h13
	    endif
	endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
if has("gui_running")
    if has("gui_gtk2")
        :set guifont=Luxi\ Mono\ 12
    elseif has("x11")
        " Also for GTK 1
        :set guifont=*-lucidatypewriter-medium-r-normal-*-*-180-*-*-m-*-*
    elseif has("gui_win32")
        :set guifont=Luxi_Mono:h12:cANSI
    elseif has("gui_macvim")
        :set guifont=DejaVu\ Sans\ Mono:h13
    endif
endif
@end verbatim
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A recommended Japanese font is MS Mincho.  You can find info here:
http://www.lexikan.com/mincho.htm
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
推奨される日本語フォントは MS Mincho である。MS Mincho についての情報はここでみつかる:

@url{http://www.lexikan.com/mincho.htm}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
7. Shell Commands					*gui-shell*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-shell}
@cindex gui-shell
@section 7. シェルコマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For the X11 GUI the external commands are executed inside the gvim window.
See |gui-pty|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
X11 GUI では外部プログラムは gvim ウィンドウの中で実行される。|@ref{gui-pty}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
WARNING: Executing an external command from the X11 GUI will not always
work.  "normal" commands like "ls", "grep" and "make" mostly work fine.
Commands that require an intelligent terminal like "less" and "ispell" won't
work.  Some may even hang and need to be killed from another terminal.  So be
careful!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{警告:} @*
X11 GUI で外部プログラムを実行することは常にうまく動作するとは限らない。"ls", "grep", "make" のような一般的なプログラムはたいていうまく機能する。"less" や "ispell" のように高度なターミナルを要求するプログラムはうまく機能しないだろう。あるものはハングさえするかもしれないし、他のターミナルから kill する必要があるかもしれない。だから気をつけて！
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For the Win32 GUI the external commands are executed in a separate window.
See |gui-shell-win32|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Win32 GUI では外部プログラムは別のウィンドウで実行される。|@ref{gui-shell-win32}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 vim:tw=78:sw=4:ts=8:noet:ft=help:norl:
@end ifset
