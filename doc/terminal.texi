@ifset JA  @c ----------- v -----------  JA  -*- tab-width: 8 -*-
@node terminal.txt, , , 目次
@unnumbered ターミナルウィンドウのサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*terminal.txt*	For Vim version 8.1.  Last change: 2018 May 17


		  VIM REFERENCE MANUAL	  by Bram Moolenaar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
*terminal.txt*  For Vim バージョン 8.1.  Last change: 2018 May 17


                VIMリファレンスマニュアル    by Bram Moolenaar
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Terminal window support				*terminal* *terminal-window*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal}
@anchor{terminal-window}
@cindex terminal
@cindex terminal-window
端末ウィンドウサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
The terminal feature is optional, use this to check if your Vim has it: >
	echo has('terminal')
If the result is "1" you have it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末機能はオプションなので、あなたの Vim が対応しているかは次のコマンドを使って確認できます:
@example
echo has('terminal')
@end example
結果が "1" ならば対応しています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
1. Basic use			|terminal-use|
      Typing				|terminal-typing|
      Size and color			|terminal-size-color|
      Syntax				|:terminal|
      Resizing				|terminal-resizing|
      Terminal Modes			|Terminal-mode|
      Cursor style			|terminal-cursor-style|
      Session				|terminal-session|
      Special keys			|terminal-special-keys|
      Unix				|terminal-unix|
      MS-Windows			|terminal-ms-windows|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .6 .4
@item 1. 基本的な使い方 @tab |@ref{terminal-use}|
@item @ @ @ @ キー入力 @tab |@ref{terminal-typing}|
@item @ @ @ @ サイズと色 @tab |@ref{terminal-size-color}|
@item @ @ @ @ 文法 @tab |@ref{:terminal}|
@item @ @ @ @ サイズ変更 @tab |@ref{terminal-resizing}|
@item @ @ @ @ ターミナルモード @tab |@ref{Terminal-mode}|
@item @ @ @ @ カーソルスタイル @tab |@ref{terminal-cursor-style}|
@item @ @ @ @ セッション @tab |@ref{terminal-session}|
@item @ @ @ @ 特別なキー @tab |@ref{terminal-special-keys}|
@item @ @ @ @ Unix @tab |@ref{terminal-unix}|
@item @ @ @ @ MS-Windows @tab |@ref{terminal-ms-windows}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
2. Terminal communication	|terminal-communication|
      Vim to job: term_sendkeys()	|terminal-to-job|
      Job to Vim: JSON API		|terminal-api|
      Using the client-server feature	|terminal-client-server|
3. Remote testing		|terminal-testing|
4. Diffing screen dumps		|terminal-diff|
      Writing a screen dump test for Vim  |terminal-dumptest|
      Creating a screen dump		  |terminal-screendump|
      Comparing screen dumps		  |terminal-diffscreendump|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 2. 端末通信 @tab |@ref{terminal-communication}|
@item @ @ @ @ Vim からジョブへ: term_sendkeys() @tab |@ref{terminal-to-job}|
@item @ @ @ @ ジョブから Vim へ: JSON API @tab |@ref{terminal-api}|
@item @ @ @ @ クライアントサーバー機能を使う @tab |@ref{terminal-client-server}|
@item 3. リモートテスト @tab |@ref{terminal-testing}|
@item 4. 画面ダンプの差分 @tab |@ref{terminal-diff}|
@item @ @ @ @ Vim の画面ダンプテストを書く@tab |@ref{terminal-dumptest}|
@item @ @ @ @ 画面ダンプを作成する @tab |@ref{terminal-screendump}|
@item @ @ @ @ 画面ダンプを比較する @tab |@ref{terminal-diffscreendump}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
5. Debugging			|terminal-debug|
      Starting				|termdebug-starting|
      Example session			|termdebug-example|
      Stepping through code		|termdebug-stepping|
      Inspecting variables		|termdebug-variables|
      Other commands			|termdebug-commands|
      Prompt mode			|termdebug-prompt|
      Communication			|termdebug-communication|
      Customizing			|termdebug-customizing|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 5. デバッグ @tab |@ref{terminal-debug}|
@item @ @ @ @ はじめに @tab |@ref{termdebug-starting}|
@item @ @ @ @ セッション例 @tab |@ref{termdebug-example}|
@item @ @ @ @ コードをステップ実行する @tab |@ref{termdebug-stepping}|
@item @ @ @ @ 変数を検査する @tab |@ref{termdebug-variables}|
@item @ @ @ @ その他のコマンド @tab |@ref{termdebug-commands}|
@item @ @ @ @ プロンプトモード @tab |@ref{termdebug-prompt}|
@item @ @ @ @ 通信 @tab |@ref{termdebug-communication}|
@item @ @ @ @ カスタマイズ @tab |@ref{termdebug-customizing}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{Vi does not have any of these commands}
{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{Vi にはこれらのコマンドはありません@}

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The terminal feature requires the |+multi_byte|, |+job| and |+channel| features.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末機能を使うには |@ref{+multi_byte}|, |@ref{+job}| そして |@ref{+channel}| 機能が必要です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
1. Basic use						*terminal-use*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-use}
@cindex terminal-use
@section 1. 基本的な使い方
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This feature is for running a terminal emulator in a Vim window.  A job can be
started connected to the terminal emulator. For example, to run a shell: >
     :term bash
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは Vim のウィンドウ内で端末エミュレーターを実行する機能です。端末エミュレーターに接続すると 1 つのジョブが開始されます。例としてシェルを実行するならば以下のようになります:
@example
:term bash
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Or to run build command: >
     :term make myprogram
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
またビルドコマンドを実行するにはこうなります:
@example
:term make myprogram
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The job runs asynchronously from Vim, the window will be updated to show
output from the job, also while editing in another window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブは Vim とは非同期的に動作し、他のウィンドウで編集中であってもジョブからの出力は随時端末ウィンドウに反映されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Typing ~
							*terminal-typing*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-typing}
@cindex terminal-typing
@unnumberedsubsec キー入力
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
When the keyboard focus is in the terminal window, typed keys will be sent to
the job.  This uses a pty when possible.  You can click outside of the
terminal window to move keyboard focus elsewhere.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末ウィンドウにキーボードのフォーカスがある時には、入力したキーはジョブに送られます。これには可能ならば pty を使用します。端末ウィンドウ外をクリックすれば、キーボードフォーカスを外に動かせます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CTRL-W can be used to navigate between windows and other CTRL-W commands, e.g.:
	CTRL-W CTRL-W	move focus to the next window
	CTRL-W :	enter an Ex command
See |CTRL-W| for more commands.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ウィンドウや他の @kbd{CTRL-W} コマンドを操作するために @kbd{CTRL-W} を使えます。例えば:
@multitable @columnfractions .4 .6
@item @kbd{CTRL-W CTRL-W} @tab 次のウィンドウにフォーカスを移動する
@item @kbd{CTRL-W :} @tab Ex コマンドに入る
@end multitable
他のコマンドについては |@ref{CTRL-W}| 参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Special in the terminal window:			*CTRL-W_.*  *CTRL-W_N* 
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{CTRL-W_.}
@anchor{CTRL-W_N}
@kindex CTRL-W_.
@kindex CTRL-W_N
@unnumberedsubsubsec 端末ウィンドウでの特別な操作:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	CTRL-W .	send a CTRL-W to the job in the terminal
	CTRL-W CTRL-\	send a CTRL-\ to the job in the terminal
	CTRL-W N	go to Terminal-Normal mode, see |Terminal-mode|
	CTRL-\ CTRL-N   go to Terminal-Normal mode, see |Terminal-mode|
	CTRL-W " {reg}  paste register {reg}		*CTRL-W_quote*
			Also works with the = register to insert the result of
			evaluating an expression.
	CTRL-W CTRL-C	ends the job, see below |t_CTRL-W_CTRL-C|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item @kbd{CTRL-W .} @tab 端末内のジョブに @kbd{CTRL-W} を送る
@item @kbd{CTRL-W} @kbd{CTRL-\} @tab 端末内のジョブに @kbd{CTRL-\} を送る
@item @kbd{CTRL-W N} @tab Terminal-Normal モードに移行, |@ref{Terminal-mode}| を参照
@item @kbd{CTRL-\ CTRL-N} @tab Terminal-Normal モードに移行, |@ref{Terminal-mode}| を参照
@anchor{CTRL-W_quote}
@c @cindex CTRL-W_quote
@kindex CTRL-W_"
@item @kbd{CTRL-W "} @{reg@} @tab レジスタ @{reg@} の内容を貼り付け式の評価結果を挿入するためのレジスタ = も機能する
@item @kbd{CTRL-W CTRL-C} @tab ジョブを停止する, 下記の |@ref{t_CTRL-W_CTRL-C}| を参照
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
See option 'termwinkey' for specifying another key instead of CTRL-W that
will work like CTRL-W.  However, typing 'termwinkey' twice sends 'termwinkey'
to the job.  For example:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-W} の代わりに別のキーを使うにはオプション '@option{termwinkey}' を参照してください。ただし '@option{termwinkey}' を 2 回タイプすると '@option{termwinkey}' がジョブへ送信されます。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	'termwinkey' CTRL-W    move focus to the next window
	'termwinkey' :	       enter an Ex command
	'termwinkey' 'termwinkey' send 'termwinkey' to the job in the terminal
	'termwinkey' .	       send 'termwinkey' to the job in the terminal
	'termwinkey' CTRL-\    send a CTRL-\ to the job in the terminal
	'termwinkey' N	       go to terminal Normal mode, see below
	'termwinkey' CTRL-N    same as CTRL-W N
	'termwinkey' CTRL-C    same as |t_CTRL-W_CTRL-C|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item '@option{termwinkey}' @kbd{CTRL-W} @tab 次のウィンドウにフォーカスを移動する
@item '@option{termwinkey}' @key{:} @tab Ex コマンドに入る
@item '@option{termwinkey}' '@option{termwinkey}' @tab 端末内のジョブに '@option{termwinkey}' を送信する
@item '@option{termwinkey}' @key{.} @tab 端末内のジョブに '@option{termwinkey}' を送信する
@item '@option{termwinkey}' @key{CTRL-\} @tab 端末内のジョブに @kbd{CTRL-W} を送信する
@item '@option{termwinkey}' @key{N} @tab Terminal-Normal モードへ移行する。以下を参照
@item '@option{termwinkey}' @kbd{CTRL-N} @tab @kbd{CTRL-W N} と同じ
@item '@option{termwinkey}' @kbd{CTRL-C} @tab |@ref{t_CTRL-W_CTRL-C}| と同じ
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*t_CTRL-\_CTRL-N*
The special key combination CTRL-\ CTRL-N can be used to switch to Normal
mode, just like this works in any other mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{t_CTRL-\_CTRL-N}
@kindex t_CTRL-\_CTRL-N
他のモードと同じように、ノーマルモードへ移行するための特別なキーの組み合わせである @kbd{CTRL-\ CTRL-N} が利用できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*t_CTRL-W_CTRL-C*
CTRL-W CTRL-C can be typed to forcefully end the job.  On MS-Windows a
CTRL-BREAK will also kill the job.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{t_CTRL-W_CTRL-C}
@kindex t_CTRL-W_CTRL-C
ジョブを強制停止するのに @kbd{CTRL-W CTRL-C} を使えます。MS-Windows では @kbd{CTRL-BREAK} でも同様にジョブを停止できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you type CTRL-C the effect depends on what the pty has been configured to
do.  For simple commands this causes a SIGINT to be sent to the job, which
would end it.  Other commands may ignore the SIGINT or handle the CTRL-C
themselves (like Vim does).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-C} を入力した場合、その効果は pty がどのように構成されているかに従います。シンプルなコマンドにおいては SIGINT がジョブに送られ、結果的にジョブが停止するでしょう。中には SIGINT を無視するコマンドもあるでしょうし、また (Vim がそうしているように) @kbd{CTRL-C} をプログラム自身で取り扱うものもあるでしょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To change the keys you type use terminal mode mappings, see |:tmap|.
These are defined like any mapping, but apply only when typing keys that are
sent to the job running in the terminal.  For example, to make F1 switch
to Terminal-Normal mode: >
   tnoremap <F1> <C-W>N
You can use Esc, but you need to make sure it won't cause other keys to
break: >
   tnoremap <Esc> <C-W>N
   set notimeout ttimeout timeoutlen=100
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
入力したキーを別のものに読み返させるには端末モードマッピング、詳細は |@ref{:tmap}| を使用してください。これはどのようなマッピングでも定義できますが、端末内で実行されているジョブに送信されるキー入力にのみ作用します。例えば、F1 キーで Terminal-Normal モードに切り替えるには:
@example
tnoremap <F1> <C-W>N
@end example
Esc を使うこともできますが、他のキーが壊れないようにする必要があります:
@example
tnoremap <Esc> <C-W>N
set notimeout ttimeout timeoutlen=100
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN

<							*options-in-terminal*
After opening the terminal window and setting 'buftype' to "terminal" the
TerminalOpen autocommand event is triggered.  This makes it possible to set
options specifically for the window and buffer.  Example: >
   au TerminalOpen * if &buftype == 'terminal' | setlocal bufhidden=hide | endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{options-in-terminal}
@cindex options-in-terminal
端末ウィンドウを開いて '@option{buftype}' を "@var{terminal}" に設定すると、TerminalOpen 自動コマンドイベントが発生します。これにより、ウィンドウとバッファ専用のオプションを設定することが可能です。例:
@example
au TerminalOpen * if &buftype == 'terminal' | setlocal bufhidden=hide | endif
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The <abuf> is set to the terminal buffer, but if there is no window (hidden
terminal) then setting options will happen in the wrong buffer, therefore the
check for &buftype in the example.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
<abuf> は端末バッファに設定されていますが、ウィンドウが存在しない場合 (隠された端末) は間違ったバッファにオプションが設定されるため、この例では &buftype のチェックが行われます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Mouse events (click and drag) are passed to the terminal.  Mouse move events
are only passed when Vim itself is receiving them.  For a terminal that is
when 'balloonevalterm' is enabled.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マウスイベント (クリックやドラッグ) は端末に渡されます。マウス移動イベントは Vim 自身が受け取ったときのみ渡されます。'@option{balloonevalterm}' が有効になっている端末の場合です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Size and color ~
							*terminal-size-color*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-size-color}
@cindex terminal-size-color
@unnumberedsubsec サイズと色
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
See option 'termwinsize' for controlling the size of the terminal window.
(TODO: scrolling when the terminal is larger than the window)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末ウィンドウのサイズを制御するにはオプション '@option{termwinsize}' を参照してください。(TODO: 端末がウィンドウよりも大きい場合にはスクロールすることを記述する)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The job running in the terminal can change the colors.  The default foreground
and background colors are taken from Vim, the Normal highlight group.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末内のジョブは端末の色を変更できます。デフォルトの前景色及び背景色は Vim の Normal ハイライトグループにより決定されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For a color terminal the 'background' option is used to decide whether the
terminal window will start with a white or black background.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カラー端末を開始する際に、背景に白と黒どちらの系統の色を使用するかは、オプション '@option{background}' を用いて決定します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To use a different color the Terminal highlight group can be used, for
example: >
    hi Terminal ctermbg=lightgrey ctermfg=blue guibg=lightgrey guifg=blue
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
異なる色を使う場合には Terminal ハイライトグループを利用できます。例:
@example
hi Terminal ctermbg=lightgrey ctermfg=blue guibg=lightgrey guifg=blue
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*g:terminal_ansi_colors*
In GUI mode or with 'termguicolors', the 16 ANSI colors used by default in new
terminal windows may be configured using the variable
`g:terminal_ansi_colors`, which should be a list of 16 color names or
hexadecimal color codes, similar to those accepted by |highlight-guifg|.  When
not using GUI colors, the terminal window always uses the 16 ANSI colors of
the underlying terminal.
The |term_setansicolors()| function can be used to change the colors, and
|term_getansicolors()| to get the currently used colors.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:terminal_ansi_colors}
@vindex g:terminal_ansi_colors
新しい端末ウィンドウでデフォルトで使用される 16 個のANSI カラーは、変数 `@var{g:terminal_ansi_colors}` を使用して設定することができます。これは、16 個の色名または 16 進数の色コードのリストでなければなりません。これは、|@ref{highlight-guifg}| で受け入れられるものと同様です。 GUI カラーを使用しない場合、端末ウィンドウは常に端末基礎の 16 個の ANSI カラーを使用します。

|@ref{term_setansicolors()}| 関数を使用して色を変更したり、|@ref{term_getansicolors()}| を使用して現在使用されている色を取得することができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Syntax ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:ter}
@anchor{:terminal}
@pindex :ter
@pindex :terminal
@unnumberedsubsec 文法
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]ter[minal] [options] [command]			*:ter* *:terminal*
			Open a new terminal window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item :[range]ter[minal] [options] [command]
新しい端末ウィンドウを開きます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			If [command] is provided run it as a job and connect
			the input and output to the terminal.
			If [command] is not given the 'shell' option is used.
			if [command] is NONE no job is started, the pty of the
			terminal can be used by a command like gdb.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[command] が指定された場合、それをジョブとして実行し、端末の入出力を接続します。

[command] が指定されなかった場合、オプション '@option{shell}' を使用します。

[command] が NONE の場合ジョブは開始されず、端末の pty は gdb のようなコマンドによって利用できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			If [command] is missing the default behavior is to
			close the terminal when the shell exits.  This can be
			changed with the ++noclose argument.
			If [command] is present the default behavior is to
			keep the terminal open in Terminal-Normal mode.  This
			can be changed with the ++close argument.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[command] がない場合、デフォルトの動作はシェルが終了したときに端末を閉じます。この動作は ++noclose 引数で変更できます。

[command] が指定されている場合、デフォルトの動作は端末を端末ノーマルモードで開いたままにします。この動作は ++close 引数で変更できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			A new buffer will be created, using [command] or
			'shell' as the name, prefixed with a "!".  If a buffer
			by this name already exists a number is added in
			parentheses.  E.g. if "gdb" exists the second terminal
			buffer will use "!gdb (1)".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しいバッファが作られ、 [command] もしくは '@option{shell}' に "!" が前置された名前が与えられます。すでに同じ名前のバッファが存在する場合には、カッコに囲まれた番号が付与されます。例えば "gdb" が存在するなら 2 つ目の端末には "!gdb (1)" という名前が使われます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			If [range] is given the specified lines are used as
			input for the job.  It will not be possible to type
			keys in the terminal window.  For MS-Windows see the
			++eof argument below.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[range] が与えられた場合は、指定された範囲の行がジョブの入力として使われます。その際の端末ウィンドウではキー入力ができなくなります。MS-Windows においては以下の ++eof オプションも参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*term++close* *term++open*
			Supported [options] are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term++close}
@anchor{term++open}
@cindex term++close
@cindex term++open
サポートされる [options] は以下の通り:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			++close		The terminal window will close
					automatically when the job terminates.
			++noclose	The terminal window will NOT close
					automatically when the job terminates.
			++open		When the job terminates and no window
					shows it, a window will be opened.
					Note that this can be interruptive.
				The last of ++close, ++noclose and ++open
				matters and rules out earlier arguments.

			++curwin	Open the terminal in the current
					window, do not split the current
					window.  Fails if the current buffer
					cannot be |abandon|ed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item ++close @tab ジョブが終了した際には自動的に端末ウィンドウを閉じる。
@item ++noclose @tab ジョブが終了しても自動的に端末ウィンドウを@strong{閉じ}ません。
@item ++open @tab ジョブが終了した際にウィンドウが表示されていない場合に、ウィンドウを表示する。
@quotation
@strong{Note:} @*
割り込み的に発生しうることに留意。
@end quotation
++close, ++noclose と ++open は最後に指定されたものが有効です。
@item ++curwin @tab 現在のウィンドウで端末を開き、現在のウィンドウを分割しない。現在のバッファを放棄( |@ref{abandon}| )できない場合は失敗する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			++hidden	Open the terminal in a hidden buffer,
					no window will be used.
			++norestore	Do not include this terminal window
					in a session file.
			++kill={how}	When trying to close the terminal
					window kill the job with {how}.  See
					|term_setkill()| for the values.
			++rows={height} Use {height} for the terminal window
					height.  If the terminal uses the full
					Vim height (no window above or below
					the terminal window) the command line
					height will be reduced as needed.
			++cols={width}  Use {width} for the terminal window
					width. If the terminal uses the full
					Vim width (no window left or right of
					the terminal window) this value is
					ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ++hidden @tab 端末を隠しバッファとして開く。ウィンドウは使用されない。
@item ++norestore @tab セッションファイルに端末ウィンドウを含めません。
@item ++kill=@{how@} @tab 端末ウィンドウを閉じるときに @{how@} でジョブを終了させます。値については |@ref{term_setkill()}| を参照してください。
@item ++rows=@{height@} @tab 端末ウィンドウの高さとして @{height@} を使います。もし、端末が Vim の完全な高さ (端末ウィンドウの上や下にウィンドウがない) を使用する場合、必要に応じてコマンドラインの高さが現象します。
@item ++cols=@{width@} @tab 端末ウィンドウの幅として @{width@} を使います。もし、端末が Vim の完全な幅 (端末ウィンドウの左や右にウィンドウがない) を使用する場合、この値は無視されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			++eof={text}	when using [range]: text to send after
					the last line was written. Cannot
					contain white space.  A CR is
					appended.  For MS-Windows the default
					is to send CTRL-D.
					E.g. for a shell use "++eof=exit" and
					for Python "++eof=exit()".  Special
					codes can be used like with `:map`,
					e.g. "<C-Z>" for CTRL-Z.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ++eof=@{text@} @tab [range] を使った場合: 最後の行を送信したあとに指定したテキストが送られる。空白を含むことはできない。 CR が 1 つ付け加えられる。MS-Windows ではデフォルトでは CTRL-D が送られる。

例: シェルには "++eof=exit" を、Python には "++eof=exit()" を指定する。特殊 コードが `@command{:map}` と同様に利用できる。例: "<C-Z>" は CTRL-Z を示す。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			If you want to use more options use the |term_start()|
			function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
より詳細なオプションを使いたいならば |@ref{term_start()}| 関数を使ってください。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the buffer associated with the terminal is forcibly unloaded or wiped out
the job is killed, similar to calling `job_stop(job, "kill")` .
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末に関連付けられたバッファが強制的にアンロードもしくは削除された場合には、`@command{job_stop(job, "kill")}` を呼んだのと同じようにそのジョブが殺されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Closing the window normally results in |E947|.  When a kill method was set
with "++kill={how}" or |term_setkill()| then closing the window will use that
way to kill or interrupt the job.  For example: >
	:term ++kill=term tail -f /tmp/log
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
普通にウィンドウを閉じると |@ref{E947}| が返ります。kill メソッドが "++kill=@{how@}" か |@ref{term_setkill()}| で設定されている時にウィンドウを閉じると、その方法でジョブを強制停止または中断します。例:
@example
:term ++kill=term tail -f /tmp/log
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
So long as the job is running the window behaves like it contains a modified
buffer.  Trying to close the window with `CTRL-W :quit` fails.  When using
`CTRL-W :quit!` the job is ended.  The text in the window is lost.  The buffer
still exists, but getting it in a window with `:buffer` will show an empty
buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブが実行され続けるとウィンドウはそのバッファが変更されたかのように振る舞います。 `@command{CTRL-W :quit}` でウィンドウを閉じようとしても失敗します。`@command{CTRL-W :quit!}` を使うとジョブは終了します。ウィンドウのテキストは失われます。バッファは依然存在しますが、`@command{:buffer}` でウィンドウに割り当てても空のバッファが表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Trying to close the window with `CTRL-W :close` also fails.   Using
`CTRL-W :close!` will close the window and make the buffer hidden.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
`@command{CTRL-W :close}` で閉じようとしてもまた失敗します。`@command{CTRL-W :close!}` はウィンドウを閉じ、バッファを隠し状態にします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use `CTRL-W :hide` to close the terminal window and make the buffer
hidden, the job keeps running.  The `:buffer` command can be used to turn the
current window into a terminal window.  If there are unsaved changes this
fails, use ! to force, as usual.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
`@command{CTRL-W :hide}` を使うとジョブを実行したまま、端末ウィンドウを閉じバッファを隠し状態にできます。`@command{:buffer}` コマンドで現在のウィンドウを端末ウィンドウにすることができます。未保存の変更があった場合にはこれは失敗しますが、通常と同じように ! で強制できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To have a background job run without a window, and open the window when it's
done, use options like this: >
	:term ++hidden ++open make
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バックグラウンドジョブをウィンドウ無しで実行し、終了したらウィンドウに表示するには、次のようにオプションを指定します:
@example
:term ++hidden ++open make
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Note that the window will open at an unexpected moment, this will interrupt
what you are doing.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ウィンドウが予期せぬタイミングで開かれ、あなたが行っている操作に割り込む可能性があることに留意してください。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*E947* *E948*
So long as the job is running, the buffer is considered modified and Vim
cannot be quit easily, see |abandon|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E947}
@anchor{E948}
@erindex E947
@erindex E948
ジョブが実行され続けると、バッファが変更されたとみなされ Vim を簡単には終了できなくなります。|@ref{abandon}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the job has finished and no changes were made to the buffer: closing the
window will wipe out the buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブが終了しバッファになんの変更も及ぼさなかった場合、そのウィンドウを閉じるとバッファは削除されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Before changes can be made to a terminal buffer, the 'modifiable' option must
be set.  This is only possible when the job has finished.  At the first change
the buffer will become a normal buffer and the highlighting is removed.
You may want to change the buffer name with |:file| to be able to write, since
the buffer name will still be set to the command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末バッファを変更するにはオプション '@option{modifiable}' をセットする必要があります。これはジョブが終了した後にのみ行なえます。バッファを最初に変更した瞬間に普通のバッファになりハイライトは削除されます。バッファを保存可能にするために |@ref{:file}| でバッファの名前を、コマンド名から変更することもできます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Resizing ~
							*terminal-resizing*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-resizing}
@cindex terminal-resizing
@unnumberedsubsec サイズ変更
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The size of the terminal can be in one of three modes:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末のサイズは 3 つのモードのいずれか 1 つで決まります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. The 'termwinsize' option is empty: The terminal size follows the window
   size.  The minimal size is 2 screen lines with 10 cells.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item オプション '@option{termwinsize}' が空の場合: 端末サイズはウィンドウのサイズに従う。最小で 2 行、10 桁。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
2. The 'termwinsize' option is "rows*cols", where "rows" is the minimal number
   of screen rows and "cols" is the minimal number of cells.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item オプション '@option{termwinsize}' が "@var{rows*cols}" の場合、"@var{rows}" を最小行数、"@var{cols}" を最小桁数とする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
3. The 'termwinsize' option is "rowsXcols" (where the x is upper or lower
   case).  The terminal size is fixed to the specified number of screen lines
   and cells.  If the window is bigger there will be unused empty space.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item オプション '@option{termwinsize}' が "@var{rowsXcols}" ("X" は大文字小文字を問わない) の場合: 端末サイズは指定された行数と桁数で固定される。もしもウィンドウがそれよりも大きい場合には、使用されない空の領域ができる。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the window is smaller than the terminal size, only part of the terminal can
be seen (the lower-left part).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ウィンドウサイズが端末サイズよりも小さい場合、端末の一部の領域 (左下に相当する部分) のみが描画されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The |term_getsize()| function can be used to get the current size of the
terminal.  |term_setsize()| can be used only when in the first or second mode,
not when 'termwinsize' is "rowsXcols".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末の現在のサイズを取得するのに関数 |@ref{term_getsize()}| が使えます。|@ref{term_setsize()}| は 1 か 2 のモードの時にだけ、すなわち '@option{termwinsize}' が "@var{rowsXcols}" 形式ではない時に使えます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Terminal-Job and Terminal-Normal mode ~
						*Terminal-mode* *Terminal-Job*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Terminal-mode}
@anchor{Terminal-Job}
@cindex Terminal-mode
@cindex Terminal-Job
@unnumberedsubsec Terminal-Job と Terminal-Normal モード
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
When the job is running the contents of the terminal is under control of the
job.  That includes the cursor position.  Typed keys are sent to the job.
The terminal contents can change at any time.  This is called Terminal-Job
mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブが実行中には端末の内容はジョブの制御下にあります。それにはカーソルの位置も含まれます。入力したキーはジョブに送られます。端末の内容はいつでも更新されえます。これを Terminal-Job モードと呼びます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Use CTRL-W N (or 'termwinkey' N) to switch to Terminal-Normal mode.  Now the
contents of the terminal window is under control of Vim, the job output is
suspended.  CTRL-\ CTRL-N does the same.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-W N} (もしくは 'termwinkey' N) を入力すると Terminal-Normal モードに遷移します。このモードでは端末ウィンドウのコンテンツは Vim の制御下に置かれ、ジョブの出力は一時保留されます。@kbd{CTRL-\ CTRL-N} でも同じようになります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Terminal-Job mode is where |:tmap| mappings are applied. Keys sent by
|term_sendkeys()| are not subject to tmap, but keys from |feedkeys()| are.

It is not possible to enter Insert mode from Terminal-Job mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:tmap}| のマッピングは Terminal-Job モードにおいて作用します。|@ref{term_sendkeys()}| で送ったキーには tmap は適用されませんが、|@ref{feedkeys()}| で送ったキーには適用されます。

Terminal-Job モードから挿入モードに移る方法はありません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*Terminal-Normal* *E946*
In Terminal-Normal mode you can move the cursor around with the usual Vim
commands, Visually mark text, yank text, etc.  But you cannot change the
contents of the buffer.  The commands that would start insert mode, such as
'i' and 'a', return to Terminal-Job mode.  The window will be updated to show
the contents of the terminal. |:startinsert| is ineffective.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Terminal-Normal}
@anchor{E946}
@cindex Terminal-Normal
@erindex E946
Terminal-Normal モードでは、Vim の普通のコマンドでカーソルを自由に動かせます。視覚的にテキストをマークしたり、テキストをヤンクしたり思いのままです。しかしバッファの内容を変更することはできません。'i' や 'a' など挿入モードを開始するコマンドを使うと Terminal-Job モードに戻ります。結果としてウィンドウは端末のコンテンツを反映させるために更新されます。|@ref{:startinsert}| は無効です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In Terminal-Normal mode the statusline and window title show "(Terminal)".  If
the job ends while in Terminal-Normal mode this changes to
"(Terminal-finished)".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Terminal-Normal モードではステータスラインとウィンドウタイトルには "(Terminal)" と表示されます。Terminal-Normal モード中にジョブが終了してしまった場合にはそれが "(Terminal-finished)" に変わります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the job outputs lines in the terminal, such that the contents scrolls off
the top, those lines are remembered and can be seen in Terminal-Normal mode.
The number of lines is limited by the 'termwinscroll' option. When going over
this limit, the first 10% of the scrolled lines are deleted and are lost.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブが端末内で行を出力し内容がスクロールすると、それらの行は記憶され Terminal-Normal モードで表示されます。行数は '@option{'termwinscroll}' オプションによって制限されます。この制限を超えると、スクロールされた行の最初の 10% が削除され失われます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Cursor style ~
							*terminal-cursor-style*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-cursor-style}
@cindex terminal-cursor-style
@unnumberedsubsec カーソルスタイル
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
By default the cursor in the terminal window uses a not blinking block.  The
normal xterm escape sequences can be used to change the blinking state and the
shape.  Once focus leaves the terminal window Vim will restore the original
cursor.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デフォルトでは端末ウィンドウのカーソルには点滅しないブロックが使われます。カーソルの点滅状態や形を変更するのに、普通の xterm のエスケープシーケンスが使われます。端末ウィンドウからフォーカスが外れる際に Vim は元々のカーソルを復元します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An exception is when xterm is started with the "-bc" argument, or another way
that causes the cursor to blink.  This actually means that the blinking flag
is inverted.  Since Vim cannot detect this, the terminal window cursor
blinking will also be inverted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
xterm を "-bc" 引数で起動した場合、または他の方法でカーソルの点滅を発生させた場合、が1つの例外となります。それらにより点滅フラグが逆転したことが問題の引き金となります。なぜなら Vim はその逆転を検出できず、端末ウィンドウのカーソルの点滅も逆転します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Session ~
							*terminal-session*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-session}
@cindex terminal-session
@unnumberedsubsec セッション
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
A terminal window will be restored when using a session file, if possible and
wanted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
可能かつ必要であれば、セッションファイルを使用する歳に端末ウィンドウが復元されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If "terminal" was removed from 'sessionoptions' then no terminal windows will
be restored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"terminal" が '@option{sessionoptions}' から削除された場合、端末ウィンドウは復元されません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the job in the terminal was finished the window will not be restored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末内のジョブが終了した場合、ウィンドウは復元されません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the terminal can be restored, the command that was used to open it will be
used again.  To change this use the |term_setrestore()| function.  This can
also be used to not restore a specific terminal by setting the command to
"NONE".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末を復元できる場合は、その端末を開くために使われたコマンドが再び使われます。これを変更するには |@ref{term_setrestore()}| 関数を使用します。これは、コマンドを "NONE" に設定して特定の端末を復元しない場合にも使用できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Special keys ~
							*terminal-special-keys*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-special-keys}
@cindex terminal-special-keys
@unnumberedsubsec 特別なキー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Since the terminal emulator simulates an xterm, only escape sequences that
both Vim and xterm recognize will be available in the terminal window.  If you
want to pass on other escape sequences to the job running in the terminal you
need to set up forwarding.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末エミュレーターは xterm をシミュレートするので、Vim と xterm の両方が認識するエスケープシーケンスのみが端末ウィンドウで利用可能になります。もし、端末で実行中のジョブに他のエスケープシーケンスを渡したい場合は、転送を設定する必要があります。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	tmap <expr> <Esc>]b SendToTerm("\<Esc>]b")
	func SendToTerm(what)
	  call term_sendkeys('', a:what)
	  return ''
	endfunc
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
tmap <expr> <Esc>]b SendToTerm("\<Esc>]b")
func SendToTerm(what)
  call term_sendkeys('', a:what)
  return ''
endfunc
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Unix ~
							*terminal-unix*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-unix}
@cindex terminal-unix
@unnumberedsubsec Unix
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
On Unix a pty is used to make it possible to run all kinds of commands.  You
can even run Vim in the terminal!  That's used for debugging, see below.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
UNIX ではすべての種類のコマンドを実行可能とするために pty を用いています。端末内で Vim ですら実行できるのです！これは以下のようにデバッグに利用できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Environment variables are used to pass information to the running job:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
実行中のジョブに情報を伝えるのに以下の環境変数が利用できます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    TERM		the name of the terminal, from the 'term' option or
			$TERM in the GUI; falls back to "xterm" if it does not
			start with "xterm"
    ROWS		number of rows in the terminal initially
    LINES		same as ROWS
    COLUMNS		number of columns in the terminal initially
    COLORS		number of colors, 't_Co' (256*256*256 in the GUI)
    VIM_SERVERNAME	v:servername
    VIM_TERMINAL	v:version
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item TERM @tab 端末の名前、'@option{term}' オプションまたは GUI では @var{$TERM} から。"xterm" で始まらなければ "xterm" にフォールバックする
@item ROWS @tab 端末の初期行数
@item LINES @tab ROWS と同じ
@item COLUMNS @tab 端末の初期桁数
@item COLORS @tab 色数 '@option{t_Co}' (GUIでは 256*256*256)
@item VIM_SERVERNAME @tab v:servername
@item VIM_TERMINAL @tab v:version
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MS-Windows ~
							*terminal-ms-windows*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-ms-windows}
@cindex terminal-ms-windows
@unnumberedsubsec MS-Windows
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
On MS-Windows winpty is used to make it possible to run all kind of commands.
Obviously, they must be commands that run in a terminal, not open their own
window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
MS-Windows ではすべての種類のコマンドを実行可能とするために winpty を用いています。あたりまえのことですが、ここで実行するコマンドは端末の中で動くもので、独自のウィンドウを開くものであってはいけません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You need the following two files from winpty:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
winpty 内の以下の 2 つのファイルが必要です:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
    winpty.dll
    winpty-agent.exe
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
winpty.dll
winpty-agent.exe
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can download them from the following page:

    https://github.com/rprichard/winpty
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらは以下のページからダウンロードできます:

@url{https://github.com/rprichard/winpty}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Just put the files somewhere in your PATH.  You can set the 'winptydll' option
to point to the right file, if needed.  If you have both the 32-bit and 64-bit
version, rename to winpty32.dll and winpty64.dll to match the way Vim was
build.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのファイルを環境変数 PATH のいずれかに置くだけです。必要ならばオプション '@option{winptydll}' でファイルの場所を指定できます。もしも 32 ビット版と 64 ビット版を同じディレクトリに置きたいのであれば、Vim のビルドに合わせてそれぞれを winpty32.dll もしくは winpty64.dll という名前に変更してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Environment variables are used to pass information to the running job:
    VIM_SERVERNAME	v:servername
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
環境変数は実行中のジョブに情報を渡すために使用されます:
@example
VIM_SERVERNAME	v:servername
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
2. Terminal communication			 *terminal-communication*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-communication}
@cindex terminal-communication
@section 2. 端末通信
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are several ways to communicate with the job running in a terminal:
- Use |term_sendkeys()| to send text and escape sequences from Vim to the job.
- Use the JSON API to send encoded commands from the job to Vim.
- Use the |client-server| mechanism. This works on machines with an X server
  and on MS-Windows.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末内で実行中のジョブと通信するには、いくつかの方法があります:
@itemize
@item |@ref{term_sendkeys()}| でテキストやエスケープシーケンスを Vim に送信する。
@item JSON API を使用して、エンコードされたコマンドをジョブから Vim に送信する。
@item |@ref{client-server}| 機構を使います。これは X server と MS-Windows のマシンで動作します。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Vim to job: term_sendkeys() ~
							*terminal-to-job*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-to-job}
@cindex terminal-to-job
@unnumberedsubsec Vim からジョブへ: term_sendkeys()
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This allows for remote controlling the job running in the terminal.  It is a
one-way mechanism.  The job can update the display to signal back to Vim.
For example, if a shell is running in a terminal, you can do: >
	call term_sendkeys(buf, "ls *.java\<CR>")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これにより、端末内で実行中のジョブをリモート制御することができます。これは一方向の機構です。ジョブは Vim に合図することで表示を更新することができます。例えば、シェルが端末内で実行されている場合、次の操作を実行できます:
@example
call term_sendkeys(buf, "ls *.java\<CR>")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This requires for the job to be in the right state where it will do the right
thing when receiving the keys.  For the above example, the shell must be
waiting for a command to be typed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは、キーを受け取ったときに正しいことをする適切な状態になるようなジョブを必要とします。上記の例では、シェルはコマンドの入力を待つ必要があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For a job that was written for the purpose, you can use the JSON API escape
sequence in the other direction.  E.g.: >
	call term_sendkeys(buf, "\<Esc>]51;["response"]\x07")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この目的のために作成されたジョブでは、JSON API エスケープシーケンスを別の方向で使用できます。例:
@example
call term_sendkeys(buf, "\<Esc>]51;["response"]\x07")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Job to Vim: JSON API ~
							*terminal-api*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-api}
@cindex terminal-api
@unnumberedsubsec ジョブから Vim へ: JSON API
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The job can send JSON to Vim, using a special escape sequence.  The JSON
encodes a command that Vim understands.  Example of such a message: >
	<Esc>]51;["drop", "README.md"]<07>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブは特殊なエスケープシーケンスを使用して JSON を Vim に送ることができます。JSON は Vim が理解できるコマンドをエンコードします。そのようなメッセージの例:
@example
<Esc>]51;["drop", "README.md"]<07>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The body is always a list, making it easy to find the end: ]<07>.
The <Esc>]51;msg<07> sequence is reserved by xterm for "Emacs shell", which is
similar to what we are doing here.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
本体は常にリストになっており、終わりを見つけやすいです: @samp{]<07>}。@samp{<Esc>]51;msg<07>} シーケエンスは "Emacs shell" のために xterm によって予約されています。私たちがここでやっていることに似ています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Currently supported commands:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec 現在サポートされているコマンド:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	call {funcname} {argument}

		Call a user defined function with {argument}.
		The function is called with two arguments: the buffer number
		of the terminal and {argument}, the decoded JSON argument. 
		The function name must start with "Tapi_" to avoid
		accidentally calling a function not meant to be used for the
		terminal API.
		The user function should sanity check the argument.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item call @{funcname@} @{argument@}
ユーザー定義関数を @{argument@} で呼び出します。関数は 2 つの引数で呼び出されます: 端末のバッファ番号とデコードされた JSON 引数 @{argument@} です。

関数名は端末 API 用に意図されていない関数を誤って呼び出すのを避けるため、"Tapi_" で始まる必要があります。

ユーザー関数は引数の正常性チェックをする必要があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The function can use |term_sendkeys()| to send back a reply.
		Example in JSON: >
			["call", "Tapi_Impression", ["play", 14]]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数は |@ref{term_sendkeys()}| を使って返信を送り返すことができます。

JSON での例:
@example
["call", "Tapi_Impression", ["play", 14]]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		Calls a function defined like this: >
			function Tapi_Impression(bufnum, arglist)
			  if len(a:arglist) == 2
			    echomsg "impression " . a:arglist[0]
			    echomsg "count " . a:arglist[1]
			  endif
			endfunc
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のように定義された関数を呼び出します:
@example
function Tapi_Impression(bufnum, arglist)
  if len(a:arglist) == 2
    echomsg "impression " . a:arglist[0]
    echomsg "count " . a:arglist[1]
  endif
endfunc
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		Output from `:echo` may be erased by a redraw, use `:echomsg`
		to be able to see it with `:messages`.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
`@command{:echo}` からの出力は再描画によって消去されかもしれません。`@command{:echomsg}` を使い、`@command{:messages}` でそれを見ることができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	drop {filename} [options]

		Let Vim open a file, like the `:drop` command.  If {filename}
		is already open in a window, switch to that window.  Otherwise
		open a new window to edit {filename}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item drop @{filename@} [options]
Vim に `@command{:drop}` コマンドのようにファイルを開かせます。もし、@{filename@} が既にウィンドウで開かれていたら、そのウィンドウに切り替えます。それ以外の場合は、@{filename@} を編集するための新しいウィンドウを開きます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that both the job and Vim may change the current
		directory, thus it's best to use the full path.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ジョブと Vim の両方がカレントディレクトリを変更する可能性があるので、フルパスを使用することをお勧めします。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		[options] is only used when opening a new window.  If present,
		it must be a Dict.  Similarly to |++opt|, These entries are recognized:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[options] は新しくウィンドウを開いた時にだけ使われます。与える場合、それは辞書でなければなりません。|@ref{++opt}| と同様に、これらのエントリは認識されます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		  "ff"		file format: "dos", "mac" or "unix"
		  "fileformat"	idem
		  "enc"		overrides 'fileencoding'
		  "encoding"	idem
		  "bin"		sets 'binary'
		  "binary"	idem
		  "nobin"	resets 'binary'
		  "nobinary"	idem
		  "bad"		specifies behavior for bad characters, see
				|++bad|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item "ff" @tab ファイルフォーマット: "dos", "mac" もしくは "unix"
@item "fileformat" @tab 同上
@item "enc" @tab '@option{fileencoding}' を上書きします
@item "encoding" @tab 同上
@item "bin" @tab '@option{binary}' を設定します
@item "binary" @tab 同上
@item "nobin" @tab '@option{binary}' をリセットします
@item "nobinary" @tab 同上
@item "bad" @tab 不正な文字のための振る舞いを指定します。|@ref{++bad}| を参照
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example in JSON: >
			["drop", "path/file.txt", {"ff": "dos"}]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

JSON での例:
@example
["drop", "path/file.txt", @{"ff": "dos"@}]
@end example
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A trick to have Vim send this escape sequence: >
	exe "set t_ts=\<Esc>]51; t_fs=\x07"
	let &titlestring = '["call","Tapi_TryThis",["hello",123]]'
	redraw
	set t_ts& t_fs&
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim にこのエスケープシーケエンスを送信させるトリック:
@example
exe "set t_ts=\<Esc>]51; t_fs=\x07"
let &titlestring = '["call","Tapi_TryThis",["hello",123]]'
redraw
set t_ts& t_fs&
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Rationale: Why not allow for any command or expression?  Because that might
create a security problem.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
論理的根拠: コマンドや式を許可しないのはなぜですか？セキュリティ上の問題が生じる可能性があるためです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Using the client-server feature ~
						*terminal-client-server*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-client-server}
@cindex terminal-client-server
@unnumberedsubsec クライアントサーバー機能を使う
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This only works when v:servername is not empty.  If needed you can set it,
before opening the terminal, with: >
	call remote_startserver('vim-server')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは v:servername が空ではない場合にのみ機能します。必要に応じて、端末を開く前に次のように設定することができます:
@example
call remote_startserver('vim-server')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
$VIM_SERVERNAME is set in the terminal to pass on the server name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@env{$VIM_SERVERNAME} はサーバー名を渡すために端末内に設定されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In the job you can then do something like: >
	vim --servername $VIM_SERVERNAME --remote +123 some_file.c
This will open the file "some_file.c" and put the cursor on line 123.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブでは、次のようなことをおこなうことができます:
@verbatim
vim --servername $VIM_SERVERNAME --remote +123 some_file.c
@end verbatim
これによりファイル "@file{some_file.c}" が開き、123 行目にカーソルが置かれます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
3. Remote testing					*terminal-testing*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-testing}
@cindex terminal-testing
@section 3. リモートテスト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Most Vim tests execute a script inside Vim.  For some tests this does not
work, running the test interferes with the code being tested.  To avoid this
Vim is executed in a terminal window.  The test sends keystrokes to it and
inspects the resulting screen state.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim のほとんどのテストは Vim のなかでスクリプトを実行しています。テスト対象のコードと干渉してしまうような、幾つかのテストではこれは機能しません。これを避けるために端末ウィンドウ内でさらに Vim を実行しています。そのテストではキーストロークを端末に送信し、その結果として端末画面の状態が変わるのを検査します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Functions ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 関数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|term_sendkeys()|	send keystrokes to a terminal (not subject to tmap)
|term_wait()|		wait for screen to be updated
|term_scrape()|		inspect terminal screen
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item |@ref{term_sendkeys()}| @tab 端末にキーストロークを送信する (tmap の影響を受けない)
@item |@ref{term_wait()}| @tab 端末画面が更新されるのを待つ
@item |@ref{term_scrape()}| @tab 端末画面の内容を検査する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
==============================================================================
4. Diffing screen dumps					*terminal-diff*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-diff}
@cindex terminal-diff
@section 4. 画面ダンプの差分
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In some cases it can be bothersome to test that Vim displays the right
characters on the screen.  E.g. with syntax highlighting.  To make this
simpler it is possible to take a screen dump of a terminal and compare it to
an expected screen dump.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
場合によっては、Vim が正しい文字を画面に表示するかどうかテストするのは面倒かもしれません。例えば、構文の強調表示。これを簡単にするために、端末の画面ダンプを取ってそれを予想される画面ダンプと比較することが可能です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim uses the window size, text, color and other attributes as displayed.  The
Vim screen size, font and other properties do not matter.  Therefore this
mechanism is portable across systems.  A conventional screenshot would reflect
all differences, including font size and family.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim はウィンドウのサイズ、テキスト、色、その他の属性を表示します。 Vim の画面サイズ、フォント、その他のプロパティは関係ありません。したがって、この機構はシステム間で移植可能です。従来のスクリーンショットでは、フォントサイズやフォントファミリーなど、すべての違いが反映されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Writing a screen dump test for Vim ~
							*terminal-dumptest*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-dumptest}
@cindex terminal-dumptest
@unnumberedsubsec Vim の画面ダンプテストを書く
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
For an example see the Test_syntax_c() function in
src/testdir/test_syntax.vim.  The main parts are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例については、src/testdir/test_syntax.vim の Test_syntax_c() 関数を参照してください。主要な部分は:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Write a file you want to test with. This is useful for testing syntax
  highlighting.  You can also start Vim with en empty buffer.
- Run Vim in a terminal with a specific size.  The default is 20 lines of 75
  characters.  This makes sure the dump is always this size.  The function
  RunVimInTerminal() takes care of this.  Pass it the arguments for the Vim
  command.
- Send any commands to Vim using |term_sendkeys()|.  For example: >
	call term_sendkeys(buf, ":echo &lines &columns\<CR>")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item テストするファイルを作成します。構文のハイライトをテストするのに便利です。空のバッファで Vim を起動することもできます。
@item 特定のサイズの端末で Vim を実行します。デフォルトは 75 桁で 20 行です。これはダンプが常にこのサイズであることを確認します。RunVimInTerminal() 関数がこれを処理します。Vim コマンドの引数を渡します。
@item |@ref{term_sendkeys()}| を使用して任意のコマンドを Vim に送信します。例えば:
@example
call term_sendkeys(buf, ":echo &lines &columns\<CR>")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Check that the screen is now in the expected state, using
  VerifyScreenDump().  This expects the reference screen dump to be in the
  src/testdir/dumps/ directory.  Pass the name without ".dump".  It is
  recommended to use the name of the test function and a sequence number, so
  that we know what test is using the file.
- Repeat sending commands and checking the state.
- Finally stop Vim by calling StopVimInTerminal().
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item VerifyScreenDump() を使用して、画面が期待どおりの状態になっていることを確認します。これは、参照する画面ダンプが src/testdir/dumps/ ディレクトリに存在することを前提としています。 ".dump" なしの名前を渡します。テスト関数の名前とシーケンス番号を使用してファイルがどのようなテストで使用されているかを知ることができます。
@item コマンド送信と状態の確認を繰り返します。
@item 最後に StopVimInTerminal() を呼び出して Vim を停止します。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The first time you do this you won't have a screen dump yet.  Create an empty
file for now, e.g.: >
	touch src/testdir/dumps/Test_function_name_01.dump
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
初めてこれを行うときにはスクリーンダンプはまだありません。空のファイルを作成します。例:
@example
touch src/testdir/dumps/Test_function_name_01.dump
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The test will then fail, giving you the command to compare the reference dump
and the failed dump, e.g.: >
	call term_dumpdiff("Test_func.dump.failed", "dumps/Test_func.dump")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
テストが失敗したら、参照ダンプと失敗したダンプを比較するコマンドを提供します。例:
@example
call term_dumpdiff("Test_func.dump.failed", "dumps/Test_func.dump")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Use this command in Vim, with the current directory set to src/testdir.
Once you are satisfied with the test, move the failed dump in place of the
reference: >
	:!mv Test_func.dump.failed dumps/Test_func.dump
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カレントディレクトリを src/testdir に設定して、Vim でこのコマンドを使用します。テストに満足したら、参照の代わりに失敗したダンプを移動します:
@example
:!mv Test_func.dump.failed dumps/Test_func.dump
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Creating a screen dump ~
							*terminal-screendump*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-screendump}
@cindex terminal-screendump
@unnumberedsubsec 画面ダンプを作成する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To create the screen dump, run Vim (or any other program) in a terminal and
make it show the desired state.  Then use the |term_dumpwrite()| function to
create a screen dump file.  For example: >
	:call term_dumpwrite(77, "mysyntax.dump")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
画面ダンプを作成するには、端末で Vim (または他のプログラム) を実行し、目的の状態を表示させます。その後、|@ref{term_dumpwrite()}| 関数を使用して画面ダンプファイルを作成します。例:
@example
:call term_dumpwrite(77, "mysyntax.dump")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here "77" is the buffer number of the terminal.  Use `:ls!` to see it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この "77" は端末のバッファ番号です。それを見るためには `:ls!` を使用してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can view the screen dump with |term_dumpload()|: >
	:call term_dumpload("mysyntax.dump")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{term_dumpload()}| で画面ダンプを見ることができます:
@example
:call term_dumpload("mysyntax.dump")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To verify that Vim still shows exactly the same screen, run Vim again with
exactly the same way to show the desired state.  Then create a screen dump
again, using a different file name: >
	:call term_dumpwrite(88, "test.dump")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim がまったく同じ画面を表示していることを確認するには、まったく同じ方法で Vim を再度実行し、目的の状態を表示します。次に、別のファイル名を使用して画面ダンプを再度作成します:
@example
:call term_dumpwrite(88, "test.dump")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To assert that the files are exactly the same use |assert_equalfile()|: >
	call assert_equalfile("mysyntax.dump", "test.dump")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルがまったく同じものであることを主張するには |@ref{assert_equalfile()}| を使います:
@example
call assert_equalfile("mysyntax.dump", "test.dump")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If there are differences then v:errors will contain the error message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
違いがある場合、v:errors はエラーメッセージを含みます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Comparing screen dumps ~
						*terminal-diffscreendump*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-diffscreendump}
@cindex terminal-diffscreendump
@unnumberedsubsec 画面ダンプを比較する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|assert_equalfile()| does not make it easy to see what is different.
To spot the problem use |term_dumpdiff()|: >
	call term_dumpdiff("mysyntax.dump", "test.dump")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{assert_equalfile()}| は、何が違うのかを簡単に見分けることはできません。問題を見つけるには、|@ref{term_dumpdiff()}| を使用します:
@example
call term_dumpdiff("mysyntax.dump", "test.dump")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This will open a window consisting of three parts:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これで 3 つの部分からなるウィンドウが開きます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
1.  The contents of the first dump
2.  The difference between the first and second dump
3.  The contents of the second dump
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item 1 番目のダンプの内容
@item 1 番目と 2 番目のダンプの差分
@item 2 番目のダンプの内容
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can usually see what differs in the second part.  Use the 'ruler' to
relate it to the position in the first or second dump.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
通常、2 番目の部分で何が違うかを見ることができます。1 番目または 2 番目ダンプの位置に関連付けるには '@option{ruler}' を使用します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Alternatively, press "s" to swap the first and second dump. Do this several
times so that you can spot the difference in the context of the text.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
あるいは、"s" を押して、1 番目と 2 番目のダンプを入れ替えます。これを何度か実行して、テキストの文脈における相違を見つけ出すことができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
5. Debugging				*terminal-debug* *terminal-debugger*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-debug}
@anchor{terminal-debugger}
@cindex terminal-debug
@cindex terminal-debugger
@section 5. デバッグ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The Terminal debugging plugin can be used to debug a program with gdb and view
the source code in a Vim window.  Since this is completely contained inside
Vim this also works remotely over an ssh connection.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim のウィンドウでソースコードを表示しながらプログラムを gdb でデバッグするのに、端末デバッグプラグインが利用できます。これは Vim の中だけで完結するので、SSH 接続が 1 つあればリモートで機能します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the |+terminal| feature is missing, the plugin will use the "prompt"
buffer type, if possible.  The running program will then use a newly opened
terminal window.  See |termdebug-prompt| below for details.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{+terminal}| 機能がない場合、プラグインは可能であれば "prompt" バッファタイプを使用します。実行中のプログラムは、新しく開かれた端末ウィンドウを使用します。詳細は |@ref{termdebug-prompt}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Starting ~
							*termdebug-starting*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug-starting}
@cindex termdebug-starting
@unnumberedsubsec はじめに
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Load the plugin with this command: >
	packadd termdebug
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下のコマンドでプラグインを読み込みます:
@example
packadd termdebug
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<							*:Termdebug*
To start debugging use `:Termdebug` or `:TermdebugCommand` followed by the
command name, for example: >
	:Termdebug vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:Termdebug}
@pindex :Termdebug
デバッグを開始するには `@command{:TermDebug}` または `@command{:TermdebugCommand}` に続けてコマンド名を入力します。例:
@example
:TermDebug vim
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This opens two windows:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これにより 2 つのウィンドウが開きます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
gdb window	A terminal window in which "gdb vim" is executed.  Here you
		can directly interact with gdb.  The buffer name is "!gdb".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item gdb のウィンドウ @tab "gdb vim" を実行した端末ウィンドウ。ここでは直接 gdb とやりとりできる。バッファ名は "!gdb"
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
program window	A terminal window for the executed program.  When "run" is
		used in gdb the program I/O will happen in this window, so
		that it does not interfere with controlling gdb.  The buffer
		name is "gdb program".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item プログラムのウィンドウ @tab 実行したプログラムの端末ウィンドウ。gdb 内で "run" をしてプログラムの I/O が発生するとこのウィンドウに反映される。その内容は gdb の制御下にない。バッファ名は "gdb program"
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The current window is used to show the source code.  When gdb pauses the
source file location will be displayed, if possible.  A sign is used to
highlight the current position, using highlight group debugPC.	 
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
現在のウィンドウはソースコードを表示するのに使われます。gdb が一時停止した際に、可能ならばその場所が表示されます。現在の位置を示すためにハイライトグループ debugPC を使ってサインが利用されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the buffer in the current window is modified, another window will be opened
to display the current gdb position.  You can use `:Winbar` to add a window
toolbar there.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
現在のウィンドウの内容が変更されると、現在の gdb の位置を表示するために別のウィンドウが開きます。`@command{:Winbar}` を使ってウィンドウツールバーを追加することができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Focus the terminal of the executed program to interact with it.  This works
the same as any command running in a terminal window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
実行中のプログラムを操作するにはその端末にフォーカスを合わせます。以降の操作は普通の端末ウィンドウと同様です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the debugger ends, typically by typing "quit" in the gdb window, the two
opened windows are closed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デバッガの終了は、通常は gdb のウィンドウで "quit" とタイプすると、開いている 2 つのウィンドウが閉じられます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Only one debugger can be active at a time.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
一度にアクティブにできるデバッガは 1 つだけです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:TermdebugCommand*
If you want to give specific commands to the command being debugged, you can
use the `:TermdebugCommand` command followed by the command name and
additional parameters. >
	:TermdebugCommand vim --clean -c ':set nu'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:TermdebugCommand}
@pindex :TermdebugCommand
デバッグ中のコマンドに特定のコマンドを与える場合は、`@command{:TermdebugCommand}` コマンドの後にコマンド名と追加パラメータを使用できます。
@example
:TermdebugCommand vim @minus{}@minus{}clean -c ':set nu'
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Both the `:Termdebug` and `:TermdebugCommand` support an optional "!" bang
argument to start the command right away, without pausing at the gdb window
(and cursor will be in the debugged window).  For example: >
	:TermdebugCommand! vim --clean
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
`@command{:Termdebug}` と `@command{:TermdebugCommand}` はオプションの "!" をサポートしています。gdb ウィンドウで一時停止せずにコマンドをすぐに開始します (そしてカーソルはデバッグされたウィンドウに表示されます) 例えば:
@example
:TermdebugCommand! vim @minus{}@minus{}clean
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To attach gdb to an already running executable or use a core file, pass extra
arguments.  E.g.: >
	:Termdebug vim core
	:Termdebug vim 98343
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
すでに実行中の実行可能ファイルに gdb をアタッチするか、コアファイルを使用するには、追加の引数を渡します。例:
@example
:Termdebug vim core
:Termdebug vim 98343
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If no argument is given, you'll end up in a gdb window, in which you need to
specify which command to run using e.g. the gdb `file` command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数が指定されていない場合、gdb ウィンドウが表示されます。このウィンドウでは、例えば gdb の `@command{file}` コマンドを使って、どのコマンドを実行するか指定する必要があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Example session ~
							*termdebug-example*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug-example}
@cindex termdebug-example
@unnumberedsubsec セッション例
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Start in the Vim "src" directory and build Vim: >
	% make
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim の "src" ディレクトリを起動して、Vim をビルドします:
@example
% make
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Start Vim: >
	% ./vim
Load the termdebug plugin and start debugging Vim: >
	:packadd termdebug
	:Termdebug vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim を起動します:
@example
% ./vim
@end example
termdebug プラグインを読み込んで、Vim のデバッグを開始します:
@example
:packadd termdebug
:Termdebug vim
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
You should now have three windows:
    source  - where you started, has a window toolbar with buttons
    gdb	    - you can type gdb commands here
    program - the executed program will use this window
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これで、3 つのウィンドウが表示されます:
@itemize
@item source  - 開始直後はボタン付きウィンドウツールバーがあります
@item gdb     - ここに gdb コマンドを入力できます
@item program - 実行されたプログラムはこのウィンドウを使用します
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use CTRL-W CTRL-W or the mouse to move focus between windows.
Put focus on the gdb window and type: >
	break ex_help
	run
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-W CTRL-W} またはマウスを使用して、ウィンドウ間でフォーカスを移動できます。gdbウィンドウにフォーカスを当てて、次のように入力します:
@example
break ex_help
run
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Vim will start running in the program window. Put focus there and type: >
	:help gui
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は programウィンドウで実行を開始します。そこにフォーカスを置いて入力します:
@example
:help gui
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Gdb will run into the ex_help breakpoint.  The source window now shows the 
ex_cmds.c file.  A red "1 " marker will appear in the signcolumn where the
breakpoint was set.  The line where the debugger stopped is highlighted.  You
can now step through the program.  Let's use the mouse: click on the "Next"
button in the window toolbar.  You will see the highlighting move as the
debugger executes a line of source code.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Gdb は ex_help ブレークポイントまで実行します。source ウィンドウに @file{ex_cmds.c} ファイルが表示されます。ブレークポイントが設定されている目印欄に赤い "1 " のマーカーが表示されます。デバッガが停止した行が強調表示されます。今すぐプログラムを進めることができます。マウスを使いましょう: ウィンドウツールバーの "Next" ボタンをクリックしてください。デバッガがソースコードの行を実行すると、強調表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Click "Next" a few times until the for loop is highlighted.  Put the cursor on
the end of "eap->arg", then click "Eval" in the toolbar.  You will see this
displayed:
	"eap->arg": 0x555555e68855 "gui" ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
for ループが強調表示されるまで、"Next" を数回クリックします。カーソルを "eap->arg" の最後に置き、ツールバーの "Eval" をクリックします。これが表示されます:
@example
"eap->arg": 0x555555e68855 "gui"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This way you can inspect the value of local variables.  You can also focus the
gdb window and use a "print" command, e.g.: >
	print *eap
If mouse pointer movements are working, Vim will also show a balloon when the
mouse rests on text that can be evaluated by gdb.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
こうすることで、ローカル変数の値を調べることができます。また、gdb ウィンドウにフォーカスを当てて、"print" コマンドを使用することもできます。例:
@example
print *eap
@end example
マウスポインタの動きがうまくいっていれば、マウスが gdb で評価できるテキストの上に置かれたときに Vim はバルーンを表示します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now go back to the source window and put the cursor on the first line after
the for loop, then type: >
	:Break
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次に、source ウィンドウに戻り、for ループの後の最初の行にカーソルを置いて、次のように入力します:
@example
:Break
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
You will see a ">>" marker appear, this indicates the new breakpoint.  Now
click "Cont" in the toolbar and the code until the breakpoint will be
executed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しいブレークポイントを示す ">>" マーカーが表示されます。ツールバーの "Cont" をクリックして、コードをブレークポイントまで実行させます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can type more advanced commands in the gdb window.  For example, type: >
	watch curbuf
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
より高度なコマンドを gdb ウィンドウに入力することができます。たとえば、次のように入力します:
@example
watch curbuf
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Now click "Cont" in the toolbar (or type "cont" in the gdb window). Execution
will now continue until the value of "curbuf" changes, which is in do_ecmd().
To remove this watchpoint again type in the gdb window: >
	delete 3
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ツールバーの "Cont" をクリックします (または、gdb ウィンドウで "cont" と入力します)。do_ecmd() にある "curbuf" の値が変更されるまで、実行が継続されます。このウォッチポイントを再度削除するには、gdb ウィンドウで次のように入力します:
@example
delete 3
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can see the stack by typing in the gdb window: >
	where
Move through the stack frames, e.g. with: >
	frame 3
The source window will show the code, at the point where the call was made to
a deeper level.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
gdb ウィンドウに次のように入力すると、スタックが表示されます:
@example
where
@end example
スタックフレームを移動します。例えば:
@example
frame 3
@end example
source ウィンドウには、より深いレベルに呼び出された時点のコードが表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Stepping through code ~
							*termdebug-stepping*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug-stepping}
@cindex termdebug-stepping
@unnumberedsubsec コードをステップ実行する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Put focus on the gdb window to type commands there.  Some common ones are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
gdb ウィンドウにフォーカスを移しコマンドを入力します。一般的なものは以下:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- CTRL-C	interrupt the program
- next		execute the current line and stop at the next line
- step		execute the current line and stop at the next statement,
		entering functions
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item CTRL-C    プログラムを中断する
@item next      現在の行を実行し、次の行 (の手前) で停止する
@item step      現在の行を実行し、次の文 (の手前) で停止する。関数の内側に入る
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- finish	execute until leaving the current function
- where		show the stack
- frame N	go to the Nth stack frame
- continue	continue execution
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item finish    現在の関数を抜けるまで実行する
@item where     スタックを表示する
@item frame N   N 番目のスタックフレームに移動する
@item continue  実行を再開する
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:Run* *:Arguments*
In the window showing the source code these commands can be used to control
gdb:
 `:Run` [args]	    run the program with [args] or the previous arguments
 `:Arguments` {args}  set arguments for the next `:Run`
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:Run}
@anchor{:Arguments}
@pindex :Run
@pindex :Arguments
ソースコードを表示しているウィンドウで、これらのコマンドを gdb の制御に使用できます:
@multitable @columnfractions .3 .7
@item `:Run` [args] @tab [args] または以前の引数でプログラムを実行します
@item `:Arguments` @{args@} @tab 次の `@command{:Run}` のために引数を設定します
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 *:Break*	set a breakpoint at the current line; a sign will be displayed
 *:Clear*	delete the breakpoint at the current line
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:Break}
@pindex :Break
@item :Break @tab 現在の行にブレークポイントを設定する。サインが表示される
@anchor{:Clear}
@pindex :Clear
@item :Clear @tab 現在の行のブレークポイントを削除する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 *:Step*	execute the gdb "step" command
 *:Over*	execute the gdb "next" command (`:Next` is a Vim command)
 *:Finish*	execute the gdb "finish" command
 *:Continue*	execute the gdb "continue" command
 *:Stop*	interrupt the program
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:Step}
@pindex :Step
@item :Step @tab gdb の "step" コマンドを実行する
@anchor{:Over}
@pindex :Over
@item :Over @tab gdb の "next" コマンドを実行する (`@command{:Next}` だと Vim のコマンドとかぶるので)
@anchor{:Finish}
@pindex :Finish
@item :Finish @tab gdb の "finish" コマンドを実行する
@anchor{:Continue}
@pindex :Continue
@item :Continue @tab gdb の "continue" コマンドを実行する
@anchor{:Stop}
@pindex :Stop
@item :Stop @tab プログラムを中断する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If 'mouse' is set the plugin adds a window toolbar with these entries:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{mouse}' が設定されている場合、プラグインはこれらのエントリを持つウィンドウツールバーを追加します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
  Step		`:Step`
  Next		`:Over`
  Finish	`:Finish`
  Cont		`:Continue`
  Stop		`:Stop`
  Eval		`:Evaluate`
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
Step          `:Step`
Next          `:Over`
Finish        `:Finish`
Cont          `:Continue`
Stop          `:Stop`
Eval          `:Evaluate`
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This way you can use the mouse to perform the most common commands.  You need
to have the 'mouse' option set to enable mouse clicks.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この方法で、マウスを使用して最も一般的なコマンドを実行できます。マウスのクリックを有効にするには、'@option{mouse}' オプションを設定する必要があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
								*:Winbar*
You can add the window toolbar in other windows you open with: >
  :Winbar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:Winbar}
@pindex :Winbar
開いている他のウィンドウにウィンドウツールバーを追加することができます:
@example
:Winbar
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If gdb stops at a source line and there is no window currently showing the
source code, a new window will be created for the source code.  This also
happens if the buffer in the source code window has been modified and can't be
abandoned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
gdb がソース行で停止し、現在ソースコードを表示しているウィンドウがない場合、ソースコード用の新しいウィンドウが作成されます。これは、ソースコードウィンドウのバッファが変更され、破棄できない場合でも発生します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Gdb gives each breakpoint a number.  In Vim the number shows up in the sign
column, with a red background.  You can use these gdb commands:
- info break	list breakpoints
- delete N	delete breakpoint N
You can also use the `:Clear` command if the cursor is in the line with the
breakpoint, or use the "Clear breakpoint" right-click menu entry.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Gdb は各ブレークポイントに番号を与えます。Vim 内では、赤い背景で、目印欄に表示されます。次の gdb コマンドを使用できます。
@itemize
@item info break: ブレークポイントの一覧
@item delete N: ブレークポイント N を削除
@end itemize
また、カーソルがブレークポイントの行にある場合は `@command{:Clear}` コマンドを使うことができます。または、右クリックのメニュー項目 "Clear breakpoint" を使用することもできます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Inspecting variables ~
					*termdebug-variables* *:Evaluate*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug-variables}
@anchor{:Evaluate}
@cindex termdebug-variables
@pindex :Evaluate
@unnumberedsubsec 変数を検査する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
 `:Evaluate`	    evaluate the expression under the cursor
 `K`		    same
 `:Evaluate` {expr}   evaluate {expr}
 `:'<,'>Evaluate`     evaluate the Visually selected text
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item `:Evaluate` @tab カーソルの下の式を評価する
@item `K` @tab 上に同じ
@item `:Evaluate` @{expr@} @tab @{expr@} を評価する
@item `:'<,'>Evaluate` @tab ビジュアル選択したテキストを評価する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This is similar to using "print" in the gdb window.
You can usually shorten `:Evaluate` to `:Ev`.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは gdb ウィンドウで "print" コマンドを使ったのに相当します。`:Evaluate` は `:Ev` に短縮できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Other commands ~
							*termdebug-commands*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug-commands}
@cindex termdebug-commands
@unnumberedsubsec その他のコマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
 *:Gdb*	     jump to the gdb window
 *:Program*    jump to the window with the running program
 *:Source*     jump to the window with the source code, create it if there
	     isn't one
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@anchor{:Gdb}
@pindex :Gdb
@item :Gdb @tab gdb ウィンドウに移動する
@anchor{:Program}
@pindex :Program
@item :Program @tab デバッグ中のプログラムウィンドウに移動する
@anchor{:Source}
@pindex :Source
@item :Source @tab ソースコードのウィンドウに移動する。ウィンドウがなければ作成する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Prompt mode ~
						*termdebug-prompt*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug-prompt}
@cindex termdebug-prompt
@unnumberedsubsec プロンプトモード
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
When the |+terminal| feature is not supported and on MS-Windows, gdb will run
in a buffer with 'buftype' set to "prompt".  This works slightly differently:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{+terminal}| 機能がサポートされていない場合や MS-Windows 上の場合、gdb は '@option{buftype}' が "@var{prompt}" に設定されたバッファで動作します。これは少し違った働きをします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The gdb window will be in Insert mode while typing commands.  Go to Normal
  mode with <Esc>, then you can move around in the buffer, copy/paste, etc.
  Go back to editing the gdb command with any command that starts Insert mode,
  such as `a` or `i`.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item コマンドを入力している間、gdb ウィンドウは挿入モードになります。<Esc> でノーマルモードにして、バッファ間を移動したり、コピー/ペーストなどをおこなうことができます。`@command{a}` や `@command{i}` のような挿入モードを開始するコマンドで gdb コマンドの編集に戻ります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The program being debugged will run in a separate window.  On MS-Windows
  this is a new console window.  On Unix, if the |+terminal| feature is
  available a Terminal window will be opened to run the debugged program in.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item デバッグ中のプログラムは別のウィンドウで実行されます。MS-Windows では、これは新しいコンソールウィンドウです。Unix では、|@ref{+terminal}| 機能が利用可能な場合、端末ウィンドウが開いてデバッグされたプログラムを実行します。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*termdebug_use_prompt*
Prompt mode can be used even when the |+terminal| feature is present with: >
	let g:termdebug_use_prompt = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug_use_prompt}
@cindex termdebug_use_prompt
プロンプトモードは、|@ref{+terminal}| 機能が有効な場合でも使用できます:
@example
let g:termdebug_use_prompt = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Communication ~
						*termdebug-communication*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug-communication}
@cindex termdebug-communication
@unnumberedsubsec 通信
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
There is another, hidden, buffer, which is used for Vim to communicate with
gdb.  The buffer name is "gdb communication".  Do not delete this buffer, it
will break the debugger.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim が gdb と通信するために他に隠されたバッファを利用します。バッファ名は "gdb communicate" です。このバッファは消さないでください。消してしまうとデバッガが動作しなくなってしまうでしょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Gdb has some weird behavior, the plugin does its best to work around that.
For example, after typing "continue" in the gdb window a CTRL-C can be used to
interrupt the running program.  But after using the MI command
"-exec-continue"  pressing CTRL-C does not interrupt.  Therefore you will see
"continue" being used for the `:Continue` command, instead of using the
communication channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
gdb は奇妙な動作をしていますが、プラグインはその問題を回避するために最善を尽くしています。例えば、gdb ウィンドウで "continue" と入力した後に、@kbd{CTRL-C} を使用して実行中のプログラムを中断することができます。しかし、MI コマンド "-exec-continue" を使用した後、@kbd{CTRL-C} を押しても中断しません。したがって、通信チャネルを使用する代わりに、`@command{:Continue}` コマンドに "continue" が使用されていることがわかります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Customizing ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec カスタマイズ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
GDB command						 *termdebug-customizing*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug-customizing}
@cindex termdebug-customizing
@unnumberedsubsubsec GDB コマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To change the name of the gdb command, set the "termdebugger" variable before
invoking `:Termdebug`: >
	let termdebugger = "mygdb"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
gdb コマンド以外のデバッガを使うには、 `@command{:Termdebug}` を実行する前に "@var{termdebugger}" 変数を変更してください:
@example
let termdebugger = "mygdb"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<							*gdb-version*
Only debuggers fully compatible with gdb will work.  Vim uses the GDB/MI
interface.  The "new-ui" command  requires gdb version 7.12 or later.  if you
get this error:
	Undefined command: "new-ui". Try "help".~
Then your gdb is too old.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gdb-version}
@cindex gdb-version
gdb と完全互換のあるデバッガのみが使えます。Vim は gdb の操作に GDB/MI インターフェイスを利用しています。"new-ui" コマンドは gdb バージョン 7.12 以降が必要です。このエラーが発生した場合:
@example
Undefined command: "new-ui". Try "help".
@end example
あなたの gdb が古すぎます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Colors						*hl-debugPC* *hl-debugBreakpoint*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-debugPC}
@anchor{hl-debugBreakpoint}
@cindex hl-debugPC
@cindex hl-debugBreakpoint
@unnumberedsubsubsec カラー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The color of the signs can be adjusted with these highlight groups:
- debugPC		the current position
- debugBreakpoint	a breakpoint
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
サインの色は以下のハイライトグループで調整できます:
@multitable @columnfractions .4 .6
@item debugPC @tab 現在の位置
@item debugBreakpoint @tab ブレークポイント
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The defaults are, when 'background' is "light":
  hi debugPC term=reverse ctermbg=lightblue guibg=lightblue
  hi debugBreakpoint term=reverse ctermbg=red guibg=red
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{background}' オプションが "@var{light}" の時のデフォルトは以下のとおりです:
@example
hi debugPC term=reverse ctermbg=lightblue guibg=lightblue
hi debugBreakpoint term=reverse ctermbg=red guibg=red
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When 'background' is "dark":
  hi debugPC term=reverse ctermbg=darkblue guibg=darkblue
  hi debugBreakpoint term=reverse ctermbg=red guibg=red
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{background}' オプションが "@var{dark}" の時は以下のとおりです:
@example
hi debugPC term=reverse ctermbg=darkblue guibg=darkblue
hi debugBreakpoint term=reverse ctermbg=red guibg=red
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Shorcuts						*termdebug_shortcuts*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug_shortcuts}
@cindex termdebug_shortcuts
@unnumberedsubsubsec ショートカット
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can define your own shortcuts (mappings) to control gdb, that can work in
any window, using the TermDebugSendCommand() function.  Example: >
	map ,w :call TermDebugSendCommand('where')<CR>
The argument is the gdb command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
TermDebugSendCommand() 関数を使用して、任意のウィンドウで動作する gdb を制御する独自のショートカット (マッピング) を定義できます。例:
@example
map ,w :call TermDebugSendCommand('where')<CR>
@end example
引数は gdb コマンドです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Popup menu						*termdebug_popup*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug_popup}
@cindex termdebug_popup
@unnumberedsubsubsec ポップアップメニュー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
By default the Termdebug plugin sets 'mousemodel' to "popup_setpos" and adds
these entries to the popup menu:
	Set breakpoint		`:Break`
	Clear breakpoint	`:Clear`
	Evaluate		`:Evaluate`
If you don't want this then disable it with: >
	let g:termdebug_popup = 0
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デフォルトで Termdebug プラグインは '@option{mousemodel}' を "@var{popup_setpos}" に設定し、これらのエントリをポップアップメニューに追加します:
@example
Set breakpoint          `:Break`
Clear breakpoint        `:Clear`
Evaluate                `:Evaluate`
@end example
あなたがこれを望まないならば、それを無効にしてください:
@example
let g:termdebug_popup = 0
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Vim window width						*termdebug_wide*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug_wide}
@cindex termdebug_wide
@unnumberedsubsubsec Vim のウィンドウ幅
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To change the width of the Vim window when debugging starts, and use a
vertical split: >
  let g:termdebug_wide = 163
This will set &columns to 163 when `:Termdebug` is used.  The value is restored
when quitting the debugger.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デバッグを開始した際に Vim のウィンドウ幅を変更し、垂直分割を利用するには次のように設定します:
@example
let g:termdebug_wide = 163
@end example
これは `@command{:Termdebug}` を実行した際に &columns を 163 に設定します。元の値はデバッガが終了する際に復元されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
If g:termdebug_wide is set and &columns is already larger than
g:termdebug_wide then a vertical split will be used without changing &columns.
Set it to 1 to get a vertical split without every changing &columns (useful
for when the terminal can't be resized by Vim).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

g:termdebug_wide が設定されていて、&columns がすでに g:termdebug_wide より大きい場合、&columns を変更せずに垂直分割が使用されます。&columns を変更せずに垂直分割を行うには、1 に設定します。(端末が Vim によってサイズ変更できない場合に便利です)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------



@ifset EN
 vim:tw=78:ts=8:noet:ft=help:norl:
@end ifset
