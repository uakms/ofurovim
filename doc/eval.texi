@ifset JA  @c ----------- v -----------  JA  -*- tab-width: 8 -*-
@node eval.txt, , , 目次
@unnumbered 式の評価、条件式 (Vim script リファレンス)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*eval.txt*	For Vim version 8.1.  Last change: 2018 May 17


		  VIM REFERENCE MANUAL	  by Bram Moolenaar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
*eval.txt*	For Vim バージョン 8.1.  Last change: 2018 May 17


		  VIMリファレンスマニュアル    by Bram Moolenaar
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Expression evaluation			*expression* *expr* *E15* *eval*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expression}
@anchor{expr}
@anchor{E15}
@anchor{eval}
@cindex expression
@cindex expr
@erindex E15
@cindex eval
Vim script
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Using expressions is introduced in chapter 41 of the user manual |usr_41.txt|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim script の利用についてはユーザーマニュアルの 41 章 |@ref{usr_41.txt}| でも解説されている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: Expression evaluation can be disabled at compile time.  If this has been
done, the features in this document are not available.  See |+eval| and
|no-eval-feature|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
Vim script はコンパイル時に無効化できる。もしそうなっているとこのドキュメントに書かれている事は有効ではない。|@ref{+eval}| と |@ref{no-eval-feature}| を参照。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1.  Variables			|variables|
    1.1 Variable types
    1.2 Function references		|Funcref|
    1.3 Lists				|Lists|
    1.4 Dictionaries			|Dictionaries|
    1.5 More about variables		|more-variables|
2.  Expression syntax		|expression-syntax|
3.  Internal variable		|internal-variables|
4.  Builtin Functions		|functions|
5.  Defining functions		|user-functions|
6.  Curly braces names		|curly-braces-names|
7.  Commands			|expression-commands|
8.  Exception handling		|exception-handling|
9.  Examples			|eval-examples|
10. No +eval feature		|no-eval-feature|
11. The sandbox			|eval-sandbox|
12. Textlock			|textlock|
13. Testing			|testing|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .5 .5
@item 1. 変数 @tab |@ref{variables}|
@item @ @ @ @ 1.1 変数の型 @tab
@item @ @ @ @ 1.2 関数への参照 @tab |@ref{Funcref}|
@item @ @ @ @ 1.3 リスト @tab |@ref{Lists}|
@item @ @ @ @ 1.4 辞書 @tab |@ref{Dictionaries}|
@item @ @ @ @ 1.5 変数について補足 @tab |@ref{more-variables}|
@item 2. 式の文法 @tab |@ref{expression-syntax}|
@item 3. 内部変数 @tab |@ref{internal-variables}|
@item 4. 組み込み関数 @tab |@ref{functions}|
@item 5. 関数定義 @tab |@ref{user-functions}|
@item 6. 波括弧 @{@} 変数 @tab |@ref{curly-braces-names}|
@item 7. コマンド @tab |@ref{expression-commands}|
@item 8. 例外処理 @tab |@ref{exception-handling}|
@item 9. 例 @tab |@ref{eval-examples}|
@item 10. +eval 機能が無効 @tab |@ref{no-eval-feature}|
@item 11. サンドボックス @tab |@ref{eval-sandbox}|
@item 12. テキストロック @tab |@ref{textlock}|
@item 13. テスト @tab |@ref{testing}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{Vi does not have any of these commands}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{Vi にはこれらのコマンドはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
1. Variables						*variables*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{variables}
@cindex variables
@cindex 変数
@section 1. 変数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1.1 Variable types ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex 変数の型
@unnumberedsubsec 1.1 変数の型
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*E712*
There are nine types of variables:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E712}
@erindex E712
変数には 9 種類の型がある:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Number		A 32 or 64 bit signed number.  |expr-number| *Number*
		64-bit Numbers are available only when compiled with the
		|+num64| feature.
		Examples:  -123  0x10  0177  0b1011
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{Number}
@cindex Number
@item 数値
32 ビットまたは 64 ビットの符号有整数。|@ref{expr-number}|

64 ビット数値は |@ref{+num64}| 機能つきでコンパイルされたときのみ有効。

例:
@example
-123  0x10  0177  0b1011
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Float		A floating point number. |floating-point-format| *Float*
		{only when compiled with the |+float| feature}
		Examples: 123.456  1.15e-6  -1.1e3
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Float}
@cindex Float
@item 浮動小数点数
浮動小数点数。|@ref{floating-point-format}|

@{|@ref{+float}| 機能つきでコンパイルされたときのみ@}

例:
@example
123.456  1.15e-6  -1.1e3
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*E928*
String		A NUL terminated string of 8-bit unsigned characters (bytes).
		|expr-string| Examples: "ab\txx\"--"  'x-z''a,c'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E928}
@erindex E928
@item 文字列
終端が NUL 文字である 8 ビットの符号無し文字 (バイト)。|@ref{expr-string}|

例:
@example
"ab\txx\"--"  'x-z''a,c'
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
List		An ordered sequence of items |List|.
		Example: [1, 2, ['a', 'b']]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item リスト
要素の順序つきの列 |@ref{List}|。

例:
@example
[1, 2, ['a', 'b']]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Dictionary	An associative, unordered array: Each entry has a key and a
		value. |Dictionary|
		Example: {'blue': "#0000ff", 'red': "#ff0000"}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 辞書
順序を持たない連想配列: 各要素はキーと値を持つ。|@ref{Dictionary}|

例:
@example
@{'blue': "#0000ff", 'red': "#ff0000"@}
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Funcref		A reference to a function |Funcref|.
		Example: function("strlen")
		It can be bound to a dictionary and arguments, it then works
		like a Partial.
		Example: function("Callback", [arg], myDict)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item Funcref
関数への参照 |@ref{Funcref}|。

例:
@example
function("strlen")
@end example
辞書や引数とバインドすることができ、そのときは部分適用 (Partial) のように働く。

例:
@example
function("Callback", [arg], myDict)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Special		|v:false|, |v:true|, |v:none| and |v:null|.  *Special*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Special}
@cindex Special
@item 特殊値
|@ref{v:false}|, |@ref{v:true}|, |@ref{v:none}| と |@ref{v:null}|。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Job		Used for a job, see |job_start()|. *Job* *Jobs*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Job}
@anchor{Jobs}
@cindex Job
@cindex Jobs
@item ジョブ
ジョブに使われる。|@ref{job_start()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Channel		Used for a channel, see |ch_open()|. *Channel* *Channels*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Channel}
@anchor{Channels}
@cindex Channel
@cindex Channels
@item チャネル
チャネルに使われる。|@ref{ch_open()}| を参照。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The Number and String types are converted automatically, depending on how they
are used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
数値と文字列は文脈に応じて相互に変換される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Conversion from a Number to a String is by making the ASCII representation of
the Number.  Examples:
	Number 123	-->	String "123" ~
	Number 0	-->	String "0" ~
	Number -1	-->	String "-1" ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
数値から文字列への変換は数字のASCII表現によって行われる。例:
@verbatim
数値 123        -->     文字列 "123"
数値 0          -->     文字列 "0"
数値 -1         -->     文字列 "-1"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*octal*
Conversion from a String to a Number is done by converting the first digits to
a number.  Hexadecimal "0xf9", Octal "017", and Binary "0b10" numbers are
recognized.  If the String doesn't start with digits, the result is zero.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{octal}
@cindex octal
文字列から数値への変換は最初の数字を用いて数値に変換する。16 進表記 "0xf9" や 8 進表記 "017"、2 進数表記の "0b10" も認識される。文字列が数字で始まらない場合結果は 0 となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Examples:
	String "456"	-->	Number 456 ~
	String "6bar"	-->	Number 6 ~
	String "foo"	-->	Number 0 ~
	String "0xf1"	-->	Number 241 ~
	String "0100"	-->	Number 64 ~
	String "0b101"	-->	Number 5 ~
	String "-8"	-->	Number -8 ~
	String "+8"	-->	Number 0 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@verbatim
文字列 "456"    -->     数値 456
文字列 "6bar"   -->     数値 6
文字列 "foo"    -->     数値 0
文字列 "0xf1"   -->     数値 241
文字列 "0100"   -->     数値 64
文字列 "0b101"  -->     数値 5
文字列 "-8"     -->     数値 -8
文字列 "+8"     -->     数値 0
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To force conversion from String to Number, add zero to it: >
	:echo "0100" + 0
<	64 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列を強制的に数値に変換するには 0 を足す:
@example
:echo "0100" + 0
64
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To avoid a leading zero to cause octal conversion, or for using a different
base, use |str2nr()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
先頭の 0 によって 8 進数とみなされるのを防いだり、異なる基数を使うには |@ref{str2nr()}| を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*TRUE* *FALSE*
For boolean operators Numbers are used.  Zero is FALSE, non-zero is TRUE.
You can also use |v:false| and |v:true|.  When TRUE is returned from a
function it is the Number one, FALSE is the number zero.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{TRUE}
@anchor{FALSE}
@cindex TRUE
@cindex FALSE
ブール (真理値) 演算には数値が使われる。0 は偽を意味し、非 0 は真を表す。また、|@ref{v:false}| と |@ref{v:true}| を使うこともできる。関数から真が返されたときは数値の 1 であり、偽が返されたときは数値の 0 である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that in the command: >
	:if "foo"
	:" NOT executed
"foo" is converted to 0, which means FALSE.  If the string starts with a
non-zero number it means TRUE: >
	:if "8foo"
	:" executed
To test for a non-empty string, use empty(): >
	:if !empty("foo")
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note} @*
次のコマンドをみると
@example
:if "foo"
:" 実行されない
@end example
"foo" は 0 に変換され、それは偽を意味する。もし文字列がゼロでない数値から始まる場合は真を意味する:
@example
:if "8foo"
:" 実行される
@end example
文字列が空ではないか調べるためには empty() を使用して次のようにする。
@example
:if !empty("foo")
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*non-zero-arg*
Function arguments often behave slightly different from |TRUE|: If the
argument is present and it evaluates to a non-zero Number, |v:true| or a
non-empty String, then the value is considered to be TRUE.
Note that " " and "0" are also non-empty strings, thus considered to be TRUE.
A List, Dictionary or Float is not a Number or String, thus evaluate to FALSE.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{non-zero-arg}
@cindex non-zero-arg
関数の引数は、|@ref{TRUE}| とは少し異なる場合がある: 引数が存在し、それが非ゼロの Number, |@ref{v:true}| または空でない String に評価される場合、値は TRUE と見なされる。" " と "0" も空文字列ではないので、TRUE と見なされることに注意すること。List, Dictionary または Float は数値または文字列ではないため、FALSE と評価される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		*E745* *E728* *E703* *E729* *E730* *E731* *E908* *E910* *E913*
List, Dictionary, Funcref, Job and Channel types are not automatically
converted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E745}
@anchor{E728}
@anchor{E703}
@anchor{E729}
@anchor{E730}
@anchor{E731}
@anchor{E908}
@anchor{E910}
@anchor{E913}
@erindex E745
@erindex E728
@erindex E703
@erindex E729
@erindex E730
@erindex E731
@erindex E908
@erindex E910
@erindex E913
リスト、辞書、Funcref、ジョブ、チャネルは自動的に変換されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*E805* *E806* *E808*
When mixing Number and Float the Number is converted to Float.  Otherwise
there is no automatic conversion of Float.  You can use str2float() for String
to Float, printf() for Float to String and float2nr() for Float to Number.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E805}
@anchor{E806}
@anchor{E808}
@erindex E805
@erindex E806
@erindex E808
数値と浮動小数点数をまぜると浮動小数点数になる。それ以外には浮動小数点数への自動的な変換は存在しない。文字列から浮動小数点数へは str2float() を使い、浮動小数点数から文字列へは printf() を、浮動小数点数から数値へは float2nr() を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			*E891* *E892* *E893* *E894* *E907* *E911* *E914*
When expecting a Float a Number can also be used, but nothing else.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E891}
@anchor{E892}
@anchor{E893}
@anchor{E894}
@anchor{E907}
@anchor{E911}
@anchor{E914}
@erindex E891
@erindex E892
@erindex E893
@erindex E894
@erindex E907
@erindex E911
@erindex E914
浮動小数点数が予期されているところでは数値も使用可能だが、それ以外は使用できない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*no-type-checking*
You will not get an error if you try to change the type of a variable.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{no-type-checking}
@cindex no-type-checking
変数の型を変更しようとしてもエラーは発生しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
1.2 Function references ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex 関数への参照
@unnumberedsubsec 1.2 関数への参照
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*Funcref* *E695* *E718*
A Funcref variable is obtained with the |function()| function, the |funcref()|
function or created with the lambda expression |expr-lambda|.  It can be used
in an expression in the place of a function name, before the parenthesis
around the arguments, to invoke the function it refers to.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Funcref}
@anchor{E695}
@anchor{E718}
@cindex Funcref
@erindex E695
@erindex E718
関数への参照は、関数 |@ref{function()}|、関数 |@ref{funcref()}| またはラムダ式 |@ref{expr-lambda}| を使うことで得られる。関数への参照は、式の中で関数名が要求される場所で使うと参照先の関数を呼び出す。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let Fn = function("MyFunc")
	:echo Fn()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:let Fn = function("MyFunc")
:echo Fn()
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<							*E704* *E705* *E707*
A Funcref variable must start with a capital, "s:", "w:", "t:" or "b:".  You
can use "g:" but the following name must still start with a capital.  You
cannot have both a Funcref variable and a function with the same name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E704}
@anchor{E705}
@anchor{E707}
@erindex E704
@erindex E705
@erindex E707
関数参照の変数名は、大文字、"s:", "w:", "t:", "b:" のいずれかで始めなければならない。"g:" も使えるが、あとに続く名前は大文字で始めなければならない。関数参照と参照先の関数の名前を同じにすることはできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A special case is defining a function and directly assigning its Funcref to a
Dictionary entry.  Example: >
	:function dict.init() dict
	:   let self.val = 0
	:endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数を定義して、それへの参照を直接辞書に入れるための特別な形式がある。例:
@verbatim
:function dict.init() dict
:   let self.val = 0
:endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The key of the Dictionary can start with a lower case letter.  The actual
function name is not used here.  Also see |numbered-function|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この辞書のキーは小文字で始めなければならない。実際の関数名はここでは使われない。|@ref{numbered-function}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A Funcref can also be used with the |:call| command: >
	:call Fn()
	:call dict.init()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:call}| コマンドでも関数参照を使うことができる:
@example
:call Fn()
:call dict.init()
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The name of the referenced function can be obtained with |string()|. >
	:let func = string(Fn)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
参照先の関数名は |@ref{string()}| で得られる。
@example
:let func = string(Fn)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use |call()| to invoke a Funcref and use a list variable for the
arguments: >
	:let r = call(Fn, mylist)
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{call()}| を使うと、リスト型の変数を引数として関数参照を呼び出すことができる:
@example
:let r = call(Fn, mylist)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
								*Partial*
A Funcref optionally binds a Dictionary and/or arguments.  This is also called
a Partial.  This is created by passing the Dictionary and/or arguments to
function() or funcref().  When calling the function the Dictionary and/or
arguments will be passed to the function.  Example: >

	let Cb = function('Callback', ['foo'], myDict)
	call Cb()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Partial}
@cindex Partial
関数参照は、辞書および/もしくは引数とバインドすることができる。これは部分適用 (Partial) とも呼ばれる。これは、辞書および/もしくは引数を function() または funcref() に渡すことで作成される。その関数を呼び出すと、その辞書および/もしくは引数がその関数に渡される。例:
@example
let Cb = function('Callback', ['foo'], myDict)
call Cb()
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This will invoke the function as if using: >
	call myDict.Callback('foo')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは、関数を以下のようにして呼び出す:
@example
call myDict.Callback('foo')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This is very useful when passing a function around, e.g. in the arguments of
|ch_open()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは関数を何かに渡す場合、例えば |@ref{ch_open()}| の引数とする場合などに非常に有用である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that binding a function to a Dictionary also happens when the function is
a member of the Dictionary: >

	let myDict.myFunction = MyFunction
	call myDict.myFunction()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
関数の辞書へのバインドは、その関数が辞書のメンバーであるときにも発生することに注意:
@example
let myDict.myFunction = MyFunction
call myDict.myFunction()
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here MyFunction() will get myDict passed as "self".  This happens when the
"myFunction" member is accessed.  When making assigning "myFunction" to
otherDict and calling it, it will be bound to otherDict: >

	let otherDict.myFunction = myDict.myFunction
	call otherDict.myFunction()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここで、MyFunction() は myDict を "self" として受け取る。これは、"myFunction" メンバーがアクセスされたときに起こる。"myFunction" を別の辞書 otherDict に代入して呼び出すと、それは otherDict にバインドされる:
@example
let otherDict.myFunction = myDict.myFunction
call otherDict.myFunction()
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now "self" will be "otherDict".  But when the dictionary was bound explicitly
this won't happen: >

	let myDict.myFunction = function(MyFunction, myDict)
	let otherDict.myFunction = myDict.myFunction
	call otherDict.myFunction()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
今度は、"self" は "otherDict" になる。しかし、辞書を明示的にバインドしたときにはこれは起こらない:
@example
let myDict.myFunction = function(MyFunction, myDict)
let otherDict.myFunction = myDict.myFunction
call otherDict.myFunction()
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here "self" will be "myDict", because it was bound explicitly.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここでは、"self" は "myDict" である。なぜなら明示的にバインドされているからである。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
1.3 Lists ~
						*list* *List* *Lists* *E686*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{list}
@anchor{List}
@anchor{Lists}
@anchor{E686}
@cindex list
@cindex List
@cindex Lists
@erindex E686
@cindex リスト
@unnumberedsubsec 1.3 リスト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
A List is an ordered sequence of items.  An item can be of any type.  Items
can be accessed by their index number.  Items can be added and removed at any
position in the sequence.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リストとは順序を保つ要素の列である。要素はどんな型でもよい。要素へはインデックス番号を使ってアクセスする。列の任意の位置に要素を追加したり削除することができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
List creation ~
							*E696* *E697*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E696}
@anchor{E697}
@erindex E696
@erindex E697
@cindex リストの作成
@unnumberedsubsubsec リストの作成
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
A List is created with a comma separated list of items in square brackets.
Examples: >
	:let mylist = [1, two, 3, "four"]
	:let emptylist = []
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リストを作るには、[]の中にコンマで区切って要素を書く。例:
@example
:let mylist = [1, two, 3, "four"]
:let emptylist = []
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An item can be any expression.  Using a List for an item creates a
List of Lists: >
	:let nestlist = [[11, 12], [21, 22], [31, 32]]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
要素はどんな式でもよい。要素としてリストを指定すると、リストのリストができる:
@example
:let nestlist = [[11, 12], [21, 22], [31, 32]]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An extra comma after the last item is ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最後の要素の後に余分なコンマがあると無視される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
List index ~
							*list-index* *E684*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{list-index}
@anchor{E684}
@cindex list-index
@erindex E684
@cindex リストのインデックス
@unnumberedsubsubsec リストのインデックス
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
An item in the List can be accessed by putting the index in square brackets
after the List.  Indexes are zero-based, thus the first item has index zero. >
	:let item = mylist[0]		" get the first item: 1
	:let item = mylist[2]		" get the third item: 3
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リストの要素にアクセスするには、リスト名の後に[]を書き、その中にインデックスを書く。インデックスは 0 基点 (つまり最初の要素のインデックスは 0) である。
@example
:let item = mylist[0]           " 最初の要素 (1) を取得
:let item = mylist[2]           " 3 番目の要素 (3) を取得
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the resulting item is a list this can be repeated: >
	:let item = nestlist[0][1]	" get the first list, second item: 12
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
取得した要素がリストならば、さらに続けてインデックスを書くことができる:
@example
:let item = nestlist[0][1]      " 最初のリストの 2 番目の要素 (12) を取得
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
A negative index is counted from the end.  Index -1 refers to the last item in
the List, -2 to the last but one item, etc. >
	:let last = mylist[-1]		" get the last item: "four"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
負のインデックスを指定すると、リストの末尾から数えられる。インデックス -1 は最後の要素を示し、-2 は最後から 2 番目を指す
@example
:let last = mylist[-1]          " 最後の要素 ("four") を取得
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To avoid an error for an invalid index use the |get()| function.  When an item
is not available it returns zero or the default value you specify: >
	:echo get(mylist, idx)
	:echo get(mylist, idx, "NONE")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
無効なインデックスによるエラーを回避するには関数 |@ref{get()}| を使う。するとインデックスが無効な場合は、0 かまたは自分で指定した既定値が返る:
@example
:echo get(mylist, idx)
:echo get(mylist, idx, "NONE")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
List concatenation ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex リストの連結
@unnumberedsubsubsec リストの連結
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Two lists can be concatenated with the "+" operator: >
	:let longlist = mylist + [5, 6]
	:let mylist += [7, 8]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2 つのリストを連結するには演算子 "+" を使う:
@example
:let longlist = mylist + [5, 6]
:let mylist += [7, 8]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To prepend or append an item turn the item into a list by putting [] around
it.  To change a list in-place see |list-modification| below.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
1 個の要素を先頭または末尾に付け加えるには、[] で囲んでリストにして連結する。リストの特定の要素を変更するには後述の |@ref{list-modification}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Sublist ~
							*sublist*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sublist}
@cindex sublist
@cindex 部分リスト
@unnumberedsubsubsec 部分リスト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
A part of the List can be obtained by specifying the first and last index,
separated by a colon in square brackets: >
	:let shortlist = mylist[2:-1]	" get List [3, "four"]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リストの一部分を取り出すには、[] の中に始点と終点のインデックスを書き、コロンで区切る:
@example
:let shortlist = mylist[2:-1]   " リスト [3, "four"] を得る
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Omitting the first index is similar to zero.  Omitting the last index is
similar to -1. >
	:let endlist = mylist[2:]	" from item 2 to the end: [3, "four"]
	:let shortlist = mylist[2:2]	" List with one item: [3]
	:let otherlist = mylist[:]	" make a copy of the List
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
始点のインデックスを省略すると 0 となる。終点のインデックスを省略すると -1 となる。
@example
:let endlist = mylist[2:]       " 2 番目から最後まで: [3, "four"]
:let shortlist = mylist[2:2]    " 1 個の要素からなるリスト: [3]
:let otherlist = mylist[:]      " リストのコピーを作る
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the first index is beyond the last item of the List or the second item is
before the first item, the result is an empty list.  There is no error
message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
終点のインデックスが始点のインデックスよりも前になってしまった場合は空リストとなる。エラーメッセージは表示されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the second index is equal to or greater than the length of the list the
length minus one is used: >
	:let mylist = [0, 1, 2, 3]
	:echo mylist[2:8]		" result: [2, 3]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
終点のインデックスがリストの長さより大きい場合は、長さ -1 を指定したときと同じになる:
@example
:let mylist = [0, 1, 2, 3]
:echo mylist[2:8]               " 結果: [2, 3]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
NOTE: mylist[s:e] means using the variable "s:e" as index.  Watch out for
using a single letter variable before the ":".  Insert a space when needed:
mylist[s : e].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
mylist[s:e] と書くと変数 "s:e" をインデックスとして使ったと解釈される。":" の前に 1 文字の変数を使うときは十分注意すること。必要ならこのようにスペースを入れるとよい: mylist[s : e].
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
List identity ~
							*list-identity*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{list-identity}
@cindex list-identity
@cindex リストの同一性
@unnumberedsubsubsec リストの同一性
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
When variable "aa" is a list and you assign it to another variable "bb", both
variables refer to the same list.  Thus changing the list "aa" will also
change "bb": >
	:let aa = [1, 2, 3]
	:let bb = aa
	:call add(aa, 4)
	:echo bb
<	[1, 2, 3, 4]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数 "aa" がリストであり、それを別の変数 "bb" に代入したとすると、両方とも同じ変数を参照するようになる。よってリスト "aa" を変更すると "bb" も変更される:
@example
:let aa = [1, 2, 3]
:let bb = aa
:call add(aa, 4)
:echo bb
[1, 2, 3, 4]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Making a copy of a list is done with the |copy()| function.  Using [:] also
works, as explained above.  This creates a shallow copy of the list: Changing
a list item in the list will also change the item in the copied list: >
	:let aa = [[1, 'a'], 2, 3]
	:let bb = copy(aa)
	:call add(aa, 4)
	:let aa[0][1] = 'aaa'
	:echo aa
<	[[1, aaa], 2, 3, 4] >
	:echo bb
<	[[1, aaa], 2, 3]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リストのコピーを作るには関数 |@ref{copy()}| を使う。前述の通り [:] を使ってもできる。これは浅いコピーである。つまりリストの要素であるリストに変更を加えると、コピーされたリスト内の同じ要素も変更される:
@example
:let aa = [[1, 'a'], 2, 3]
:let bb = copy(aa)
:call add(aa, 4)
:let aa[0][1] = 'aaa'
:echo aa
[[1, aaa], 2, 3, 4]
:echo bb
[[1, aaa], 2, 3]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To make a completely independent list use |deepcopy()|.  This also makes a
copy of the values in the list, recursively.  Up to a hundred levels deep.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
完全に独立したコピーを作るには |@ref{deepcopy()}| を使う。これは再帰的にリストの要素のコピーを作る。ただし深さは 100 レベルまでである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The operator "is" can be used to check if two variables refer to the same
List.  "isnot" does the opposite.  In contrast "==" compares if two lists have
the same value. >
	:let alist = [1, 2, 3]
	:let blist = [1, 2, 3]
	:echo alist is blist
<	0 >
	:echo alist == blist
<	1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2 つの変数が同じリストを指しているかは演算子 "is" で判定できる。"isnot" はその逆である。一方、"==" は 2 つのリストが同じ値を持っているかを判定する。
@example
:let alist = [1, 2, 3]
:let blist = [1, 2, 3]
:echo alist is blist
0
:echo alist == blist
1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note about comparing lists: Two lists are considered equal if they have the
same length and all items compare equal, as with using "==".  There is one
exception: When comparing a number with a string they are considered
different.  There is no automatic type conversion, as with using "==" on
variables.  Example: >
	echo 4 == "4"
<	1 >
	echo [4] == ["4"]
<	0
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
リストの比較について注意: 2 つのリストは、同じ長さを持ち、全要素が "==" の意味で等しいとき、等しいとみなされる。ただ、1 つ例外がある: 数値と文字列を比較するとそれらは異なるとみなされる。変数に対して "==" で比較したときに行われるような自動的な型変換は行われない。例:
@example
echo 4 == "4"
1
echo [4] == ["4"]
0
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Thus comparing Lists is more strict than comparing numbers and strings.  You
can compare simple values this way too by putting them in a list: >

	:let a = 5
	:let b = "5"
	:echo a == b
<	1 >
	:echo [a] == [b]
<	0
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
つまり、リストの比較は数値や文字列の比較よりも厳格である。単純な値もリストに入れることによりこの方法で比較することができる:
@example
:let a = 5
:let b = "5"
:echo a == b
1
:echo [a] == [b]
0
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
List unpack ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex リストのアンパック
@unnumberedsubsubsec リストのアンパック
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To unpack the items in a list to individual variables, put the variables in
square brackets, like list items: >
	:let [var1, var2] = mylist
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リストの要素を個々の変数としてアンパックするには、[] の中に変数を書く:
@example
:let [var1, var2] = mylist
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the number of variables does not match the number of items in the list
this produces an error.  To handle any extra items from the list append ";"
and a variable name: >
	:let [var1, var2; rest] = mylist
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数の個数とリストの要素数が一致しないときはエラーになる。リストにある余分な要素をまとめて受け取るには、";" と受け取る変数名を書いておく:
@example
:let [var1, var2; rest] = mylist
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This works like: >
	:let var1 = mylist[0]
	:let var2 = mylist[1]
	:let rest = mylist[2:]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上の例は次とほぼ同じである:
@example
:let var1 = mylist[0]
:let var2 = mylist[1]
:let rest = mylist[2:]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Except that there is no error if there are only two items.  "rest" will be an
empty list then.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
要素が 2 つしかないときでもエラーにはならない。"rest" は空リストになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
List modification ~
							*list-modification*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{list-modification}
@cindex list-modification
@cindex リストの変更
@unnumberedsubsubsec リストの変更
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
To change a specific item of a list use |:let| this way: >
	:let list[4] = "four"
	:let listlist[0][3] = item
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リストの中の特定の要素を変更するには次のように |@ref{:let}| を使う:
@example
:let list[4] = "four"
:let listlist[0][3] = item
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To change part of a list you can specify the first and last item to be
modified.  The value must at least have the number of items in the range: >
	:let list[3:5] = [3, 4, 5]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
始点と終点を指定してリストの一部分を変更することができる。代入する値は、少なくとも削除する範囲の要素数と同じ数だけ必要である:
@example
:let list[3:5] = [3, 4, 5]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Adding and removing items from a list is done with functions.  Here are a few
examples: >
	:call insert(list, 'a')		" prepend item 'a'
	:call insert(list, 'a', 3)	" insert item 'a' before list[3]
	:call add(list, "new")		" append String item
	:call add(list, [1, 2])		" append a List as one new item
	:call extend(list, [1, 2])	" extend the list with two more items
	:let i = remove(list, 3)	" remove item 3
	:unlet list[3]			" idem
	:let l = remove(list, 3, -1)	" remove items 3 to last item
	:unlet list[3 : ]		" idem
	:call filter(list, 'v:val !~ "x"')  " remove items with an 'x'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リストに要素を追加したり削除するには関数を使う。いくつか例を示す:
@example
:call insert(list, 'a')         " 先頭に要素 'a' を挿入する
:call insert(list, 'a', 3)      " 要素 'a' を list[3] の前に挿入する
:call add(list, "new")          " 文字列の要素を最後に追加する
:call add(list, [1, 2])         " 1 個の要素としてリストを追加する
:call extend(list, [1, 2])      " 2 個の要素からなるリストを連結する
:let i = remove(list, 3)        " 要素 3 を削除する
:unlet list[3]                  " 同上
:let l = remove(list, 3, -1)    " 要素 3 から最後までを削除する
:unlet list[3 : ]               " 同上
:call filter(list, 'v:val !~ "x"')  " 要素 'x' を削除
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Changing the order of items in a list: >
	:call sort(list)		" sort a list alphabetically
	:call reverse(list)		" reverse the order of items
	:call uniq(sort(list))		" sort and remove duplicates
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
要素の順番を変更する:
@example
:call sort(list)                " リストをアルファベット順にソート
:call reverse(list)             " 要素の順序を反転させる
:call uniq(sort(list))          " ソートして重複を削除する
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
For loop ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex for ループ
@unnumberedsubsubsec for ループ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The |:for| loop executes commands for each item in a list.  A variable is set
to each item in the list in sequence.  Example: >
	:for item in mylist
	:   call Doit(item)
	:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:for}| ループは、1 つの変数に対してリストの各要素を順番に代入し、コマンドを実行していく。例:
@verbatim
:for item in mylist
:   call Doit(item)
:endfor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This works like: >
	:let index = 0
	:while index < len(mylist)
	:   let item = mylist[index]
	:   :call Doit(item)
	:   let index = index + 1
	:endwhile
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上の例は次と同じ:
@verbatim
:let index = 0
:while index < len(mylist)
:   let item = mylist[index]
:   :call Doit(item)
:   let index = index + 1
:endwhile
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If all you want to do is modify each item in the list then the |map()|
function will be a simpler method than a for loop.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
やりたいことがリストの各要素を変更するだけなら、for ループを使うより関数 |@ref{map()}| を使った方がよりシンプルになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Just like the |:let| command, |:for| also accepts a list of variables.  This
requires the argument to be a list of lists. >
	:for [lnum, col] in [[1, 3], [2, 8], [3, 0]]
	:   call Doit(lnum, col)
	:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:let}| コマンドと同じように、|@ref{:for}| は変数のリストをループ変数にすることができる。この場合、引数はリストのリストでなければならない。
@verbatim
:for [lnum, col] in [[1, 3], [2, 8], [3, 0]]
:   call Doit(lnum, col)
:endfor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This works like a |:let| command is done for each list item.  Again, the types
must remain the same to avoid an error.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはリストの各要素に対して |@ref{:let}| コマンドを実行するかのように実行される。またこの場合も引数の型は全て同じでないとエラーになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It is also possible to put remaining items in a List variable: >
	:for [i, j; rest] in listlist
	:   call Doit(i, j)
	:   if !empty(rest)
	:      echo "remainder: " . string(rest)
	:   endif
	:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数の残りを 1 個のリスト変数に代入することもできる:
@verbatim
:for [i, j; rest] in listlist
:   call Doit(i, j)
:   if !empty(rest)
:      echo "remainder: " . string(rest)
:   endif
:endfor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
List functions ~
						*E714*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E714}
@erindex E714
@cindex リスト操作関数
@unnumberedsubsubsec リスト操作関数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Functions that are useful with a List: >
	:let r = call(funcname, list)	" call a function with an argument list
	:if empty(list)			" check if list is empty
	:let l = len(list)		" number of items in list
	:let big = max(list)		" maximum value in list
	:let small = min(list)		" minimum value in list
	:let xs = count(list, 'x')	" count nr of times 'x' appears in list
	:let i = index(list, 'x')	" index of first 'x' in list
	:let lines = getline(1, 10)	" get ten text lines from buffer
	:call append('$', lines)	" append text lines in buffer
	:let list = split("a b c")	" create list from items in a string
	:let string = join(list, ', ')	" create string from list items
	:let s = string(list)		" String representation of list
	:call map(list, '">> " . v:val')  " prepend ">> " to each item
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下はリスト操作に使える関数である:
@example
:let r = call(funcname, list)   " 引数リストをつけて関数を呼び出す
:if empty(list)                 " リストが空かどうか判定する
:let l = len(list)              " リストの要素数
:let big = max(list)            " リスト中の最大値
:let small = min(list)          " リスト中の最小値
:let xs = count(list, 'x')      " 'x' の出現回数を数える
:let i = index(list, 'x')       " 最初に 'x' が現れる位置のインデックス
:let lines = getline(1, 10)     " バッファから10行を取得
:call append('$', lines)        " バッファに行を追加する
:let list = split("a b c")      " 文字列を分割してリストにする
:let string = join(list, ', ')  " リストの要素を連結して文字列にする
:let s = string(list)           " リストの文字列表現
:call map(list, '">> " . v:val')  " 各要素の前に ">> " をつける
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Don't forget that a combination of features can make things simple.  For
example, to add up all the numbers in a list: >
	:exe 'let sum = ' . join(nrlist, '+')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
機能を組み合わせると、処理を単純に記述できることを覚えておくとよい。例えば、リスト中の全ての数値の和を求める例:
@example
:exe 'let sum = ' . join(nrlist, '+')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
1.4 Dictionaries ~
					*dict* *Dictionaries* *Dictionary*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{dict}
@anchor{Dictionaries}
@anchor{Dictionary}
@cindex dict
@cindex Dictionaries
@cindex Dictionary
@cindex 辞書
@unnumberedsubsec 1.4 辞書
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
A Dictionary is an associative array: Each entry has a key and a value.  The
entry can be located with the key.  The entries are stored without a specific
ordering.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
辞書とは連想配列である。各要素はキーと値を持つ。要素はキーによって特定できる。要素は特に順序を持たずに保持される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Dictionary creation ~
						*E720* *E721* *E722* *E723*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E720}
@anchor{E721}
@anchor{E722}
@anchor{E723}
@erindex E720
@erindex E721
@erindex E722
@erindex E723
@cindex 辞書の作成
@unnumberedsubsubsec 辞書の作成
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
A Dictionary is created with a comma separated list of entries in curly
braces.  Each entry has a key and a value, separated by a colon.  Each key can
only appear once.  Examples: >
	:let mydict = {1: 'one', 2: 'two', 3: 'three'}
	:let emptydict = {}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
辞書を作るには、@{@} の中にコンマで区切って要素を書く。各要素のキーと値はコロンで区切る。それぞれのキーは1度しか現れてはならない。例:
@example
:let mydict = @{1: 'one', 2: 'two', 3: 'three'@}
:let emptydict = @{@}
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<							*E713* *E716* *E717*
A key is always a String.  You can use a Number, it will be converted to a
String automatically.  Thus the String '4' and the number 4 will find the same
entry.  Note that the String '04' and the Number 04 are different, since the
Number will be converted to the String '4'.  The empty string can be used as a
key.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E713}
@anchor{E716}
@anchor{E717}
@erindex E713
@erindex E716
@erindex E717
キーは必ず文字列である。数値を使うこともできるが、自動的に文字列に変換される。よって文字列 '4' のキーと数値4のキーは同一の要素を参照する。
@quotation
@strong{Note:} @*
文字列 '04' と数値 04 は異なることに注意。なぜなら数値 04 は文字列 '4' に変換されるからである。空文字列もキーとして使用できる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A value can be any expression.  Using a Dictionary for a value creates a
nested Dictionary: >
	:let nestdict = {1: {11: 'a', 12: 'b'}, 2: {21: 'c'}}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
値はどんな式でもよい。辞書を値にすると、ネストした辞書ができる:
@example
:let nestdict = @{1: @{11: 'a', 12: 'b'@}, 2: @{21: 'c'@}@}
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An extra comma after the last entry is ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最後の要素の後に余分なコンマがあると無視される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Accessing entries ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex 要素にアクセスする
@unnumberedsubsubsec 要素にアクセスする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The normal way to access an entry is by putting the key in square brackets: >
	:let val = mydict["one"]
	:let mydict["four"] = 4
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
通常、要素にアクセスするには [] の中にキーを書く:
@example
:let val = mydict["one"]
:let mydict["four"] = 4
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can add new entries to an existing Dictionary this way, unlike Lists.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
また、この書き方で既存の辞書に要素を追加できる。この点はリストと異なる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For keys that consist entirely of letters, digits and underscore the following
form can be used |expr-entry|: >
	:let val = mydict.one
	:let mydict.four = 4
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
キー名がアルファベット、数字、アンダースコアだけからなる場合は、以下の形式が使える |@ref{expr-entry}|:
@example
:let val = mydict.one
:let mydict.four = 4
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Since an entry can be any type, also a List and a Dictionary, the indexing and
key lookup can be repeated: >
	:echo dict.key[idx].key
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
要素はリストや辞書を含むどんな型でもよいため、インデックス参照とキー参照を続けて書くことができる:
@example
:echo dict.key[idx].key
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Dictionary to List conversion ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex 辞書からリストへの変換
@unnumberedsubsubsec 辞書からリストへの変換
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You may want to loop over the entries in a dictionary.  For this you need to
turn the Dictionary into a List and pass it to |:for|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
辞書の全要素に対してループを行いたい場合がある。そのためには辞書をリストに変換し、そのリストに対して |@ref{:for}| ループを行う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Most often you want to loop over the keys, using the |keys()| function: >
	:for key in keys(mydict)
	:   echo key . ': ' . mydict[key]
	:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
多くの場合はキーに対してループを行う。これには関数 |@ref{keys()}| を使う:
@verbatim
:for key in keys(mydict)
:   echo key . ': ' . mydict[key]
:endfor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The List of keys is unsorted.  You may want to sort them first: >
	:for key in sort(keys(mydict))
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このキーのリストはソートされていない。ソートさせるには関数 |@ref{sort()}| を使う:
@example
:for key in sort(keys(mydict))
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To loop over the values use the |values()| function:  >
	:for v in values(mydict)
	:   echo "value: " . v
	:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
値に対してループを行うには関数 |@ref{values()}| を使う:
@verbatim
:for v in values(mydict)
:   echo "value: " . v
:endfor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want both the key and the value use the |items()| function.  It returns
a List in which each item is a	List with two items, the key and the value: >
	:for [key, value] in items(mydict)
	:   echo key . ': ' . value
	:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
キーと値両方を得るには関数 |@ref{items()}| を使う。この関数は、キーと値の 2 個の要素からなるリストのリストを返す:
@verbatim
:for [key, value] in items(mydict)
:   echo key . ': ' . value
:endfor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Dictionary identity ~
							*dict-identity*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{dict-identity}
@cindex dict-identity
@cindex 辞書の同一性
@unnumberedsubsubsec 辞書の同一性
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Just like Lists you need to use |copy()| and |deepcopy()| to make a copy of a
Dictionary.  Otherwise, assignment results in referring to the same
Dictionary: >
	:let onedict = {'a': 1, 'b': 2}
	:let adict = onedict
	:let adict['a'] = 11
	:echo onedict['a']
	11
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
辞書のコピーを作るにはリストと同様に |@ref{copy()}| と |@ref{deepcopy()}| を使う必要がある。そうでなく代入を行うと同一の辞書を参照するようになる:
@example
:let onedict = @{'a': 1, 'b': 2@}
:let adict = onedict
:let adict['a'] = 11
:echo onedict['a']
11
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Two Dictionaries compare equal if all the key-value pairs compare equal.  For
more info see |list-identity|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2 つの辞書は、全てのキー・値のペアが等しいとき等しいとみなされる。より詳しくは |@ref{list-identity}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Dictionary modification ~
							*dict-modification*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{dict-modification}
@cindex dict-modification
@cindex 辞書の変更
@unnumberedsubsubsec 辞書の変更
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
To change an already existing entry of a Dictionary, or to add a new entry,
use |:let| this way: >
	:let dict[4] = "four"
	:let dict['one'] = item
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
辞書の要素を変更したり、新しい要素を追加するには |@ref{:let}| を使う:
@example
:let dict[4] = "four"
:let dict['one'] = item
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Removing an entry from a Dictionary is done with |remove()| or |:unlet|.
Three ways to remove the entry with key "aaa" from dict: >
	:let i = remove(dict, 'aaa')
	:unlet dict.aaa
	:unlet dict['aaa']
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
辞書から要素を取り除くには |@ref{remove()}| か |@ref{:unlet}| を使う。以下のように辞書からキー "aaa" を取り除くには 3 つの方法がある:
@example
:let i = remove(dict, 'aaa')
:unlet dict.aaa
:unlet dict['aaa']
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Merging a Dictionary with another is done with |extend()|: >
	:call extend(adict, bdict)
This extends adict with all entries from bdict.  Duplicate keys cause entries
in adict to be overwritten.  An optional third argument can change this.
Note that the order of entries in a Dictionary is irrelevant, thus don't
expect ":echo adict" to show the items from bdict after the older entries in
adict.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2 つの辞書を併合させるには |@ref{extend()}| を使う:
@example
:call extend(adict, bdict)
@end example
上のコマンドは bdict の全ての要素を adict に追加する。キーが重複した要素は bdict の要素により上書きされる。この動作は3番目の引数により変更できる。
@quotation
@strong{Note:} @*
辞書の要素間に順序は定まっていない。そのため "@command{:echo adict}" としたとき、もともと adict にあった要素が先に、bdict から追加された要素が後に表示されると考えてはならない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Weeding out entries from a Dictionary can be done with |filter()|: >
	:call filter(dict, 'v:val =~ "x"')
This removes all entries from "dict" with a value not matching 'x'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
辞書から条件を指定して要素を取り除くには |@ref{filter()}| が使える:
@example
:call filter(dict, 'v:val =~ "x"')
@end example
このコマンドは "dict" から 'x' にマッチしない要素を全て取り除く。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Dictionary function ~
				*Dictionary-function* *self* *E725* *E862*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Dictionary-function}
@anchor{self}
@anchor{E725}
@anchor{E862}
@cindex Dictionary-function
@cindex self
@erindex E725
@erindex E862
@cindex 関数を辞書に入れる
@unnumberedsubsubsec 関数を辞書に入れる
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
When a function is defined with the "dict" attribute it can be used in a
special way with a dictionary.  Example: >
	:function Mylen() dict
	:   return len(self.data)
	:endfunction
	:let mydict = {'data': [0, 1, 2, 3], 'len': function("Mylen")}
	:echo mydict.len()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数が "dict" 属性つきで定義されると、特殊な方法で呼び出すことができる。例:
@verbatim
:function Mylen() dict
:   return len(self.data)
:endfunction
:let mydict = {'data': [0, 1, 2, 3], 'len': function("Mylen")}
:echo mydict.len()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This is like a method in object oriented programming.  The entry in the
Dictionary is a |Funcref|.  The local variable "self" refers to the dictionary
the function was invoked from.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはオブジェクト指向プログラミングのメソッドに似ている。この辞書の要素は |@ref{Funcref}| である。暗黙に定義されるローカル変数 "self" は、この関数を呼び出した辞書を参照している。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It is also possible to add a function without the "dict" attribute as a
Funcref to a Dictionary, but the "self" variable is not available then.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"dict" 属性をつけないで Funcref を辞書に入れることもできる。しかしその場合、変数 "self" は定義されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*numbered-function* *anonymous-function*
To avoid the extra name for the function it can be defined and directly
assigned to a Dictionary in this way: >
	:let mydict = {'data': [0, 1, 2, 3]}
	:function mydict.len()
	:   return len(self.data)
	:endfunction
	:echo mydict.len()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{numbered-function}
@anchor{anonymous-function}
@cindex numbered-function
@cindex anonymous-function
関数に名前をつける必要をなくすために、関数を定義して直接辞書に代入することができる:
@verbatim
:let mydict = {'data': [0, 1, 2, 3]}
:function mydict.len()
:   return len(self.data)
:endfunction
:echo mydict.len()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The function will then get a number and the value of dict.len is a |Funcref|
that references this function.  The function can only be used through a
|Funcref|.  It will automatically be deleted when there is no |Funcref|
remaining that refers to it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
こうすると関数に番号がふられ、dict.len がこの関数を参照する |@ref{Funcref}| となる。この関数は |@ref{Funcref}| を通してのみ呼び出せる。参照している |@ref{Funcref}| がなくなると、この関数は自動的に削除される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It is not necessary to use the "dict" attribute for a numbered function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
番号付き関数には "dict" 属性を付ける必要はない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you get an error for a numbered function, you can find out what it is with
a trick.  Assuming the function is 42, the command is: >
	:function {42}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
番号付き関数でエラーが発生したときは、あるトリックを使うことで発生源を確認できる。例えば 42 という関数なら次のようにする:
@example
:function @{42@}
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Functions for Dictionaries ~
							*E715*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E715}
@erindex E715
@cindex 辞書操作関数
@unnumberedsubsubsec 辞書操作関数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Functions that can be used with a Dictionary: >
	:if has_key(dict, 'foo')	" TRUE if dict has entry with key "foo"
	:if empty(dict)			" TRUE if dict is empty
	:let l = len(dict)		" number of items in dict
	:let big = max(dict)		" maximum value in dict
	:let small = min(dict)		" minimum value in dict
	:let xs = count(dict, 'x')	" count nr of times 'x' appears in dict
	:let s = string(dict)		" String representation of dict
	:call map(dict, '">> " . v:val')  " prepend ">> " to each item
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下は辞書操作に使える関数である:
@example
:if has_key(dict, 'foo')        " 辞書がキー "foo" の要素を持つなら真
:if empty(dict)                 " 辞書が空なら真
:let l = len(dict)              " 辞書の要素数
:let big = max(dict)            " 辞書中の最大値
:let small = min(dict)          " 辞書中の最小値
:let xs = count(dict, 'x')      " 'x' の出現回数を数える
:let s = string(dict)           " 辞書の文字列表現
:call map(dict, '">> " . v:val')  " 各要素の前に ">> " をつける
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
1.5 More about variables ~
							*more-variables*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{more-variables}
@cindex more-variables
@cindex 変数について補足
@unnumberedsubsec 1.5 変数について補足
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
If you need to know the type of a variable or expression, use the |type()|
function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数や式の結果の型を知りたいのならば、関数 |@ref{type()}| を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the '!' flag is included in the 'viminfo' option, global variables that
start with an uppercase letter, and don't contain a lowercase letter, are
stored in the viminfo file |viminfo-file|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{viminfo}' にフラグ '!' が含まれるならば、大文字で始まり小文字を含まない名前のグローバル変数は、@file{viminfo} ファイル |@ref{viminfo-file}| に格納される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the 'sessionoptions' option contains "global", global variables that
start with an uppercase letter and contain at least one lowercase letter are
stored in the session file |session-file|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{sessionoptions}' が "@var{global}" を含むなら、大文字で始まり少なくとも一文字以上の小文字を含む名前のグローバル変数は、@file{session} ファイル |@ref{session-file}| に格納される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
variable name		can be stored where ~
my_var_6		not
My_Var_6		session file
MY_VAR_6		viminfo file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@headitem 変数名 @tab 何処に保存されるか
@item my_var_6 @tab されない
@item My_Var_6 @tab sessionファイル
@item MY_VAR_6 @tab viminfoファイル
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
It's possible to form a variable name with curly braces, see
|curly-braces-names|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
波括弧を使って変数名を構成できる。詳細は |@ref{curly-braces-names}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
2. Expression syntax					*expression-syntax*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expression-syntax}
@cindex expression-syntax
@cindex 式の文法
@section 2. 式の文法
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Expression syntax summary, from least to most significant:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
式文法一覧、優先順位の低いものから高い順に:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|expr1|	expr2
	expr2 ? expr1 : expr1	if-then-else
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .3 .6
@item |@ref{expr1}| @tab expr2
@item @tab expr2 ? expr1 : expr1 @tab if-then-else 条件式
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|expr2|	expr3
	expr3 || expr3 ..	logical OR
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item |@ref{expr2}| @tab expr3
@item @tab expr3 || expr3 .. @tab 論理和
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|expr3|	expr4
	expr4 && expr4 ..	logical AND
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item |@ref{expr3}| @tab expr4
@item @tab expr4 && expr4 .. @tab 論理積
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|expr4|	expr5
	expr5 == expr5		equal
	expr5 != expr5		not equal
	expr5 >	 expr5		greater than
	expr5 >= expr5		greater than or equal
	expr5 <	 expr5		smaller than
	expr5 <= expr5		smaller than or equal
	expr5 =~ expr5		regexp matches
	expr5 !~ expr5		regexp doesn't match
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item |@ref{expr4}| @tab expr5
@item @tab expr5 == expr5 @tab 等しい
@item @tab expr5 != expr5 @tab 等しくない
@item @tab expr5 > expr5 @tab より大きい
@item @tab expr5 >= expr5 @tab 大きいか等しい
@item @tab expr5 < expr5 @tab より小さい
@item @tab expr5 <= expr5 @tab 小さいか等しい
@item @tab expr5 =~ expr5 @tab 正規表現にマッチする
@item @tab expr5 !~ expr5 @tab 正規表現にマッチしない
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	expr5 ==? expr5		equal, ignoring case
	expr5 ==# expr5		equal, match case
	etc.			As above, append ? for ignoring case, # for
				matching case
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item @tab expr5 ==? expr5 @tab 文字列として等しい(大文字/小文字区別無し)
@item @tab expr5 ==# expr5 @tab 文字列として等しい(大文字/小文字区別有り)
@item @tab etc. @tab 上記の各式は大小文字の区別を、?を付加すると行わず、#を付加すると行う
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	expr5 is expr5		same |List| instance
	expr5 isnot expr5	different |List| instance
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item @tab expr5 is expr5 @tab 同一の |@ref{List}| のインスタンス
@item @tab expr5 isnot expr5 @tab 異なる |@ref{List}| のインスタンス
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|expr5|	expr6
	expr6 +	 expr6 ..	number addition or list concatenation
	expr6 -	 expr6 ..	number subtraction
	expr6 .	 expr6 ..	string concatenation
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item |@ref{expr5}| @tab expr6
@item @tab expr6 + expr6 .. @tab 足し算またはリストの連結
@item @tab expr6 - expr6 .. @tab 引き算
@item @tab expr6 . expr6 .. @tab 文字列の連結
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|expr6|	expr7
	expr7 *	 expr7 ..	number multiplication
	expr7 /	 expr7 ..	number division
	expr7 %	 expr7 ..	number modulo
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item |@ref{expr6}| @tab expr7
@item @tab expr7 * expr7 .. @tab 掛け算
@item @tab expr7 / expr7 .. @tab 割り算
@item @tab expr7 % expr7 .. @tab 剰余(割った余り)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|expr7|	expr8
	! expr7			logical NOT
	- expr7			unary minus
	+ expr7			unary plus
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item |@ref{expr7}| @tab expr8
@item @tab ! expr7 @tab 論理否定
@item @tab - expr7 @tab 単項のマイナス @{訳注: -1 等@}
@item @tab + expr7 @tab 単項のプラス
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|expr8|	expr9
	expr8[expr1]		byte of a String or item of a |List|
	expr8[expr1 : expr1]	substring of a String or sublist of a |List|
	expr8.name		entry in a |Dictionary|
	expr8(expr1, ...)	function call with |Funcref| variable
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item |@ref{expr8}| @tab expr9
@item @tab expr8[expr1]	 @tab 文字列のバイト、またはリスト |@ref{List}| の要素
@item @tab expr8[expr1 : expr1] @tab 文字列の部分文字列、またはリスト |@ref{List}| の部分リスト
@item @tab expr8.name @tab 辞書 |@ref{Dictionary}| の要素
@item @tab expr8(expr1, ...) @tab |@ref{Funcref}| 変数による関数呼び出し
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|expr9|	number			number constant
	"string"		string constant, backslash is special
	'string'		string constant, ' is doubled
	[expr1, ...]		|List|
	{expr1: expr1, ...}	|Dictionary|
	&option			option value
	(expr1)			nested expression
	variable		internal variable
	va{ria}ble		internal variable with curly braces
	$VAR			environment variable
	@r			contents of register 'r'
	function(expr1, ...)	function call
	func{ti}on(expr1, ...)	function call with curly braces
	{args -> expr1}		lambda expression
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item |@ref{expr9}| @tab number @tab 数定数
@item @tab "string" @tab 文字列定数。バックスラッシュは特別な意味を持つ
@item @tab 'string' @tab リテラル文字列定数。'を含めるには 2 重にする
@item @tab [expr1, ...] @tab リスト |@ref{List}|
@item @tab @{expr1: expr1, ...@} @tab 辞書 |@ref{Dictionary}|
@item @tab &option @tab オプション変数
@item @tab (expr1) @tab 式の入れ子
@item @tab variable @tab 内部変数
@item @tab va@{ria@}ble @tab 波括弧付きの内部変数
@item @tab $VAR @tab 環境変数
@item @tab @@r @tab レジスタ 'r' の値
@item @tab function(expr1, ...) @tab 関数呼出し
@item @tab func@{ti@}on(expr1, ...) @tab 波括弧付きの関数呼出し
@item @tab @{args -> expr1@} @tab ラムダ式
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
".." indicates that the operations in this level can be concatenated.
Example: >
	&nu || &list && &shell == "csh"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
".." はその演算が、その後に他の演算を続ける事ができることを示している。例:
@example
&nu || &list && &shell == "csh"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
All expressions within one level are parsed from left to right.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
1 つのレベルにある全ての式は左から右に解釈される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
expr1							*expr1* *E109*
-----
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr1}
@anchor{E109}
@cindex expr1
@erindex E109
@unnumberedsubsec expr1
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
expr2 ? expr1 : expr1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .9
@item expr2 ? expr1 : expr1
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The expression before the '?' is evaluated to a number.  If it evaluates to
|TRUE|, the result is the value of the expression between the '?' and ':',
otherwise the result is the value of the expression after the ':'.
Example: >
	:echo lnum == 1 ? "top" : lnum
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'?' より前の式は数値として評価される。その結果が |@ref{TRUE}| であった場合、'?' と ':' に挟まれた式の値がこの式全体の値となり、そうでなかった場合は ':' 以降の式の値が全体の値となる。
例:
@example
:echo lnum == 1 ? "先頭" : lnum
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Since the first expression is an "expr2", it cannot contain another ?:.  The
other two expressions can, thus allow for recursive use of ?:.
Example: >
	:echo lnum == 1 ? "top" : lnum == 1000 ? "last" : lnum
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
始めの式が "expr2" であるから、そこに別の ?: を含むことはできない。残り 2 つの式については以下のように再帰的な ?: の利用が許される。
例:
@example
:echo lnum == 1 ? "top" : lnum == 1000 ? "last" : lnum
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To keep this readable, using |line-continuation| is suggested: >
	:echo lnum == 1
	:\	? "top"
	:\	: lnum == 1000
	:\		? "last"
	:\		: lnum
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
読み易くするために、行継続 |@ref{line-continuation}| を利用することが推奨される:
@verbatim
:echo lnum == 1
:\      ? "top"
:\      : lnum == 1000
:\              ? "last"
:\              : lnum
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You should always put a space before the ':', otherwise it can be mistaken for
use in a variable such as "a:1".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
':' の前には必ずスペースを入れること。そうでないと "a:1" のような変数の使用と間違えてしまう可能性がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
expr2 and expr3						*expr2* *expr3*
---------------
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr2}
@anchor{expr3}
@cindex expr2
@cindex expr3
@unnumberedsubsec expr2 and expr3
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
expr3 || expr3 ..	logical OR		*expr-barbar*
expr4 && expr4 ..	logical AND		*expr-&&*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .5 .5
@anchor{expr-barbar}
@cindex expr-barbar
@item expr3 || expr3 .. @tab 論理和
@anchor{expr-&&}
@cindex expr-&&
@item expr4 && expr4 .. @tab 論理積
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "||" and "&&" operators take one argument on each side.  The arguments
are (converted to) Numbers.  The result is:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
演算子 "||" と "&&" は左右に 1 つずつ引数を取る。引数は数値に変換される。結果は:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
    input			 output ~
n1	n2		n1 || n2	n1 && n2 ~
|FALSE|	|FALSE|		|FALSE|		|FALSE|
|FALSE|	|TRUE|		|TRUE|		|FALSE|
|TRUE|	|FALSE|		|TRUE|		|FALSE|
|TRUE|	|TRUE|		|TRUE|		|TRUE|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .25 .25 .25 .25
@item 入力 @tab @tab 出力
@item n1 @tab n2 @tab n1 || n2 @tab n1 && n2
@item |@ref{FALSE}| @tab |@ref{FALSE}| @tab |@ref{FALSE}| @tab |@ref{FALSE}|
@item |@ref{FALSE}| @tab |@ref{TRUE}| @tab |@ref{TRUE}| @tab |@ref{FALSE}|
@item |@ref{TRUE}| @tab |@ref{FALSE}| @tab |@ref{TRUE}| @tab |@ref{FALSE}|
@item |@ref{TRUE}| @tab |@ref{TRUE}| @tab |@ref{TRUE}| @tab |@ref{TRUE}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The operators can be concatenated, for example: >

	&nu || &list && &shell == "csh"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
演算子は続けて書く事ができる。例:
@example
&nu || &list && &shell == "csh"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that "&&" takes precedence over "||", so this has the meaning of: >

	&nu || (&list && &shell == "csh")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"&&" は "||" よりも高い優先順位を持っている。これは次の事を意味する:
@example
&nu || (&list && &shell == "csh")
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Once the result is known, the expression "short-circuits", that is, further
arguments are not evaluated.  This is like what happens in C.  For example: >

	let a = 1
	echo a || b
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
結果が確定した時点で残りの式は省略され、解釈されない。これはC言語で行われることに似ている。例:
@example
let a = 1
echo a || b
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This is valid even if there is no variable called "b" because "a" is |TRUE|,
so the result must be |TRUE|.  Similarly below: >

	echo exists("b") && b == "yes"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは a が |@ref{TRUE}| であるため、変数bが宣言されていなくても有効であり、結果は絶対に |@ref{TRUE}| である。次のも同様に:
@example
echo exists("b") && b == "yes"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This is valid whether "b" has been defined or not.  The second clause will
only be evaluated if "b" has been defined.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これも b が宣言されているいないにかかわらず有効である。後半の項は b が定義されている時にだけ評価される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
expr4							*expr4*
-----
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr4}
@cindex expr4
@unnumberedsubsec expr4
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
expr5 {cmp} expr5
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .99
@item expr5 @{cmp@} expr5
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Compare two expr5 expressions, resulting in a 0 if it evaluates to false, or 1
if it evaluates to true.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2 つの式 expr5 を比較し、結果が偽なら 0 を、真なら 1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			*expr-==*  *expr-!=*  *expr->*	 *expr->=*
			*expr-<*   *expr-<=*  *expr-=~*  *expr-!~*
			*expr-==#* *expr-!=#* *expr->#*  *expr->=#*
			*expr-<#*  *expr-<=#* *expr-=~#* *expr-!~#*
			*expr-==?* *expr-!=?* *expr->?*  *expr->=?*
			*expr-<?*  *expr-<=?* *expr-=~?* *expr-!~?*
			*expr-is* *expr-isnot* *expr-is#* *expr-isnot#*
			*expr-is?* *expr-isnot?*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr-==}
@anchor{expr-!=}
@anchor{expr->}
@anchor{expr->=}
@anchor{expr-<}
@anchor{expr-<=}
@anchor{expr-=~}
@anchor{expr-!~}
@anchor{expr-==#}
@anchor{expr-!=#}
@anchor{expr->#}
@anchor{expr->=#}
@anchor{expr-<#}
@anchor{expr-<=#}
@anchor{expr-=~#}
@anchor{expr-!~#}
@anchor{expr-==?}
@anchor{expr-!=?}
@anchor{expr->?}
@anchor{expr->=?}
@anchor{expr-<?}
@anchor{expr-<=?}
@anchor{expr-=~?}
@anchor{expr-!~?}
@anchor{expr-is}
@anchor{expr-isnot}
@anchor{expr-is#}
@anchor{expr-isnot#}
@anchor{expr-is?}
@anchor{expr-isnot?}
@cindex expr-==
@cindex expr-!=
@cindex expr->
@cindex expr->=
@cindex expr-<
@cindex expr-<=
@cindex expr-=~
@cindex expr-!~
@cindex expr-==#
@cindex expr-!=#
@cindex expr->#
@cindex expr->=#
@cindex expr-<#
@cindex expr-<=#
@cindex expr-=~#
@cindex expr-!~#
@cindex expr-==?
@cindex expr-!=?
@cindex expr->?
@cindex expr->=?
@cindex expr-<?
@cindex expr-<=?
@cindex expr-=~?
@cindex expr-!~?
@cindex expr-is
@cindex expr-isnot
@cindex expr-is#
@cindex expr-isnot#
@cindex expr-is?
@cindex expr-isnot?
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		use 'ignorecase'    match case	   ignore case ~
equal			==		==#		==?
not equal		!=		!=#		!=?
greater than		>		>#		>?
greater than or equal	>=		>=#		>=?
smaller than		<		<#		<?
smaller than or equal	<=		<=#		<=?
regexp matches		=~		=~#		=~?
regexp doesn't match	!~		!~#		!~?
same instance		is		is#		is?
different instance	isnot		isnot#		isnot?
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .25 .25 .25 .25
@headitem @tab '@option{ignorecase}' 次第 @tab 大小文字考慮 @tab 大小文字無視
@item 等しい @tab == @tab ==# @tab ==?
@item 等しくない @tab != @tab !=# @tab !=?
@item より大きい @tab > @tab ># @tab >?
@item より大きいか等しい @tab >= @tab >=# @tab >=?
@item より小さい @tab < @tab <# @tab <?
@item より小さいか等しい @tab <= @tab <=# @tab <=?
@item 正規表現マッチ @tab =~ @tab =~# @tab =~?
@item 正規表現非マッチ @tab !~ @tab !~# @tab !~?
@item 同一のインスタンス @tab is @tab is# @tab is?
@item 異なるインスタンス @tab isnot @tab isnot# @tab isnot?
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples:
"abc" ==# "Abc"	  evaluates to 0
"abc" ==? "Abc"	  evaluates to 1
"abc" == "Abc"	  evaluates to 1 if 'ignorecase' is set, 0 otherwise
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@multitable @columnfractions .3 .7
@item "abc" ==# "Abc" @tab 0 と評価される
@item "abc" ==? "Abc" @tab 1 と評価される
@item "abc" == "Abc" @tab '@option{ignorecase}' が設定されていれば 1 と、でなければ 0 と評価
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*E691* *E692*
A |List| can only be compared with a |List| and only "equal", "not equal",
"is" and "isnot" can be used.  This compares the values of the list,
recursively.  Ignoring case means case is ignored when comparing item values.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E691}
@anchor{E692}
@erindex E691
@erindex E692
リスト |@ref{List}| はリストとだけ比較可能で、== 系, != 系, is 系, isnot 系のみ利用できる。これらはそれぞれのリストの値を再帰的に比較する。大文字小文字無視にすると要素を比較するときに大文字小文字を無視する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*E735* *E736*
A |Dictionary| can only be compared with a |Dictionary| and only "equal", "not
equal", "is" and "isnot" can be used.  This compares the key/values of the
|Dictionary| recursively.  Ignoring case means case is ignored when comparing
item values.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E735}
@anchor{E736}
@erindex E735
@erindex E736
辞書 |@ref{Dictionary}| は辞書とだけ比較可能で、== 系, != 系, is 系, isnot 系のみ利用できる。これらは辞書のキー/値を再帰的に比較する。大文字小文字無視にすると要素を比較するときに大文字小文字を無視する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*E694*
A |Funcref| can only be compared with a |Funcref| and only "equal", "not
equal", "is" and "isnot" can be used.  Case is never ignored.  Whether
arguments or a Dictionary are bound (with a partial) matters.  The
Dictionaries must also be equal (or the same, in case of "is") and the
arguments must be equal (or the same).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E694}
@erindex E694
|@ref{Funcref}| は Funcref とだけ比較可能で、== 系, != 系, is 系, isnot 系のみ利用できる。大文字小文字は常に区別される。引数や辞書が (部分適用に) バインドされているかどうかも重要である。辞書も同値 (あるいは "is" の場合は同一) でなければならず、引数も同値 (あるいは同一) でなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To compare Funcrefs to see if they refer to the same function, ignoring bound
Dictionary and arguments, use |get()| to get the function name: >
	if get(Part1, 'name') == get(Part2, 'name')
	   " Part1 and Part2 refer to the same function
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数参照が同じ関数を指しているのかを、バインドされた辞書や引数を無視して比較したい場合は、|@ref{get()}| を使用して関数名を取得すればよい:
@verbatim
if get(Part1, 'name') == get(Part2, 'name')
" Part1 と Part2 は同じ関数を指している
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When using "is" or "isnot" with a |List| or a |Dictionary| this checks if the
expressions are referring to the same |List| or |Dictionary| instance.  A copy
of a |List| is different from the original |List|.  When using "is" without
a |List| or a |Dictionary| it is equivalent to using "equal", using "isnot"
equivalent to using "not equal".  Except that a different type means the
values are different: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リスト (|@ref{List}|) や 辞書 (|@ref{Dictionary}|) に対して "is" や "isnot" を使うと、それらの式が同じリストのインスタンスを参照しているか判定される。リストのコピーと元のリストは異なると判定される。リスト以外に対して "is" は "equal" と同じで、"isnot" は "not equal" と同じである。ただし "is"、"isnot" は型が異なると値が等しくない点が "==" とは異なる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	echo 4 == '4'
	1
	echo 4 is '4'
	0
	echo 0 is []
	0
"is#"/"isnot#" and "is?"/"isnot?" can be used to match and ignore case.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
echo 4 == '4'
1
echo 4 is '4'
0
echo 0 is []
0
@end example
"is#"/"isnot#" と "is?"/"isnot?" は大文字小文字を区別するかどうかが違う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When comparing a String with a Number, the String is converted to a Number,
and the comparison is done on Numbers.  This means that: >
	echo 0 == 'x'
	1
because 'x' converted to a Number is zero.  However: >
	echo [0] == ['x']
	0
Inside a List or Dictionary this conversion is not used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列と数値を比較した場合、文字列が数値に変換され、数値として比較される。これは以下のようになることを意味する:
@example
echo 0 == 'x'
1
@end example
なぜなら、'x' は数値のゼロに変換されるからである。しかし、
@example
echo [0] == ['x']
0
@end example
リストや辞書の中ではこの変換は行われない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When comparing two Strings, this is done with strcmp() or stricmp().  This
results in the mathematical difference (comparing byte values), not
necessarily the alphabetical difference in the local language.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列同士を比較した場合、strcmp() や stricmp() によって比較される。これは数値的に (バイトの値で) 比較されるのであって、必ずしも言語に基づく文字種の違いではない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When using the operators with a trailing '#', or the short version and
'ignorecase' is off, the comparing is done with strcmp(): case matters.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'#' を付けた演算子を使うか、省略形かつ '@option{ignorecase}' が設定されていない場合、比較は strcmp() で行われる。大文字・小文字は区別される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When using the operators with a trailing '?', or the short version and
'ignorecase' is set, the comparing is done with stricmp(): case is ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'?' を付けた演算子を使うか、省略形かつ '@option{ignorecase}' が設定されている場合、比較はstricmp()で行われる。大文字・小文字は区別されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
'smartcase' is not used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'smartcase' は適用されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "=~" and "!~" operators match the lefthand argument with the righthand
argument, which is used as a pattern.  See |pattern| for what a pattern is.
This matching is always done like 'magic' was set and 'cpoptions' is empty, no
matter what the actual value of 'magic' or 'cpoptions' is.  This makes scripts
portable.  To avoid backslashes in the regexp pattern to be doubled, use a
single-quote string, see |literal-string|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"=~" と "!~" 演算子は右側の引数を正規表現のパターンとして、左側の引数に対してマッチを試みる。正規表現のパターンに関しては |@ref{pattern}| を参照。このマッチは '@option{magic}' が設定され '@option{cpoptions}' が空であるように振舞い、実際の '@option{magic}' や '@option{cpoptions}' に何が設定されているには依存しない。これがスクリプトをポータブルにしてくれる。正規表現中のバックスラッシュが重複してしまうのを避けるには、シングルクォーテーションの文字列を使用する。詳細は |@ref{literal-string}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Since a string is considered to be a single line, a multi-line pattern
(containing \n, backslash-n) will not match.  However, a literal NL character
can be matched like an ordinary character.  Examples:
	"foo\nbar" =~ "\n"	evaluates to 1
	"foo\nbar" =~ "\\n"	evaluates to 0
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列は単一行として扱われるので、複数行のパターン (\n を含むもの) はマッチしない。しかしながらリテラルなヌル文字 (NL) を、普通の文字として代用することはできる。例:
@multitable @columnfractions .5 .5
@item "foo\nbar" =~ "\n" @tab 1 として評価される
@item "foo\nbar" =~ "\\n" @tab 0 として評価される
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
expr5 and expr6						*expr5* *expr6*
---------------
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr5}
@anchor{expr6}
@cindex expr5
@cindex expr6
@unnumberedsubsec expr5 and expr6
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
expr6 +	 expr6 ..	Number addition or |List| concatenation	*expr-+*
expr6 -	 expr6 ..	Number subtraction			*expr--*
expr6 .	 expr6 ..	String concatenation			*expr-.*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@anchor{expr-+}
@cindex expr-+
@item expr6 + expr6 .. @tab 足し算、またはリスト |@ref{List}| の連結
@anchor{expr--}
@cindex expr@minus{}@minus{}
@item expr6 - expr6 .. @tab 引き算
@anchor{expr-.}
@cindex expr-.
@item expr6 . expr6 .. @tab 文字列の連結
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For |Lists| only "+" is possible and then both expr6 must be a list.  The
result is a new list with the two lists Concatenated.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リスト |@ref{List}| に対しては "+" のみ可能で、expr6 は両方ともリストでなければならない。結果は 2 つのリストを連結した新しいリスト。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
expr7 *	 expr7 ..	Number multiplication			*expr-star*
expr7 /	 expr7 ..	Number division				*expr-/*
expr7 %	 expr7 ..	Number modulo				*expr-%*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@anchor{expr-star}
@c @cindex expr-star
@cindex expr-*
@item expr7 * expr7 .. @tab 掛け算
@anchor{expr-/}
@cindex expr-/
@item expr7 / expr7 .. @tab 割り算
@anchor{expr-%}
@cindex expr-%
@item expr7 % expr7 .. @tab 剰余(割った余り)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For all, except ".", Strings are converted to Numbers.
For bitwise operators see |and()|, |or()| and |xor()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"." を除く全ての演算子は自動的に文字列を数値に変換する。ビット演算については |@ref{and()}|, |@ref{or()}|, |@ref{xor()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note the difference between "+" and ".":
	"123" + "456" = 579
	"123" . "456" = "123456"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"+" と "." の違いに注意:
@example
"123" + "456" = 579
"123" . "456" = "123456"
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Since '.' has the same precedence as '+' and '-', you need to read: >
	1 . 90 + 90.0
As: >
	(1 . 90) + 90.0
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'.' は '+' と '-' と等しい優先順位を持つので、次の式は:
@example
1 . 90 + 90.0
@end example
次のように解釈される:
@example
(1 . 90) + 90.0
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
That works, since the String "190" is automatically converted to the Number
190, which can be added to the Float 90.0.  However: >
	1 . 90 * 90.0
Should be read as: >
	1 . (90 * 90.0)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはエラーにならない。というのは、"190" は自動的に数値 190 に変換され、それと浮動小数点数 90.0 との和になる。しかし次の式は:
@example
1 . 90 * 90.0
@end example
次のように解釈される:
@example
1 . (90 * 90.0)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Since '.' has lower precedence than '*'.  This does NOT work, since this
attempts to concatenate a Float and a String.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'.' は '*' より優先順位が低いためである。これはエラーになる。というのは、浮動小数点数と文字列を結合することになるからである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When dividing a Number by zero the result depends on the value:
	  0 / 0  = -0x80000000	(like NaN for Float)
	 >0 / 0  =  0x7fffffff	(like positive infinity)
	 <0 / 0  = -0x7fffffff	(like negative infinity)
	(before Vim 7.2 it was always 0x7fffffff)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
数値をゼロで割った結果は、被除数によって次のようになる:
@multitable @columnfractions .5 .5
@item @ 0 / 0 @ = -0x80000000 @tab (浮動小数点数の NaN のようなもの)
@item >0 / 0  = @ 0x7fffffff @tab (正の無限大のようなもの)
@item <0 / 0  = -0x7fffffff @tab (負の無限大のようなもの)
@end multitable
@{訳注: >0 は正の数、<0 は負の数の意味@}

(Vim 7.2 以前では常に 0x7fffffff だった)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When 64-bit Number support is enabled:
	  0 / 0  = -0x8000000000000000	(like NaN for Float)
	 >0 / 0  =  0x7fffffffffffffff	(like positive infinity)
	 <0 / 0  = -0x7fffffffffffffff	(like negative infinity)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
64ビット数値が有効化されている場合は:
@multitable @columnfractions .5 .5
@item @ 0 / 0 @ = -0x8000000000000000 @tab (浮動小数点数の NaN のようなもの)
@item >0 / 0  = @ 0x7fffffffffffffff @tab (正の無限大のようなもの)
@item <0 / 0  = -0x7fffffffffffffff @tab (負の無限大のようなもの)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the righthand side of '%' is zero, the result is 0.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'%' の右辺(法)が 0 の場合、結果は 0 になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
None of these work for |Funcref|s.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらは全て |@ref{Funcref}| には適用できない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
. and % do not work for Float. *E804*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E804}
@erindex E804
. と % は浮動小数点数には適用できない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
expr7							*expr7*
-----
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr7}
@cindex expr7
@unnumberedsubsec expr7
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
! expr7			logical NOT		*expr-!*
- expr7			unary minus		*expr-unary--*
+ expr7			unary plus		*expr-unary-+*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .5 .5
@anchor{expr-!}
@cindex expr-!
@item ! expr7 @tab 論理否定
@anchor{expr-unary--}
@cindex expr-unary@minus{}@minus{}
@item - expr7 @tab 単項マイナス
@anchor{expr-unary-+}
@cindex expr-unary-+
@item + expr7 @tab 単項プラス
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For '!' |TRUE| becomes |FALSE|, |FALSE| becomes |TRUE| (one).
For '-' the sign of the number is changed.
For '+' the number is unchanged.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'!' 演算子では |@ref{TRUE}| は |@ref{FALSE}| に、|@ref{FALSE}| は |@ref{TRUE}| になる。'-' では数値の符号が反転される。'+" では変化はない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A String will be converted to a Number first.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列はまず数値に変換される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These three can be repeated and mixed.  Examples:
	!-1	    == 0
	!!8	    == 1
	--9	    == 9
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これら 2 つは繰り返したり混ぜたりできる。例:
@example
!-1         == 0
!!8         == 1
--9         == 9
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
expr8							*expr8*
-----
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr8}
@cindex expr8
@unnumberedsubsec expr8
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This expression is either |expr9| or a sequence of the alternatives below,
in any order.  E.g., these are all possible:
	expr9[expr1].name
	expr9.name[expr1]
	expr9(expr1, ...)[expr1].name
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この式は |@ref{expr9}| もしくはすぐ下の代替シーケンスが任意の順番で可能。例えば、次のものはすべて可能:
@example
expr9[expr1].name
expr9.name[expr1]
expr9(expr1, ...)[expr1].name
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
expr8[expr1]		item of String or |List|	*expr-[]* *E111*
							*E909* *subscript*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr-[]}
@anchor{E111}
@anchor{E909}
@anchor{subscript}
@cindex expr-[]
@erindex E111
@erindex E909
@cindex subscript
@unnumberedsubsubsec expr8[expr1] @ @ @ @ 文字列またはリストの要素
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
If expr8 is a Number or String this results in a String that contains the
expr1'th single byte from expr8.  expr8 is used as a String, expr1 as a
Number.  This doesn't recognize multi-byte encodings, see `byteidx()` for
an alternative, or use `split()` to turn the string into a list of characters.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
expr8 が数値か文字列ならば、この値は文字列 expr8 の第 expr1 番目のバイトからなる 1 バイトの文字列となる。expr8 は文字列、expr1 は数として扱われる。ただし expr8 がマルチバイト文字列である場合、この値は単なるバイトコードであり、1 文字とはならないかもしれないことに注意。マルチバイト文字列に対する代替方法は `byteidx()` を参照するか、`split()`を使って文字列を文字のリストに変換すれば良い。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Index zero gives the first byte.  This is like it works in C.  Careful:
text column numbers start with one!  Example, to get the byte under the
cursor: >
	:let c = getline(".")[col(".") - 1]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
インデックスが0の場合、先頭のバイトが得られることに注意。これはC言語のように働く。注意:カラム番号は1から始まる。例えばカーソルの下のバイトを得るためには、次のようにする必要がある:
@example
:let c = getline(".")[col(".") - 1]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the length of the String is less than the index, the result is an empty
String.  A negative index always results in an empty string (reason: backward
compatibility).  Use [-1:] to get the last byte.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列の長さよりも大きなインデックスが指定された場合、結果は空文字列になる。負数のインデックスを指定すると、結果は常に空文字列になる (後方互換性のため)。最後のバイトを得るには [-1:] を使うこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If expr8 is a |List| then it results the item at index expr1.  See |list-index|
for possible index values.  If the index is out of range this results in an
error.  Example: >
	:let item = mylist[-1]		" get last item
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
expr8 がリスト |@ref{List}| ならばインデックス expr1 の要素が返る。取りうるインデックスの値については |@ref{list-index}| を参照。インデックスが範囲を超えている場合はエラーとなる。例:
@example
:let item = mylist[-1]          " 最後の要素を取得
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Generally, if a |List| index is equal to or higher than the length of the
|List|, or more negative than the length of the |List|, this results in an
error.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
一般的には、インデックスが正でリスト |@ref{List}| の長さ以上または、負でリストの長さ ×-1 より小さいときエラーとなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
expr8[expr1a : expr1b]	substring or sublist		*expr-[:]*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr-[:]}
@cindex expr-[:]
@unnumberedsubsubsec expr8[expr1a : expr1b] @ @ @ @ 部分文字列または部分リスト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If expr8 is a Number or String this results in the substring with the bytes
from expr1a to and including expr1b.  expr8 is used as a String, expr1a and
expr1b are used as a Number.  This doesn't recognize multi-byte encodings, see
|byteidx()| for computing the indexes.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
expr8 が数値か文字列ならば、expr1a バイトから expr1b バイトまでの部分文字列となる (両端を含む)。expr8 は文字列として扱われ、expr1a と expr1b は数値として扱われる。Note マルチバイトのエンコーディングは認識しない。マルチバイト文字列のインデックスを計算する方法については |@ref{byteidx()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If expr1a is omitted zero is used.  If expr1b is omitted the length of the
string minus one is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
expr1a が省略されたときは 0 となる。expr1b が省略されたときは文字列の長さ -1 となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A negative number can be used to measure from the end of the string.  -1 is
the last character, -2 the last but one, etc.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
負数のインデックスを使うことによって文字列の末尾から取り出すことができる。-1 は最後の文字、-2 は最後から 2 文字目…を表す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If an index goes out of range for the string characters are omitted.  If
expr1b is smaller than expr1a the result is an empty string.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
インデックスがその文字の範囲外に出てしまったときは、その文字は省かれる。expr1b が expr1a より小さいときは空文字列となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples: >
	:let c = name[-1:]		" last byte of a string
	:let c = name[-2:-2]		" last but one byte of a string
	:let s = line(".")[4:]		" from the fifth byte to the end
	:let s = s[:-3]			" remove last two bytes
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:let c = name[-1:]              " 文字列の最後のバイト
:let c = name[-2:-2]            " 文字列の最後から 2 バイト目
:let s = line(".")[4:]          " 5 バイト目から末尾まで
:let s = s[:-3]                 " 最後の 2 文字を削除する
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*slice*
If expr8 is a |List| this results in a new |List| with the items indicated by
the indexes expr1a and expr1b.  This works like with a String, as explained
just above. Also see |sublist| below.  Examples: >
	:let l = mylist[:3]		" first four items
	:let l = mylist[4:4]		" List with one item
	:let l = mylist[:]		" shallow copy of a List
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{slice}
@cindex slice
expr8 がリスト |@ref{List}| ならば、インデックス expr1a と expr1b の間の要素からなる新しいリストとなる。すぐ上で説明した文字列の場合と同様である。部分リスト |@ref{sublist}| も参照のこと。例:
@example
:let l = mylist[:3]             " 最初の 4 個の要素
:let l = mylist[4:4]            " 1 個の要素からなるリスト
:let l = mylist[:]              " リストの浅いコピー
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Using expr8[expr1] or expr8[expr1a : expr1b] on a |Funcref| results in an
error.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{Funcref}| に対して expr8[expr1] や expr8[expr1a : expr1b] を使うとエラーになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Watch out for confusion between a namespace and a variable followed by a colon
for a sublist: >
	mylist[n:]     " uses variable n
	mylist[s:]     " uses namespace s:, error!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
部分リストでスコープと変数に続くコロンとの混乱に注意してください:
@example
mylist[n:]     " 変数 n は使える
mylist[s:]     " スコープ s: を使うとエラー！
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
expr8.name		entry in a |Dictionary|		*expr-entry*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr-entry}
@cindex expr-entry
@unnumberedsubsubsec expr8.name @ @ @ @ 辞書 Dictionary の要素
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If expr8 is a |Dictionary| and it is followed by a dot, then the following
name will be used as a key in the |Dictionary|.  This is just like:
expr8[name].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
expr8 が辞書 |@ref{Dictionary}| のとき、ドットをつけるとその後に書かれた名前が辞書のキーと見なされる。例: expr8[name]。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The name must consist of alphanumeric characters, just like a variable name,
but it may start with a number.  Curly braces cannot be used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
名前は変数名と同じようにアルファベットと数字だけから構成されなければならないが、数字で始まってもよい。波括弧は使えない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There must not be white space before or after the dot.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ドットの前後に空白があってはならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples: >
	:let dict = {"one": 1, 2: "two"}
	:echo dict.one
	:echo dict .2
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:let dict = @{"one": 1, 2: "two"@}
:echo dict.one
:echo dict .2
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that the dot is also used for String concatenation.  To avoid confusion
always put spaces around the dot for String concatenation.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ドットは文字列連結にも使われる。混乱を避けるために、文字列連結のドットの周りには必ずスペースを入れること。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
expr8(expr1, ...)	|Funcref| function call
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec expr8(expr1, ...) @ @ @ @ Funcref 関数呼び出し
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When expr8 is a |Funcref| type variable, invoke the function it refers to.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
expr8 が |@ref{Funcref}| 型の変数のとき、その参照する関数を呼び出す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------



@ifset EN
							*expr9*
number
------
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr9}
@cindex expr9
@unnumberedsubsec 数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
number			number constant			*expr-number*
				*hex-number* *octal-number* *binary-number*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr-number}
@anchor{hex-number}
@anchor{octal-number}
@anchor{binary-number}
@cindex expr-number
@cindex hex-number
@cindex octal-number
@cindex binary-number
@unnumberedsubsubsec number @ @ @ @ 数定数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Decimal, Hexadecimal (starting with 0x or 0X), Binary (starting with 0b or 0B)
and Octal (starting with 0).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
10 進数、16 進数 (0x か 0X で始まる)、2 進数 (0b か 0B で始まる)、もしくは 8 進数 (0 で始まる) の数定数。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*floating-point-format*
Floating point numbers can be written in two forms:

	[-+]{N}.{M}
	[-+]{N}.{M}[eE][-+]{exp}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{floating-point-format}
@cindex floating-point-format
浮動小数点数は次の 2 つの形式で書ける:
@example
[-+]@{N@}.@{M@}
[-+]@{N@}.@{M@}[eE][-+]@{exp@}
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{N} and {M} are numbers.  Both {N} and {M} must be present and can only
contain digits.
[-+] means there is an optional plus or minus sign.
{exp} is the exponent, power of 10.
Only a decimal point is accepted, not a comma.  No matter what the current
locale is.
{only when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここで @{N@} と @{M@} は数値である。@{N@} と @{M@} の両方とも省略してはならず、数値のみを含めることができる。[-+] は、省略可能なプラスまたはマイナス記号である。@{exp@} は指数で、10 のベキ。現在のロケールが何であれ、小数点にはドットのみを使える。コンマは使えない。

@{|@ref{+float}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples:
	123.456
	+0.0001
	55.0
	-0.123
	1.234e03
	1.0E-6
	-3.1416e+88
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
123.456
+0.0001
55.0
-0.123
1.234e03
1.0E-6
-3.1416e+88
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These are INVALID:
	3.		empty {M}
	1e40		missing .{M}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のものは無効である:
@example
3.              @{M@} が空
1e40            .@{M@} がない
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*float-pi* *float-e*
A few useful values to copy&paste: >
	:let pi = 3.14159265359
	:let e  = 2.71828182846
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{float-pi}
@anchor{float-e}
@cindex float-pi
@cindex float-e
コピー＆ペーストしておくのに便利な値:
@example
:let pi = 3.14159265359
:let e  = 2.71828182846
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Rationale:
Before floating point was introduced, the text "123.456" was interpreted as
the two numbers "123" and "456", both converted to a string and concatenated,
resulting in the string "123456".  Since this was considered pointless, and we
could not find it intentionally being used in Vim scripts, this backwards
incompatibility was accepted in favor of being able to use the normal notation
for floating point numbers.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
論理的根拠:

浮動小数点数が導入される前は、123.456 と書くと 123 と 456 の2つの数値と解釈され、それらが文字列に変換されて結合されて "123456" という文字列になった。これは無意味であり、Vim script 内で意図的に使われているものが見つからなかったので、浮動小数点数の普通の表記法を用いるため、この後方非互換性は許容された。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*floating-point-precision*
The precision and range of floating points numbers depends on what "double"
means in the library Vim was compiled with.  There is no way to change this at
runtime.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{floating-point-precision}
@cindex floating-point-precision
浮動小数点数の精度と範囲は、Vim とリンクしたライブラリの "double" の意味による。実行時にこれを変更することはできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The default for displaying a |Float| is to use 6 decimal places, like using
printf("%g", f).  You can select something else when using the |printf()|
function.  Example: >
	:echo printf('%.15e', atan(1))
<	7.853981633974483e-01
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
浮動小数点数 |@ref{Float}| は printf("%g", f) とするのと同様に、小数点以下 6 桁まで表示される。表示する桁数は |@ref{printf()}| を使えば変えられる。例:
@example
:echo printf('%.15e', atan(1))
7.853981633974483e-01
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------



@ifset EN
string					*string* *String* *expr-string* *E114*
------
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{string}
@anchor{String}
@anchor{expr-string}
@anchor{E114}
@cindex string
@cindex String
@cindex expr-string
@erindex E114
@cindex 文字列
@unnumberedsubsec 文字列
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"string"		string constant		*expr-quote*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr-quote}
@cindex expr-quote
@unnumberedsubsubsec "string" @ @ @ @ 文字列定数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that double quotes are used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ダブルクォートが使われていることに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A string constant accepts these special characters:
\...	three-digit octal number (e.g., "\316")
\..	two-digit octal number (must be followed by non-digit)
\.	one-digit octal number (must be followed by non-digit)
\x..	byte specified with two hex numbers (e.g., "\x1f")
\x.	byte specified with one hex number (must be followed by non-hex char)
\X..	same as \x..
\X.	same as \x.
\u....	character specified with up to 4 hex numbers, stored according to the
	current value of 'encoding' (e.g., "\u02a4")
\U....	same as \u but allows up to 8 hex numbers.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列定数には以下の特殊文字が使用できる:
@multitable @columnfractions .15 .85
@item \... @tab 3 桁の 8 進数字 (例 "\316")
@item \.. @tab 2 桁の 8 進数字 (非数字が続かなければならない)
@item \. @tab 1 桁の 8 進数字 (非数字が続かなければならない)
@item \x.. @tab 2 桁の 16 進数字 (例 "\x1f")
@item \x. @tab 1 桁の 16 進数字 (16 進数字でないものが続かなければならない)
@item \X.. @tab \x..に同じ
@item \X. @tab \x.に同じ
@item \u.... @tab 文字を 4 桁の 16 進数で表現したもので、実際の値は現在の '@option{encoding}' の値に依存する (例えば "\u02a4")
@item \U.... @tab \u と同じだが 8 桁までの 16 進数が使える
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
\b	backspace <BS>
\e	escape <Esc>
\f	formfeed <FF>
\n	newline <NL>
\r	return <CR>
\t	tab <Tab>
\\	backslash
\"	double quote
\<xxx>	Special key named "xxx".  e.g. "\<C-W>" for CTRL-W.  This is for use
	in mappings, the 0x80 byte is escaped.
	To use the double quote character it must be escaped: "<M-\">".
	Don't use <Char-xxxx> to get a utf-8 character, use \uxxxx as
	mentioned above.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item \b @tab バックスペース <BS>
@item \e @tab エスケープ <Esc>
@item \f @tab フォームフィード <FF>
@item \n @tab 改行 <NL>
@item \r @tab 改行(キャリッジリターン) <CR>
@item \t @tab タブ <Tab>
@item \\ @tab 円記号(バックスラッシュ)
@item \" @tab ダブルクォート
@item \<xxx> @tab "xxx" という名の特殊キー。 例 "\<C-W>" は CTRL-W。これはマップで使うためのものであり、0x80 バイトはエスケープされる。ダブルクォート文字を使う場合はエスケープしなければならない: "<M-\">" utf-8 文字を得るためには <Char-xxxx> を使わずに、上述の \uxxxx を使うこと。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that "\xff" is stored as the byte 255, which may be invalid in some
encodings.  Use "\u00ff" to store character 255 according to the current value
of 'encoding'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"\xff" は値 255 の 1 バイトとなる。これはエンコーディングによっては無効な値かもしれない。現在の '@option{encoding}' の値に応じた文字 255 を得るには "\u00ff" を使う。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that "\000" and "\x00" force the end of the string.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"\000" と "\x00" は強制的に文字列の終端として扱われる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
literal-string						*literal-string* *E115*
---------------
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{literal-string}
@anchor{E115}
@cindex literal-string
@erindex E115
@cindex リテラル文字列
@unnumberedsubsec リテラル文字列
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
'string'		string constant			*expr-'*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr-'}
@cindex expr-'
@unnumberedsubsubsec 'string' @ @ @ @ 文字列定数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that single quotes are used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
シングルクォートが使われていることに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This string is taken as it is.  No backslashes are removed or have a special
meaning.  The only exception is that two quotes stand for one quote.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この文字列は文字通りに扱われる。バックスラッシュは取り除かれないし、また特別な意味を持ったりもしない。唯一の例外は、2 つのシングルクォートで 1 つのシングルクォートになることである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Single quoted strings are useful for patterns, so that backslashes do not need
to be doubled.  These two commands are equivalent: >
	if a =~ "\\s*"
	if a =~ '\s*'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シングルクォートの文字列は、バックスラッシュを2重にしなくてよいため、正規表現パターンを表すのに便利である。以下の 2 つのコマンドは同値である:
@example
if a =~ "\\s*"
if a =~ '\s*'
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
option						*expr-option* *E112* *E113*
------
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr-option}
@anchor{E112}
@anchor{E113}
@cindex expr-option
@erindex E112
@erindex E113
@cindex オプション
@unnumberedsubsec オプション
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
&option			option value, local value if possible
&g:option		global option value
&l:option		local option value
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item &option @tab オプション変数、ローカルなものが優先
@item &g:option @tab グローバルオプション変数
@item &l:option @tab ローカルオプション変数
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples: >
	echo "tabstop is " . &tabstop
	if &insertmode
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
echo "タブストップは " . &tabstop . " です"
if &insertmode
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Any option name can be used here.  See |options|.  When using the local value
and there is no buffer-local or window-local value, the global value is used
anyway.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここにはあらゆるオプション名を使うことができる。|@ref{options}| を参照。ローカル変数を使おうとして、実際にはバッファローカルもウィンドウローカルも存在しない場合には、グローバル変数が利用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
register						*expr-register* *@r*
--------
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr-register}
@anchor{@@r}
@cindex expr-register
@cindex @@r
@cindex レジスタ
@unnumberedsubsec レジスタ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
@r			contents of register 'r'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec @@r @ @ @ @ レジスタ 'r' の値
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The result is the contents of the named register, as a single string.
Newlines are inserted where required.  To get the contents of the unnamed
register use @" or @@.  See |registers| for an explanation of the available
registers.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
名前付きレジスタの中身を1つの文字列として得る。必要なところには改行文字が挿入されている。無名レジスタの中身を取得するには @@" か @@@@ を使う。利用可能なレジスタの説明については |@ref{registers}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When using the '=' register you get the expression itself, not what it
evaluates to.  Use |eval()| to evaluate it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
レジスタ '=' を使うと、式の値でなく式そのものを得る。それを評価するには |@ref{eval()}| を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
nesting							*expr-nesting* *E110*
-------
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr-nesting}
@anchor{E110}
@cindex expr-nesting
@erindex E110
@cindex 入れ子
@unnumberedsubsec 入れ子
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
(expr1)			nested expression
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec (expr1) @ @ @ @ 式の入れ子
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
environment variable					*expr-env*
--------------------
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr-env}
@cindex expr-env
@cindex 環境変数
@unnumberedsubsec 環境変数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
$VAR			environment variable
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec $VAR @ @ @ @ 環境変数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The String value of any environment variable.  When it is not defined, the
result is an empty string.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
環境変数の文字列。定義されていない環境変数を指定した場合、結果は空文字列。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*expr-env-expand*
Note that there is a difference between using $VAR directly and using
expand("$VAR").  Using it directly will only expand environment variables that
are known inside the current Vim session.  Using expand() will first try using
the environment variables known inside the current Vim session.  If that
fails, a shell will be used to expand the variable.  This can be slow, but it
does expand all variables that the shell knows about.  Example: >
	:echo $shell
	:echo expand("$shell")
The first one probably doesn't echo anything, the second echoes the $shell
variable (if your shell supports it).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr-env-expand}
@cindex expr-env-expand
@quotation
@strong{Note:} @*
$VAR を直接使用した場合と expand("$VAR") を使用した場合では、動作に違いがあることに注意。直接使用した場合には、現在の Vim のセッション中で既知の値に展開されるだけである。expand() を使用した場合、まず最初に Vim のセッション中で既知の値に展開される。それが失敗した場合、変数の展開にシェルが使用されることになる。これは遅くはなるが、シェルの知りうる全ての変数を展開することができる。例:
@example
:echo $shell
:echo expand("$shell")
@end example
最初の 1 つは恐らく何も返ってこず、2 つ目は $shell の値が返ってくるだろう (貴方のシェルがそれをサポートしているなら)
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
internal variable					*expr-variable*
-----------------
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr-variable}
@cindex expr-variable
@cindex 内部変数
@unnumberedsubsec 内部変数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
variable		internal variable
See below |internal-variables|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec variable @ @ @ @ 内部変数
以下の |@ref{internal-variables}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
function call		*expr-function* *E116* *E118* *E119* *E120*
-------------
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr-function}
@anchor{E116}
@anchor{E118}
@anchor{E119}
@anchor{E120}
@cindex expr-function
@erindex E116
@erindex E118
@erindex E119
@erindex E120
@cindex 関数呼出
@unnumberedsubsec 関数呼出
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
function(expr1, ...)	function call
See below |functions|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec function(expr1, ...) @ @ @ @ 関数呼出
以下の |@ref{functions}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
lambda expression				*expr-lambda* *lambda*
-----------------
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expr-lambda}
@anchor{lambda}
@cindex expr-lambda
@cindex lambda
@cindex ラムダ式
@unnumberedsubsec ラムダ式
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
{args -> expr1}		lambda expression
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec @{args -> expr1@} @ @ @ @ ラムダ式
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A lambda expression creates a new unnamed function which returns the result of
evaluating |expr1|.  Lambda expressions differ from |user-functions| in
the following ways:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ラムダ式は、|@ref{expr1}| を評価した結果を返す新しい無名関数を作成する。ラムダ式は以下の点がユーザー定義関数 |@ref{user-functions}| と異なる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. The body of the lambda expression is an |expr1| and not a sequence of |Ex|
   commands.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item ラムダ式の本体は単一の式 |@ref{expr1}| であり、|@ref{Ex}| コマンド列ではない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
2. The prefix "a:" should not be used for arguments.  E.g.: >
	:let F = {arg1, arg2 -> arg1 - arg2}
	:echo F(5, 2)
<	3
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 引数に前置詞 "a:" を使用しない。例:
@example
:let F = @{arg1, arg2 -> arg1 - arg2@}
:echo F(5, 2)
3
@end example
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The arguments are optional.  Example: >
	:let F = {-> 'error function'}
	:echo F()
<	error function
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数は任意である。例:
@example
:let F = @{-> 'error function'@}
:echo F()
error function
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*closure*
Lambda expressions can access outer scope variables and arguments.  This is
often called a closure.  Example where "i" and "a:arg" are used in a lambda
while they already exist in the function scope.  They remain valid even after
the function returns: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{closure}
@cindex closure
ラムダ式は外側のスコープの変数と引数にアクセスできる。これはよくクロージャと呼ばれる。以下の例ではラムダの中で "i" と "a:arg" が使われているが、これらは関数のスコープにすでに存在する。これらは関数から抜けても有効であり続ける:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:function Foo(arg)
	:  let i = 3
	:  return {x -> x + i - a:arg}
	:endfunction
	:let Bar = Foo(4)
	:echo Bar(6)
<	5
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:function Foo(arg)
:  let i = 3
:  return @{x -> x + i - a:arg@}
:endfunction
:let Bar = Foo(4)
:echo Bar(6)
5
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that the variables must exist in the outer scope before the lamba is
defined for this to work.  See also |:func-closure|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
変数はラムダがこれに作用するために定義される前に、外側のスコープに存在していなければならないことに注意。|@ref{:func-closure}| も参照。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Lambda and closure support can be checked with: >
	if has('lambda')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ラムダとクロージャのサポートは以下のように判定できる:
@example
if has('lambda')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples for using a lambda expression with |sort()|, |map()| and |filter()|: >
	:echo map([1, 2, 3], {idx, val -> val + 1})
<	[2, 3, 4] >
	:echo sort([3,7,2,1,4], {a, b -> a - b})
<	[1, 2, 3, 4, 7]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{sort()}|, |@ref{map()}|, |@ref{filter()}| とともにラムダ式を使う例:
@example
:echo map([1, 2, 3], @{idx, val -> val + 1@})
[2, 3, 4]
:echo sort([3,7,2,1,4], @{a, b -> a - b@})
[1, 2, 3, 4, 7]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The lambda expression is also useful for Channel, Job and timer: >
	:let timer = timer_start(500,
			\ {-> execute("echo 'Handler called'", "")},
			\ {'repeat': 3})
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ラムダ式は、チャネル、ジョブ、タイマーを使う際にも有用である:
@example
:let timer = timer_start(500,
                \ @{-> execute("echo 'Handler called'", "")@},
                \ @{'repeat': 3@})
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	Handler called
	Handler called
	Handler called
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
Handler called
Handler called
Handler called
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note how execute() is used to execute an Ex command.  That's ugly though.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
Ex コマンドを実行するためにどのように execute() を使っているかに注意。醜いが。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Lambda expressions have internal names like '<lambda>42'.  If you get an error
for a lambda expression, you can find what it is with the following command: >
	:function {'<lambda>42'}
See also: |numbered-function|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ラムダ式は '<lambda>42' のような内部名を持っている。もしラムダ式でエラーが発生した場合には、以下のコマンドでどのラムダ式でエラーが起きたかを調べることができる:
@example
:function @{'<lambda>42'@}
@end example
|@ref{numbered-function}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
3. Internal variable				*internal-variables* *E461*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{internal-variables}
@anchor{E461}
@cindex internal-variables
@erindex E461
@cindex 内部変数
@section 3. 内部変数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An internal variable name can be made up of letters, digits and '_'.  But it
cannot start with a digit.  It's also possible to use curly braces, see
|curly-braces-names|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
内部変数の名前には文字と、数字とアンダーバー ('_') を使うことができる。しかし数字で始めることはできない。波括弧を使うこともできる。詳細は |@ref{curly-braces-names}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An internal variable is created with the ":let" command |:let|.
An internal variable is explicitly destroyed with the ":unlet" command
|:unlet|.
Using a name that is not an internal variable or refers to a variable that has
been destroyed results in an error.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
内部変数は ":let" コマンドで作成される |@ref{:let}|。"@command{:unlet}" コマンドで明示的に内部変数を破棄することができる |@ref{:unlet}|。内部変数に使われてない名前か、既に破棄された内部変数を使うとエラーとなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are several name spaces for variables.  Which one is to be used is
specified by what is prepended:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数には幾つもの名前空間が存在する。実際にどれが利用されるかは、どのような前置子が使われたかで決まる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		(nothing) In a function: local to a function; otherwise: global
|buffer-variable|    b:	  Local to the current buffer.
|window-variable|    w:	  Local to the current window.
|tabpage-variable|   t:	  Local to the current tab page.
|global-variable|    g:	  Global.
|local-variable|     l:	  Local to a function.
|script-variable|    s:	  Local to a |:source|'ed Vim script.
|function-argument|  a:	  Function argument (only inside a function).
|vim-variable|       v:	  Global, predefined by Vim.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .1 .6
@item @tab (無し) @tab 関数の中では関数ローカル、それ以外ではグローバル
@item |@ref{buffer-variable}| @tab b: @tab 現在のバッファにローカル
@item |@ref{window-variable}| @tab w: @tab 現在のウィンドウにローカル
@item |@ref{tabpage-variable}| @tab t: @tab 現在のタブページにローカル
@item |@ref{global-variable}| @tab g: @tab グローバル
@item |@ref{local-variable}| @tab l: @tab 関数にローカル
@item |@ref{script-variable}| @tab s: @tab |@ref{:source}| された Vim script にローカル
@item |@ref{function-argument}| @tab a: @tab 関数の引数(関数内のみ)
@item |@ref{vim-variable}| @tab v: @tab グローバル、Vim があらかじめ定義
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The scope name by itself can be used as a |Dictionary|.  For example, to
delete all script-local variables: >
	:for k in keys(s:)
	:    unlet s:[k]
	:endfor
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのスコープそのものに辞書 |@ref{Dictionary}| を通じてアクセスできる。例えば、全てのスクリプトローカル変数を削除するには次のようにする:
@example
:for k in keys(s:)
:    unlet s:[k]
:endfor
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*buffer-variable* *b:var* *b:*
A variable name that is preceded with "b:" is local to the current buffer.
Thus you can have several "b:foo" variables, one for each buffer.
This kind of variable is deleted when the buffer is wiped out or deleted with
|:bdelete|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{buffer-variable}
@anchor{b:var}
@anchor{b:}
@cindex buffer-variable
@cindex b:var
@cindex b:
"b:" で始まる変数名は、カレントバッファに局所的な変数を意味する。このように 1 つ 1 つのバッファ毎に、変数 "b:foo" を別々に使用することができる。この種の変数はバッファが掃除 (wipe out) された時や、|@ref{:bdelete}| で削除された時に一緒に削除される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
One local buffer variable is predefined:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
1 つのバッファローカル変数が定義済:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*b:changedtick* *changetick*
b:changedtick	The total number of changes to the current buffer.  It is
		incremented for each change.  An undo command is also a change
		in this case.  This can be used to perform an action only when
		the buffer has changed.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{b:changedtick}
@anchor{changetick}
@vindex b:changedtick
@cindex changetick
@item b:changedtick
現在のバッファに対する変更の総回数。変更を行うたびに増加する。これには 1 回のアンドゥ操作もカウントされる。この変数はバッファに変更が行われた際にだけアクションを起こしたい時に利用できる。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		    :if my_changedtick != b:changedtick
		    :	let my_changedtick = b:changedtick
		    :	call My_Update()
		    :endif
<		You cannot change or delete the b:changedtick variable.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:if my_changedtick != b:changedtick
:   let my_changedtick = b:changedtick
:   call My_Update()
:endif
@end example
b:changedtick 変数を変更したり削除することはできない。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*window-variable* *w:var* *w:*
A variable name that is preceded with "w:" is local to the current window.  It
is deleted when the window is closed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{window-variable}
@anchor{w:var}
@anchor{w:}
@cindex window-variable
@cindex w:var
@cindex w:
"w:" で始まる変数名は、カレントウィンドウにローカルな変数を意味する。これはウィンドウを閉じるときに破棄される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*tabpage-variable* *t:var* *t:*
A variable name that is preceded with "t:" is local to the current tab page,
It is deleted when the tab page is closed. {not available when compiled
without the |+windows| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tabpage-variable}
@anchor{t:var}
@anchor{t:}
@cindex tabpage-variable
@cindex t:var
@cindex t:
"t:" で始まる変数名は、カレントタブページにローカルな変数を意味する。これはタブページを閉じるときに破棄される。

@{|@ref{+windows}| 機能つきでコンパイルしたときのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*global-variable* *g:var* *g:*
Inside functions global variables are accessed with "g:".  Omitting this will
access a variable local to a function.  But "g:" can also be used in any other
place if you like.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{global-variable}
@anchor{g:var}
@anchor{g:}
@cindex global-variable
@cindex g:var
@cindex g:
関数の中からグローバル変数へアクセスするには、"g:" を付けた名前を使用する。これが省略された場合は関数ローカルな変数にアクセスする。ただし "g:" 自体は、関数の外でも使うことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*local-variable* *l:var* *l:*
Inside functions local variables are accessed without prepending anything.
But you can also prepend "l:" if you like.  However, without prepending "l:"
you may run into reserved variable names.  For example "count".  By itself it
refers to "v:count".  Using "l:count" you can have a local variable with the
same name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{local-variable}
@anchor{l:var}
@anchor{l:}
@cindex local-variable
@cindex l:var
@cindex l:
関数の中からそのローカル変数にアクセスするには何も前置しなければ良い。明示的に "l:" を付けることも可能である。ただし "l:" をつけないと予約されている変数名と衝突してしまうことがある。例: "count" とすると "v:count" を参照してしまう。"l:count" とすればローカル変数 count を参照できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*script-variable* *s:var*
In a Vim script variables starting with "s:" can be used.  They cannot be
accessed from outside of the scripts, thus are local to the script.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{script-variable}
@anchor{s:var}
@cindex script-variable
@cindex s:var
Vim script 内では "s:" で始まる変数名を使うことができる。これはスクリプトについてローカルであり、スクリプトの外部からはアクセスできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
They can be used in:
- commands executed while the script is sourced
- functions defined in the script
- autocommands defined in the script
- functions and autocommands defined in functions and autocommands which were
  defined in the script (recursively)
- user defined commands defined in the script
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
スクリプト変数は次の場所で使える:
@itemize
@item そのスクリプトを source している間に実行されるコマンド
@item そのスクリプト内で定義される関数
@item そのスクリプト内で定義されるオートコマンド
@item そのスクリプト内で定義される関数やオートコマンドで定義される関数やオートコマンド(再帰的)
@item そのスクリプト内で定義されるユーザー定義コマンド
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Thus not in:
- other scripts sourced from this one
- mappings
- menus
- etc.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次の場面では使えない:
@itemize
@item そのスクリプトから source される他のスクリプト
@item マッピング
@item メニュー
@item  など。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Script variables can be used to avoid conflicts with global variable names.
Take this example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
グローバル変数との衝突を避けるにはスクリプト変数を使う。次の例を参照:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	let s:counter = 0
	function MyCounter()
	  let s:counter = s:counter + 1
	  echo s:counter
	endfunction
	command Tick call MyCounter()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
let s:counter = 0
function MyCounter()
  let s:counter = s:counter + 1
  echo s:counter
endfunction
command Tick call MyCounter()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can now invoke "Tick" from any script, and the "s:counter" variable in
that script will not be changed, only the "s:counter" in the script where
"Tick" was defined is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここで他のスクリプトから "Tick" を実行してみると、そのスクリプト内の変数 "s:counter" は変化せず、"Tick" が定義されたスクリプト内の "s:counter" だけが変化する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Another example that does the same: >

	let s:counter = 0
	command Tick let s:counter = s:counter + 1 | echo s:counter
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これと同じことをするもう 1 つの例:
@example
let s:counter = 0
command Tick let s:counter = s:counter + 1 | echo s:counter
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When calling a function and invoking a user-defined command, the context for
script variables is set to the script where the function or command was
defined.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数呼び出しやユーザー定義コマンドを実行するとき、スクリプト変数のコンテキストはその関数、コマンドが定義されたスクリプトとなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The script variables are also available when a function is defined inside a
function that is defined in a script.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数の中で関数を定義した場合、スクリプト変数も共有される。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	let s:counter = 0
	function StartCounting(incr)
	  if a:incr
	    function MyCounter()
	      let s:counter = s:counter + 1
	    endfunction
	  else
	    function MyCounter()
	      let s:counter = s:counter - 1
	    endfunction
	  endif
	endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
let s:counter = 0
function StartCounting(incr)
  if a:incr
    function MyCounter()
      let s:counter = s:counter + 1
    endfunction
  else
    function MyCounter()
      let s:counter = s:counter - 1
    endfunction
  endif
endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This defines the MyCounter() function either for counting up or counting down
when calling StartCounting().  It doesn't matter from where StartCounting() is
called, the s:counter variable will be accessible in MyCounter().
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この StartCounting() を呼ぶと、カウントアップかカウントダウンのどちらかを行う関数 MyCounter() を定義する。StartCounting() がどこで呼ばれたかに関係なく、MyCounter() の中では変数 s:counter にアクセスできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the same script is sourced again it will use the same script variables.
They will remain valid as long as Vim is running.  This can be used to
maintain a counter: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
同じスクリプトが再度読み込まれた場合、同一のスクリプト変数が使われる。スクリプト変数は Vim が終了するまで存続する。以下の例はカウンタを保持する:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	if !exists("s:counter")
	  let s:counter = 1
	  echo "script executed for the first time"
	else
	  let s:counter = s:counter + 1
	  echo "script executed " . s:counter . " times now"
	endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
if !exists("s:counter")
  let s:counter = 1
  echo "script executed for the first time"
else
  let s:counter = s:counter + 1
  echo "script executed " . s:counter . " times now"
endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that this means that filetype plugins don't get a different set of script
variables for each buffer.  Use local buffer variables instead |b:var|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
これはつまり、ファイルタイププラグインはバッファごとにスクリプト変数を 1 セット持つのではないということを意味する。そのような目的にはバッファローカル変数 |@ref{b:var}| を使うこと。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Predefined Vim variables:			*vim-variable* *v:var* *v:*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{vim-variable}
@anchor{v:var}
@anchor{v:}
@cindex vim-variable
@cindex v:var
@cindex v:
@cindex Vim の定義済変数
@unnumberedsubsec Vim の定義済変数:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:beval_col* *beval_col-variable*
v:beval_col	The number of the column, over which the mouse pointer is.
		This is the byte index in the |v:beval_lnum| line.
		Only valid while evaluating the 'balloonexpr' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{v:beval_col}
@anchor{beval_col-variable}
@vindex v:beval_col
@cindex beval_col-variable
@item v:beval_col
マウスポインタがある桁の桁番号。|@ref{v:beval_lnum}| 行目のバイトインデックスである。オプション '@option{balloonexpr}' を評価している最中のみ有効。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:beval_bufnr* *beval_bufnr-variable*
v:beval_bufnr	The number of the buffer, over which the mouse pointer is. Only
		valid while evaluating the 'balloonexpr' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:beval_bufnr}
@anchor{beval_bufnr-variable}
@vindex v:beval_bufnr
@cindex beval_bufnr-variable
@item v:beval_bufnr
マウスポインタがあるバッファの番号。オプション '@option{balloonexpr}' を評価している最中のみ有効。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:beval_lnum* *beval_lnum-variable*
v:beval_lnum	The number of the line, over which the mouse pointer is. Only
		valid while evaluating the 'balloonexpr' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:beval_lnum}
@anchor{beval_lnum-variable}
@vindex v:beval_lnum
@cindex beval_lnum-variable
@item v:beval_lnum
マウスポインタがある行の行番号。オプション '@option{balloonexpr}' を評価している最中のみ有効。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:beval_text* *beval_text-variable*
v:beval_text	The text under or after the mouse pointer.  Usually a word as
		it is useful for debugging a C program.  'iskeyword' applies,
		but a dot and "->" before the position is included.  When on a
		']' the text before it is used, including the matching '[' and
		word before it.  When on a Visual area within one line the
		highlighted text is used.  Also see |<cexpr>|.
		Only valid while evaluating the 'balloonexpr' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:beval_text}
@anchor{beval_text-variable}
@vindex v:beval_text
@cindex beval_text-variable
@item v:beval_text
マウスポインタの下もしくは後ろにあるテキスト。C プログラムのデバッグのために有用。'@option{iskeyword}' が適用されるが、マウスポインタの下より前にあるドットと "->" は含まれる。マウスポインタが ']' の上にあるときは、そこから対応する '[' とその前にあるテキストまでが含まれる。マウスポインタが 1 行に収まるビジュアル領域の上にあるときはその選択領域となる。|@ref{<cexpr>}| を参照。

オプション '@option{balloonexpr}' を評価している最中のみ有効。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:beval_winnr* *beval_winnr-variable*
v:beval_winnr	The number of the window, over which the mouse pointer is. Only
		valid while evaluating the 'balloonexpr' option.  The first
		window has number zero (unlike most other places where a
		window gets a number).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:beval_winnr}
@anchor{beval_winnr-variable}
@vindex v:beval_winnr
@cindex beval_winnr-variable
@item v:beval_winnr
マウスポインタがあるウィンドウの番号。オプション '@option{balloonexpr}' を評価している最中のみ有効。1 番目のウィンドウの番号はゼロである (他の場所でのウィンドウ番号と異なっている)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:beval_winid* *beval_winid-variable*
v:beval_winid	The |window-ID| of the window, over which the mouse pointer
		is.  Otherwise like v:beval_winnr.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:beval_winid}
@anchor{beval_winid-variable}
@vindex v:beval_winid
@cindex beval_winid-variable
@item v:beval_winid
マウスポインタがあるウィンドウのウィンドウ ID |@ref{window-ID}|。それ以外は v:beval_winnr と同様。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:char* *char-variable*
v:char		Argument for evaluating 'formatexpr' and used for the typed
		character when using <expr> in an abbreviation |:map-<expr>|.
		It is also used by the |InsertCharPre| and |InsertEnter| events.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:char}
@anchor{char-variable}
@vindex v:char
@cindex char-variable
@item v:char
'@option{formatexpr}' を評価しているときの引数。また、短縮入力 |@ref{:map-<expr>}| で <expr> を指定しているとき、タイプされた文字を保持する。これは |@ref{InsertCharPre}| と |@ref{InsertEnter}| イベントでも使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			*v:charconvert_from* *charconvert_from-variable*
v:charconvert_from
		The name of the character encoding of a file to be converted.
		Only valid while evaluating the 'charconvert' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:charconvert_from}
@anchor{charconvert_from-variable}
@vindex v:charconvert_from
@cindex charconvert_from-variable
@item v:charconvert_from
変換しようとしているファイルの文字エンコーディング名。オプション '@option{charconvert}' を評価している最中のみ有効。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			*v:charconvert_to* *charconvert_to-variable*
v:charconvert_to
		The name of the character encoding of a file after conversion.
		Only valid while evaluating the 'charconvert' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:charconvert_to}
@anchor{charconvert_to-variable}
@vindex v:charconvert_to
@cindex charconvert_to-variable
@item v:charconvert_to
変換後のファイルの文字エンコーディング名。オプション '@option{charconvert}' を評価している最中のみ有効。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:cmdarg* *cmdarg-variable*
v:cmdarg	This variable is used for two purposes:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:cmdarg}
@anchor{cmdarg-variable}
@vindex v:cmdarg
@cindex cmdarg-variable
@item v:cmdarg
2 つの目的のために使われる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		1. The extra arguments given to a file read/write command.
		   Currently these are "++enc=" and "++ff=".  This variable is
		   set before an autocommand event for a file read/write
		   command is triggered.  There is a leading space to make it
		   possible to append this variable directly after the
		   read/write command.  Note: The "+cmd" argument isn't
		   included here, because it will be executed anyway.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item ファイルの読み書きコマンドに与えられる余分な引数。現在のところ "++enc=" と "++ff=" がそれである。読み書きコマンドに対するオートコマンドイベントが発生する前にこの変数が代入される。その読み書きコマンドの後に直接この変数を連結できるように、先頭にスペースがついている。
@quotation
@strong{Note:} @*
ここには "+cmd" 引数は含まれていない。どちらにしろそれは実行されるからである。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		2. When printing a PostScript file with ":hardcopy" this is
		   the argument for the ":hardcopy" command.  This can be used
		   in 'printexpr'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "@command{:hardcopy}" で PostScript ファイルを印刷するとき、これが "@command{:hardcopy}" への引数になる。'@option{printexpr}' の中で使うことができる。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:cmdbang* *cmdbang-variable*
v:cmdbang	Set like v:cmdarg for a file read/write command.  When a "!"
		was used the value is 1, otherwise it is 0.  Note that this
		can only be used in autocommands.  For user commands |<bang>|
		can be used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:cmdbang}
@anchor{cmdbang-variable}
@vindex v:cmdbang
@cindex cmdbang-variable
@item v:cmdbang
v:cmdarg と同じく読み書きコマンドを実行したとき設定される。読み書きコマンドに "!" が使われたときは 1 となり、使われていなければ 0 となる。
@quotation
@strong{Note:} @*
オートコマンドの中でのみ利用可能なことに注意。ユーザー定義コマンドでは |@ref{<bang>}| を使えば同じことができる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*v:completed_item* *completed_item-variable*
v:completed_item
		|Dictionary| containing the |complete-items| for the most
		recently completed word after |CompleteDone|.  The
		|Dictionary| is empty if the completion failed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:completed_item}
@anchor{completed_item-variable}
@vindex v:completed_item
@cindex completed_item-variable
@item v:completed_item
最も最近補完された単語が含まれた |@ref{complete-items}| の |@ref{Dictionary}| が |@ref{CompleteDone}| イベント後に設定される。補完に失敗した時、その |@ref{Dictionary}| は空である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:count* *count-variable*
v:count		The count given for the last Normal mode command.  Can be used
		to get the count before a mapping.  Read-only.  Example: >
	:map _x :<C-U>echo "the count is " . v:count<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:count}
@anchor{count-variable}
@vindex v:count
@cindex count-variable
@item v:count
最後に実行されたノーマルモードコマンドに渡されたカウント数。マッピングの前のカウントを取得するのに使用できる。読出し専用。使用例:
@example
:map _x :<C-U>echo "the count is " . v:count<CR>
@end example                
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		Note: The <C-U> is required to remove the line range that you
		get when typing ':' after a count.
		When there are two counts, as in "3d2w", they are multiplied,
		just like what happens in the command, "d6w" for the example.
		Also used for evaluating the 'formatexpr' option.
		"count" also works, for backwards compatibility.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
<C-U>は、カウントの後に ':' をタイプした時に示される行範囲指定を削除するために必要となる。"3d2w" のようにカウントが 2 個指定された場合、その数が掛けられる。よって "d6w" となる。オプション '@option{formatexpr}' を評価するためにも使われる。また "count" は、以前の版の Vim との互換性の為に動作する。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:count1* *count1-variable*
v:count1	Just like "v:count", but defaults to one when no count is
		used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:count1}
@anchor{count1-variable}
@vindex v:count1
@cindex count1-variable
@item v:count1
"v:count" と同じだが、カウントが指定されなかった時の既定値が 1 となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*v:ctype* *ctype-variable*
v:ctype		The current locale setting for characters of the runtime
		environment.  This allows Vim scripts to be aware of the
		current locale encoding.  Technical: it's the value of
		LC_CTYPE.  When not using a locale the value is "C".
		This variable can not be set directly, use the |:language|
		command.
		See |multi-lang|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:ctype}
@anchor{ctype-variable}
@vindex v:ctype
@cindex ctype-variable
@item v:ctype
文字に関する実行環境の現在のロケール設定。これを使えば Vim script 内で現在のロケール設定に対応できるようになる。技術的な詳細: LC_CTYPE に等しい。ロケールを使用していないときは "C" になる。この変数を設定するには |@ref{:language}| コマンドを使うこと。直接設定することはできない。|@ref{multi-lang}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:dying* *dying-variable*
v:dying		Normally zero.  When a deadly signal is caught it's set to
		one.  When multiple signals are caught the number increases.
		Can be used in an autocommand to check if Vim didn't
		terminate normally. {only works on Unix}
		Example: >
	:au VimLeave * if v:dying | echo "\nAAAAaaaarrrggghhhh!!!\n" | endif
<		Note: if another deadly signal is caught when v:dying is one,
		VimLeave autocommands will not be executed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:dying}
@anchor{dying-variable}
@vindex v:dying
@cindex dying-variable
@item v:dying
通常時は 0。致命的なシグナルを受信したとき 1 が代入される。複数のシグナルを受信すると値が増加していく。オートコマンド内で Vim が正常に終了するかチェックするために使える。@{Unix でのみ動作@}

例:
@example
:au VimLeave * if v:dying | echo "\nAAAAaaaarrrggghhhh!!!\n" | endif
@end example
@quotation
@strong{Note:} @*
v:dying が 1 のときに別の致命的なシグナルを受信した場合は VimLeave 自動コマンドは実行されない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:errmsg* *errmsg-variable*
v:errmsg	Last given error message.  It's allowed to set this variable.
		Example: >
	:let v:errmsg = ""
	:silent! next
	:if v:errmsg != ""
	:  ... handle error
<		"errmsg" also works, for backwards compatibility.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:errmsg}
@anchor{errmsg-variable}
@vindex v:errmsg
@cindex errmsg-variable
@item v:errmsg
最後に表示されたエラーメッセージ。この変数は代入することが許されている。例:
@example
:let errmsg = ""
:next
:if (errmsg != "")
:  ...
@end example
また "errmsg" は、以前の版の Vim との互換性の為に動作する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*v:errors* *errors-variable* *assert-return*
v:errors	Errors found by assert functions, such as |assert_true()|.
		This is a list of strings.
		The assert functions append an item when an assert fails.
		The return value indicates this: a one is returned if an item
		was added to v:errors, otherwise zero is returned.
		To remove old results make it empty: >
	:let v:errors = []
<		If v:errors is set to anything but a list it is made an empty
		list by the assert function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:errors}
@anchor{errors-variable}
@anchor{assert-return}
@vindex v:errors
@cindex errors-variable
@cindex assert-return
@item v:errors
|@ref{assert_true()}| のような、テスト用関数によって見つかったエラー。これは文字列のリストである。テスト用関数はテストに失敗した時にエラーを末尾に追加する。戻りり値は次のようになる。もしも項目が v:errors に加えられるなら 1 が返され、そうでなければ 0 が返される。古い結果を削除する方法はこの変数を空にする:
@example
:let v:errors = []
@end example
たとえ |@ref{v:errors}| にリスト以外のいかなる値をセットしたとしても、(次に実行される時に) テスト用関数によって空のリストが設定 (上書き) される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:event* *event-variable*
v:event		Dictionary containing information about the current
		|autocommand|.  The dictionary is emptied when the |autocommand|
		finishes, please refer to |dict-identity| for how to get an
		independent copy of it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:event}
@anchor{event-variable}
@vindex v:event
@cindex event-variable
@item v:event
現在の |@ref{autocommand}| についての情報を含んでいる辞書。|@ref{autocommand}| が終了すると辞書は空にされる。独立した辞書のコピーを取得するためには、どうか |@ref{dict-identity}| を参照してほしい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:exception* *exception-variable*
v:exception	The value of the exception most recently caught and not
		finished.  See also |v:throwpoint| and |throw-variables|.
		Example: >
	:try
	:  throw "oops"
	:catch /.*/
	:  echo "caught" v:exception
	:endtry
<		Output: "caught oops".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:exception}
@anchor{exception-variable}
@vindex v:exception
@cindex exception-variable
@item v:exception
最も直近に捕捉され、まだ終了していない例外の値。|@ref{v:throwpoint}| と |@ref{throw-variables}| を参照。例:
@example
:try
:  throw "oops"
:catch /.*/
:  echo "caught" v:exception
:endtry
@end example
出力: "caught oops".
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:false* *false-variable*
v:false		A Number with value zero. Used to put "false" in JSON.  See
		|json_encode()|.
		When used as a string this evaluates to "v:false". >
			echo v:false
<			v:false ~
		That is so that eval() can parse the string back to the same
		value.  Read-only.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:false}
@anchor{false-variable}
@vindex v:false
@cindex false-variable
@item v:false
数値 0。JSON では "false" として使われる。|@ref{json_encode()}| を参照。文字列として使われた時、これは "v:false" として評価される。
@example
echo v:false
v:false
@end example
これは eval() がその文字列をパースしたときに、元の値に戻せるようにするためである。読出し専用。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:fcs_reason* *fcs_reason-variable*
v:fcs_reason	The reason why the |FileChangedShell| event was triggered.
		Can be used in an autocommand to decide what to do and/or what
		to set v:fcs_choice to.  Possible values:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:fcs_reason}
@anchor{fcs_reason-variable}
@vindex v:fcs_reason
@cindex fcs_reason-variable
@item v:fcs_reason
|@ref{FileChangedShell}| イベントが発生した理由。オートコマンドの中で何をすべきかや v:fcs_choice に何を代入すべきかを決めるために使う。値は次のどれかとなる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			deleted		file no longer exists
			conflict	file contents, mode or timestamp was
					changed and buffer is modified
			changed		file contents has changed
			mode		mode of file changed
			time		only file timestamp changed
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item deleted @tab もはやファイルが存在しない
@item conflict @tab ファイルの内容、モード、タイムスタンプが変化しており、バッファが変更されている状態。
@item changed @tab ファイルの内容が変化している
@item mode @tab ファイルのモードが変化している
@item time @tab タイムスタンプだけが変化している
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:fcs_choice* *fcs_choice-variable*
v:fcs_choice	What should happen after a |FileChangedShell| event was
		triggered.  Can be used in an autocommand to tell Vim what to
		do with the affected buffer:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:fcs_choice}
@anchor{fcs_choice-variable}
@vindex v:fcs_choice
@cindex fcs_choice-variable
@item v:fcs_choice
|@ref{FileChangedShell}| イベントが発生した後に何をすべきかを表す。オートコマンドの中で、そのバッファに対して何をすべきかを指示するために使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			reload		Reload the buffer (does not work if
					the file was deleted).
			ask		Ask the user what to do, as if there
					was no autocommand.  Except that when
					only the timestamp changed nothing
					will happen.
			<empty>		Nothing, the autocommand should do
					everything that needs to be done.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item reload @tab バッファを読み直す (バッファが削除されている場合には効果がない)。
@item ask @tab 何をすべきかをユーザーに問い合わせる。これはこのオートコマンドがない場合と同じである。ただしタイムスタンプだけが変化しているときは何もしない。
@item <empty> @tab 何もしない。オートコマンドの中だけで必要なことは全て行ってしまっているという場合にこの値を代入する。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The default is empty.  If another (invalid) value is used then
		Vim behaves like it is empty, there is no warning message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
既定値は <empty>。これら以外の (無効な) 値が代入されたときは空のときと同じ動作になり、警告メッセージは表示されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:fname_in* *fname_in-variable*
v:fname_in	The name of the input file.  Valid while evaluating:
			option		used for ~
			'charconvert'	file to be converted
			'diffexpr'	original file
			'patchexpr'	original file
			'printexpr'	file to be printed
		And set to the swap file name for |SwapExists|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:fname_in}
@anchor{fname_in-variable}
@vindex v:fname_in
@cindex fname_in-variable
@item v:fname_in
入力ファイルの名前。以下のオプションを評価している最中のみ有効:
@multitable @columnfractions .3 .7
@headitem オプション @tab このファイル名の意味
@item '@option{charconvert}' @tab 変換するファイル
@item '@option{diffexpr}' @tab 元のファイル
@item '@option{patchexpr}' @tab 元のファイル
@item '@option{printexpr}' @tab 印刷するファイル
@end multitable
また、オートコマンドイベント |@ref{SwapExists}| が発生したときスワップファイル名が代入される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:fname_out* *fname_out-variable*
v:fname_out	The name of the output file.  Only valid while
		evaluating:
			option		used for ~
			'charconvert'	resulting converted file (*)
			'diffexpr'	output of diff
			'patchexpr'	resulting patched file
		(*) When doing conversion for a write command (e.g., ":w
		file") it will be equal to v:fname_in.  When doing conversion
		for a read command (e.g., ":e file") it will be a temporary
		file and different from v:fname_in.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:fname_out}
@anchor{fname_out-variable}
@vindex v:fname_out
@cindex fname_out-variable
@item v:fname_out
出力ファイルの名前。以下のオプションを評価している最中のみ有効:
@multitable @columnfractions .3 .7
@headitem オプション @tab このファイル名の意味
@item '@option{charconvert}' @tab 変換した結果のファイル (*)
@item '@option{diffexpr}' @tab diff の出力
@item '@option{patchexpr}' @tab パッチを当てた結果のファイル
@end multitable
(*) 書き込みコマンド ("@command{:w file}" など) を実行する際の変換では v:fname_in と同じになる。読み込みコマンド ("@command{:e file}" など) を実行する際の変換では一時ファイル名になり、v:fname_in と異なる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:fname_new* *fname_new-variable*
v:fname_new	The name of the new version of the file.  Only valid while
		evaluating 'diffexpr'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:fname_new}
@anchor{fname_new-variable}
@vindex v:fname_new
@cindex fname_new-variable
@item v:fname_new
新しい方のファイル名。'@option{diffexpr}' を評価している最中のみ有効。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:fname_diff* *fname_diff-variable*
v:fname_diff	The name of the diff (patch) file.  Only valid while
		evaluating 'patchexpr'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:fname_diff}
@anchor{fname_diff-variable}
@vindex v:fname_diff
@cindex fname_diff-variable
@item v:fname_diff
diff(patch) ファイルの名前。'@option{patchexpr}' を評価している最中のみ有効。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:folddashes* *folddashes-variable*
v:folddashes	Used for 'foldtext': dashes representing foldlevel of a closed
		fold.
		Read-only in the |sandbox|. |fold-foldtext|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:folddashes}
@anchor{folddashes-variable}
@vindex v:folddashes
@cindex folddashes-variable
@item v:folddashes
'@option{foldtext}' 用。閉じた折り畳みのレベルを表すダッシュ。サンドボックス |@ref{sandbox}| の中では読出し専用。|@ref{fold-foldtext}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:foldlevel* *foldlevel-variable*
v:foldlevel	Used for 'foldtext': foldlevel of closed fold.
		Read-only in the |sandbox|. |fold-foldtext|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:foldlevel}
@anchor{foldlevel-variable}
@vindex v:foldlevel
@cindex foldlevel-variable
@item v:foldlevel
'@option{foldtext}' 用。閉じた折り畳みのレベル。サンドボックス |@ref{sandbox}| の中では読出し専用。|@ref{fold-foldtext}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:foldend* *foldend-variable*
v:foldend	Used for 'foldtext': last line of closed fold.
		Read-only in the |sandbox|. |fold-foldtext|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:foldend}
@anchor{foldend-variable}
@vindex v:foldend
@cindex foldend-variable
@item v:foldend
'@option{foldtext}' 用。閉じた折り畳みの最後の行。サンドボックス |@ref{sandbox}| の中では読出し専用。|@ref{fold-foldtext}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:foldstart* *foldstart-variable*
v:foldstart	Used for 'foldtext': first line of closed fold.
		Read-only in the |sandbox|. |fold-foldtext|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:foldstart}
@anchor{foldstart-variable}
@vindex v:foldstart
@cindex foldstart-variable
@item v:foldstart
'@option{foldtext}' 用。閉じた折り畳みの最初の行。サンドボックス |@ref{sandbox}| の中では読出し専用。|@ref{fold-foldtext}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:hlsearch* *hlsearch-variable*
v:hlsearch	Variable that indicates whether search highlighting is on.
		Setting it makes sense only if 'hlsearch' is enabled which
		requires |+extra_search|. Setting this variable to zero acts
		like the |:nohlsearch| command, setting it to one acts like >
			let &hlsearch = &hlsearch
<		Note that the value is restored when returning from a
		function. |function-search-undo|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:hlsearch}
@anchor{hlsearch-variable}
@vindex v:hlsearch
@cindex hlsearch-variable
@item v:hlsearch
検索による強調表示がオンになっているかどうかを示す変数。設定は |@ref{+extra_search}| 機能が必要な '@option{hlsearch}' が有効になっている時のみ意味をなす。この変数を 0 に設定することは、|@ref{:nohlsearch}| コマンドを実行することと同様に働き、1 に設定することは以下と同様に働く
@example
let &hlsearch = &hlsearch
@end example                
@quotation
@strong{Note:} @*
関数から戻ったときに値が復元されることに注意すること。|@ref{function-search-undo}|
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:insertmode* *insertmode-variable*
v:insertmode	Used for the |InsertEnter| and |InsertChange| autocommand
		events.  Values:
			i	Insert mode
			r	Replace mode
			v	Virtual Replace mode
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:insertmode}
@anchor{insertmode-variable}
@vindex v:insertmode
@cindex insertmode-variable
@item v:insertmode
オートコマンドイベント |@ref{InsertEnter}| と |@ref{InsertChange}| 用。値は次のどれか:
@multitable @columnfractions .2 .8
@item i @tab 挿入モード
@item r @tab 置換モード
@item v @tab 仮想置換モード
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*v:key* *key-variable*
v:key		Key of the current item of a |Dictionary|.  Only valid while
		evaluating the expression used with |map()| and |filter()|.
		Read-only.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:key}
@anchor{key-variable}
@vindex v:key
@cindex key-variable
@item v:key
辞書 |@ref{Dictionary}| の現在の要素のキー。|@ref{map()}| と |@ref{filter()}| で使われる式を評価している最中のみ有効。読出し専用。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*v:lang* *lang-variable*
v:lang		The current locale setting for messages of the runtime
		environment.  This allows Vim scripts to be aware of the
		current language.  Technical: it's the value of LC_MESSAGES.
		The value is system dependent.
		This variable can not be set directly, use the |:language|
		command.
		It can be different from |v:ctype| when messages are desired
		in a different language than what is used for character
		encoding.  See |multi-lang|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:lang}
@anchor{lang-variable}
@vindex v:lang
@cindex lang-variable
@item v:lang
メッセージに関する実行環境の現在のロケール設定。これを使えば Vim script 内で現在のロケール設定に対応できるようになる。技術的な詳細: LC_MESSAGES に等しい。この値はシステムに依存する。この変数を設定するには |@ref{:language}| コマンドを使うこと。直接設定することはできない。

文字エンコーディングに使うのと違う言語でメッセージを表示させたい場合は |@ref{v:ctype}| と異なる値でもよい。|@ref{multi-lang}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*v:lc_time* *lc_time-variable*
v:lc_time	The current locale setting for time messages of the runtime
		environment.  This allows Vim scripts to be aware of the
		current language.  Technical: it's the value of LC_TIME.
		This variable can not be set directly, use the |:language|
		command.  See |multi-lang|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:lc_time}
@anchor{lc_time-variable}
@vindex v:lc_time
@cindex lc_time-variable
@item v:lc_time
時刻のメッセージに関する実行環境の現在のロケール設定。これを使えば Vim script 内で現在のロケール設定に対応できるようになる。技術的な詳細: LC_TIME に等しい。この値はシステムに依存する。この変数を設定するには |@ref{:language}| コマンドを使うこと。直接設定することはできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*v:lnum* *lnum-variable*
v:lnum		Line number for the 'foldexpr' |fold-expr|, 'formatexpr' and
		'indentexpr' expressions, tab page number for 'guitablabel'
		and 'guitabtooltip'.  Only valid while one of these
		expressions is being evaluated.  Read-only when in the
		|sandbox|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:lnum}
@anchor{lnum-variable}
@vindex v:lnum
@cindex lnum-variable
@item v:lnum
'@option{foldexpr}' |@ref{fold-expr}| と '@option{indentexpr}' に使うための行番号。また '@option{guitablabel}' と '@option{guitabtooltip}' の文脈ではタブページ番号になる。これらの式のどれかを評価しているときのみ有効。サンドボックス |@ref{sandbox}| の中では読出し専用。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:mouse_win* *mouse_win-variable*
v:mouse_win	Window number for a mouse click obtained with |getchar()|.
		First window has number 1, like with |winnr()|.  The value is
		zero when there was no mouse button click.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:mouse_win}
@anchor{mouse_win-variable}
@vindex v:mouse_win
@cindex mouse_win-variable
@item v:mouse_win
|@ref{getchar()}| でマウスクリックイベントが発生したときのウィンドウ番号。|@ref{winnr()}| と同じく番号は 1 から始まる。マウスがクリックされなかったときは 0 となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:mouse_winid* *mouse_winid-variable*
v:mouse_winid	Window ID for a mouse click obtained with |getchar()|.
		The value is zero when there was no mouse button click.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:mouse_winid}
@anchor{mouse_winid-variable}
@vindex v:mouse_winid
@cindex mouse_winid-variable
@item v:mouse_winid
|@ref{getchar()}| でマウスクリックイベントが発生したときのウィンドウ ID。マウスがクリックされていないときは 0 になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:mouse_lnum* *mouse_lnum-variable*
v:mouse_lnum	Line number for a mouse click obtained with |getchar()|.
		This is the text line number, not the screen line number.  The
		value is zero when there was no mouse button click.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:mouse_lnum}
@anchor{mouse_lnum-variable}
@vindex v:mouse_lnum
@cindex mouse_lnum-variable
@item v:mouse_lnum
|@ref{getchar()}| でマウスクリックイベントが発生したときの行番号。物理行ではなく論理行。マウスがクリックされていないときは 0 となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:mouse_col* *mouse_col-variable*
v:mouse_col	Column number for a mouse click obtained with |getchar()|.
		This is the screen column number, like with |virtcol()|.  The
		value is zero when there was no mouse button click.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:mouse_col}
@anchor{mouse_col-variable}
@vindex v:mouse_col
@cindex mouse_col-variable
@item v:mouse_col
|@ref{getchar()}| でマウスクリックイベントが発生したときの桁番号。|@ref{virtcol()}| と同じく画面上の桁番号。マウスがクリックされていないときは 0 となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:none* *none-variable*
v:none		An empty String. Used to put an empty item in JSON.  See
		|json_encode()|.
		When used as a number this evaluates to zero.
		When used as a string this evaluates to "v:none". >
			echo v:none
<			v:none ~
		That is so that eval() can parse the string back to the same
		value.  Read-only.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:none}
@anchor{none-variable}
@vindex v:none
@cindex none-variable
@item v:none
空の文字列。JSON では空の要素として使われる。|@ref{json_encode()}| を参照。数値として使われた時、これは 0 として評価される。文字列として使われた時、これは "v:none" として評価される。
@example
echo v:none
v:none
@end example
これは eval() がその文字列をパースしたときに、元の値に戻せるようにするためである。読出し専用。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:null* *null-variable*
v:null		An empty String. Used to put "null" in JSON.  See
		|json_encode()|.
		When used as a number this evaluates to zero.
		When used as a string this evaluates to "v:null". >
			echo v:null
<			v:null ~
		That is so that eval() can parse the string back to the same
		value.  Read-only.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:null}
@anchor{null-variable}
@vindex v:null
@cindex null-variable
@item v:null
空の文字列。JSON では "null" として使われる。|@ref{json_encode()}| を参照。数値として使われた時、これは 0 として評価される。文字列として使われた時、これは "v:null" として評価される。
@example
echo v:null
v:null
@end example
これは eval() がその文字列をパースしたときに、元の値に戻せるようにするためである。読出し専用。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:oldfiles* *oldfiles-variable*
v:oldfiles	List of file names that is loaded from the |viminfo| file on
		startup.  These are the files that Vim remembers marks for.
		The length of the List is limited by the ' argument of the
		'viminfo' option (default is 100).
		When the |viminfo| file is not used the List is empty.
		Also see |:oldfiles| and |c_#<|.
		The List can be modified, but this has no effect on what is
		stored in the |viminfo| file later.  If you use values other
		than String this will cause trouble.
		{only when compiled with the |+viminfo| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:oldfiles}
@anchor{oldfiles-variable}
@vindex v:oldfiles
@cindex oldfiles-variable
@item v:oldfiles
起動時に |@ref{viminfo}| から読み込まれたファイルの名前のリスト。これらはマークを記憶しているファイルである。リストの長さの上限はオプション '@option{viminfo}' の引数 ' によって決まる (既定では 100)。|@ref{viminfo}| ファイルが使われていない時、リストは空となる。|@ref{:oldfiles}| と |@ref{c_#<}| を参照。このリストは変更可能であるが、後で |@ref{viminfo}| ファイルに書き込まれるものには影響しない。文字列以外の値を使うと問題を引き起こすだろう。

@{|@ref{+viminfo}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						    *v:option_new*
v:option_new    New value of the option. Valid while executing an |OptionSet|
		autocommand.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:option_new}
@vindex v:option_new
@item v:option_new
オプションに設定された新しい値。自動コマンド |@ref{OptionSet}| を実行している間のみ有効。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						    *v:option_old*
v:option_old    Old value of the option. Valid while executing an |OptionSet|
		autocommand.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:option_old}
@vindex v:option_old
@item v:option_old
オプションの以前の値。自動コマンド |@ref{OptionSet}| を実行している間のみ有効。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						    *v:option_type*
v:option_type   Scope of the set command. Valid while executing an
		|OptionSet| autocommand. Can be either "global" or "local"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:option_type}
@vindex v:option_type
@item v:option_type
set コマンドのスコープ。自動コマンド |@ref{OptionSet}| を実行している間のみ有効。"global" もしくは "local" のどちらかとなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*v:operator* *operator-variable*
v:operator	The last operator given in Normal mode.  This is a single
		character except for commands starting with <g> or <z>,
		in which case it is two characters.  Best used alongside
		|v:prevcount| and |v:register|.  Useful if you want to cancel
		Operator-pending mode and then use the operator, e.g.: >
			:omap O <Esc>:call MyMotion(v:operator)<CR>
<		The value remains set until another operator is entered, thus
		don't expect it to be empty.
		v:operator is not set for |:delete|, |:yank| or other Ex
		commands.
		Read-only.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:operator}
@anchor{operator-variable}
@vindex v:operator
@cindex operator-variable
@item v:operator
ノーマルモードにおいて最後に実行したオペレータコマンド。基本的に 1 文字である。例外は <g> や <z> で始まるコマンドで、その場合は2文字になる。|@ref{v:prevcount}| と |@ref{v:register}| と組み合わせて使うとよい。オペレータ待機モードをキャンセルして、それからオペレータを使いたいときに便利である。例:
@example
:omap O <Esc>:call MyMotion(v:operator)<CR>
@end example
この値は他のオペレータが入力されるまでセットされている。よって空になると期待してはいけない。|@ref{:delete}|, |@ref{:yank}| などの Ex コマンドに対しては v:operator はセットされない。

読出し専用。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:prevcount* *prevcount-variable*
v:prevcount	The count given for the last but one Normal mode command.
		This is the v:count value of the previous command.  Useful if
		you want to cancel Visual or Operator-pending mode and then
		use the count, e.g.: >
			:vmap % <Esc>:call MyFilter(v:prevcount)<CR>
<		Read-only.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:prevcount}
@anchor{prevcount-variable}
@vindex v:prevcount
@cindex prevcount-variable
@item v:prevcount
最後の 1 つ前のノーマルモードコマンドに与えられたカウントの値。前のコマンドの v:count の値である。ビジュアルモードやオペレータ待機モードをキャンセルし、その後にカウントを使う場合に便利である。例:
@example
:vmap % <Esc>:call MyFilter(v:prevcount)<CR>
@end example
読出し専用。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:profiling* *profiling-variable*
v:profiling	Normally zero.  Set to one after using ":profile start".
		See |profiling|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:profiling}
@anchor{profiling-variable}
@vindex v:profiling
@cindex profiling-variable
@item v:profiling
通常時は 0。":profile start" を実行すると1が代入される。|@ref{profiling}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:progname* *progname-variable*
v:progname	Contains the name (with path removed) with which Vim was
		invoked.  Allows you to do special initialisations for |view|,
		|evim| etc., or any other name you might symlink to Vim.
		Read-only.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:progname}
@anchor{progname-variable}
@vindex v:progname
@cindex progname-variable
@item v:progname
Vim を起動したときのプログラム名(パスは除かれる)。|@ref{view}|, |@ref{evim}| などの名前やシンボリックリンクなどで起動した場合に特別な初期化を行うのに便利。

読出し専用。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:progpath* *progpath-variable*
v:progpath	Contains the command with which Vim was invoked, including the
		path.  Useful if you want to message a Vim server using a
		|--remote-expr|.
		To get the full path use: >
			echo exepath(v:progpath)
<		If the path is relative it will be expanded to the full path,
		so that it still works after `:cd`. Thus starting "./vim"
		results in "/home/user/path/to/vim/src/vim".
		On MS-Windows the executable may be called "vim.exe", but the
		".exe" is not added to v:progpath.
		Read-only.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:progpath}
@anchor{progpath-variable}
@vindex v:progpath
@cindex progpath-variable
@item v:progpath
Vim を起動したときのコマンド (パスを含む)。|@ref{--remote-expr}| で Vim サーバーにメッセージを送信するときに便利。フルパスを得るには:
@example
echo exepath(v:progpath)
@end example
パスが相対の場合、フルパスに展開され、これにより `:cd` 後でも機能する。例えば "./vim" で開始すると "/home/user/path/to/vim/src/vim" という結果になる。MS-Windows では実行ファイルが "vim.exe" として呼び出されるかもしれないが、".exe" は v:progpath には追加されない。

読出し専用。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:register* *register-variable*
v:register	The name of the register in effect for the current normal mode
		command (regardless of whether that command actually used a
		register).  Or for the currently executing normal mode mapping
		(use this in custom commands that take a register).
		If none is supplied it is the default register '"', unless
		'clipboard' contains "unnamed" or "unnamedplus", then it is
		'*' or '+'.
		Also see |getreg()| and |setreg()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:register}
@anchor{register-variable}
@vindex v:register
@cindex register-variable
@item v:register
現在のノーマルモードコマンドに適用されるレジスタの名前 (そのコマンドが実際にレジスタを使うかどうかには依らない)。または、現在実行しているノーマルモードマッピング用のレジスタの名前 (レジスタを使うカスタムコマンドの中で使う)。レジスタが指定されなかったときはデフォルトレジスタ '"' になる。'@option{clipboard}' に "unnamed" か "unnamedplus" が含まれているときはデフォルトはそれぞれ '*' か '+' になる。|@ref{getreg()}| と |@ref{setreg()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:scrollstart* *scrollstart-variable*
v:scrollstart	String describing the script or function that caused the
		screen to scroll up.  It's only set when it is empty, thus the
		first reason is remembered.  It is set to "Unknown" for a
		typed command.
		This can be used to find out why your script causes the
		hit-enter prompt.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:scrollstart}
@anchor{scrollstart-variable}
@vindex v:scrollstart
@cindex scrollstart-variable
@item v:scrollstart
画面のスクロールの原因となったスクリプトや関数を説明する文字列。空であるときのみ代入される。よってこの変数には最初の原因だけが記録されている。原因がキーボードから入力されたコマンドの場合は "Unknown" が代入される。スクリプトを実行したとき現れた hit-enter プロンプトの原因を探るために便利。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:servername* *servername-variable*
v:servername	The resulting registered |client-server-name| if any.
		Read-only.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:servername}
@anchor{servername-variable}
@vindex v:servername
@cindex servername-variable
@item v:servername
|@ref{client-server-name}| に登録されている名前。

読出し専用。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
v:searchforward			*v:searchforward* *searchforward-variable*
		Search direction:  1 after a forward search, 0 after a
		backward search.  It is reset to forward when directly setting
		the last search pattern, see |quote/|.
		Note that the value is restored when returning from a
		function. |function-search-undo|.
		Read-write.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:searchforward}
@anchor{searchforward-variable}
@vindex v:searchforward
@cindex searchforward-variable
@item v:searchforward
検索方向: 前方検索の後なら 1、後方検索の後なら 0。|@ref{quote/}| で示す方法によって最終検索パターンを直接セットしたときは 1 (前方検索) にリセットされる。関数から戻るとき、この値は呼び出し前の値に復元される。|@ref{function-search-undo}|。

読み書き両用。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:shell_error* *shell_error-variable*
v:shell_error	Result of the last shell command.  When non-zero, the last
		shell command had an error.  When zero, there was no problem.
		This only works when the shell returns the error code to Vim.
		The value -1 is often used when the command could not be
		executed.  Read-only.
		Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:shell_error}
@anchor{shell_error-variable}
@vindex v:shell_error
@cindex shell_error-variable
@item v:shell_error
最後に実行したシェルコマンドの結果。シェルコマンドの実行時に何かエラーがあったならば、非零の値を取る。問題がなければ零になる。これはシェルがエラーコードを Vim に通知する時のみ働く。コマンドが実行されなかった時には、値として -1 が良く使われる。読出し専用。

例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:!mv foo bar
	:if v:shell_error
	:  echo 'could not rename "foo" to "bar"!'
	:endif
<		"shell_error" also works, for backwards compatibility.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:!mv foo bar
:if v:shell_error
:  echo 'could not rename "foo" to "bar"!'
:endif
@end example
また "shell_error" は、以前の版の Vim との互換性の為に動作する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:statusmsg* *statusmsg-variable*
v:statusmsg	Last given status message.  It's allowed to set this variable.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:statusmsg}
@anchor{statusmsg-variable}
@vindex v:statusmsg
@cindex statusmsg-variable
@item v:statusmsg
最後に表示されたステータスメッセージ。この変数は代入することが許されている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:swapname* *swapname-variable*
v:swapname	Only valid when executing |SwapExists| autocommands: Name of
		the swap file found.  Read-only.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:swapname}
@anchor{swapname-variable}
@vindex v:swapname
@cindex swapname-variable
@item v:swapname
オートコマンド |@ref{SwapExists}| を実行している最中のみ有効。見つかったスワップファイルの名前。読出し専用。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:swapchoice* *swapchoice-variable*
v:swapchoice	|SwapExists| autocommands can set this to the selected choice
		for handling an existing swap file:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:swapchoice}
@anchor{swapchoice-variable}
@vindex v:swapchoice
@cindex swapchoice-variable
@item v:swapchoice
イベント |@ref{SwapExists}| により実行されたオートコマンドが、見つかったスワップファイルをどう処理するかをこの変数に代入する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			'o'	Open read-only
			'e'	Edit anyway
			'r'	Recover
			'd'	Delete swapfile
			'q'	Quit
			'a'	Abort
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item 'o' @tab 読込専用で開く
@item 'e' @tab とにかく編集する
@item 'r' @tab 復活させる
@item 'd' @tab スワップファイルを削除する
@item 'q' @tab 終了する
@item 'a' @tab 中止する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The value should be a single-character string.  An empty value
		results in the user being asked, as would happen when there is
		no SwapExists autocommand.  The default is empty.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この変数の値は 1 文字の文字列でなければならない。値が空のときはオートコマンド SwapExists が存在しないときと同じようにユーザーに問い合わせる。既定値は空。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:swapcommand* *swapcommand-variable*
v:swapcommand	Normal mode command to be executed after a file has been
		opened.  Can be used for a |SwapExists| autocommand to have
		another Vim open the file and jump to the right place.  For
		example, when jumping to a tag the value is ":tag tagname\r".
		For ":edit +cmd file" the value is ":cmd\r".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:swapcommand}
@anchor{swapcommand-variable}
@vindex v:swapcommand
@cindex swapcommand-variable
@item v:swapcommand
ファイルを開いた後に実行するノーマルモードコマンド。オートコマンド |@ref{SwapExists}| で、他の Vim インスタンスにファイルを開かせ、指定位置までジャンプするために使うことができる。例えば、あるタグへジャンプするには、この変数に ":tag tagname\r" という値を代入する。":edit +cmd file" を実行させるには ":cmd\r" を代入する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*v:t_TYPE* *v:t_bool* *t_bool-variable*
v:t_bool	Value of Boolean type.  Read-only.  See: |type()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:t_TYPE}
@anchor{v:t_bool}
@anchor{t_bool-variable}
@cindex v:t_TYPE
@vindex v:t_bool
@cindex t_bool-variable
@item v:t_bool
真偽値型の値。読出し専用。参照: |@ref{type()}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*v:t_channel* *t_channel-variable*
v:t_channel	Value of Channel type.  Read-only.  See: |type()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:t_channel}
@anchor{t_channel-variable}
@vindex v:t_channel
@cindex t_channel-variable
@item v:t_channel
チャネル型の値。読出し専用。参照: |@ref{type()}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*v:t_dict* *t_dict-variable*
v:t_dict	Value of Dictionary type.  Read-only.  See: |type()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:t_dict}
@anchor{t_dict-variable}
@vindex v:t_dict
@cindex t_dict-variable
@item v:t_dict
辞書型の値。読出し専用。参照: |@ref{type()}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*v:t_float* *t_float-variable*
v:t_float	Value of Float type.  Read-only.  See: |type()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:t_float}
@anchor{t_float-variable}
@vindex v:t_float
@cindex t_float-variable
@item v:t_float
浮動小数点数型の値。読出し専用。参照: |@ref{type()}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*v:t_func* *t_func-variable*
v:t_func	Value of Funcref type.  Read-only.  See: |type()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:t_func}
@anchor{t_func-variable}
@vindex v:t_func
@cindex t_func-variable
@item v:t_func
Funcref 型の値。読出し専用。参照: |@ref{type()}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*v:t_job* *t_job-variable*
v:t_job		Value of Job type.  Read-only.  See: |type()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:t_job}
@anchor{t_job-variable}
@vindex v:t_job
@cindex t_job-variable
@item v:t_job
ジョブ型の値。読出し専用。参照: |@ref{type()}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*v:t_list* *t_list-variable*
v:t_list	Value of List type.  Read-only.  See: |type()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:t_list}
@anchor{t_list-variable}
@vindex v:t_list
@cindex t_list-variable
@item v:t_list
リスト型の値。読出し専用。参照: |@ref{type()}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*v:t_none* *t_none-variable*
v:t_none	Value of None type.  Read-only.  See: |type()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:t_none}
@anchor{t_none-variable}
@vindex v:t_none
@cindex t_none-variable
@item v:t_none
特殊値型の値。読出し専用。参照: |@ref{type()}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*v:t_number* *t_number-variable*
v:t_number	Value of Number type.  Read-only.  See: |type()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:t_number}
@anchor{t_number-variable}
@vindex v:t_number
@cindex t_number-variable
@item v:t_number
数値型の値。読出し専用。参照: |@ref{type()}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*v:t_string* *t_string-variable*
v:t_string	Value of String type.  Read-only.  See: |type()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:t_string}
@anchor{t_string-variable}
@vindex v:t_string
@cindex t_string-variable
@item v:t_string
文字列型の値。読出し専用。参照: |@ref{type()}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*v:termresponse* *termresponse-variable*
v:termresponse	The escape sequence returned by the terminal for the |t_RV|
		termcap entry.  It is set when Vim receives an escape sequence
		that starts with ESC [ or CSI and ends in a 'c', with only
		digits, ';' and '.' in between.
		When this option is set, the TermResponse autocommand event is
		fired, so that you can react to the response from the
		terminal.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:termresponse}
@anchor{termresponse-variable}
@vindex v:termresponse
@cindex termresponse-variable
@item v:termresponse
termcap のエントリ |@ref{t_RV}| で端末から返されるエスケープシーケンス。ESC [ または CSI で始まり、途中数字と ';' と '.' だけから構成され 'c' で終わるエスケープシーケンスを受け取ったとき代入される。このオプションがセットされるとオートコマンドイベント TermResponse が発生し、端末からの応答に反応することができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The response from a new xterm is: "<Esc>[ Pp ; Pv ; Pc c".  Pp
		is the terminal type: 0 for vt100 and 1 for vt220.  Pv is the
		patch level (since this was introduced in patch 95, it's
		always 95 or bigger).  Pc is always zero.
		{only when compiled with |+termresponse| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しい xterm からの応答は次の形式である: "<Esc>[ Pp ; Pv ; Pc c"。ここで Pp は端末のタイプ: 0 なら vt100、1 なら vt220。Pv はパッチレベル (パッチ 95 で導入されたため常に 95 以上)。Pc は常に 0。

@{Vimが |@ref{+termresponse}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*v:termblinkresp*
v:termblinkresp	The escape sequence returned by the terminal for the |t_RC|
		termcap entry.  This is used to find out whether the terminal
		cursor is blinking. This is used by |term_getcursor()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:termblinkresp}
@vindex v:termblinkresp
@item v:termblinkresp
termcap のエントリ |@ref{t_RC}| へのターミナルによって返されるエスケープシーケンス。ターミナルのカーソルが点滅しているかどうかを知るのに使われる。これは |@ref{term_getcursor()}| にも使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*v:termstyleresp*
v:termstyleresp	The escape sequence returned by the terminal for the |t_RS|
		termcap entry.  This is used to find out what the shape of the
		cursor is.  This is used by |term_getcursor()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:termstyleresp}
@vindex v:termstyleresp
@item v:termstyleresp
termcap のエントリ |@ref{t_RS}| へのターミナルによって返されるエスケープシーケンス。カーソルの形が何であるのかを知るのに使われる。これは |@ref{term_getcursor()}| にも使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*v:termrbgresp*
v:termrbgresp	The escape sequence returned by the terminal for the |t_RB|
		termcap entry.  This is used to find out what the terminal
		background color is, see 'background'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:termrbgresp}
@vindex v:termrbgresp
@item v:termrbgresp
termcap のエントリ |@ref{t_RB}| へのターミナルによって返されるエスケープシーケンス。ターミナルの背景色が何であるのかを知るのに使われる。'@option{background}' を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*v:termrfgresp*
v:termrfgresp	The escape sequence returned by the terminal for the |t_RF|
		termcap entry.  This is used to find out what the terminal
		foreground color is.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:termrfgresp}
@vindex v:termrfgresp
@item v:termrfgresp
termcap のエントリ |@ref{t_RF}| へのターミナルによって返されるエスケープシーケンス。ターミナルの前景色が何であるのかを知るのに使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*v:termu7resp*
v:termu7resp	The escape sequence returned by the terminal for the |t_u7|
		termcap entry.  This is used to find out what the terminal
		does with ambiguous width characters, see 'ambiwidth'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:termu7resp}
@vindex v:termu7resp
@item v:termu7resp
termcap のエントリ |@ref{t_u7}| へのターミナルによって返されるエスケープシーケンス。ターミナルが曖昧幅文字をどのように扱うのかを知るのに使われる。'@option{ambiwidth}' を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:testing* *testing-variable*
v:testing	Must be set before using `test_garbagecollect_now()`.
		Also, when set certain error messages won't be shown for 2
		seconds. (e.g. "'dictionary' option is empty")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:testing}
@anchor{testing-variable}
@vindex v:testing
@cindex testing-variable
@item v:testing
`test_garbagecollect_now()` を使う前に設定する必要がある。また、これが設定されていると、特定のエラーメッセージが 2 秒間表示されなくなる。(例: "'dictionary' option is empty")
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*v:this_session* *this_session-variable*
v:this_session	Full filename of the last loaded or saved session file.  See
		|:mksession|.  It is allowed to set this variable.  When no
		session file has been saved, this variable is empty.
		"this_session" also works, for backwards compatibility.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:this_session}
@anchor{this_session-variable}
@vindex v:this_session
@cindex this_session-variable
@item v:this_session
最後にロードされたか、セーブされたセッションファイルの完全なファイル名。|@ref{:mksession}| を参照。この変数は代入することが許されている。それ以前にセーブされたセッションがなければ、この変数は空となる。また "this_session" は、以前の版の Vim との互換性の為に動作する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:throwpoint* *throwpoint-variable*
v:throwpoint	The point where the exception most recently caught and not
		finished was thrown.  Not set when commands are typed.  See
		also |v:exception| and |throw-variables|.
		Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:throwpoint}
@anchor{throwpoint-variable}
@vindex v:throwpoint
@cindex throwpoint-variable
@item v:throwpoint
最も直近に捕捉されてまだ終了していない例外が発生した位置。キーボードから入力されたコマンドは記録されていない。|@ref{v:exception}| と |@ref{throw-variables}| も参照。

例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:try
	:  throw "oops"
	:catch /.*/
	:  echo "Exception from" v:throwpoint
	:endtry
<		Output: "Exception from test.vim, line 2"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:try
:  throw "oops"
:catch /.*/
:  echo "Exception from" v:throwpoint
:endtry
@end example
出力: "Exception from test.vim, line 2"
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*v:true* *true-variable*
v:true		A Number with value one. Used to put "true" in JSON.  See
		|json_encode()|.
		When used as a string this evaluates to "v:true". >
			echo v:true
<			v:true ~
		That is so that eval() can parse the string back to the same
		value.  Read-only.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:true}
@anchor{true-variable}
@vindex v:true
@cindex true-variable
@item v:true
数値 1。JSON では "true" として使われる。|@ref{json_encode()}| を参照。文字列として使われた時、これは "v:true" として評価される。
@example
echo v:true
v:true ~
@end example
これは eval() がその文字列をパースしたときに、元の値に戻せるようにするためである。読出し専用。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*v:val* *val-variable*
v:val		Value of the current item of a |List| or |Dictionary|.  Only
		valid while evaluating the expression used with |map()| and
		|filter()|.  Read-only.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:val}
@anchor{val-variable}
@vindex v:val
@cindex val-variable
@item v:val
リスト |@ref{List}| や辞書 |@ref{Dictionary}| の現在の要素の値。|@ref{map()}| と |@ref{filter()}| で使われる式を評価している最中のみ有効。読出し専用。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:version* *version-variable*
v:version	Version number of Vim: Major version number times 100 plus
		minor version number.  Version 5.0 is 500.  Version 5.1 (5.01)
		is 501.  Read-only.  "version" also works, for backwards
		compatibility.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:version}
@anchor{version-variable}
@vindex v:version
@cindex version-variable
@item v:version
Vim のバージョン番号。メジャーバージョン番号は100倍され、マイナーバージョン番号と足されている。Version 5.0 は 500。Version 5.1 (5.01) は 501 となる。読出し専用。また "version" は、以前の版の Vim との互換性の為に動作する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Use |has()| to check if a certain patch was included, e.g.: >
			if has("patch-7.4.123")
<		Note that patch numbers are specific to the version, thus both
		version 5.0 and 5.1 may have a patch 123, but these are
		completely different.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
特定のパッチが適用されているかを調べるには |@ref{has()}| を使う。例:
@example
if has("patch-7.4.123")
@end example
@quotation
@strong{Note:} @*
5.0 と 5.1 には両方ともパッチ 123 が存在しているが、バージョンが違えば番号は同じでもパッチの内容は全く異なっている。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*v:vim_did_enter* *vim_did_enter-variable*
v:vim_did_enter	Zero until most of startup is done.  It is set to one just
		before |VimEnter| autocommands are triggered.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:vim_did_enter}
@anchor{vim_did_enter-variable}
@vindex v:vim_did_enter
@cindex vim_did_enter-variable
@item v:vim_did_enter
ほとんどのスタートアップが完了するまでの間 0。|@ref{VimEnter}| 自動コマンドが実行される直前に 1 にセットされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:warningmsg* *warningmsg-variable*
v:warningmsg	Last given warning message.  It's allowed to set this variable.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:warningmsg}
@anchor{warningmsg-variable}
@vindex v:warningmsg
@cindex warningmsg-variable
@item v:warningmsg
最後に表示された警告メッセージ。この変数は代入することが許されている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*v:windowid* *windowid-variable*
v:windowid	When any X11 based GUI is running or when running in a
		terminal and Vim connects to the X server (|-X|) this will be
		set to the window ID.
		When an MS-Windows GUI is running this will be set to the
		window handle.
		Otherwise the value is zero.
		Note: for windows inside Vim use |winnr()| or |win_getid()|,
		see |window-ID|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v:windowid}
@anchor{windowid-variable}
@vindex v:windowid
@cindex windowid-variable
@item v:windowid
X11 ベースの GUI を使っているとき、もしくは端末の Vim を使っていて X サーバーに接続しているとき (|@ref{-X}|) は、ウィンドウ ID がセットされる。MS-Windows の GUI を使っているときはウィンドウハンドルがセットされる。それ以外では値はゼロである。
@quotation
@strong{Note:} @*
Vim の中のウィンドウを扱うときは |@ref{winnr()}| または |@ref{win_getid()}| を使う。|@ref{window-ID}| を参照。
@end quotation
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
4. Builtin Functions					*functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{functions}
@cindex functions
@cindex 組み込み関数
@section 4. 組み込み関数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
See |function-list| for a list grouped by what the function is used for.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
機能別に分類された一覧は |@ref{function-list}| を参照のこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
(Use CTRL-] on the function name to jump to the full explanation.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
(関数名の上で @kbd{CTRL-]} を使うことで、詳細な説明へ飛ぶことができる。)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
USAGE				RESULT	DESCRIPTION	~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .2 .4
@headitem 使用法 @tab 結果 @tab 説明
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
abs({expr})			Float or Number  absolute value of {expr}
acos({expr})			Float	arc cosine of {expr}
add({list}, {item})		List	append {item} to |List| {list}
and({expr}, {expr})		Number	bitwise AND
append({lnum}, {string})	Number	append {string} below line {lnum}
append({lnum}, {list})		Number	append lines {list} below line {lnum}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{abs(), , abs}(@{expr@}) @tab 浮動小数点数または数値 @tab @{expr@} の絶対値
@item @ref{acos(), , acos}(@{expr@}) @tab 浮動小数点数 @tab @{expr@} のアークコサイン
@item @ref{add(), , add}(@{list@}, @{item@}) @tab リスト @tab @{item@} をリスト |@ref{List}| @{list@} に追加する
@item @ref{and(), , and}(@{expr@}, @{expr@}) @tab 数値 @tab ビット論理積
@item @ref{append(), , append}(@{lnum@}, @{string@}) @tab 数値 @tab @{string@} を @{lnum@} 行目に付け加える
@item @ref{append(), , append}(@{lnum@}, @{list@}) @tab 数値 @tab 行 @{list@} を @{lnum@} 行目に付け加える
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
argc()				Number	number of files in the argument list
argidx()			Number	current index in the argument list
arglistid([{winnr} [, {tabnr}]]) Number	argument list id
argv({nr})			String	{nr} entry of the argument list
argv()				List	the argument list
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{argc(), , argc}() @tab 数値 @tab 引数内のファイルの数
@item @ref{argidx(), , argidx}() @tab 数値 @tab 引数リスト内の現在のインデックス
@item @ref{arglistid(), , arglistid}([@{winnr@} [, @{tabnr@}]]) @tab 数値 @tab 引数リストID
@item @ref{argv(), , argv}(@{nr@}) @tab 文字列 @tab 引数の第 @{nr@} 番目
@item @ref{argv(), , argv}() @tab リスト @tab 引数リスト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
assert_beeps({cmd})		Number	assert {cmd} causes a beep
assert_equal({exp}, {act} [, {msg}])
				Number	assert {exp} is equal to {act}
assert_equalfile({fname-one}, {fname-two})
				Number	assert file contents is equal
assert_exception({error} [, {msg}])
				Number	assert {error} is in v:exception
assert_fails({cmd} [, {error}])	Number	assert {cmd} fails
assert_false({actual} [, {msg}])
				Number	assert {actual} is false
assert_inrange({lower}, {upper}, {actual} [, {msg}])
				Number	assert {actual} is inside the range
assert_match({pat}, {text} [, {msg}])
				Number	assert {pat} matches {text}
assert_notequal({exp}, {act} [, {msg}])
				Number	assert {exp} is not equal {act}
assert_notmatch({pat}, {text} [, {msg}])
				Number	assert {pat} not matches {text}
assert_report({msg})		Number	report a test failure
assert_true({actual} [, {msg}])	Number	assert {actual} is true
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{assert_beeps(), , assert_beeps}(@{cmd@}) @tab 数値 @tab @{cmd@} がビープを引き起すかテストする
@item @ref{assert_equal(), , assert_equal}(@{exp@}, @{act@} [, @{msg@}]) @tab 数値 @tab @{exp@} と @{act@} が等しいかどうかテストする
@item @ref{assert_equalfile(), , assert_equalfile}(@{fname-one@}, @{fname-two@}) @tab 数値 @tab ファイルの内容が等しいかどうかテストする
@item @ref{assert_exception(), , assert_exception}(@{error@} [, @{msg@}]) @tab 数値 @tab v:exception が @{error@} であるかテストする
@item @ref{assert_fails(), , assert_fails}(@{cmd@} [, @{error@}]) @tab 数値 @tab @{cmd@} が失敗するかどうかテストする
@item @ref{assert_false(), , assert_false}(@{actual@} [, @{msg@}]) @tab 数値 @tab @{actual@} が false かどうかテストする
@item @ref{assert_inrange(), , assert_inrange}(@{lower@}, @{upper@}, @{actual@} [, @{msg@}]) @tab 数値 @tab @{actual@} が範囲内にあるかテストする
@item @ref{assert_match(), , assert_match}(@{pat@}, @{text@} [, @{msg@}]) @tab 数値 @tab @{pat@} が @{text@} にマッチするかテストする
@item @ref{assert_notequal(), , assert_notequal}(@{exp@}, @{act@} [, @{msg@}]) @tab 数値 @tab @{exp@} が @{act@} と等しくないことをテストする
@item @ref{assert_notmatch(), , assert_notmatch}(@{pat@}, @{text@} [, @{msg@}]) @tab 数値 @tab @{pat@} が @{text@} とマッチしないことをテストする
@item @ref{assert_report(), , assert_report}(@{msg@}) @tab 数値 @tab テストの失敗を報告する
@item @ref{assert_true(), , assert_true}(@{actual@} [, @{msg@}]) @tab 数値 @tab @{actual@} が true かどうかテストする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
asin({expr})			Float	arc sine of {expr}
atan({expr})			Float	arc tangent of {expr}
atan2({expr1}, {expr2})		Float	arc tangent of {expr1} / {expr2}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{asin(), , asin}(@{expr@}) @tab 浮動小数点数 @tab @{expr@} のアークサイン
@item @ref{atan(), , atan}(@{expr@}) @tab 浮動小数点数 @tab @{expr@} のアークタンジェント
@item @ref{atan2(), , atan2}(@{expr@}, @{expr@}) @tab 浮動小数点数 @tab @{expr1@} / @{expr2@} のアークタンジェント
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
balloon_show({expr})		none	show {expr} inside the balloon
balloon_split({msg})		List	split {msg} as used for a balloon
browse({save}, {title}, {initdir}, {default})
				String	put up a file requester
browsedir({title}, {initdir})	String	put up a directory requester
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{balloon_show(), , balloon_show}(@{expr@}) @tab なし @tab @{expr@} をバルーン内に表示
@item @ref{balloon_split(), , balloon_split}(@{msg@}) @tab リスト @tab バルーンで使うために @{msg@} を分割する
@item @ref{browse(), , browse}(@{save@}, @{title@}, @{initdir@}, @{default@}) @tab 文字列 @tab ファイル選択ダイアログを表示
@item @ref{browsedir(), , browsedir}(@{title@}, @{initdir@}) @tab 文字列 @tab ディレクトリ選択ダイアログを表示
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
bufexists({expr})		Number	|TRUE| if buffer {expr} exists
buflisted({expr})		Number	|TRUE| if buffer {expr} is listed
bufloaded({expr})		Number	|TRUE| if buffer {expr} is loaded
bufname({expr})			String	Name of the buffer {expr}
bufnr({expr} [, {create}])	Number	Number of the buffer {expr}
bufwinid({expr})		Number	window ID of buffer {expr}
bufwinnr({expr})		Number	window number of buffer {expr}
byte2line({byte})		Number	line number at byte count {byte}
byteidx({expr}, {nr})		Number	byte index of {nr}'th char in {expr}
byteidxcomp({expr}, {nr})	Number	byte index of {nr}'th char in {expr}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{bufexists(), , bufexists}(@{expr@}) @tab 数値 @tab バッファ @{expr@} が存在すれば |@ref{TRUE}|
@item @ref{buflisted(), , buflisted}(@{expr@}) @tab 数値 @tab バッファ @{expr@} がリストにあるなら |@ref{TRUE}|
@item @ref{bufloaded(), , bufloaded}(@{expr@}) @tab 数値 @tab バッファ @{expr@} がロード済みなら |@ref{TRUE}|
@item @ref{bufname(), , bufname}(@{expr@}) @tab 文字列 @tab バッファ @{expr@} の名前
@item @ref{bufnr(), , bufnr}(@{expr@} [, @{create@}]) @tab 数値 @tab バッファ @{expr@} の番号
@item @ref{bufwinid(), , bufwinid}(@{expr@}) @tab 数値 @tab バッファ @{expr@} のウィンドウ ID
@item @ref{bufwinnr(), , bufwinnr}(@{nr@}) @tab 数値 @tab バッファ @{nr@} のウィンドウ番号
@item @ref{byte2line(), , byte2line}(@{byte@}) @tab 数値 @tab @{byte@} 番目のバイトの行番号
@item @ref{byteidx(), , byteidx}(@{expr@}, @{nr@}) @tab 数値 @tab @{expr@} の @{nr@} 文字目のバイトインデックス
@item @ref{byteidxcomp(), , byteidxcomp}(@{expr@}, @{nr@}) @tab 数値 @tab @{expr@} の @{nr@} 文字目のバイトインデックス
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
call({func}, {arglist} [, {dict}])
				any	call {func} with arguments {arglist}
ceil({expr})			Float	round {expr} up
ch_canread({handle})		Number	check if there is something to read
ch_close({handle})		none	close {handle}
ch_close_in({handle})		none	close in part of {handle}
ch_evalexpr({handle}, {expr} [, {options}])
				any	evaluate {expr} on JSON {handle}
ch_evalraw({handle}, {string} [, {options}])
				any	evaluate {string} on raw {handle}
ch_getbufnr({handle}, {what})	Number	get buffer number for {handle}/{what}
ch_getjob({channel})		Job	get the Job of {channel}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{call(), , call}(@{func@}, @{arglist@} [, @{dict@}]) @tab 任意 @tab 引数 @{arglist@} をつけて @{func@} を呼ぶ
@item @ref{ceil(), , ceil}(@{expr@}) @tab 浮動小数点数 @tab @{expr@} を切り上げる
@item @ref{ch_canread(), , ch_canread}(@{handle@}) @tab 数値 @tab 何か読むものがあるかをチェックする
@item @ref{ch_close(), , ch_close}(@{handle@}) @tab なし @tab @{handle@} を閉じる
@item @ref{ch_close_in(), , ch_close_in}(@{handle@}) @tab なし @tab @{handle@} の入力を閉じる
@item @ref{ch_evalexpr(), , ch_evalexpr}(@{handle@}, @{expr@} [, @{options@}]) @tab 任意 @tab @{handle@} に @{expr@} を送り応答を JSON として評価する
@item @ref{ch_evalraw(), , ch_evalraw}(@{handle@}, @{string@} [, @{options@}]) @tab 任意 @tab @{handle@} に @{string@} を送り応答を生の文字列として評価する
@item @ref{ch_getbufnr(), , ch_getbufnr}(@{handle@}, @{what@}) @tab 数値 @tab @{handle@}/@{what@} に割り当てられたバッファ番号を得る
@item @ref{ch_getjob(), , ch_getjob}(@{channel@}) @tab ジョブ @tab @{channel@} の Job を得る
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
ch_info({handle})		String	info about channel {handle}
ch_log({msg} [, {handle}])	none	write {msg} in the channel log file
ch_logfile({fname} [, {mode}])	none	start logging channel activity
ch_open({address} [, {options}])
				Channel	open a channel to {address}
ch_read({handle} [, {options}]) String	read from {handle}
ch_readraw({handle} [, {options}])
				String	read raw from {handle}
ch_sendexpr({handle}, {expr} [, {options}])
				any	send {expr} over JSON {handle}
ch_sendraw({handle}, {string} [, {options}])
				any	send {string} over raw {handle}
ch_setoptions({handle}, {options})
				none	set options for {handle}
ch_status({handle} [, {options}])
				String	status of channel {handle}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{ch_info(), , ch_info}(@{handle@}) @tab 文字列 @tab チャネル @{handle@} に関する情報を得る
@item @ref{ch_log(), , ch_log}(@{msg@} [, @{handle@}]) @tab なし @tab チャネルのログファイルに @{msg@} を書き込む
@item @ref{ch_logfile(), , ch_logfile}(@{fname@} [, @{mode@}]) @tab なし @tab チャネルの挙動ログ出力を開始する
@item @ref{ch_open(), , ch_open}(@{address@} [, @{options@}]) @tab チャネル @tab @{address@} へのチャネルを開く
@item @ref{ch_read(), , ch_read}(@{handle@} [, @{options@}]) @tab 文字列 @tab @{handle@} から読み込む
@item @ref{ch_readraw(), , ch_readraw}(@{handle@} [, @{options@}]) @tab 文字列 @tab @{handle@} から生の文字列を読み込む
@item @ref{ch_sendexpr(), , ch_sendexpr}(@{handle@}, @{expr@} [, @{options@}]) @tab 任意 @tab @{expr@} を JSON チャネル @{handle@} に送る
@item @ref{ch_sendraw(), , ch_sendraw}(@{handle@}, @{string@} [, @{options@}]) @tab 任意 @tab @{string@} を raw チャネル @{handle@} に送る
@item @ref{ch_setoptions(), , ch_setoptions}@{handle@}, @{options@}) @tab なし @tab @{handle@} にオプションを設定する
@item @ref{ch_status(), , ch_status}(@{handle@} [, @{options@}]) @tab 文字列 @tab チャネル @{handle@} の状態
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
changenr()			Number	current change number
char2nr({expr} [, {utf8}])	Number	ASCII/UTF8 value of first char in {expr}
cindent({lnum})			Number	C indent for line {lnum}
clearmatches()			none	clear all matches
col({expr})			Number	column nr of cursor or mark
complete({startcol}, {matches}) none	set Insert mode completion
complete_add({expr})		Number	add completion match
complete_check()		Number	check for key typed during completion
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{changenr(), , changenr}() @tab 数値 @tab 現在の変更番号
@item @ref{char2nr(), , char2nr}(@{expr@} [, @{utf8@}]) @tab 数値 @tab @{expr@} の先頭文字の ASCII/UTF8 コード
@item @ref{cindent(), , cindent}(@{lnum@}) @tab 数値 @tab @{lnum@} 行目の C インデント量
@item @ref{clearmatches(), , clearmatches}() @tab なし @tab 全マッチをクリアする
@item @ref{col(), , col}(@{expr@}) @tab 数値 @tab カーソルかマークのカラム番号
@item @ref{complete(), , complete}(@{startcol@}, @{matches@}) @tab なし @tab 挿入モード補完を設定する
@item @ref{complete_add(), , complete_add}(@{expr@}) @tab 数値 @tab 補完候補を追加する
@item @ref{complete_check(), , complete_check}() @tab 数値 @tab 補完中に押されたキーをチェックする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
confirm({msg} [, {choices} [, {default} [, {type}]]])
				Number	number of choice picked by user
copy({expr})			any	make a shallow copy of {expr}
cos({expr})			Float	cosine of {expr}
cosh({expr})			Float	hyperbolic cosine of {expr}
count({list}, {expr} [, {ic} [, {start}]])
				Number	count how many {expr} are in {list}
cscope_connection([{num}, {dbpath} [, {prepend}]])
				Number	checks existence of cscope connection
cursor({lnum}, {col} [, {off}])
				Number	move cursor to {lnum}, {col}, {off}
cursor({list})			Number	move cursor to position in {list}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{confirm(), , confirm}(@{msg@} [, @{choices@} [, @{default@} [, @{type@}]]]) @tab 数値 @tab ユーザーへの選択肢と番号
@item @ref{copy(), ,copy}(@{expr@}) @tab 任意 @tab @{expr@} の浅いコピーを作る
@item @ref{cos(), , cos}(@{expr@}) @tab 浮動小数点数 @tab @{expr@} の余弦 (コサイン)
@item @ref{cosh(), , cosh}(@{expr@}) @tab 浮動小数点数 @tab @{expr@} のハイパボリックコサイン
@item @ref{count(), , count}(@{list@}, @{expr@} [, @{ic@} [, @{start@}]]) @tab 数値 @tab @{list@} 中に @{expr@} が何個現れるか数える
@item @ref{cscope_connection(), ,cscope_connection}([@{num@} , @{dbpath@} [, @{prepend@}]]) @tab 数値 @tab cscope 接続の存在を判定する
@item @ref{cursor(), , cursor}(@{lnum@}, @{col@} [, @{off@}]) @tab 数値 @tab カーソルを @{lnum@}, @{col@}, @{off@} へ移動
@item @ref{cursor(), , cursor}(@{list@}) @tab 数値 @tab カーソルを @{list@} の位置へ移動
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
debugbreak({pid})		Number  interrupt process being debugged
deepcopy({expr} [, {noref}])	any	make a full copy of {expr}
delete({fname} [, {flags}])	Number	delete the file or directory {fname}
deletebufline({expr}, {first} [, {last}])
				Number	delete lines from buffer {expr}
did_filetype()			Number	|TRUE| if FileType autocmd event used
diff_filler({lnum})		Number	diff filler lines about {lnum}
diff_hlID({lnum}, {col})	Number	diff highlighting at {lnum}/{col}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{debugbreak(), , debugbreak}(@{pid@}) @tab 数値 @tab デバッグしているプロセスを中断する
@item @ref{deepcopy(), , deepcopy}(@{expr@} [, @{noref@}]) @tab 任意 @tab @{expr@} の完全なコピーを作る
@item @ref{delete(), , delete}(@{fname@} [, @{flags@}]) @tab 数値 @tab ファイルやディレクトリ @{fname@} を消す
@item @ref{deletebufline(), , deletebufline}(@{expr@}, @{first@} [, @{last@}]) @tab 数値 @tab バッファ @{expr@} から行を削除する
@item @ref{did_filetype(), , did_filetype}() @tab 数値 @tab FileType の autocommand が実行されると |@ref{TRUE}|
@item @ref{diff_filler(), , diff_filler}(@{lnum@}) @tab 数値 @tab 差分モードで @{lnum@} に挿入された行
@item @ref{diff_hlID(), , diff_hlID}(@{lnum@}, @{col@}) @tab 数値 @tab 差分モードで @{lnum@}/@{col@} 位置の強調
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
empty({expr})			Number	|TRUE| if {expr} is empty
escape({string}, {chars})	String	escape {chars} in {string} with '\'
eval({string})			any	evaluate {string} into its value
eventhandler()			Number	|TRUE| if inside an event handler
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{empty(), , empty}(@{expr@}) @tab 数値 @tab @{expr@} が空なら |@ref{TRUE}|
@item @ref{escape(), , escape}(@{string@}, @{chars@}) @tab 文字列 @tab @{string@} 内の @{chars@} を '\' でエスケープ
@item @ref{eval(), , eval}(@{string@}) @tab 任意 @tab @{string@} を評価し、値を得る
@item @ref{eventhandler(), , eventhandler}() @tab 数値 @tab イベントハンドラの内側なら |@ref{TRUE}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
executable({expr})		Number	1 if executable {expr} exists
execute({command})		String	execute {command} and get the output
exepath({expr})			String	full path of the command {expr}
exists({expr})			Number	|TRUE| if {expr} exists
extend({expr1}, {expr2} [, {expr3}])
				List/Dict insert items of {expr2} into {expr1}
exp({expr})			Float	exponential of {expr}
expand({expr} [, {nosuf} [, {list}]])
				any	expand special keywords in {expr}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{executable(), , executable}(@{expr@}) @tab 数値 @tab 実行可能な @{expr@} が存在するなら 1
@item @ref{execute(), , execute}(@{command@}) @tab 文字列 @tab @{command@} を実行し、出力を得る
@item @ref{exepath(), , exepath}(@{expr@}) @tab 文字列 @tab コマンド @{expr@} のフルパス
@item @ref{exists(), , exists}(@{var@}) @tab 数値 @tab 変数 @{var@} が存在したら |@ref{TRUE}|
@item @ref{extend(), , extend}(@{expr1@}, @{expr2@} [, @{expr3@}]) @tab リスト/辞書 @tab @{expr1@} に @{expr2@} の要素を挿入
@item @ref{exp(), , exp}(@{expr@}) @tab 浮動小数点数 @tab @{expr@} の指数
@item @ref{expand(), , expand}(@{expr@} [, @{nosuf@} [, @{list@}]]) @tab 任意 @tab @{expr@} 内の特別なキーワードを展開
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
feedkeys({string} [, {mode}])	Number	add key sequence to typeahead buffer
filereadable({file})		Number	|TRUE| if {file} is a readable file
filewritable({file})		Number	|TRUE| if {file} is a writable file
filter({expr1}, {expr2})	List/Dict  remove items from {expr1} where
					{expr2} is 0
finddir({name} [, {path} [, {count}]])
				String	find directory {name} in {path}
findfile({name} [, {path} [, {count}]])
				String	find file {name} in {path}
float2nr({expr})		Number	convert Float {expr} to a Number
floor({expr})			Float	round {expr} down
fmod({expr1}, {expr2})		Float	remainder of {expr1} / {expr2}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{feedkeys(), , feedkeys}(@{string@} [, @{mode@}]) @tab 数値 @tab 先行入力バッファにキーシーケンスを追加
@item @ref{filereadable(), , filereadable}(@{file@}) @tab 数値 @tab @{file@} が読み込み可能なら |@ref{TRUE}|
@item @ref{filewritable(), , filewritable}(@{file@}) @tab 数値 @tab @{file@} が書き込み可能なら |@ref{TRUE}|
@item @ref{filter(), , filter}(@{expr1@}, @{expr2@}) @tab リスト/辞書  @tab @{expr2@} が 0 となる要素を @{expr1@} からとり除く
@item @ref{finddir(), , finddir}(@{name@} [, @{path@} [, @{count@}]]) @tab 文字列 @tab @{path@} からディレクトリ @{name@} を探す
@item @ref{findfile(), , findfile}(@{name@} [, @{path@} [, @{count@}]]) @tab 文字列 @tab @{path@} からファイル @{name@} を探す
@item @ref{float2nr(), , float2nr}(@{expr@}) @tab 数値 @tab 浮動小数点数 @{expr@} を数値に変換する
@item @ref{floor() , , floor}(@{expr@}) @tab 浮動小数点数 @tab @{expr@} を切り捨てる
@item @ref{fmod(), , fmod}(@{expr1@}, @{expr2@}) @tab 浮動小数点数 @tab @{expr1@} / @{expr2@} の余り
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
fnameescape({fname})		String	escape special characters in {fname}
fnamemodify({fname}, {mods})	String	modify file name
foldclosed({lnum})		Number	first line of fold at {lnum} if closed
foldclosedend({lnum})		Number	last line of fold at {lnum} if closed
foldlevel({lnum})		Number	fold level at {lnum}
foldtext()			String	line displayed for closed fold
foldtextresult({lnum})		String	text for closed fold at {lnum}
foreground()			Number	bring the Vim window to the foreground
funcref({name} [, {arglist}] [, {dict}])
				Funcref	reference to function {name}
function({name} [, {arglist}] [, {dict}])
				Funcref	named reference to function {name}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{fnameescape(), , fnameescape}(@{fname@}) @tab 文字列 @tab @{fname@} 内の特殊文字をエスケープする
@item @ref{fnamemodify(), , fnamemodify}(@{fname@}, @{mods@}) @tab 文字列 @tab ファイル名を変更
@item @ref{foldclosed(), , foldclosed}(@{lnum@}) @tab 数値 @tab @{lnum@} の折り畳みの最初の行 (閉じているなら)
@item @ref{foldclosedend(), , foldclosedend}(@{lnum@}) @tab 数値 @tab @{lnum@} の折り畳みの最後の行 (閉じているなら)
@item @ref{foldlevel(), , foldlevel}(@{lnum@}) @tab 数値 @tab @{lnum@} の折り畳みレベル
@item @ref{foldtext(), , foldtext}() @tab 文字列 @tab 閉じた折り畳みに表示されている行
@item @ref{foldtextresult(), , foldtextresult}(@{lnum@}) @tab 文字列 @tab @{lnum@} で閉じている折り畳みのテキスト
@item @ref{foreground(), , foreground}() @tab 数値 @tab Vim ウィンドウを前面に移動する
@item @ref{funcref(), , funcref}(@{name@} [, @{arglist@}] [, @{dict@}]) @tab Funcref @tab 関数 @{name@} への参照
@item @ref{function(), , function}(@{name@} [, @{arglist@}] [, @{dict@}]) @tab Funcref @tab 名前による関数 @{name@} への参照
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
garbagecollect([{atexit}])	none	free memory, breaking cyclic references
get({list}, {idx} [, {def}])	any	get item {idx} from {list} or {def}
get({dict}, {key} [, {def}])	any	get item {key} from {dict} or {def}
get({func}, {what})		any	get property of funcref/partial {func}
getbufinfo([{expr}])		List	information about buffers
getbufline({expr}, {lnum} [, {end}])
				List	lines {lnum} to {end} of buffer {expr}
getbufvar({expr}, {varname} [, {def}])
				any	variable {varname} in buffer {expr}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{garbagecollect(), , garbagecollect}([@{atexit@}]) @tab なし @tab メモリを解放する。循環参照を断ち切る
@item @ref{get(), , get}(@{list@}, @{idx@} [, @{def@}]) @tab 任意 @tab @{list@} や @{def@} から要素 @{idx@} を取得
@item @ref{get(), , get}(@{dict@}, @{key@} [, @{def@}]) @tab 任意 @tab @{dict@} や @{def@} から要素 @{key@} を取得
@item @ref{get(), , get}(@{func@}, @{what@}) @tab 任意 @tab funcref/partial @{func@} のプロパティ取得
@item @ref{getbufinfo(), , getbufinfo}([@{expr@}]) @tab リスト @tab バッファに関する情報
@item @ref{getbufline(), , getbufline}(@{expr@}, @{lnum@} [, @{end@}]) @tab リスト @tab バッファ @{expr@} の @{lnum@} から @{end@} 行目
@item @ref{getbufvar(), , getbufvar}(@{expr@}, @{varname@} [, @{def@}]) @tab 任意 @tab バッファ @{expr@} の変数 @{varname@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
getchangelist({expr})		List	list of change list items
getchar([expr])			Number	get one character from the user
getcharmod()			Number	modifiers for the last typed character
getcharsearch()			Dict	last character search
getcmdline()			String	return the current command-line
getcmdpos()			Number	return cursor position in command-line
getcmdtype()			String	return current command-line type
getcmdwintype()			String	return current command-line window type
getcompletion({pat}, {type} [, {filtered}])
				List	list of cmdline completion matches
getcurpos()			List	position of the cursor
getcwd([{winnr} [, {tabnr}]])	String	get the current working directory
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{getchangelist(), , getchangelist}(@{expr@}) @tab リスト @tab 変更リストのリスト
@item @ref{getchar(), , getchar}([expr]) @tab 数値 @tab ユーザーから 1 文字を取得する
@item @ref{getcharmod(), , getcharmod}() @tab 数値 @tab 修飾キーの状態を表す数値を取得
@item @ref{getcharsearch(), , getcharsearch}() @tab 辞書 @tab 最後の文字検索を取得
@item @ref{getcmdline(), , getcmdline}() @tab 文字列 @tab 現在のコマンドラインを取得
@item @ref{getcmdpos(), , getcmdpos}() @tab 数値 @tab コマンドラインのカーソル位置を取得
@item @ref{getcmdtype(), , getcmdtype}() @tab 文字列 @tab 現在のコマンドラインの種類を取得
@item @ref{getcmdwintype(), , getcmdwintype}() @tab 文字列 @tab 現在のコマンドラインウィンドウの種類
@item @ref{getcompletion(), , getcompletion}(@{pat@}, @{type@} [, @{filtered@}]) @tab リスト @tab コマンドライン補完にマッチするリスト
@item @ref{getcurpos(), , getcurpos}() @tab リスト @tab カーソルの位置
@item @ref{getcwd(), , getcwd}([@{winnr@} [, @{tabnr@}]]) @tab 文字列 @tab 現在の作業ディレクトリを取得
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
getfontname([{name}])		String	name of font being used
getfperm({fname})		String	file permissions of file {fname}
getfsize({fname})		Number	size in bytes of file {fname}
getftime({fname})		Number	last modification time of file
getftype({fname})		String	description of type of file {fname}
getjumplist([{winnr} [, {tabnr}]])
				List	list of jump list items
getline({lnum})			String	line {lnum} of current buffer
getline({lnum}, {end})		List	lines {lnum} to {end} of current buffer
getloclist({nr} [, {what}])	List	list of location list items
getmatches()			List	list of current matches
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{getfontname(), , getfontname}([@{name@}]) @tab 文字列 @tab 使用しているフォントの名前
@item @ref{getfperm(), , getfperm}(@{fname@}) @tab 文字列 @tab ファイル @{fname@} の許可属性を取得
@item @ref{getfsize(), , getfsize}(@{fname@}) @tab 数値 @tab ファイル @{fname@} のバイト数を取得
@item @ref{getftime(), , getftime}(@{fname@}) @tab 数値 @tab ファイルの最終更新時間
@item @ref{getftype(), , getftype}(@{fname@}) @tab 文字列 @tab ファイル @{fname@} の種類の説明
@item @ref{getjumplist(), , getjumplist}([@{winnr@} [, @{tabnr@}]]) @tab リスト @tab ジャンプリスト項目のリスト
@item @ref{getline(), , getline}(@{lnum@}) @tab 文字列 @tab 現在のバッファから行の内容を取得
@item @ref{getline(), , getline}(@{lnum@}, @{end@}) @tab リスト @tab カレントバッファの @{lnum@} から @{end@} 行目
@item @ref{getloclist(), , getloclist}(@{nr@} [, @{what@}]) @tab リスト @tab ロケーションリストの要素のリスト
@item @ref{getmatches(), , getmatches}() @tab リスト @tab 現在のマッチのリスト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
getpid()			Number	process ID of Vim
getpos({expr})			List	position of cursor, mark, etc.
getqflist([{what}])		List	list of quickfix items
getreg([{regname} [, 1 [, {list}]]])
				String or List   contents of register
getregtype([{regname}])		String	type of register
gettabinfo([{expr}])		List	list of tab pages
gettabvar({nr}, {varname} [, {def}])
				any	variable {varname} in tab {nr} or {def}
gettabwinvar({tabnr}, {winnr}, {name} [, {def}])
				any	{name} in {winnr} in tab page {tabnr}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{getpid(), , getpid}() @tab 数値 @tab Vim のプロセス ID
@item @ref{getpos(), , getpos}(@{expr@}) @tab リスト @tab カーソル・マークなどの位置を取得
@item @ref{getqflist(), , getqflist}([@{what@}]) @tab リスト @tab quickfix 要素のリスト
@item @ref{getreg(), , getreg}([@{regname@} [, 1 [, @{list@}]]]) @tab 文字列/リスト @tab レジスタの中身を取得
@item @ref{getregtype(), , getregtype}([@{regname@}]) @tab 文字列 @tab レジスタの種類を取得
@item @ref{gettabinfo(), , gettabinfo}([@{expr@}]) @tab リスト @tab タブページのリスト
@item @ref{gettabvar(), , gettabvar}(@{nr@}, @{varname@} [, @{def@}]) @tab 任意 @tab タブ @{nr@} の変数 @{varname@} または @{def@}
@item @ref{gettabwinvar(), , gettabwinvar}(@{tabnr@}, @{winnr@}, @{name@} [, @{def@}]) @tab 任意 @tab タブページ @{tabnr@} の @{winnr@} の @{name@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
getwininfo([{winid}])		List	list of info about each window
getwinpos([{timeout}])		List	X and Y coord in pixels of the Vim window
getwinposx()			Number	X coord in pixels of the Vim window
getwinposy()			Number	Y coord in pixels of the Vim window
getwinvar({nr}, {varname} [, {def}])
				any	variable {varname} in window {nr}
glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])
				any	expand file wildcards in {expr}
glob2regpat({expr})		String	convert a glob pat into a search pat
globpath({path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]])
				String	do glob({expr}) for all dirs in {path}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{getwininfo(), , getwininfo}([@{winid@}]) @tab リスト @tab それぞれのウィンドウに関する情報のリスト
@item @ref{getwinpos(), , getwinpos}([@{timeout@}]) @tab リスト @tab Vim window の X, Y 座標
@item @ref{getwinposx(), , getwinposx}() @tab 数値 @tab Vim window の X 座標
@item @ref{getwinposy(), , getwinposy}() @tab 数値 @tab Vim window の Y 座標
@item @ref{getwinvar(), , getwinvar}(@{nr@}, @{varname@} [, @{def@}]) @tab 文字列 @tab ウィンドウ @{nr@} の変数 @{varname@}
@item @ref{glob(), , glob}(@{expr@} [, @{nosuf@} [, @{list@} [, @{alllinks@}]]]) @tab 任意 @tab @{expr@} 内の file wildcard を展開
@item @ref{glob2regpat(), , glob2regpat}(@{expr@}) @tab 文字列 @tab glob パターンを検索パターンに変換
@item @ref{globpath(), , globpath}(@{path@}, @{expr@} [, @{nosuf@} [, @{list@} [, @{alllinks@}]]]) @tab 文字列 @tab @{path@}の全ディレクトリに対し glob(@{expr@}) を行う
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
has({feature})			Number	|TRUE| if feature {feature} supported
has_key({dict}, {key})		Number	|TRUE| if {dict} has entry {key}
haslocaldir([{winnr} [, {tabnr}]])
				Number	|TRUE| if the window executed |:lcd|
hasmapto({what} [, {mode} [, {abbr}]])
				Number	|TRUE| if mapping to {what} exists
histadd({history}, {item})	String	add an item to a history
histdel({history} [, {item}])	String	remove an item from a history
histget({history} [, {index}])	String	get the item {index} from a history
histnr({history})		Number	highest index of a history
hlexists({name})		Number	|TRUE| if highlight group {name} exists
hlID({name})			Number	syntax ID of highlight group {name}
hostname()			String	name of the machine Vim is running on
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{has(),  ,has}(@{feature@}) @tab 数値 @tab 機能 @{feature@} がサポートならば |@ref{TRUE}|
@item @ref{has_key(), , has_key}(@{dict@}, @{key@}) @tab 数値 @tab @{dict@} が要素 @{key@} を持つなら |@ref{TRUE}|
@item @ref{haslocaldir(), , haslocaldir}([@{winnr@} [, @{tabnr@}]]) @tab 数値 @tab 現在のウィンドウで |@ref{:lcd}| が実行されたなら |@ref{TRUE}|
@item @ref{hasmapto(), , hasmapto}(@{what@} [, @{mode@} [, @{abbr@}]]) @tab 数値 @tab @{what@} のマッピングが存在するなら |@ref{TRUE}|
@item @ref{histadd(), , histadd}(@{history@}, @{item@}) @tab 文字列 @tab ヒストリに追加
@item @ref{histdel(), , histdel}(@{history@} [, @{item@}]) @tab 文字列 @tab ヒストリから item を削除
@item @ref{histget(), , histget}(@{history@} [, @{index@}]) @tab 文字列 @tab ヒストリから @{index@} アイテムを取得
@item @ref{histnr(), , histnr}(@{history@}) @tab 数値 @tab ヒストリの数
@item @ref{hlexists(), , hlexists}(@{name@}) @tab 数値 @tab highlight group @{name@} が存在したら |@ref{TRUE}|
@item @ref{hlID(), , hlID}(@{name@}) @tab 数値 @tab highlight group @{name@} の ID
@item @ref{hostname(), , hostname}() @tab 文字列 @tab vim が動作しているマシンの名前
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
iconv({expr}, {from}, {to})	String	convert encoding of {expr}
indent({lnum})			Number	indent of line {lnum}
index({list}, {expr} [, {start} [, {ic}]])
				Number	index in {list} where {expr} appears
input({prompt} [, {text} [, {completion}]])
				String	get input from the user
inputdialog({prompt} [, {text} [, {completion}]])
				String	like input() but in a GUI dialog
inputlist({textlist})		Number	let the user pick from a choice list
inputrestore()			Number	restore typeahead
inputsave()			Number	save and clear typeahead
inputsecret({prompt} [, {text}]) String	like input() but hiding the text
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{iconv(), , iconv}(@{expr@}, @{from@}, @{to@}) @tab 文字列 @tab @{expr@} のエンコーディングを変換する
@item @ref{indent(), , indent}(@{lnum@}) @tab 文字列 @tab 行 @{lnum@} のインデントを取得
@item @ref{index(), , index}(@{list@}, @{expr@} [, @{start@} [, @{ic@}]]) @tab 数値 @tab @{list@} 中に @{expr@} が現れる位置
@item @ref{input(), , input}(@{prompt@} [, @{text@} [, @{completion@}]]) @tab 文字列 @tab ユーザーからの入力を取得
@item @ref{inputdialog(), , inputdialog}(@{prompt@} [, @{text@} [, @{completion@}]]) @tab 文字列 @tab input() と同様。GUI のダイアログを使用
@item @ref{inputlist(), , inputlist}(@{textlist@}) @tab 数値 @tab ユーザーに選択肢から選ばせる
@item @ref{inputrestore(), , inputrestore}() @tab 数値 @tab 先行入力を復元する
@item @ref{inputsave(), , inputsave}() @tab 数値 @tab 先行入力を保存し、クリアする
@item @ref{inputsecret(), , inputsecret}(@{prompt@} [, @{text@}]) @tab 文字列 @tab input() だがテキストを隠す
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
insert({list}, {item} [, {idx}]) List	insert {item} in {list} [before {idx}]
invert({expr})			Number	bitwise invert
isdirectory({directory})	Number	|TRUE| if {directory} is a directory
islocked({expr})		Number	|TRUE| if {expr} is locked
isnan({expr})			Number	|TRUE| if {expr} is NaN
items({dict})			List	key-value pairs in {dict}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{insert(), , insert}(@{list@}, @{item@} [, @{idx@}]) @tab リスト @tab @{list@} に要素 @{item@} を挿入 [@{idx@} の前]
@item @ref{invert(), , invert}(@{expr@}) @tab 数値 @tab ビット反転
@item @ref{isdirectory(), , isdirectory}(@{directory@}) @tab 数値 @tab @{directory@} がディレクトリならば |@ref{TRUE}|
@item @ref{islocked(), , islocked}(@{expr@}) @tab 数値 @tab @{expr@} がロックされているなら |@ref{TRUE}|
@item @ref{isnan(), , isnan}(@{expr@}) @tab 数値 @tab @{expr@}が NaN ならば |@ref{TRUE}|
@item @ref{items(), , items}(@{dict@}) @tab リスト @tab @{dict@} のキーと値のペアを取得
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
job_getchannel({job})		Channel	get the channel handle for {job}
job_info([{job}])		Dict	get information about {job}
job_setoptions({job}, {options}) none	set options for {job}
job_start({command} [, {options}])
				Job	start a job
job_status({job})		String	get the status of {job}
job_stop({job} [, {how}])	Number	stop {job}
join({list} [, {sep}])		String	join {list} items into one String
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{job_getchannel(), , job_getchannel}(@{job@}) @tab チャネル @tab @{job@} のチャネルハンドルを取得
@item @ref{job_info(), , job_info}([@{job@}]) @tab 辞書 @tab @{job@} についての情報を取得
@item @ref{job_setoptions(), , job_setoptions}(@{job@}, @{options@}) @tab なし @tab @{job@} のオプションを設定する
@item @ref{job_start(), , job_start}(@{command@} [, @{options@}]) @tab ジョブ @tab ジョブを開始する
@item @ref{job_status(), , job_status}(@{job@}) @tab 文字列 @tab @{job@} のステータスを取得する
@item @ref{job_stop(), , job_stop}(@{job@} [, @{how@}]) @tab 数値 @tab @{job@} を停止する
@item @ref{join(), , join}(@{list@} [, @{sep@}]) @tab 文字列 @tab @{list@} の要素を連結して文字列にする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
js_decode({string})		any	decode JS style JSON
js_encode({expr})		String	encode JS style JSON
json_decode({string})		any	decode JSON
json_encode({expr})		String	encode JSON
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{js_decode(), , js_decode}(@{string@}) @tab 任意 @tab JS 形式の JSON をデコードする
@item @ref{js_encode(), , js_encode}(@{expr@}) @tab 文字列 @tab JS 形式の JSON にエンコードする
@item @ref{json_decode(), , json_decode}(@{string@}) @tab 任意 @tab JSON をデコードする
@item @ref{json_encode(), , json_encode}(@{expr@}) @tab 文字列 @tab JSON にエンコードする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
keys({dict})			List	keys in {dict}
len({expr})			Number	the length of {expr}
libcall({lib}, {func}, {arg})	String	call {func} in library {lib} with {arg}
libcallnr({lib}, {func}, {arg})	Number	idem, but return a Number
line({expr})			Number	line nr of cursor, last line or mark
line2byte({lnum})		Number	byte count of line {lnum}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{keys(), , keys}(@{dict@}) @tab リスト @tab @{dict@} のキーを取得
@item @ref{len(), , len}(@{expr@}) @tab 数値 @tab @{expr@} の長さを取得
@item @ref{libcall(), , libcall}(@{lib@}, @{func@}, @{arg@} @tab 文字列 @tab ライブラリ @{lib@} の関数 @{func@} をコール
@item @ref{libcallnr(), , libcallnr}(@{lib@}, @{func@}, @{arg@}) @tab 数値 @tab 上と同じ。ただし数値を返す
@item @ref{line(), , line}(@{expr@}) @tab 数値 @tab 行番号の取得
@item @ref{line2byte(), , line2byte}(@{lnum@}) @tab 数値 @tab 行 @{lnum@} のバイトカウント
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
lispindent({lnum})		Number	Lisp indent for line {lnum}
localtime()			Number	current time
log({expr})			Float	natural logarithm (base e) of {expr}
log10({expr})			Float	logarithm of Float {expr} to base 10
luaeval({expr} [, {expr}])	any	evaluate |Lua| expression
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{lispindent(), , lispindent}(@{lnum@}) @tab 数値 @tab @{lnum@} 行目の Lisp インデント量を取得
@item @ref{localtime(), , localtime}() @tab 数値 @tab 現在時刻
@item @ref{log(), , log}(@{expr@}) @tab 浮動小数点数 @tab @{expr@} の自然対数 (底 e)
@item @ref{log10(), , log10}(@{expr@}) @tab 浮動小数点数 @tab 浮動小数点数 @{expr@} の 10 を底とする対数
@item @ref{luaeval(), , luaeval}(@{expr@} [, @{expr@}]) @tab 任意 @tab |@ref{Lua}| の式を評価する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
map({expr1}, {expr2})		List/Dict  change each item in {expr1} to {expr}
maparg({name} [, {mode} [, {abbr} [, {dict}]]])
				String or Dict
					rhs of mapping {name} in mode {mode}
mapcheck({name} [, {mode} [, {abbr}]])
				String	check for mappings matching {name}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{map(), , map}(@{expr1@}, @{expr2@}) @tab リスト/辞書 @tab @{expr1@} の各要素を @{expr2@} に変える
@item @ref{maparg(), , maparg}(@{name@} [, @{mode@} [, @{abbr@} [, @{dict@}]]]) @tab 文字列/辞書 @tab モード @{mode@} でのマッピング @{name@} の値
@item @ref{mapcheck(), , mapcheck}(@{name@} [, @{mode@} [, @{abbr@}]]) @tab 文字列 @tab @{name@} にマッチするマッピングを確認
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
match({expr}, {pat} [, {start} [, {count}]])
				Number	position where {pat} matches in {expr}
matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])
				Number	highlight {pattern} with {group}
matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])
				Number	highlight positions with {group}
matcharg({nr})			List	arguments of |:match|
matchdelete({id})		Number	delete match identified by {id}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{match(), , match}(@{expr@}, @{pat@} [, @{start@} [, @{count@}]]) @tab 数値 @tab @{expr@} 内で @{pat@} がマッチする位置
@item @ref{matchadd(), , matchadd}(@{group@}, @{pattern@} [, @{priority@} [, @{id@} [, @{dict@}]]]) @tab 数値 @tab @{pattern@} を @{group@} で強調表示する
@item @ref{matchaddpos(), , matchaddpos}(@{group@}, @{pos@} [, @{priority@} [, @{id@} [, @{dict@}]]]) @tab 数値 @tab 位置を @{group@} で強調表示する
@item @ref{matcharg(), , matcharg}(@{nr@}) @tab リスト @tab |@ref{:match}| の引数
@item @ref{matchdelete(), , matchdelete}(@{id@}) @tab 数値 @tab @{id@} で指定されるマッチを削除する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
matchend({expr}, {pat} [, {start} [, {count}]])
				Number	position where {pat} ends in {expr}
matchlist({expr}, {pat} [, {start} [, {count}]])
				List	match and submatches of {pat} in {expr}
matchstr({expr}, {pat} [, {start} [, {count}]])
				String	{count}'th match of {pat} in {expr}
matchstrpos({expr}, {pat} [, {start} [, {count}]])
				List	{count}'th match of {pat} in {expr}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{matchend(), , ,matchend}(@{expr@}, @{pat@} [, @{start@} [, @{count@}]]) @tab 数値 @tab @{expr@} 内で @{pat@} が終了する位置
@item @ref{matchlist(), , matchlist}(@{expr@}, @{pat@} [, @{start@} [, @{count@}]]) @tab リスト @tab @{expr@} 内の @{pat@} のマッチと部分マッチ
@item @ref{matchstr(), , matchstr}(@{expr@}, @{pat@} [, @{start@} [, @{count@}]]) @tab 文字列 @tab @{expr@} 内の @{count@} 番目の @{pat@} のマッチ
@item @ref{matchstrpos(), , matchstrpos}(@{expr@}, @{pat@} [, @{start@} [, @{count@}]]) @tab リスト @tab @{expr@} 内の @{count@} 番目の @{pat@} のマッチ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
max({expr})			Number	maximum value of items in {expr}
min({expr})			Number	minimum value of items in {expr}
mkdir({name} [, {path} [, {prot}]])
				Number	create directory {name}
mode([expr])			String	current editing mode
mzeval({expr})			any	evaluate |MzScheme| expression
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{max(), , max}(@{expr@}) @tab 数値 @tab @{expr@} 内の要素の最大値
@item @ref{min(), , min}(@{expr@}) @tab 数値 @tab @{expr@} 内の要素の最小値
@item @ref{mkdir(), , mkdir}(@{name@} [, @{path@} [, @{prot@}]]) @tab 数値 @tab ディレクトリ @{name@} を作成
@item @ref{mode(), , mode}([expr]) @tab 文字列 @tab 現在の編集モード
@item @ref{mzeval(), , mzeval}(@{expr@}) @tab 任意 @tab |@ref{MzScheme}| の式を評価する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
nextnonblank({lnum})		Number	line nr of non-blank line >= {lnum}
nr2char({expr} [, {utf8}])	String	single char with ASCII/UTF8 value {expr}
or({expr}, {expr})		Number	bitwise OR
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{nextnonblank(), , nextnonblank}(@{lnum@}) @tab 数値 @tab @{lnum@} 行目以降で空行でない行の行番号
@item @ref{nr2char(), , nr2char}(@{expr@} [, @{utf8@}]) @tab 文字列 @tab ASCII/UTF8 コード @{expr@} で示される文字
@item @ref{or(), , or}(@{expr@}, @{expr@}) @tab 数値 @tab ビット論理和
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
pathshorten({expr})		String	shorten directory names in a path
perleval({expr})		any	evaluate |Perl| expression
pow({x}, {y})			Float	{x} to the power of {y}
prevnonblank({lnum})		Number	line nr of non-blank line <= {lnum}
printf({fmt}, {expr1}...)	String	format text
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{pathshorten(), , pathshorten}(@{expr@}) @tab 文字列 @tab path 内の短縮したディレクトリ名
@item @ref{perleval(), , perleval}(@{expr@}) @tab 任意 @tab |@ref{Perl}| の式を評価する
@item @ref{pow(), , pow}(@{x@}, @{y@}) @tab 浮動小数点数 @tab @{x@} の @{y@} 乗
@item @ref{prevnonblank(), , prevnonblank}(@{lnum@}) @tab 数値 @tab @{lnum@} 行目以前の空行でない行の行番号
@item @ref{printf(), , printf}(@{fmt@}, @{expr1@}...) @tab 文字列 @tab 文字列を組み立てる
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
prompt_addtext({buf}, {expr})	none	add text to a prompt buffer
prompt_setcallback({buf}, {expr}) none	set prompt callback function
prompt_setinterrupt({buf}, {text}) none	set prompt interrupt function
prompt_setprompt({buf}, {text}) none	set prompt text
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item prompt_addtext(@{buf@}, @{expr@}) @tab なし @tab プロンプトバッファにテキストを追加する
@item @ref{prompt_setcallback(), , prompt_setcallback}(@{buf@}, @{expr@}) @tab なし @tab プロンプトコールバック関数を設定する
@item @ref{prompt_setinterrupt(), , prompt_setinterrupt}(@{buf@}, @{text@}) @tab なし @tab プロンプトインタラプト関数を設定する
@item @ref{prompt_setprompt(), , prompt_setprompt}(@{buf@}, @{text@}) @tab なし @tab プロンプトテキストを設定する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
pumvisible()			Number	whether popup menu is visible
pyeval({expr})			any	evaluate |Python| expression
py3eval({expr})			any	evaluate |python3| expression
pyxeval({expr})			any	evaluate |python_x| expression
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{pumvisible(), , pumvisible()} @tab 数値 @tab ポップアップメニューが表示されているか
@item @ref{pyeval(), , pyeval}(@{expr@}) @tab 任意 @tab |@ref{Python}| の式を評価する
@item @ref{py3eval(), , py3eval}(@{expr@}) @tab 任意 @tab |@ref{python3}| の式を評価する
@item @ref{pyxeval(), , pyxeval}(@{expr@}) @tab 任意 @tab |@ref{python_x}| の式を評価する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
range({expr} [, {max} [, {stride}]])
				List	items from {expr} to {max}
readfile({fname} [, {binary} [, {max}]])
				List	get list of lines from file {fname}
reg_executing()			String	get the executing register name
reg_recording()			String	get the recording register name
reltime([{start} [, {end}]])	List	get time value
reltimefloat({time})		Float	turn the time value into a Float
reltimestr({time})		String	turn time value into a String
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{range(), , range}(@{expr@} [, @{max@} [, @{stride@}]]) @tab リスト @tab @{expr@} から @{max@} までの要素のリスト
@item @ref{readfile(), , readfile}(@{fname@} [, @{binary@} [, @{max@}]]) @tab リスト @tab ファイル @{fname@} から行のリストを取得
@item @ref{reg_executing()} @tab 文字列 @tab 実行しているレジスタ名を取得
@item @ref{reg_recording()} @tab 文字列 @tab 記録しているレジスタ名を取得
@item @ref{reltime(), , reltime}([@{start@} [, @{end@}]]) @tab リスト @tab 時刻の値を取得
@item @ref{reltimefloat(), , reltimefloat}(@{time@}) @tab 浮動小数点数 @tab 時刻の値を浮動小数点に変換
@item @ref{reltimestr(), , reltimestr}(@{time@}) @tab 文字列 @tab 時刻の値を文字列に変換
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
remote_expr({server}, {string} [, {idvar} [, {timeout}]])
				String	send expression
remote_foreground({server})	Number	bring Vim server to the foreground
remote_peek({serverid} [, {retvar}])
				Number	check for reply string
remote_read({serverid} [, {timeout}])
				String	read reply string
remote_send({server}, {string} [, {idvar}])
				String	send key sequence
remote_startserver({name})	none	become server {name}
				String	send key sequence
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{remote_expr(), , remote_expr}(@{server@}, @{string@} [, @{idvar@} [, @{timeout@}]]) @tab 文字列 @tab 式を送信する
@item @ref{remote_foreground(), , remote_foreground}(@{server@}) @tab 数値 @tab Vim サーバーを前面に出す
@item @ref{remote_peek(), , remote_peek}(@{serverid@} [, @{retvar@}]) @tab 数値 @tab 返信文字列を確認する
@item @ref{remote_read(), , remote_read}(@{serverid@} [, @{timeout@}]) @tab 文字列 @tab 返信文字列を読み込む
@item @ref{remote_send(), , remote_send}(@{server@}, @{string@} [, @{idvar@}]) @tab 文字列 @tab キーシーケンスを送信する
@item @ref{remote_startserver(), , remote_startserver}(@{name@}) @tab なし @tab サーバー @{name@} になる
@item @tab 文字列 @tab キーシーケーンスを送信する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
remove({list}, {idx} [, {end}])	any	remove items {idx}-{end} from {list}
remove({dict}, {key})		any	remove entry {key} from {dict}
rename({from}, {to})		Number	rename (move) file from {from} to {to}
repeat({expr}, {count})		String	repeat {expr} {count} times
resolve({filename})		String	get filename a shortcut points to
reverse({list})			List	reverse {list} in-place
round({expr})			Float	round off {expr}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{remove(), , remove}(@{list@}, @{idx@} [, @{end@}]) @tab 任意 @tab @{list@} から @{idx@} と @{end@} 間の要素を削除
@item @ref{remove(), , remove}(@{dict@}, @{key@}) @tab 任意 @tab @{dict@} から要素 @{key@} を削除
@item @ref{rename(), , rename}(@{from@}, @{to@}) @tab 数値 @tab @{file@} から @{to@} へファイル名変更
@item @ref{repeat(), , repeat}(@{expr@}, @{count@}) @tab 文字列 @tab @{expr@} を @{count@} 回繰り返す
@item @ref{resolve(), , resolve}(@{filename@}) @tab 文字列 @tab ショートカットが指す先のファイル名
@item @ref{reverse(), , reverse}(@{list@}) @tab 文字列 @tab @{list@} をその場で反転させる
@item @ref{round(), , round}(@{expr@}) @tab 浮動小数点数 @tab @{expr@} を四捨五入する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
screenattr({row}, {col})	Number	attribute at screen position
screenchar({row}, {col})	Number	character at screen position
screencol()			Number	current cursor column
screenrow()			Number	current cursor row
search({pattern} [, {flags} [, {stopline} [, {timeout}]]])
				Number	search for {pattern}
searchdecl({name} [, {global} [, {thisblock}]])
				Number	search for variable declaration
searchpair({start}, {middle}, {end} [, {flags} [, {skip} [...]]])
				Number	search for other end of start/end pair
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip} [...]]])
				List	search for other end of start/end pair
searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]])
				List	search for {pattern}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{screenattr(), , screenattr}(@{row@}, @{col@}) @tab 数値 @tab スクリーン位置の属性
@item @ref{screenchar(), , screenchar}(@{row@}, @{col@}) @tab 数値 @tab スクリーン位置の文字
@item @ref{screencol(), , screencol}() @tab 数値 @tab 現在のカーソル列
@item @ref{screenrow(), , screenrow}() @tab 数値 @tab 現在のカーソル行
@item @ref{search(), , search}(@{pattern@} [, @{flags@} [, @{stopline@} [, @{timeout@}]]]) @tab 数値 @tab @{pattern@} を検索する
@item @ref{searchdecl(), , searchdecl}(@{name@} [, @{global@} [, @{thisblock@}]]) @tab 数値 @tab 変数の宣言を検索
@item @ref{searchpair(), , searchpair}(@{start@}, @{middle@}, @{end@} [, @{flags@} [, @{skip@} [...]]]) @tab 数値 @tab 開始/終端のペアの他方を検索
@item @ref{searchpairpos(), , searchpairpos}(@{start@}, @{middle@}, @{end@} [, @{flags@} [, @{skip@} [...]]]) @tab リスト @tab 開始/終端のペアの他方を検索
@item @ref{searchpos(), , searchpos}(@{pattern@} [, @{flags@} [, @{stopline@} [, @{timeout@}]]]) @tab リスト @tab @{pattern@} を検索
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
server2client({clientid}, {string})
				Number	send reply string
serverlist()			String	get a list of available servers
setbufline({expr}, {lnum}, {line})
				Number	set line {lnum} to {line} in buffer
					{expr}
setbufvar({expr}, {varname}, {val})
				none	set {varname} in buffer {expr} to {val}
setcharsearch({dict})		Dict	set character search from {dict}
setcmdpos({pos})		Number	set cursor position in command-line
setfperm({fname}, {mode})	Number	set {fname} file permissions to {mode}
setline({lnum}, {line})		Number	set line {lnum} to {line}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{server2client(), , server2client}(@{clientid@}, @{string@}) @tab 数値 @tab 返信文字列を送信する
@item @ref{serverlist(), , serverlist}() @tab 文字列 @tab 利用可能なサーバーのリストを取得
@item @ref{setbufline(), , setbufline}(@{expr@}, @{lnum@}, @{line@}) @tab 数値 @tab バッファ内の @{expr@} で @{line@} に 行 @{lnum@} をセット
@item @ref{setbufvar(), , setbufvar}(@{expr@}, @{varname@}, @{val@}) @tab なし @tab バッファ @{expr@} 内の変数 @{varname@} に @{val@} をセット
@item @ref{setcharsearch(), , setcharsearch}(@{dict@}) @tab 辞書 @tab 文字検索を @{dict@} に設定
@item @ref{setcmdpos(), , setcmdpos}(@{pos@}) @tab 数値 @tab コマンドライン内のカーソル位置を設定
@item @ref{setfperm(), , setfperm}(@{fname@}, @{mode@}) @tab 数値 @tab ファイル @{fname@} のパーミッションを @{mode@} に設定
@item @ref{setline(), , setline}(@{lnum@}, @{line@}) @tab 数値 @tab 行 @{lnum@} に @{line@} (文字列) をセット
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
setloclist({nr}, {list} [, {action} [, {what}]])
				Number	modify location list using {list}
setmatches({list})		Number	restore a list of matches
setpos({expr}, {list})		Number	set the {expr} position to {list}
setqflist({list} [, {action} [, {what}]])
				Number	modify quickfix list using {list}
setreg({n}, {v} [, {opt}])	Number	set register to value and type
settabvar({nr}, {varname}, {val}) none	set {varname} in tab page {nr} to {val}
settabwinvar({tabnr}, {winnr}, {varname}, {val})
				none	set {varname} in window {winnr} in tab
					page {tabnr} to {val}
setwinvar({nr}, {varname}, {val}) none	set {varname} in window {nr} to {val}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{setloclist(), , setloclist}(@{nr@}, @{list@} [, @{action@} [, @{what@}]]) @tab 数値 @tab @{list@} を使ってロケーションリストを変更
@item @ref{setmatches(), , setmatches}(@{list@}) @tab 数値 @tab マッチのリストを復元する
@item @ref{setpos(), , setpos}(@{expr@}, @{list@}) @tab なし @tab @{expr@} の位置を @{list@} にする
@item @ref{setqflist(), , setqflist}(@{list@} [, @{action@} [, @{what@}]]) @tab 数値 @tab @{list@} を使って QuickFix リストを変更
@item @ref{setreg(), , setreg}(@{n@}, @{v@} [, @{opt@}]) @tab 数値 @tab レジスタの値とタイプを設定
@item @ref{settabvar(), , settabvar}(@{nr@}, @{varname@}, @{val@}) @tab なし @tab タブページ @{nr@} の変数 @{varname@} を @{val@} に設定する
@item @ref{settabwinvar(), , settabwinvar}(@{tabnr@}, @{winnr@}, @{varname@}, @{val@}) @tab なし @tab タブページ @{tabnr@} 内のウィンドウ @{winnr@} の変数 @{varname@} に @{val@} をセット
@item @ref{setwinvar(), , setwinvar}(@{nr@}, @{varname@}, @{val@}) @tab なし @tab ウィンドウ @{nr@} の変数 @{varname@} に @{val@} をセット
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
sha256({string})		String	SHA256 checksum of {string}
shellescape({string} [, {special}])
				String	escape {string} for use as shell
					command argument
shiftwidth()			Number	effective value of 'shiftwidth'
simplify({filename})		String	simplify filename as much as possible
sin({expr})			Float	sine of {expr}
sinh({expr})			Float	hyperbolic sine of {expr}
sort({list} [, {func} [, {dict}]])
				List	sort {list}, using {func} to compare
soundfold({word})		String	sound-fold {word}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{sha256(), , sha256}(@{string@}) @tab 文字列 @tab @{string@} の SHA256 チェックサム
@item @ref{shellescape(), , shellescape}(@{string@} [, @{special@}]) @tab 文字列 @tab @{string@} をシェルコマンド引数として使うためにエスケープする。
@item @ref{shiftwidth(), ,shiftwidth}() @tab 数値 @tab 実際に使用される '@option{shiftwidth}' の値
@item @ref{simplify(), , simplify}(@{filename@}) @tab 文字列 @tab ファイル名を可能なかぎり簡略化する
@item @ref{sin(), , sin}(@{expr@}) @tab 浮動小数点数 @tab @{expr@} の正弦(サイン)
@item @ref{sinh(), , sinh}(@{expr@}) @tab 浮動小数点数 @tab @{expr@} のハイパボリックサイン
@item @ref{sort(), , sort}(@{list@} [, @{func@} [, @{dict@}]]) @tab リスト @tab 比較に @{func@} を使って @{list@} をソートする
@item @ref{soundfold(), , soundfold}(@{word@}) @tab 文字列 @tab @{word@} の sound-fold
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
spellbadword()			String	badly spelled word at cursor
spellsuggest({word} [, {max} [, {capital}]])
				List	spelling suggestions
split({expr} [, {pat} [, {keepempty}]])
				List	make |List| from {pat} separated {expr}
sqrt({expr})			Float	square root of {expr}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{spellbadword(), , spellbadword}() @tab 文字列 @tab カーソル位置のスペルミスした単語
@item @ref{spellsuggest(), , spellsuggest}(@{word@} [, @{max@} [, @{capital@}]]) @tab リスト @tab スペリング補完
@item @ref{split(), , split}(@{expr@} [, @{pat@} [, @{keepempty@}]]) @tab リスト @tab @{expr@} を @{pat@} で区切ってリスト |@ref{List}| を作る
@item @ref{sqrt(), , sqrt}(@{expr@}) @tab 浮動小数点数 @tab @{expr@} の平方根
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
str2float({expr})		Float	convert String to Float
str2nr({expr} [, {base}])	Number	convert String to Number
strchars({expr} [, {skipcc}])	Number	character length of the String {expr}
strcharpart({str}, {start} [, {len}])
				String	{len} characters of {str} at {start}
strdisplaywidth({expr} [, {col}]) Number display length of the String {expr}
strftime({format} [, {time}])	String	time in specified format
strgetchar({str}, {index})	Number	get char {index} from {str}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{str2float(), , str2float}(@{expr@}) @tab 浮動小数点数 @tab 文字列を浮動小数点数に変換する
@item @ref{str2nr(), , str2nr}(@{expr@} [, @{base@}]) @tab 数値 @tab 文字列を数値に変換する
@item @ref{strchars(), , strchars}(@{expr@} [, @{skipcc@}]) @tab 数値 @tab 文字列 @{expr@} の文字の数
@item @ref{strcharpart(), , strcharpart}(@{str@}, @{start@} [, @{len@}]) @tab 文字列 @tab @{str@} の @{start@} から長さ @{len@} の文字列を得る
@item @ref{strdisplaywidth(), , strdisplaywidth}(@{expr@} [, @{col@}]) @tab 数値 @tab 文字列 @{expr@} の表示幅
@item @ref{strftime(), , strftime}(@{format@} [, @{time@}]) @tab 文字列 @tab 指定されたフォーマットでの時刻
@item @ref{strgetchar(), , strgetchar}(@{str@}, @{index@}) @tab 数値 @tab @{str@} から @{index@} 番目の文字インデックスを得る
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
stridx({haystack}, {needle} [, {start}])
				Number	index of {needle} in {haystack}
string({expr})			String	String representation of {expr} value
strlen({expr})			Number	length of the String {expr}
strpart({str}, {start} [, {len}])
				String	{len} characters of {str} at {start}
strridx({haystack}, {needle} [, {start}])
				Number	last index of {needle} in {haystack}
strtrans({expr})		String	translate string to make it printable
strwidth({expr})		Number	display cell length of the String {expr}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{stridx(), , stridx}(@{haystack@}, @{needle@} [, @{start@}]) @tab 数値 @tab @{haystack@} 内の @{needle@} のインデックス
@item @ref{string(), , string}(@{expr@}) @tab 文字列 @tab @{expr@} の値の文字列表現
@item @ref{strlen(), , strlen}(@{expr@}) @tab 数値 @tab 文字列 @{expr@} の長さ
@item @ref{strpart(), , strpart}(@{src@}, @{start@} [, @{len@}]) @tab 文字列 @tab @{src@} 内 @{start@} から長さ @{len@} の部分
@item @ref{strridx(), , strridx}(@{haystack@}, @{needle@} [, @{start@}]) @tab 数値 @tab @{haystack@} 内の最後の @{needle@} のインデックス
@item @ref{strtrans(), , strtrans}(@{expr@}) @tab 文字列 @tab 文字列を表示可能に変更
@item @ref{strwidth(), , strwidth}(@{expr@}) @tab 数値 @tab 文字列 @{expr@} の表示セル幅
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
submatch({nr} [, {list}])	String or List
					specific match in ":s" or substitute()
substitute({expr}, {pat}, {sub}, {flags})
				String	all {pat} in {expr} replaced with {sub}
swapinfo({fname})		Dict	information about swap file {fname}
synID({lnum}, {col}, {trans})	Number	syntax ID at {lnum} and {col}
synIDattr({synID}, {what} [, {mode}])
				String	attribute {what} of syntax ID {synID}
synIDtrans({synID})		Number	translated syntax ID of {synID}
synconcealed({lnum}, {col})	List	info about concealing
synstack({lnum}, {col})		List	stack of syntax IDs at {lnum} and {col}
system({expr} [, {input}])	String	output of shell command/filter {expr}
systemlist({expr} [, {input}])	List	output of shell command/filter {expr}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{submatch(), , submatch}(@{nr@} [, @{list@}]) @tab 文字列/リスト @tab "@command{:s}" や substitute() における特定のマッチ
@item @ref{substitute(), , substitute}(@{expr@}, @{pat@}, @{sub@}, @{flags@}) @tab 文字列 @tab @{expr@} の @{pat@} を @{sub@} に置換え
@item @ref{swapinfo(), , swapinfo}(@{fname@}) @tab 辞書 @tab スワップファイル @{fname@} に関する情報
@item @ref{synID(), , synID}(@{line@}, @{col@}, @{trans@}) @tab 数値 @tab @{line@} と @{col@} の syntax ID を取得
@item @ref{synIDattr(), , synIDattr}(@{synID@}, @{what@} [, @{mode@}]) @tab 文字列 @tab syntax ID @{synID@} の属性 @{what@} を取得
@item @ref{synIDtrans(), , synIDtrans}(@{synID@}) @tab 数値 @tab @{synID@} の翻訳された syntax ID
@item @ref{synconcealed(), , synconcealed}(@{lnum@}, @{col@}) @tab リスト @tab Conceal の情報
@item @ref{synstack(), , synstack}(@{lnum@}, @{col@}) @tab リスト @tab @{lnum@} 行 @{col@} 列目における構文 ID のスタック
@item @ref{system(), , system}(@{expr@} [, @{input@}]) @tab 文字列 @tab シェルコマンド @{expr@} の出力結果
@item @ref{systemlist(), , systemlist}(@{expr@} [, @{input@}]) @tab リスト @tab シェルコマンド @{expr@} の出力結果
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
tabpagebuflist([{arg}])		List	list of buffer numbers in tab page
tabpagenr([{arg}])		Number	number of current or last tab page
tabpagewinnr({tabarg} [, {arg}]) Number	number of current window in tab page
taglist({expr} [, {filename}])	List	list of tags matching {expr}
tagfiles()			List	tags files used
tan({expr})			Float	tangent of {expr}
tanh({expr})			Float	hyperbolic tangent of {expr}
tempname()			String	name for a temporary file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{tabpagebuflist(), , tabpagebuflist}([@{arg@}]) @tab リスト @tab タブページ内のバッファ番号のリスト
@item @ref{tabpagenr(), , tabpagenr}([@{arg@}]) @tab 数値 @tab 現在または最後のタブページの番号
@item @ref{tabpagewinnr(), , tabpagewinnr}(@{tabarg@} [, @{arg@}]) @tab 数値 @tab タブページ内の現在のウィンドウの番号
@item @ref{taglist(), , taglist}(@{expr@} [, @{filename@}]) @tab リスト @tab @{expr@} にマッチするタグのリスト
@item @ref{tagfiles(), , tagfiles}() @tab リスト @tab 使用しているタグファイルのリスト
@item @ref{tan(), , tan}(@{expr@}) @tab 浮動小数点数 @tab @{expr@} のタンジェント
@item @ref{tanh(), , tanh}(@{expr@}) @tab 浮動小数点数 @tab @{expr@} のハイパボリックタンジェント
@item @ref{tempname(), , tempname}() @tab 文字列 @tab テンポラリファイルの名前
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
term_dumpdiff({filename}, {filename} [, {options}])
				Number  display difference between two dumps
term_dumpload({filename} [, {options}])
				Number	displaying a screen dump
term_dumpwrite({buf}, {filename} [, {options}])
				none	dump terminal window contents
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{term_dumpdiff(), , term_dumpdiff}(@{filename@}, @{filename@} [, @{options@}]) @tab 数値 @tab 2 つのダンプファイルの差分を表示する
@item @ref{term_dumpload(), , term_dumpload}(@{filename@} [, @{options@}])  @tab 数値 @tab スクリーンダンプを表示する
@item @ref{term_dumpwrite(), , term_dumpwrite}(@{buf@}, @{filename@} [, @{options@}]) @tab なし @tab ターミナルウィンドウの内容をダンプする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
term_getaltscreen({buf})	Number	get the alternate screen flag
term_getansicolors({buf})	List	get ANSI palette in GUI color mode
term_getattr({attr}, {what})	Number	get the value of attribute {what}
term_getcursor({buf})		List	get the cursor position of a terminal
term_getjob({buf})		Job	get the job associated with a terminal
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{term_getaltscreen(), , term_getaltscreen}(@{buf@}) @tab 数値 @tab 代替スクリーンのフラグを取得する
@item @ref{term_getansicolors(), , term_getansicolors}(@{buf@}) @tab リスト @tab GUI カラーモードで ANSI パレットを取得する
@item @ref{term_getattr(), , term_getattr}(@{attr@}, @{what@}) @tab 数値 @tab @{what@} 属性の値を取得する
@item @ref{term_getcursor(), , term_getcursor}(@{buf@}) @tab リスト @tab ターミナルのカーソル位置を取得する
@item @ref{term_getjob(), , term_getjob}(@{buf@}) @tab ジョブ @tab ターミナルと関連するジョブを取得する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
term_getline({buf}, {row})	String	get a line of text from a terminal
term_getscrolled({buf})		Number	get the scroll count of a terminal
term_getsize({buf})		List	get the size of a terminal
term_getstatus({buf})		String	get the status of a terminal
term_gettitle({buf})		String	get the title of a terminal
term_gettty({buf}, [{input}])	String	get the tty name of a terminal
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{term_getline(), , term_getline}(@{buf@}, @{row@}) @tab 文字列 @tab ターミナルからテキストの行を取得する
@item @ref{term_getscrolled(), , term_getscrolled}(@{buf@}) @tab 数値 @tab ターミナルのスクロールカウントを取得する
@item @ref{term_getsize(), , term_getsize}(@{buf@}) @tab リスト @tab ターミナルのサイズを取得する
@item @ref{term_getstatus(), , term_getstatus}(@{buf@}) @tab 文字列 @tab ターミナルのステータスを取得する
@item @ref{term_gettitle(), , term_gettitle}(@{buf@}) @tab 文字列 @tab ターミナルのタイトルを取得する
@item @ref{term_gettty(), , term_gettty}(@{buf@}, [@{input@}]) @tab 文字列 @tab ターミナルの tty 名を取得する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
term_list()			List	get the list of terminal buffers
term_scrape({buf}, {row})	List	get row of a terminal screen
term_sendkeys({buf}, {keys})	none	send keystrokes to a terminal
term_setansicolors({buf}, {colors})
				none	set ANSI palette in GUI color mode
term_setkill({buf}, {how})	none	set signal to stop job in terminal
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{term_list(), , term_list}() @tab リスト @tab ターミナルバッファのリストを取得する
@item @ref{term_scrape(), , term_scrape}(@{buf@}, @{row@}) @tab リスト @tab ターミナルスクリーンの桁を取得する
@item @ref{term_sendkeys(), , term_sendkeys}(@{buf@}, @{keys@}) @tab なし @tab ーミナルにキーストロークを送る
@item @ref{term_setansicolors(), , term_setansicolors}(@{buf@}, @{colors@}) @tab なし @tab GUI カラーモードで ANSI パレットを設定する
@item @ref{term_setkill(), , term_setkill}(@{buf@}, @{how@}) @tab なし @tab ターミナルのジョブを停止するシグナルを設定する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
term_setrestore({buf}, {command}) none	set command to restore terminal
term_setsize({buf}, {rows}, {cols})
				none	set the size of a terminal
term_start({cmd}, {options})	Job	open a terminal window and run a job
term_wait({buf} [, {time}])	Number  wait for screen to be updated
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{term_setrestore(), , term_setrestore}(@{buf@}, @{command@}) @tab なし @tab ターミナルを復帰するコマンドを設定する
@item @ref{term_setsize(), , term_setsize}(@{buf@}, @{rows@}, @{cols@}) @tab なし @tab ターミナルのサイズを設定する
@item @ref{term_start(), , term_start}(@{cmd@}, @{options@}) @tab ジョブ @tab ターミナルウィンドウを開いてジョブを開始する
@item @ref{term_wait(), , term_wait}(@{buf@} [, @{time@}]) @tab 数値 @tab スクリーンがアップデートされるまで待つ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
test_alloc_fail({id}, {countdown}, {repeat})
				none	make memory allocation fail
test_autochdir()		none	enable 'autochdir' during startup
test_feedinput()		none	add key sequence to input buffer
test_garbagecollect_now()	none	free memory right now for testing
test_ignore_error({expr})	none	ignore a specific error
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{test_alloc_fail(), , test_alloc_fail}(@{id@}, @{countdown@}, @{repeat@}) @tab なし @tab メモリの確保を失敗にさせる
@item @ref{test_autochdir(), , test_autochdir}() @tab なし @tab 起動時に '@option{autochdir}' を有効にする
@item @ref{test_feedinput(), , test_feedinput}() @tab なし @tab キーシーケンスを入力バッファに加える
@item @ref{test_garbagecollect_now(), , test_garbagecollect_now}() @tab なし @tab テスト用に直ちにメモリを解放する
@item @ref{test_ignore_error(), , test_ignore_error}(@{expr@}) @tab なし @tab 特定のエラーを無視する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
test_null_channel()		Channel	null value for testing
test_null_dict()		Dict	null value for testing
test_null_job()			Job	null value for testing
test_null_list()		List	null value for testing
test_null_partial()		Funcref	null value for testing
test_null_string()		String	null value for testing
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{test_null_channel(), , test_null_channel}() @tab チャネル @tab テスト用の null 値
@item @ref{test_null_dict(), , test_null_dict}() @tab 辞書 @tab テスト用の null 値
@item @ref{test_null_job(), , test_null_job}() @tab ジョブ @tab テスト用の null 値
@item @ref{test_null_list(), , test_null_list}() @tab リスト @tab テスト用の null 値
@item @ref{test_null_partial(), , test_null_partial}() @tab Funcref @tab テスト用の null 値
@item @ref{test_null_string(), , test_null_string}() @tab 文字列 @tab テスト用の null 値
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
test_override({expr}, {val})    none	test with Vim internal overrides
test_settime({expr})		none	set current time for testing
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{test_override(), , test_override}(@{expr@}, @{val@}) @tab なし @tab Vim の内部処理を置き換えてテストする
@item @ref{test_settime(), , test_settime}(@{expr@}) @tab なし @tab テスト用に現在の時刻を設定する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
timer_info([{id}])		List	information about timers
timer_pause({id}, {pause})	none	pause or unpause a timer
timer_start({time}, {callback} [, {options}])
				Number	create a timer
timer_stop({timer})		none	stop a timer
timer_stopall()			none	stop all timers
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{timer_info(), , timer_info}([@{id@}]) @tab リスト @tab タイマーに関する情報
@item @ref{timer_pause(), , timer_pause}(@{id@}, @{pause@}) @tab なし @tab タイマーの一時停止または一時停止解除
@item @ref{timer_start(), , timer_start}(@{time@}, @{callback@} [, @{options@}]) @tab 数値 @tab タイマーを作成する
@item @ref{timer_stop(), , timer_stop}(@{timer@}) @tab なし @tab タイマーを停止する
@item @ref{timer_stopall(), , timer_stopall}() @tab なし @tab すべてのタイマーを停止する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
tolower({expr})			String	the String {expr} switched to lowercase
toupper({expr})			String	the String {expr} switched to uppercase
tr({src}, {fromstr}, {tostr})	String	translate chars of {src} in {fromstr}
					to chars in {tostr}
trim({text} [, {mask}])		String	trim characters in {mask} from {text}
trunc({expr})			Float	truncate Float {expr}
type({name})			Number	type of variable {name}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{tolower(), , tolower}(@{expr@}) @tab 文字列 @tab 文字列 @{expr@} を小文字にする
@item @ref{toupper(), , toupper}(@{expr@}) @tab 文字列 @tab 文字列 @{expr@} を大文字にする
@item @ref{tr(), , tr}(@{src@}, @{fromstr@}, @{tostr@}) @tab 文字列 @tab @{src@} 中に現れる文字 @{fromstr@} を @{tostr@} に変換する
@item @ref{trim(), , trim}(@{text@} [, @{mask@}]) @tab 文字列 @tab @{text@} から @{mask@} の文字を切り取る
@item @ref{trunc(), , trunc}(@{expr@}) @tab 浮動小数点数 @tab 浮動小数点数 @{expr@} を切り詰める
@item @ref{type(), , type}(@{name@}) @tab 数値 @tab 変数 @{name@} の型
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
undofile({name})		String	undo file name for {name}
undotree()			List	undo file tree
uniq({list} [, {func} [, {dict}]])
				List	remove adjacent duplicates from a list
values({dict})			List	values in {dict}
virtcol({expr})			Number	screen column of cursor or mark
visualmode([expr])		String	last visual mode used
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{undofile(), , undofile}(@{name@}) @tab 文字列 @tab @{name@} に対するアンドゥファイルの名前
@item @ref{undotree(), , undotree}() @tab リスト @tab アンドゥファイルツリー
@item @ref{uniq(), , uniq}(@{list@} [, @{func@} [, @{dict@}]]) @tab リスト @tab リストから隣接した重複を削除
@item @ref{values(), , values}(@{dict@}) @tab リスト @tab @{dict@} の値のリスト
@item @ref{virtcol(), , virtcol}(@{expr@}) @tab 数値 @tab カーソルのスクリーンカラム位置
@item @ref{visualmode(), , visualmode}([expr]) @tab 文字列 @tab 最後に使われたビジュアルモード
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
wildmenumode()			Number	whether 'wildmenu' mode is active
win_findbuf({bufnr})		List	find windows containing {bufnr}
win_getid([{win} [, {tab}]])	Number	get window ID for {win} in {tab}
win_gotoid({expr})		Number	go to window with ID {expr}
win_id2tabwin({expr})		List	get tab and window nr from window ID
win_id2win({expr})		Number	get window nr from window ID
win_screenpos({nr})		List	get screen position of window {nr}
winbufnr({nr})			Number	buffer number of window {nr}
wincol()			Number	window column of the cursor
winheight({nr})			Number	height of window {nr}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{wildmenumode(), , wildmenumode}() @tab 数値 @tab '@option{wildmenu}' モードが有効かどうか
@item @ref{win_findbuf(), , win_findbuf}(@{bufnr@}) @tab リスト @tab @{bufnr@} を含むウィンドウを見つける
@item @ref{win_getid(), , win_getid}([@{win@} [, @{tab@}]]) @tab 数値 @tab @{tab@} の @{win@} のウィンドウ ID を取得
@item @ref{win_gotoid(), , win_gotoid}(@{expr@}) @tab 数値 @tab ID @{expr@} のウィンドウに行く
@item @ref{win_id2tabwin(), , win_id2tabwin}(@{expr@}) @tab リスト @tab ウィンドウ ID からタブとウィンドウ nr 取得
@item @ref{win_id2win(), , win_id2win}(@{expr@}) @tab 数値 @tab ウィンドウ ID からウィンドウ nr 取得
@item @ref{win_screenpos(), , win_screenpos}(@{nr@}) @tab リスト @tab ウィンドウ @{nr@} のスクリーン位置を取得
@item @ref{winbufnr(), , winbufnr}(@{nr@}) @tab 数値 @tab ウィンドウ @{nr@} のバッファ番号
@item @ref{wincol(), , wincol}() @tab 数値 @tab カーソル位置のウィンドウ桁
@item @ref{winheight(), , winheight}(@{nr@}) @tab 数値 @tab ウィンドウ @{nr@} の高さ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
winlayout([{tabnr}])		List	layout of windows in tab {tabnr}
winline()			Number	window line of the cursor
winnr([{expr}])			Number	number of current window
winrestcmd()			String	returns command to restore window sizes
winrestview({dict})		none	restore view of current window
winsaveview()			Dict	save view of current window
winwidth({nr})			Number	width of window {nr}
wordcount()			Dict	get byte/char/word statistics
writefile({list}, {fname} [, {flags}])
				Number	write list of lines to file {fname}
xor({expr}, {expr})		Number	bitwise XOR
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{winlayout(), , winlayout}([@{tabnr@}]) @tab リスト @tab タブ @{tabnr@} 中のウィンドウレイアウト
@item @ref{winline(), , winline}() @tab 数値 @tab カーソル位置のウィンドウ行
@item @ref{winnr(), , winnr}([@{expr@}]) @tab 数値 @tab 現在のウィンドウの番号
@item @ref{winrestcmd(), , winrestcmd}() @tab 文字列 @tab ウィンドウサイズを復元するコマンド
@item @ref{winrestview(), , winrestview}(@{dict@}) @tab なし @tab 現在のウィンドウのビューを復元
@item @ref{winsaveview(), , winsaveview}() @tab 辞書 @tab 現在のウィンドウのビューを保存
@item @ref{winwidth(), , winwidth}(@{nr@}) @tab 数値 @tab ウィンドウ @{nr@} の幅を取得
@item @ref{wordcount(), , wordcount}() @tab 辞書 @tab バイト/文字/単語の統計情報を取得
@item @ref{writefile(), , writefile}(@{list@}, @{fname@} [, @{flags@}]) @tab 数値 @tab 行のリストをファイル @{fname@} に書き込む
@item @ref{xor(), , xor}(@{expr@}, @{expr@}) @tab 数値 @tab ビット排他的論理和
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
abs({expr})							*abs()*
		Return the absolute value of {expr}.  When {expr} evaluates to
		a |Float| abs() returns a |Float|.  When {expr} can be
		converted to a |Number| abs() returns a |Number|.  Otherwise
		abs() gives an error message and returns -1.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{abs()}
@findex abs()
@item abs(@{expr@})
@{expr@} の絶対値を返す。@{expr@} の値が浮動小数点数 |@ref{Float}| である場合は浮動小数点数を返す。@{expr@} が数値 |@ref{Number}| に変換可能な場合は abs() は数値を返す。それ以外の場合はエラーメッセージを表示し、-1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
			echo abs(1.456)
<			1.456  >
			echo abs(-5.456)
<			5.456  >
			echo abs(-4)
<			4
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
echo abs(1.456)
1.456
echo abs(-5.456)
5.456
echo abs(-4)
4
@end example
@{|@ref{+float}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
acos({expr})							*acos()*
		Return the arc cosine of {expr} measured in radians, as a
		|Float| in the range of [0, pi].
		{expr} must evaluate to a |Float| or a |Number| in the range
		[-1, 1].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{acos()}
@findex acos()
@item acos(@{expr@})
@{expr@} の逆余弦 (アークコサイン) をラジアンで返す。値は [0, pi] の範囲の浮動小数点数 (|@ref{Float}|)。@{expr@} は [-1, 1] の範囲の浮動小数点数 (|@ref{Float}|) か数値 (|@ref{Number}|) でなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
			:echo acos(0)
<			1.570796 >
			:echo acos(-0.5)
<			2.094395
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
:echo acos(0)
1.570796
:echo acos(-0.5)
2.094395
@end example
@{|@ref{+float}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
add({list}, {expr})					*add()*
		Append the item {expr} to |List| {list}.  Returns the
		resulting |List|.  Examples: >
			:let alist = add([1, 2, 3], item)
			:call add(mylist, "woodstock")
<		Note that when {expr} is a |List| it is appended as a single
		item.  Use |extend()| to concatenate |Lists|.
		Use |insert()| to add an item at another position.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{add()}
@findex add()
@item add(@{list@}, @{expr@})
リスト |@ref{List}| @{list@} の末尾に要素 @{expr@} を追加する。結果のリストを返す。例:
@example
:let alist = add([1, 2, 3], item)
:call add(mylist, "woodstock")
@end example
@quotation
@strong{Note:} @*
@{expr@} がリストのときは、1 個の要素として追加される。リストを連結するには |@ref{extend()}| を使う。他の位置に要素を追加するには |@ref{insert()}| を使う。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
and({expr}, {expr})					*and()*
		Bitwise AND on the two arguments.  The arguments are converted
		to a number.  A List, Dict or Float argument causes an error.
		Example: >
			:let flag = and(bits, 0x80)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{and()}
@findex and()
@item and(@{expr@}, @{expr@})
2 つの引数のビット論理積。引数は数値に変換される。リスト、辞書、浮動小数点数を指定するとエラーになる。例:
@example
:let flag = and(bits, 0x80)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
append({lnum}, {expr})					*append()*
		When {expr} is a |List|: Append each item of the |List| as a
		text line below line {lnum} in the current buffer.
		Otherwise append {expr} as one text line below line {lnum} in
		the current buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{append()}
@findex append()
@item append(@{lnum@}, @{expr@})
@{expr@} がリスト |@ref{List}| のときは、各要素をカレントバッファの @{lnum@} 行目以降にテキストとして追加する。リストでないときは、@{expr@} をテキストとしてカレントバッファの @{lnum@} 行目以降にテキストとして追加する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{lnum} can be zero to insert a line before the first one.
		Returns 1 for failure ({lnum} out of range or out of memory),
		0 for success.  Example: >
			:let failed = append(line('$'), "# THE END")
			:let failed = append(0, ["Chapter 1", "the beginning"])
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{lnum@}は 0 でもよく、その場合は 1 行目の前に行を挿入する。失敗した場合は 1 を返す(@{lnum@} が不正な範囲であるか、メモリ不足)。成功なら 0 を返す。例:
@example
:let failed = append(line('$'), "# THE END")
:let failed = append(0, ["Chapter 1", "the beginning"])
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
appendbufline({expr}, {lnum}, {text})			*appendbufline()*
		Like |append()| but append the text in buffer {expr}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{appendbufline()}
@findex appendbufline()
@item appendbufline(@{expr@}, @{lnum@}, @{text@})
|@ref{append()}| と同じだが、@{expr@} バッファのテキストを追加する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For the use of {expr}, see |bufname()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr@} の使用については |@ref{bufname()}| を参照
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{lnum} is used like with |append()|.  Note that using |line()|
		would use the current buffer, not the one appending to.
		Use "$" to append at the end of the buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{lnum@} は |@ref{append()}| と同じように使われる。
@quotation
@strong{Note:} @*
|@ref{line()}| の使用はカレントバッファを使用し、それは追加しないことに注意。バッファの最後に追加するには "$" を使う。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		On success 0 is returned, on failure 1 is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
成功すると 0 を返し、失敗すると 1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {expr} is not a valid buffer or {lnum} is not valid, an
		error message is given. Example: >
			:let failed = appendbufline(13, 0, "# THE START")
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もしも @{expr@} が正しいバッファでなかったり、@{lnum@} が正しくなければ、エラーメッセージが与えられる。例:
@example
:let failed = appendbufline(13, 0, "# THE START")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*argc()*
argc()		The result is the number of files in the argument list of the
		current window.  See |arglist|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{argc()}
@findex argc()
@item argc()
カレントウィンドウの引数リスト内の、ファイルの数を返す。|@ref{arglist}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*argidx()*
argidx()	The result is the current index in the argument list.  0 is
		the first file.  argc() - 1 is the last one.  See |arglist|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{argidx()}
@findex argidx()
@item argidx()
引数リスト内の現在のインデックスを返す。最初のファイルは 0 となる。argc() - 1 が最後のファイルとなる。|@ref{arglist}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*arglistid()*
arglistid([{winnr} [, {tabnr}]])
		Return the argument list ID.  This is a number which
		identifies the argument list being used.  Zero is used for the
		global argument list.  See |arglist|.
		Return -1 if the arguments are invalid.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{arglistid()}
@findex arglistid()
@item arglistid([@{winnr@} [, @{tabnr@}]])
引数リストの ID を返す。値は引数リストを区別するための数値である。ゼロはグローバル引数リストを意味する。|@ref{arglist}| 参照。引数が無効な場合は -1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Without arguments use the current window.
		With {winnr} only use this window in the current tab page.
		With {winnr} and {tabnr} use the window in the specified tab
		page.
		{winnr} can be the window number or the |window-ID|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数を指定しなかった場合はカレントウィンドウが使われる。@{winnr@} を指定した場合はカレントタブページ内のウィンドウが使われる。@{winnr@} と @{tabnr@} を指定した場合は指定したタブページ内のウィンドウが使われる。@{winnr@} にはウィンドウ番号または |@ref{window-ID}| が使える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*argv()*
argv([{nr}])	The result is the {nr}th file in the argument list of the
		current window.  See |arglist|.  "argv(0)" is the first one.
		Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{argv()}
@findex argv()
@item argv([@{nr@}])
結果は引数リスト内の @{nr@} 番目のファイル。|@ref{arglist}| を参照。 "argv(0)" は一番最初のファイルを示す。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:let i = 0
	:while i < argc()
	:  let f = escape(fnameescape(argv(i)), '.')
	:  exe 'amenu Arg.' . f . ' :e ' . f . '<CR>'
	:  let i = i + 1
	:endwhile
<		Without the {nr} argument a |List| with the whole |arglist| is
		returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let i = 0
:while i < argc()
:  let f = escape(fnameescape(argv(i)), '.')
:  exe 'amenu Arg.' . f . ' :e ' . f . '<CR>'
:  let i = i + 1
:endwhile
@end verbatim
引数 @{nr@} が指定されなかった場合は、引数リスト |@ref{arglist}| 全体を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
assert_beeps({cmd})					*assert_beeps()*
		Run {cmd} and add an error message to |v:errors| if it does
		NOT produce a beep or visual bell.
		Also see |assert_fails()| and |assert-return|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{assert_beeps()}
@findex assert_beeps()
@item assert_beeps(@{cmd@})
@{cmd@} を実行し、もしもビープやビジュアルベルを@strong{生じない}ならば、エラーメッセージを |@ref{v:errors}| に追加する。|@ref{assert_fails()}| と |@ref{assert-return}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*assert_equal()*
assert_equal({expected}, {actual} [, {msg}])
		When {expected} and {actual} are not equal an error message is
		added to |v:errors| and 1 is returned.  Otherwise zero is
		returned |assert-return|.
		There is no automatic conversion, the String "4" is different
		from the Number 4.  And the number 4 is different from the
		Float 4.0.  The value of 'ignorecase' is not used here, case
		always matters.
		When {msg} is omitted an error in the form "Expected
		{expected} but got {actual}" is produced.
		Example: >
	assert_equal('foo', 'bar')
<		Will result in a string to be added to |v:errors|:
	test.vim line 12: Expected 'foo' but got 'bar' ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{assert_equal()}
@findex assert_equal()
@item assert_equal(@{expected@}, @{actual@} [, @{msg@}])
@{expected@} と @{actual@} が等しくない場合、|@ref{v:errors}| にエラーメッセージを追加し 1 を返す。そうでなければ |@ref{assert-return}| によって 0 が返される。

暗黙的な変換は行われないため、文字列 "4" は数値 4 とは異なる。同様に、数値 4 は浮動小数点数 4.0 と異なる。ここでは '@option{ignorecase}' の値は使われず、大文字小文字は常に区別される。@{msg@} が省略された場合、"Expected @{expected@} but got @{actual@}" という形式のメッセージが生成される。

例:
@example
assert_equal('foo', 'bar')
@end example
以下の結果が |@ref{v:errors}| に追加される:
@example
test.vim line 12: Expected 'foo' but got 'bar'
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*assert_equalfile()*
assert_equalfile({fname-one}, {fname-two})
		When the files {fname-one} and {fname-two} do not contain
		exactly the same text an error message is added to |v:errors|.
		Also see |assert-return|.
		When {fname-one} or {fname-two} does not exist the error will
		mention that.
		Mainly useful with |terminal-diff|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{assert_equalfile()}
@findex assert_equalfile()
@item assert_equalfile(@{fname-one@}, @{fname-two@})
@{fname-one@} と @{fname-two@} ファイルが厳密に同じテキストを含んでいない時に、エラーメッセージが |@ref{v:errors}| に追加される。|@ref{assert-return}| も参照。@{fname-one@} もしくは @{fname-two@} が存在しない時は、エラーはそれについて述べる。主に |@ref{terminal-diff}| で役立つ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
assert_exception({error} [, {msg}])			*assert_exception()*
		When v:exception does not contain the string {error} an error
		message is added to |v:errors|.  Also see |assert-return|.
		This can be used to assert that a command throws an exception.
		Using the error number, followed by a colon, avoids problems
		with translations: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{assert_exception()}
@findex assert_exception()
@item assert_exception(@{error@} [, @{msg@}])
v:exception に @{error@} が含まれていない時、|@ref{v:errors}| にエラーメッセージを追加する。|@ref{assert-return}| も参照。これは例外を投げるコマンドのテストを行う場合に使うことができる。コロンが続くエラー番号を使えば、翻訳の問題を回避できる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			try
			  commandthatfails
			  call assert_false(1, 'command should have failed')
			catch
			  call assert_exception('E492:')
			endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
try
  失敗するコマンド
  call assert_false(1, 'command should have failed')
catch
  call assert_exception('E492:')
endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
assert_fails({cmd} [, {error}])					*assert_fails()*
		Run {cmd} and add an error message to |v:errors| if it does
		NOT produce an error.  Also see |assert-return|.
		When {error} is given it must match in |v:errmsg|.
		Note that beeping is not considered an error, and some failing
		commands only beep.  Use |assert_beeps()| for those.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{assert_fails()}
@findex assert_fails()
@item assert_fails(@{cmd@} [, @{error@}])
@{cmd@} を実行しエラーを生成しなかった場合、|@ref{v:errors}| にエラーメッセージを追加する。|@ref{assert-return}| も参照。@{error@} が渡された場合、|@ref{v:errmsg}| の一部にマッチしなければならない。
@quotation
@strong{Note:} @*
ビープはエラーとはみなされない。またビープのみを実行する失敗もある。これらには |@ref{assert_beeps()}| を使うことに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
assert_false({actual} [, {msg}])				*assert_false()*
		When {actual} is not false an error message is added to
		|v:errors|, like with |assert_equal()|. 
		Also see |assert-return|.
		A value is false when it is zero. When {actual} is not a
		number the assert fails.
		When {msg} is omitted an error in the form
		"Expected False but got {actual}" is produced.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{assert_false()}
@findex assert_false()
@item assert_false(@{actual@} [, @{msg@}])
|@ref{assert_equal()}| と同様に、@{actual@} が false でない場合、|@ref{v:errors}| にエラーメッセージを追加する。|@ref{assert-return}| も参照。ゼロである時、その値は false である。@{actual@} が数値でない場合、テストが失敗する。@{msg@} が省略された場合、"Expected False but got @{actual@}" という形式のメッセージが生成される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
assert_inrange({lower}, {upper}, {actual} [, {msg}])	 *assert_inrange()*
		This asserts number values.  When {actual}  is lower than
		{lower} or higher than {upper} an error message is added to
		|v:errors|.  Also see |assert-return|.
		When {msg} is omitted an error in the form
		"Expected range {lower} - {upper}, but got {actual}" is
		produced.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{assert_inrange()}
@findex assert_inrange()
@item assert_inrange(@{lower@}, @{upper@}, @{actual@} [, @{msg@}])
これは数値の値かをテストする。@{actual@} が @{lower@} より低いか @{upper@} より大きい場合、|@ref{v:errors}| にエラーメッセージが追加される。|@ref{assert-return}| も参照。@{msg@} を省略すると、"Expected range @{lower@} - @{upper@}, but got @{actual@}" という形式のエラーが生成される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
								*assert_match()*
assert_match({pattern}, {actual} [, {msg}])
		When {pattern} does not match {actual} an error message is
		added to |v:errors|.  Also see |assert-return|.

		{pattern} is used as with |=~|: The matching is always done
		like 'magic' was set and 'cpoptions' is empty, no matter what
		the actual value of 'magic' or 'cpoptions' is.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{assert_match()}
@findex assert_match()
@item assert_match(@{pattern@}, @{actual@} [, @{msg@}])
@{pattern@} が @{actual@} と一致しない場合、|@ref{v:errors}| にエラーメッセージが追加される。|@ref{assert-return}| も参照。

|@ref{expr-=~, ,=~}| と同じように @{pattern@} が使われる: マッチングは '@option{magic}' や '@option{cpoptions}' の実際の値に関係なく、'@option{magic}' が設定され、'@option{cpoptions}' が空であるように常に行われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{actual} is used as a string, automatic conversion applies.
		Use "^" and "$" to match with the start and end of the text.
		Use both to match the whole text.

		When {msg} is omitted an error in the form
		"Pattern {pattern} does not match {actual}" is produced.
		Example: >
	assert_match('^f.*o$', 'foobar')
<		Will result in a string to be added to |v:errors|:
	test.vim line 12: Pattern '^f.*o$' does not match 'foobar' ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{actual@} は文字列として使用され、自動変換が適用される。テキストの先頭と最後に一致させるためには、"^" と "$" を使用すること。両方を使用してテキスト全体を一致させる。@{訳注: 使わなければ、部分一致で判定が行われる。@}

@{msg@} を省略すると、"Pattern @{pattern@} does not match @{actual@}" という形式のエラーが生成される。例:
@example
assert_match('^f.*o$', 'foobar')
@end example
これは |@ref{v:errors}| に文字列が追加されることになる:
@example
test.vim line 12: Pattern '^f.*o$' does not match 'foobar'
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*assert_notequal()*
assert_notequal({expected}, {actual} [, {msg}])
		The opposite of `assert_equal()`: add an error message to
		|v:errors| when {expected} and {actual} are equal.
		Also see |assert-return|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{assert_notequal()}
@findex assert_notequal()
@item assert_notequal(@{expected@}, @{actual@} [, @{msg@}])
`@command{assert_equal()}` の反対: @{expected@} と @{actual@} が等しいときにエラーメッセージを |@ref{v:errors}| に追加する。|@ref{assert-return}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*assert_notmatch()*
assert_notmatch({pattern}, {actual} [, {msg}])
		The opposite of `assert_match()`: add an error message to
		|v:errors| when {pattern} matches {actual}.
		Also see |assert-return|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{assert_notmatch()}
@findex assert_notmatch()
@item assert_notmatch(@{pattern@}, @{actual@} [, @{msg@}])
`@command{assert_match()}` の反対: @{pattern@} が @{actual@} にマッチするときに |@ref{v:errors}| にエラーメッセージを追加する。|@ref{assert-return}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
assert_report({msg})					*assert_report()*
		Report a test failure directly, using {msg}.
		Always returns one.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{assert_report()}
@findex assert_report()
@item assert_report(@{msg@})
テストの失敗を @{msg@} を使って直接報告する。常に 1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
assert_true({actual} [, {msg}])				*assert_true()*
		When {actual} is not true an error message is added to
		|v:errors|, like with |assert_equal()|.
		Also see |assert-return|.
		A value is TRUE when it is a non-zero number.  When {actual}
		is not a number the assert fails.
		When {msg} is omitted an error in the form "Expected True but
		got {actual}" is produced.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{assert_true()}
@findex assert_true()
@item assert_true(@{actual@} [, @{msg@}])
|@ref{assert_equal()}| と同様に、@{actual@} が true でない場合、|@ref{v:errors}| にエラーメッセージを追加する。|@ref{assert-return}| も参照。非ゼロである時、その値は TRUE である。@{actual@} が数値でない場合、テストが失敗する。@{msg@} が省略された場合、"Expected True but got @{actual@}" という形式のメッセージが生成される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
asin({expr})						*asin()*
		Return the arc sine of {expr} measured in radians, as a |Float|
		in the range of [-pi/2, pi/2].
		{expr} must evaluate to a |Float| or a |Number| in the range
		[-1, 1].
		Examples: >
			:echo asin(0.8)
<			0.927295 >
			:echo asin(-0.5)
<			-0.523599
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{asin()}
@findex asin()
@item asin(@{expr@})
@{expr@} の逆正弦 (アークサイン) をラジアンで返す。値は [-pi/2, pi/2] の範囲の浮動小数点数 (|@ref{Float}|)。@{expr@} は [-1, 1] の範囲の浮動小数点数 (|@ref{Float}|) か数値 (|@ref{Number}|) でなければならない。

例:
@example
:echo asin(0.8)
0.927295
:echo asin(-0.5)
-0.523599
@end example
@{|@ref{+float}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
atan({expr})						*atan()*
		Return the principal value of the arc tangent of {expr}, in
		the range [-pi/2, +pi/2] radians, as a |Float|.
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo atan(100)
<			1.560797 >
			:echo atan(-4.01)
<			-1.326405
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{atan()}
@findex atan()
@item atan(@{expr@})
@{expr@} の逆正接 (アークタンジェント) の主値を浮動小数点数 |@ref{Float}| で返す。主値はラジアンで [-pi/2, +pi/2] の範囲内にある。@{expr@} は |@ref{Float}| か |@ref{Number}| に評価されなければならない。

例:
@example
:echo atan(100)
1.560797
:echo atan(-4.01)
-1.326405
@end example
@{|@ref{+float}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
atan2({expr1}, {expr2})					*atan2()*
		Return the arc tangent of {expr1} / {expr2}, measured in
		radians, as a |Float| in the range [-pi, pi].
		{expr1} and {expr2} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo atan2(-1, 1)
<			-0.785398 >
			:echo atan2(1, -1)
<			2.356194
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{atan2()}
@findex atan2()
@item atan2(@{expr1@}, @{expr2@})
@{expr1@} / @{expr2@} の逆正接 (アークタンジェント) をラジアンで返す。値は [-pi, pi] の範囲の浮動小数点数 (|@ref{Float}|)。@{expr1@} と @{expr2@} は浮動小数点数 (|@ref{Float}|) か数値 (|@ref{Number}|) でなければならない。

例:
@example
:echo atan2(-1, 1)
-0.785398
:echo atan2(1, -1)
2.356194
@end example
@{|@ref{+float}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
balloon_show({expr})					*balloon_show()*
		Show {expr} inside the balloon.  For the GUI {expr} is used as
		a string.  For a terminal {expr} can be a list, which contains
		the lines of the balloon.  If {expr} is not a list it will be
		split with |balloon_split()|.

		Example: >
			func GetBalloonContent()
			   " initiate getting the content
			   return ''
			endfunc
			set balloonexpr=GetBalloonContent()

			func BalloonCallback(result)
			  call balloon_show(a:result)
			endfunc
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{balloon_show()}
@findex balloon_show()
@item balloon_show(@{expr@})
@{expr@} をバルーン内に表示する。GUI のために @{expr@} は文字列として使われる。端末のために @{expr@} はバルーンの行を含むリストになることができる。もしも @{expr@} がリストでなければ、|@ref{balloon_split()}| で分割されるだろう。

例:
@verbatim
func GetBalloonContent()
   " 内容の取得を開始
   return ''
endfunc
set balloonexpr=GetBalloonContent()

func BalloonCallback(result)
  call balloon_show(a:result)
endfunc
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The intended use is that fetching the content of the balloon
		is initiated from 'balloonexpr'.  It will invoke an
		asynchronous method, in which a callback invokes
		balloon_show().  The 'balloonexpr' itself can return an
		empty string or a placeholder.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
想定される使用方法は、バルーンの内容の取得が '@option{balloonexpr}' から開始されることである。そこから非同期メソッドを呼び出し、コールバックから balloon_show() を呼び出す。'@option{balloonexpr}' 自身は空文字列かプレースホルダーを返すことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When showing a balloon is not possible nothing happens, no
		error message.
		{only available when compiled with the +balloon_eval or
		+balloon_eval_term feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バルーンを表示できないときは何も起こらず、エラーメッセージも表示されない。

@{Vim が |@ref{+balloon_eval}| もしくは |@ref{+balloon_eval_term}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
balloon_split({msg})					*balloon_split()*
		Split {msg} into lines to be displayed in a balloon.  The
		splits are made for the current window size and optimize to
		show debugger output.
		Returns a |List| with the split lines.
		{only available when compiled with the +balloon_eval_term
		feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{balloon_split()}
@findex balloon_split()
@item balloon_split(@{msg@})
バルーンで表示できるようにするため、行内のメッセージを分割する。
分割されたものは、現在のウィンドウサイズになっており、デバッガの出力用に最適化されている。分割された行として |@ref{List}| を返す。

@{Vim が |@ref{+balloon_eval_term}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*browse()*
browse({save}, {title}, {initdir}, {default})
		Put up a file requester.  This only works when "has("browse")"
		returns |TRUE| (only in some GUI versions).
		The input fields are:
		    {save}	when |TRUE|, select file to write
		    {title}	title for the requester
		    {initdir}	directory to start browsing in
		    {default}	default file name
		When the "Cancel" button is hit, something went wrong, or
		browsing is not possible, an empty string is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{browse()}
@findex browse()
@item browse(@{save@}, @{title@}, @{initdir@}, @{default@})
ファイル選択ダイアログを起動。"has("browse")" が |@ref{TRUE}| を返すとき (幾つかの GUI バージョンに限定) だけ利用可能。

入力フィールドの意味は:
@multitable @columnfractions .2 .8
@item @{save@} @tab |@ref{TRUE}| ならば書込み用ファイルの選択
@item @{title@} @tab ダイアログのタイトル
@item @{initdir@} @tab ダイアログの始まるディレクトリ
@item @{default@} @tab ファイル名の省略値
@end multitable
ダイアログがキャンセルされるか、何かエラーがあるか、もしくはブラウジングが不可能ならば、空文字列が戻ってくる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*browsedir()*
browsedir({title}, {initdir})
		Put up a directory requester.  This only works when
		"has("browse")" returns |TRUE| (only in some GUI versions).
		On systems where a directory browser is not supported a file
		browser is used.  In that case: select a file in the directory
		to be used.
		The input fields are:
		    {title}	title for the requester
		    {initdir}	directory to start browsing in
		When the "Cancel" button is hit, something went wrong, or
		browsing is not possible, an empty string is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{browsedir()}
@findex browsedir()
@item browsedir(@{title@}, @{initdir@})
ディレクトリ選択ダイアログを起動。"has("browse")" が |@ref{TRUE}| を返すとき (幾つかの GUI バージョンに限定) だけ利用可能。ディレクトリ選択ダイアログがないシステムにおいてはファイル選択ダイアログが使われる。その場合は、指定したいディレクトリの中のファイルを選択すること。

入力フィールドの意味は:
@multitable @columnfractions .2 .8
@item @{title@} @tab ダイアログのタイトル
@item @{initdir@} @tab ダイアログの始まるディレクトリ
@end multitable
ダイアログがキャンセルされるか、何かエラーがあるか、もしくはブラウジングが不可能ならば、空文字列が戻ってくる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
bufexists({expr})					*bufexists()*
		The result is a Number, which is |TRUE| if a buffer called
		{expr} exists.
		If the {expr} argument is a number, buffer numbers are used.
		Number zero is the alternate buffer for the current window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{bufexists()}
@findex bufexists()
@item bufexists(@{expr@})
結果は数値で、@{expr@} と呼ばれるバッファが存在すれば |@ref{TRUE}| となる。@{expr@} が数値の場合、バッファ番号とみなされる。数値の 0 は現在のウィンドウの代替バッファである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If the {expr} argument is a string it must match a buffer name
		exactly.  The name can be:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr@} が文字列の場合、バッファ名に正確にマッチしなければならない。名前として以下のものが許される:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		- Relative to the current directory.
		- A full path.
		- The name of a buffer with 'buftype' set to "nofile".
		- A URL name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item カレントディレクトリからの相対パス。
@item フルパス。
@item '@option{buftype}' が "@var{nofile}" であるバッファの名前
@item URL 名。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Unlisted buffers will be found.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バッファリストにないバッファも検索される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that help files are listed by their short name in the
		output of |:buffers|, but bufexists() requires using their
		long name to be able to find them.
		bufexists() may report a buffer exists, but to use the name
		with a |:buffer| command you may need to use |expand()|.  Esp
		for MS-Windows 8.3 names in the form "c:\DOCUME~1"
		Use "bufexists(0)" to test for the existence of an alternate
		file name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
|@ref{:buffers}| の出力で、ヘルプファイルは短い名前でリストされているが、bufexists() は長い名前でないと見つけることができない。ある名前を bufexists() に与えて非零になったとしても、その名前をコマンド |@ref{:buffer}| に与える際には |@ref{expand()}| を使って展開しなければならない場合がある。特に MS-Windows の "c:\DOCUME~1" という 8.3 名形式において。代替ファイル名が存在するかを判定するには "bufexists(0)" を使う。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*buffer_exists()*
		Obsolete name: buffer_exists().
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{buffer_exists()}
@findex buffer_exists()
以前の名前: buffer_exists().
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
buflisted({expr})					*buflisted()*
		The result is a Number, which is |TRUE| if a buffer called
		{expr} exists and is listed (has the 'buflisted' option set).
		The {expr} argument is used like with |bufexists()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{buflisted()}
@findex buflisted()
@item buflisted(@{expr@})
戻り値は数値で、@{expr@} と呼ばれるバッファが存在しリストされている ('@option{buflisted}' オプションがオンになっている) ならば結果は |@ref{TRUE}| となる。引数 @{expr@} は |@ref{bufexists()}| と同じように扱われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
bufloaded({expr})					*bufloaded()*
		The result is a Number, which is |TRUE| if a buffer called
		{expr} exists and is loaded (shown in a window or hidden).
		The {expr} argument is used like with |bufexists()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{bufloaded()}
@findex bufloaded()
@item bufloaded(@{expr@})
戻り値は数値で、@{expr@} と呼ばれるバッファが存在しロード済み (ウィンドウに表示されているか、隠されているかは問わない) ならば結果は |@ref{TRUE}| となる。引数 @{expr@} は |@ref{bufexists()}| と同じように扱われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
bufname({expr})						*bufname()*
		The result is the name of a buffer, as it is displayed by the
		":ls" command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{bufname()}
@findex bufname()
@item bufname(@{expr@})
戻り値はバッファの名前。バッファ名はコマンド "@command{:ls}" で表示されるものと同様。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If {expr} is a Number, that buffer number's name is given.
		Number zero is the alternate buffer for the current window.
		If {expr} is a String, it is used as a |file-pattern| to match
		with the buffer names.  This is always done like 'magic' is
		set and 'cpoptions' is empty.  When there is more than one
		match an empty string is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@{expr@} が数値ならば、その番号のバッファ名が返される。0 は現在のウィンドウの代替バッファを意味する。@{expr@} が文字列ならば、バッファ名に対してファイル名マッチング |@ref{file-pattern}| を行うパターンとなる。このマッチングは常に、'@option{magic}' をセットし '@option{cpoptions}' を空にした状態で行われる。複数マッチしてしまった場合には空文字列が返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		"" or "%" can be used for the current buffer, "#" for the
		alternate buffer.
		A full match is preferred, otherwise a match at the start, end
		or middle of the buffer name is accepted.  If you only want a
		full match then put "^" at the start and "$" at the end of the
		pattern.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

"" や "%" は現在のバッファを意味し、"#" は代替バッファを意味する。

完全マッチのものが優先され、完全マッチがなければ、バッファ名の先頭でのマッチ、末尾でのマッチ、中間でのマッチが探される。完全マッチのみを探すには、パターン先頭に "^" を、末尾に "$" をつける。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Listed buffers are found first.  If there is a single match
		with a listed buffer, that one is returned.  Next unlisted
		buffers are searched for.
		If the {expr} is a String, but you want to use it as a buffer
		number, force it to be a Number by adding zero to it: >
			:echo bufname("3" + 0)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

まずバッファリストにあるバッファが探される。そこで 1 個だけマッチが見つかればそれを返す。次にバッファリストにないものが探される。

@{expr@} が文字列のときに、それをバッファ番号として使いたいならば、0 を足すことによって強制的に数値にすることができる:
@example
echo bufname("3" + 0)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		If the buffer doesn't exist, or doesn't have a name, an empty
		string is returned. >
	bufname("#")		alternate buffer name
	bufname(3)		name of buffer 3
	bufname("%")		name of current buffer
	bufname("file2")	name of buffer where "file2" matches.
<							*buffer_name()*
		Obsolete name: buffer_name().
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バッファが存在しないか名前を持っていない場合には、空文字列が返される。
@multitable @columnfractions .4 .6
@item bufname("#") @tab 代替バッファの名前
@item bufname(3) @tab バッファ 3 の名前
@item bufname("%") @tab カレントバッファの名前
@item bufname("file2") @tab "file2" にマッチするバッファの名前
@end multitable
@anchor{buffer_name()}
@findex buffer_name()
以前の名前: buffer_name().
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*bufnr()*
bufnr({expr} [, {create}])
		The result is the number of a buffer, as it is displayed by
		the ":ls" command.  For the use of {expr}, see |bufname()|
		above.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{bufnr()}
@findex bufnr()
@item bufnr(@{expr@} [, @{create@}])
結果はバッファの番号。バッファ番号はコマンド "@command{:ls}" で表示されるものと同様。@{expr@} の使い方は前述の |@ref{bufname()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If the buffer doesn't exist, -1 is returned.  Or, if the
		{create} argument is present and not zero, a new, unlisted,
		buffer is created and its number is returned.
		bufnr("$") is the last buffer: >
	:let last_buffer = bufnr("$")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バッファが存在しない場合 -1 が返される。ただし、@{create@} が与えられて0でないときは、バッファリストに載せない新しいバッファを作成しその番号を返す。

bufnr("$") は最後のバッファを意味する:
@example
:let last_buffer = bufnr("$")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		The result is a Number, which is the highest buffer number
		of existing buffers.  Note that not all buffers with a smaller
		number necessarily exist, because ":bwipeout" may have removed
		them.  Use bufexists() to test for the existence of a buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
結果は存在しているバッファのうちで、もっとも大きなバッファ番号となる。
@quotation
@strong{Note:} @*
そのバッファ番号より小さいバッファ番号を持つ (ハズの) バッファが、必ずしも全て存在するとは限らない。なぜなら "@command{:bwipeout}" がバッファを消すことができるからだ。バッファが存在するかテストするには bufexists() を使う。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*buffer_number()*
		Obsolete name: buffer_number().
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{buffer_number()}
@findex buffer_number()
以前の名前: buffer_number().
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*last_buffer_nr()*
		Obsolete name for bufnr("$"): last_buffer_nr().
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{last_buffer_nr()}
@findex last_buffer_nr()
bufnr("$") の以前の名前: last_buffer_nr().
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
bufwinid({expr})					*bufwinid()*
		The result is a Number, which is the |window-ID| of the first
		window associated with buffer {expr}.  For the use of {expr},
		see |bufname()| above.  If buffer {expr} doesn't exist or
		there is no such window, -1 is returned.  Example: >

	echo "A window containing buffer 1 is " . (bufwinid(1))
<
		Only deals with the current tab page.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{bufwinid()}
@findex bufwinid()
@item bufwinid(@{expr@})
その結果は数値で、バッファ @{expr@} に関連付けられた最初のウィンドウの |@ref{window-ID}|。@{expr@} の使い方は前述の |@ref{bufname()}| を参照。バッファ @{expr@} が存在しないか、ウィンドウが無い場合は、-1 が返される。例:
@example
echo "A window containing buffer 1 is " . (bufwinid(1))
@end example
現在のタブページのみを処理する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
bufwinnr({expr})					*bufwinnr()*
		The result is a Number, which is the number of the first
		window associated with buffer {expr}.  For the use of {expr},
		see |bufname()| above.  If buffer {expr} doesn't exist or
		there is no such window, -1 is returned.  Example: >

	echo "A window containing buffer 1 is " . (bufwinnr(1))

<		The number can be used with |CTRL-W_w| and ":wincmd w"
		|:wincmd|.
		Only deals with the current tab page.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{bufwinnr()}
@findex bufwinnr()
@item bufwinnr(@{expr@})
結果は数値で、バッファ @{expr@} に関連付けられた最初のウィンドウの番号。@{expr@} の使い方は前述の |@ref{bufname()}| を参照。バッファ @{expr@} が存在しないか、ウィンドウが無い場合には -1 を返す。例:
@example
echo "A window containing buffer 1 is " . (bufwinnr(1))
@end example
この番号は |@ref{CTRL-W_w}| や "@command{:wincmd w}" |@ref{:wincmd}| で使える。

カレントタブページ内のウィンドウだけを探す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
byte2line({byte})					*byte2line()*
		Return the line number that contains the character at byte
		count {byte} in the current buffer.  This includes the
		end-of-line character, depending on the 'fileformat' option
		for the current buffer.  The first character has byte count
		one.
		Also see |line2byte()|, |go| and |:goto|.
		{not available when compiled without the |+byte_offset|
		feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{byte2line()}
@findex byte2line()
@item byte2line(@{byte@})
カレントバッファの先頭から @{byte@} 番目の文字が、何行目に含まれるかを返す。これにはカレントバッファの '@option{fileformat}' に依存した、改行文字も含まれる。先頭の文字にはバイトカウント 1 が与えられる。|@ref{line2byte()}| と |@ref{go}| と |@ref{:goto}| も参照。

@{|@ref{+byte_offset}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
byteidx({expr}, {nr})					*byteidx()*
		Return byte index of the {nr}'th character in the string
		{expr}.  Use zero for the first character, it returns zero.
		This function is only useful when there are multibyte
		characters, otherwise the returned value is equal to {nr}.
		Composing characters are not counted separately, their byte
		length is added to the preceding base character.  See
		|byteidxcomp()| below for counting composing characters
		separately.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{byteidx()}
@findex byteidx()
@item byteidx(@{expr@}, @{nr@})
文字列 @{expr@} の @{nr@} 番目の文字のバイトインデックスを返す。最初の文字の @{nr@} は 0 であり、戻り値は 0 となる。この関数はマルチバイト文字が存在するときのみ有用であり、そうでなければこの関数が返す値は @{nr@} に等しい。合成文字はまとめて計算される。合成文字のバイト数はそれが合成されているベース文字のバイト数に合算される。合成文字を別々に数えるには |@ref{byteidxcomp()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example : >
			echo matchstr(str, ".", byteidx(str, 3))
<		will display the fourth character.  Another way to do the
		same: >
			let s = strpart(str, byteidx(str, 3))
			echo strpart(s, 0, byteidx(s, 1))
<		Also see |strgetchar()| and |strcharpart()|.

		If there are less than {nr} characters -1 is returned.
		If there are exactly {nr} characters the length of the string
		in bytes is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例 :
@example
echo matchstr(str, ".", byteidx(str, 3))
@end example
は 4 文字目を表示する。次も同じことをする:
@example
let s = strpart(str, byteidx(str, 3))
echo strpart(s, 0, byteidx(s, 1))
@end example
|@ref{strgetchar()}| と |@ref{strcharpart()}| も参照。@{expr@} が @{nr@} 文字以下の場合は -1 を返す。@{expr@} がちょうど @{nr@} 文字の場合は文字列の長さ (バイト単位) を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
byteidxcomp({expr}, {nr})					*byteidxcomp()*
		Like byteidx(), except that a composing character is counted
		as a separate character.  Example: >
			let s = 'e' . nr2char(0x301)
			echo byteidx(s, 1)
			echo byteidxcomp(s, 1)
			echo byteidxcomp(s, 2)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{byteidxcomp()}
@findex byteidxcomp()
@item byteidxcomp(@{expr@}, @{nr@})
byteidx() と同じだが、合成文字は個別にカウントされる。例:
@example
let s = 'e' . nr2char(0x301)
echo byteidx(s, 1)
echo byteidxcomp(s, 1)
echo byteidxcomp(s, 2)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		The first and third echo result in 3 ('e' plus composing
		character is 3 bytes), the second echo results in 1 ('e' is
		one byte).
		Only works different from byteidx() when 'encoding' is set to
		a Unicode encoding.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
1 番目と 3 番目は 3 が出力される ('e' の長さと合成文字の長さを足すと 3 バイト)。2 番目は 1 が出力される ('e' は 1 バイト)。'@option{encoding}' に Unicode が設定されているときのみ byteidx() と違う動作になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
call({func}, {arglist} [, {dict}])			*call()* *E699*
		Call function {func} with the items in |List| {arglist} as
		arguments.
		{func} can either be a |Funcref| or the name of a function.
		a:firstline and a:lastline are set to the cursor line.
		Returns the return value of the called function.
		{dict} is for functions with the "dict" attribute.  It will be
		used to set the local variable "self". |Dictionary-function|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{call()}
@anchor{E699}
@findex call()
@erindex E699
@item call(@{func@}, @{arglist@} [, @{dict@}])
リスト |@ref{List}| @{arglist@} の要素を引数として関数 @{func@} を呼ぶ。@{func@} は |@ref{Funcref}| でも関数の名前でもよい。a:firstline と a:lastline にはカレント行が代入される。呼び出した関数の戻り値を返す。

@{dict@} は "dict" 属性つきの関数用で、これがローカル変数 "self" に代入される。|@ref{Dictionary-function}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ceil({expr})							*ceil()*
		Return the smallest integral value greater than or equal to
		{expr} as a |Float| (round up).
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			echo ceil(1.456)
<			2.0  >
			echo ceil(-5.456)
<			-5.0  >
			echo ceil(4.0)
<			4.0
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ceil()}
@findex ceil()
@item ceil(@{expr@})
@{expr@} 以上となる最小の整数を浮動小数点数 |@ref{Float}| で返す (切り上げる)。@{expr@} は |@ref{Float}| か |@ref{Number}| に評価されなければならない。

例:
@example
echo ceil(1.456)
2.0
echo ceil(-5.456)
-5.0
echo ceil(4.0)
4.0
@end example
@{|@ref{+float}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_canread({handle})						*ch_canread()*
		Return non-zero when there is something to read from {handle}.
		{handle} can be a Channel or a Job that has a Channel.

		This is useful to read from a channel at a convenient time,
		e.g. from a timer.

		Note that messages are dropped when the channel does not have
		a callback.  Add a close callback to avoid that.

		{only available when compiled with the |+channel| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ch_canread(@{handle@})
@anchor{ch_canread()}
@findex ch_canread()
@{handle@} から何か読むものがあれば非ゼロを返す。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。

これはチャネルから、都合のよいときに読むのに便利である。例えば、タイマーから。

チャネルがコールバックを持っていない場合、メッセージはドロップされることに注意。それを防ぐには close コールバックを追加すること。

@{|@ref{+channel}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_close({handle})						*ch_close()*
		Close {handle}.  See |channel-close|.
		{handle} can be a Channel or a Job that has a Channel.
		A close callback is not invoked.

		{only available when compiled with the |+channel| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_close()}
@findex ch_close()
@item ch_close(@{handle@})
@{handle@} を閉じる。|@ref{channel-close}| を参照。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。閉じられたコールバックは呼び出されない。

@{|@ref{+channel}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_close_in({handle})						*ch_close_in()*
		Close the "in" part of {handle}.  See |channel-close-in|.
		{handle} can be a Channel or a Job that has a Channel.
		A close callback is not invoked.

		{only available when compiled with the |+channel| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_close_in()}
@findex ch_close_in()
@item ch_close_in(@{handle@})
@{handle@} の "入力" を閉じる。|@ref{channel-close-in}| を参照。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。閉じられたコールバックは呼び出されない。

@{|@ref{+channel}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_evalexpr({handle}, {expr} [, {options}])			*ch_evalexpr()*
		Send {expr} over {handle}.  The {expr} is encoded
		according to the type of channel.  The function cannot be used
		with a raw channel.  See |channel-use|.
		{handle} can be a Channel or a Job that has a Channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_evalexpr()}
@findex ch_evalexpr()
@item ch_evalexpr(@{handle@}, @{expr@} [, @{options@}])
@{handle@} へ @{expr@} を送信する。@{expr@} はチャネル側と同じ型にエンコードされる。この関数は生のチャネルでは使用できない。|@ref{channel-use}| を参照。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
								*E917*
		{options} must be a Dictionary.  It must not have a "callback"
		entry.  It can have a "timeout" entry to specify the timeout
		for this specific request.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E917}
@erindex E917
@{options@} は辞書でなければならない。また "callback" のエントリを持ってはならない。また個別のリクエストに対して "timeout" を持つ事ができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		ch_evalexpr() waits for a response and returns the decoded
		expression.  When there is an error or timeout it returns an
		empty string.

		{only available when compiled with the |+channel| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ch_evalexpr() は応答を待ち、式をデコードした物が返される。エラーもしくはタイムアウトの場合は空文字列が返る。

@{|@ref{+channel}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_evalraw({handle}, {string} [, {options}])		*ch_evalraw()*
		Send {string} over {handle}.
		{handle} can be a Channel or a Job that has a Channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_evalraw()}
@findex ch_evalraw()
@item ch_evalraw(@{handle@}, @{string@} [, @{options@}])
@{handle@} へ @{expr@} を送信する。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Works like |ch_evalexpr()|, but does not encode the request or
		decode the response.  The caller is responsible for the
		correct contents.  Also does not add a newline for a channel
		in NL mode, the caller must do that.  The NL in the response
		is removed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{ch_evalexpr()}| と同様に動作する。しかしリクエストをエンコードしたり応答をデコードしたりはしない。呼び出しは正しいコンテンツである事が保証される。また NL モードでは改行が行われるが、ここでは改行が付与されない。NL は応答から削除される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that Vim does not know when the text received on a raw
		channel is complete, it may only return the first part and you
		need to use ch_readraw() to fetch the rest.
		See |channel-use|.

		{only available when compiled with the |+channel| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
Vim は生チャネルで受け取ったテキストが完全なものなのかわからないことに注意。
最初の部分だけが返されているのかもしれないし、残りの部分を取り込むために ch_readraw() を使う必要がある。
@end quotation
|@ref{channel-use}| を参照。

@{|@ref{+channel}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_getbufnr({handle}, {what})				 *ch_getbufnr()*
		Get the buffer number that {handle} is using for {what}.
		{handle} can be a Channel or a Job that has a Channel.
		{what} can be "err" for stderr, "out" for stdout or empty for
		socket output.
		Returns -1 when there is no buffer.
		{only available when compiled with the |+channel| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_getbufnr()}
@findex ch_getbufnr()
@item ch_getbufnr(@{handle@}, @{what@})
@{what@} に使用されている @{handle@} のバッファ番号を得る。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。@{what@} は標準エラーの為の "err"、標準出力の為の "out"、もしくはソケット出力の為の空文字列が指定できる。バッファが存在しない場合は -1 が返る。

@{|@ref{+channel}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_getjob({channel})						*ch_getjob()*
		Get the Job associated with {channel}.
		If there is no job calling |job_status()| on the returned Job
		will result in "fail".

		{only available when compiled with the |+channel| and
		|+job| features}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_getjob()}
@findex ch_getjob()
@item ch_getjob(@{channel@})
@{channel@} に関連付けられた Job を得る。もしジョブが無い場合、戻り値の Job で |@ref{job_status()}| を呼び出すと "fail" が返される。

@{|@ref{+channel}| と |@ref{+job}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_info({handle})						*ch_info()*
		Returns a Dictionary with information about {handle}.  The
		items are:
		   "id"		  number of the channel
		   "status"	  "open", "buffered" or "closed", like
				  ch_status()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_info()}
@findex ch_info()
@item ch_info(@{handle@})
@{handle@} に関する情報を辞書で返す。アイテムは:
@multitable @columnfractions .2 .8
@item "id" @tab チャネル番号
@item "status" @tab ch_status() と同様に、"open", "buffered" または "closed"
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When opened with ch_open():
		   "hostname"	  the hostname of the address
		   "port"	  the port of the address
		   "sock_status"  "open" or "closed"
		   "sock_mode"	  "NL", "RAW", "JSON" or "JS"
		   "sock_io"	  "socket"
		   "sock_timeout" timeout in msec
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ch_open() で開いた場合:
@multitable @columnfractions .4 .6
@item "hostname" @tab アドレスのホスト名
@item "port" @tab アドレスのポート
@item "sock_status" @tab "open" または "closed"
@item "sock_mode" @tab "NL", "RAW", "JSON" または "JS"
@item "sock_io" @tab "socket"
@item "sock_timeout" @tab タイムアウト (ミリ秒)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When opened with job_start():
		   "out_status"	  "open", "buffered" or "closed"
		   "out_mode"	  "NL", "RAW", "JSON" or "JS"
		   "out_io"	  "null", "pipe", "file" or "buffer"
		   "out_timeout"  timeout in msec
		   "err_status"	  "open", "buffered" or "closed"
		   "err_mode"	  "NL", "RAW", "JSON" or "JS"
		   "err_io"	  "out", "null", "pipe", "file" or "buffer"
		   "err_timeout"  timeout in msec
		   "in_status"	  "open" or "closed"
		   "in_mode"	  "NL", "RAW", "JSON" or "JS"
		   "in_io"	  "null", "pipe", "file" or "buffer"
		   "in_timeout"	  timeout in msec
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
job_start() で開いた場合:
@multitable @columnfractions .3 .7
@item "out_status" @tab "open", "buffered" または "closed"
@item "out_mode" @tab "NL", "RAW", "JSON" または "JS"
@item "out_io" @tab "null", "pipe", "file" または "buffer"
@item "out_timeout" @tab タイムアウト (ミリ秒)
@item "err_status" @tab "open", "buffered" または "closed"
@item "err_mode" @tab "NL", "RAW", "JSON" または "JS"
@item "err_io" @tab "out", "null", "pipe", "file" または "buffer"
@item "err_timeout" @tab タイムアウト (ミリ秒)
@item "in_status" @tab "open" または "closed"
@item "in_mode" @tab "NL", "RAW", "JSON" または "JS"
@item "in_io" @tab "null", "pipe", "file" または "buffer"
@item "in_timeout" @tab タイムアウト (ミリ秒)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_log({msg} [, {handle}])					*ch_log()*
		Write {msg} in the channel log file, if it was opened with
		|ch_logfile()|.
		When {handle} is passed the channel number is used for the
		message.
		{handle} can be a Channel or a Job that has a Channel.  The
		Channel must be open for the channel number to be used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_log()}
@findex ch_log()
@item ch_log(@{msg@} [, @{handle@}])
|@ref{ch_logfile()}| によってログファイルが開かれている場合はチャネルのログファイルに @{msg@} を書き込む。@{handle@} が渡されている場合はチャネル番号がメッセージの中で使われる。

@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。使用されるチャネル番号のチャネルは開いていなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_logfile({fname} [, {mode}])					*ch_logfile()*
		Start logging channel activity to {fname}.
		When {fname} is an empty string: stop logging.

		When {mode} is omitted or "a" append to the file.
		When {mode} is "w" start with an empty file.

		The file is flushed after every message, on Unix you can use
		"tail -f" to see what is going on in real time.

		This function is not available in the |sandbox|.
		NOTE: the channel communication is stored in the file, be
		aware that this may contain confidential and privacy sensitive
		information, e.g. a password you type in a terminal window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_logfile()}
@findex ch_logfile()
@item ch_logfile(@{fname@} [, @{mode@}])
@{fname@} へチャネルの挙動ログ出力を開始する。@{fname@} が空の場合、ロギングは停止する。

@{mode@} が省略されるか "a" の場合、ファイルへの追加になる。@{mode@} が "w" の場合、空のファイルへで開始される。

UNIX で "tail -f" にてリアルタイムで何が行われているかが見える様に、ファイルはメッセージ毎にフラッシュされる。

この関数は |@ref{sandbox}| の中では使用できない。
@quotation
@strong{Note:} @*
チャネルのやりとりはファイルに保存される。これには機密やプライバシーの微妙な情報も含まれることに注意すること。例えば、ターミナルウィンドウで入力したパスワードなど。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ch_open({address} [, {options}])				*ch_open()*
		Open a channel to {address}.  See |channel|.
		Returns a Channel.  Use |ch_status()| to check for failure.

		{address} has the form "hostname:port", e.g.,
		"localhost:8765".

		If {options} is given it must be a |Dictionary|.
		See |channel-open-options|.

		{only available when compiled with the |+channel| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_open()}
@findex ch_open()
@item ch_open(@{address@} [, @{options@}])
@{address@}へのチャネルを開く。|@ref{channel}| を参照。チャネルを返す。失敗をチェックするには |@ref{ch_status()}| を使用する。

@{address@} は "localhost:8765" のように "ホスト名:ポート" の形式である。

@{options@} が与えられる場合は辞書でなければならない。|@ref{channel-open-options}| を参照。

@{|@ref{+channel}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_read({handle} [, {options}])					*ch_read()*
		Read from {handle} and return the received message.
		{handle} can be a Channel or a Job that has a Channel.
		For a NL channel this waits for a NL to arrive, except when
		there is nothing more to read (channel was closed).
		See |channel-more|.
		{only available when compiled with the |+channel| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_read()}
@findex ch_read()
@item ch_read(@{handle@} [, @{options@}])
@{handle@} から読み込みメッセージを受信する。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。NL チャネルのために、これ以上読み込むものが無い場合 (チャネルが閉じられた) を除き、これは NL の到着を待つ。|@ref{channel-more}| を参照。

@{|@ref{+channel}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_readraw({handle} [, {options}])			*ch_readraw()*
		Like ch_read() but for a JS and JSON channel does not decode
		the message.  For a NL channel it does not block waiting for
		the NL to arrive, but otherwise works like ch_read().
		See |channel-more|.
		{only available when compiled with the |+channel| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_readraw()}
@findex ch_readraw()
@item ch_readraw(@{handle@} [, @{options@}])
ch_read() と同様に動作するが JS や JSON の場合でもメッセージはデコードされない。NL チャネルのために、これは NL の到着を待つことをブロックしないが、ch_read() と同様に動作する。|@ref{channel-more}| を参照。

@{|@ref{+channel}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_sendexpr({handle}, {expr} [, {options}])			*ch_sendexpr()*
		Send {expr} over {handle}.  The {expr} is encoded
		according to the type of channel.  The function cannot be used
		with a raw channel.
		See |channel-use|.				*E912*
		{handle} can be a Channel or a Job that has a Channel.

		{only available when compiled with the |+channel| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_sendexpr()}
@findex ch_sendexpr()
@item ch_sendexpr(@{handle@}, @{expr@} [, @{options@}])
@{handle@} へ @{expr@} を送信する。@{expr@} はチャネル側と同じ型にエンコードされる。この関数は生のチャネルでは使用できない。
@anchor{E912}
@erindex E912
|@ref{channel-use}| を参照。

@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。

@{|@ref{+channel}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_sendraw({handle}, {string} [, {options}])		*ch_sendraw()*
		Send {string} over {handle}.
		Works like |ch_sendexpr()|, but does not encode the request or
		decode the response.  The caller is responsible for the
		correct contents.  Also does not add a newline for a channel
		in NL mode, the caller must do that.  The NL in the response
		is removed.
		See |channel-use|.

		{only available when compiled with the |+channel| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_sendraw()}
@findex ch_sendraw()
@item ch_sendraw(@{handle@}, @{string@} [, @{options@}])
@{handle@} を @{string@} に送る。|@ref{ch_sendexpr()}| と同様に動作するが、リクエストをエンコードしたり応答をデコードしたりはしない。呼び出しは正しいコンテンツである事が保証される。また NL モードでは改行が行われるが、ここでは改行が付与されない。NL は応答から削除される。|@ref{channel-use}| を参照。

@{|@ref{+channel}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_setoptions({handle}, {options})			*ch_setoptions()*
		Set options on {handle}:
			"callback"	the channel callback
			"timeout"	default read timeout in msec
			"mode"		mode for the whole channel
		See |ch_open()| for more explanation.
		{handle} can be a Channel or a Job that has a Channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_setoptions()}
@findex ch_setoptions()
@item ch_setoptions(@{handle@}, @{options@})
@{handle@} にオプションを設定する:
@multitable @columnfractions .3 .7
@item "callback" @tab チャネルのコールバック
@item "timeout" @tab デフォルトの読み込みタイムアウト (ミリ秒)
@item  "mode" @tab チャネル全体のモード
@end multitable
より詳しい説明は |@ref{ch_open()}| を参照。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Note that changing the mode may cause queued messages to be
		lost.

		These options cannot be changed:
			"waittime"	only applies to |ch_open()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
モードの変更はキューイングされているメッセージを失ってしまうかもしれない。
@end quotation
以下のオプションは変更できない:
@multitable @columnfractions .3 .7
@item "waittime" @tab |@ref{ch_open()}| だけで適用できる
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_status({handle} [, {options}])				*ch_status()*
		Return the status of {handle}:
			"fail"		failed to open the channel
			"open"		channel can be used
			"buffered"	channel can be read, not written to
			"closed"	channel can not be used
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_status()}
@findex ch_status()
@item ch_status(@{handle@} [, @{options@}])
@{handle@} の状態を返す:
@multitable @columnfractions .2 .8
@item "fail" @tab チャネルのオープンに失敗
@item "open" @tab チャネルは利用可能
@item "buffered" @tab チャネルは読込可能、または書き込まれていない
@item "closed" @tab チャネルは利用不可
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{handle} can be a Channel or a Job that has a Channel.
		"buffered" is used when the channel was closed but there is
		still data that can be obtained with |ch_read()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。チャネルは閉じられているが |@ref{ch_read()}| を使って残ったデータをまだ読み取る事ができる場合には "buffered" が利用できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {options} is given it can contain a "part" entry to specify
		the part of the channel to return the status for: "out" or
		"err".  For example, to get the error status: >
			ch_status(job, {"part": "err"})
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{options@} が指定された場合、"part" 要素でチャネルのどのパート ("out" または "err") の状態を返すかを指定できる。例えば、エラーの状態を得るには:
@example
ch_status(job, @{"part": "err"@})
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
changenr()						*changenr()*
		Return the number of the most recent change.  This is the same
		number as what is displayed with |:undolist| and can be used
		with the |:undo| command.
		When a change was made it is the number of that change.  After
		redo it is the number of the redone change.  After undo it is
		one less than the number of the undone change.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{changenr()}
@findex changenr()
@item changenr()
最も最近の変更の番号を返す。|@ref{:undolist}| で表示される番号と同じであり、|@ref{:undo}| コマンドの引数として使うことができる。変更を行った直後ではその変更の番号となる。redo を行った直後は redo された変更の番号となる。undo を行った直後は undo された変更より 1 小さい番号になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
char2nr({expr} [, {utf8}])					*char2nr()*
		Return number value of the first char in {expr}.  Examples: >
			char2nr(" ")		returns 32
			char2nr("ABC")		returns 65
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{char2nr()}
@findex char2nr()
@item char2nr(@{expr@} [, @{utf8@}])
@{expr@} の最初の文字の ASCII コードを返す。例:
@multitable @columnfractions .4 .6
@item char2nr(" ") @tab returns 32
@item char2nr("ABC") @tab returns 65
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		When {utf8} is omitted or zero, the current 'encoding' is used.
		Example for "utf-8": >
			char2nr("á")		returns 225
			char2nr("á"[0])		returns 195
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{utf8@} を省略、またはゼロを指定すると、現在の '@option{encoding}' が適用される。"@var{utf-8}" の場合の例:
@multitable @columnfractions .4 .6
@item char2nr("á") @tab returns 225
@item char2nr("á"[0]) @tab returns 195
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		With {utf8} set to 1, always treat as utf-8 characters.
		A combining character is a separate character.
		|nr2char()| does the opposite.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{utf8@} に 1 を指定すると、常に utf-8 文字として扱われる。合成文字は個別の文字として扱われる。|@ref{nr2char()}| はこの逆を行う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
cindent({lnum})						*cindent()*
		Get the amount of indent for line {lnum} according the C
		indenting rules, as with 'cindent'.
		The indent is counted in spaces, the value of 'tabstop' is
		relevant.  {lnum} is used just like in |getline()|.
		When {lnum} is invalid or Vim was not compiled the |+cindent|
		feature, -1 is returned.
		See |C-indenting|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cindent()}
@findex cindent()
@item cindent(@{lnum@})
'@option{cindent}' で使われるのと同じ C 言語用のインデント規則に従った場合の @{lnum@} 行目のインデント量を返す。インデント量はスペースで数えられ、'@option{tabstop}' の値は関係ない。@{lnum@} は |@ref{getline()}| の場合と同様に扱われる。@{lnum@} が無効な値のときや |@ref{+cindent}| 機能なしでコンパイルされているときは -1 を返す。|@ref{C-indenting}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
clearmatches()						*clearmatches()*
		Clears all matches previously defined by |matchadd()| and the
		|:match| commands.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{clearmatches()}
@findex clearmatches()
@item clearmatches()
|@ref{matchadd()}| と コマンド |@ref{:match}| により定義されたマッチをすべて消去する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*col()*
col({expr})	The result is a Number, which is the byte index of the column
		position given with {expr}.  The accepted positions are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{col()}
@findex col()
@item col(@{expr@})
戻り値は数値で、@{expr@} で与えられる位置の桁番号 (バイトインデックス)。有効な位置は:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		    .	    the cursor position
		    $	    the end of the cursor line (the result is the
			    number of bytes in the cursor line plus one)
		    'x	    position of mark x (if the mark is not set, 0 is
			    returned)
		    v       In Visual mode: the start of the Visual area (the
			    cursor is the end).  When not in Visual mode
			    returns the cursor position.  Differs from |'<| in
			    that it's updated right away.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item . @tab 現在の位置
@item $ @tab カレント行の末尾 (カレント行のバイト数 +1 を返す)
@item 'x @tab マークxの位置 (マークが設定されていない場合 0)
@item v @tab ビジュアルモードでは: ビジュアル選択領域の開始行 (カーソルがその端)。ビジュアルモード以外ではカーソル位置を返す。すぐに更新される点が |@ref{'<}| と違う。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Additionally {expr} can be [lnum, col]: a |List| with the line
		and column number. Most useful when the column is "$", to get
		the last column of a specific line.  When "lnum" or "col" is
		out of range then col() returns zero.
		To get the line number use |line()|.  To get both use
		|getpos()|.
		For the screen column position use |virtcol()|.
		Note that only marks in the current file can be used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
さらに @{expr@} は [lnum, col] という行番号と桁番号のリスト |@ref{List}| であってもよい。col に "$" を指定して、ある行の最後の桁を取得するのにとても便利である。"lnum" か "col" が範囲外である場合は 0 を返す。

行番号を取得するには |@ref{line()}| を使う。行番号と桁番号両方を取得するには |@ref{getpos()}| を使う。画面上の桁番号を取得するには |@ref{virtcol()}| を使う。

@quotation
@strong{Note:} @*
現在のファイルのマークしか使えないことに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
			col(".")		column of cursor
			col("$")		length of cursor line plus one
			col("'t")		column of mark t
			col("'" . markname)	column of mark markname
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@multitable @columnfractions .5 .5
@item col(".") @tab カーソルの桁
@item col("$") @tab カレント行の長さ +1
@item col("'t") @tab マークtの桁
@item col("'" . markname) @tab マーク markname の桁
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		The first column is 1.  0 is returned for an error.
		For an uppercase mark the column may actually be in another
		buffer.
		For the cursor position, when 'virtualedit' is active, the
		column is one higher if the cursor is after the end of the
		line.  This can be used to obtain the column in Insert mode: >
			:imap <F2> <C-O>:let save_ve = &ve<CR>
				\<C-O>:set ve=all<CR>
				\<C-O>:echo col(".") . "\n" <Bar>
				\let &ve = save_ve<CR>
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
先頭の桁は 1 になる。戻り値 0 はエラーを意味する。大文字のマークは他のバッファを指しているかもしれない。'@option{virtualedit}' が有効なとき、カーソルが行末を越えていると、桁番号は行の長さより 1 大きい値を返す。挿入モードで桁番号を取得するには次のマップが使える:
@example
:imap <F2> <C-O>:let save_ve = &ve<CR>
        \<C-O>:set ve=all<CR>
        \<C-O>:echo col(".") . "\n" <Bar>
        \let &ve = save_ve<CR>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
complete({startcol}, {matches})			*complete()* *E785*
		Set the matches for Insert mode completion.
		Can only be used in Insert mode.  You need to use a mapping
		with CTRL-R = (see |i_CTRL-R|).  It does not work after CTRL-O
		or with an expression mapping.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{complete()}
@anchor{E785}
@findex complete()
@erindex E785
@item complete(@{startcol@}, @{matches@})
挿入モード補完の候補を設定する。挿入モードでのみ使用できる。CTRL-R = (|@ref{i_CTRL-R}| を参照) と組み合わせてマッピングを作る必要がある。CTRL-O の後や、<expr> マッピングの中では正しく動作しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{startcol} is the byte offset in the line where the completed
		text start.  The text up to the cursor is the original text
		that will be replaced by the matches.  Use col('.') for an
		empty string.  "col('.') - 1" will replace one character by a
		match.
		{matches} must be a |List|.  Each |List| item is one match.
		See |complete-items| for the kind of items that are possible.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{startcol@} は補完すべき単語の開始位置を示す、行内のバイトオフセットである。その位置からカーソルまでのテキストが補完すべき単語となる。

@{matches@} はリスト |@ref{List}| でなければならない。リストの各要素が 1 つの候補となる。この要素として許される値については |@ref{complete-items}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that the after calling this function you need to avoid
		inserting anything that would cause completion to stop.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
この関数を呼んだ後は補完を停止させるようなテキストの挿入をしないように注意しなければならない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The match can be selected with CTRL-N and CTRL-P as usual with
		Insert mode completion.  The popup menu will appear if
		specified, see |ins-completion-menu|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この関数で設定した候補は普通の挿入モード補完と同じ様に @kbd{CTRL-N} と @kbd{CTRL-P} で選択できる。設定されていればポップアップメニューが表示される。|@ref{ins-completion-menu}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example: >
	inoremap <F5> <C-R>=ListMonths()<CR>

	func! ListMonths()
	  call complete(col('.'), ['January', 'February', 'March',
		\ 'April', 'May', 'June', 'July', 'August', 'September',
		\ 'October', 'November', 'December'])
	  return ''
	endfunc
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@verbatim
inoremap <F5> <C-R>=ListMonths()<CR>
func! ListMonths()
  call complete(col('.'), ['January', 'February', 'March',
        \ 'April', 'May', 'June', 'July', 'August', 'September',
        \ 'October', 'November', 'December'])
  return ''
endfunc
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		This isn't very useful, but it shows how it works.  Note that
		an empty string is returned to avoid a zero being inserted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この例はそれほど役には立たないが、使い方を示している。
@quotation
@strong{Note:} @*
0 が挿入されてしまわないように空文字列を返していることに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
complete_add({expr})				*complete_add()*
		Add {expr} to the list of matches.  Only to be used by the
		function specified with the 'completefunc' option.
		Returns 0 for failure (empty string or out of memory),
		1 when the match was added, 2 when the match was already in
		the list.
		See |complete-functions| for an explanation of {expr}.  It is
		the same as one item in the list that 'omnifunc' would return.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{complete_add()}
@findex complete_add()
@item complete_add(@{expr@})
候補のリストに @{expr@} を追加する。'@option{completefunc}' で指定された関数の中でのみ使われる。

失敗したときは 0 を返す (空文字列かメモリ不足)。候補が追加されたときは 1 を返し、その候補が既にリストに存在するときは 2 を返す。

@{expr@} の説明については |@ref{complete-functions}| を参照。'@option{omnifunc}' が返すリストと同じである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
complete_check()				*complete_check()*
		Check for a key typed while looking for completion matches.
		This is to be used when looking for matches takes some time.
		Returns |TRUE| when searching for matches is to be aborted,
		zero otherwise.
		Only to be used by the function specified with the
		'completefunc' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{complete_check()}
@findex complete_check()
@item complete_check()
補完候補を探している間にキーがタイプされたかどうか確認する。補完の検索に時間がかかる場合に使われる。候補の検索を中断しようとしているときは |@ref{TRUE}| を返す。そうでないときは 0 を返す。

'@option{completefunc}' で指定された関数の中でのみ使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*confirm()*
confirm({msg} [, {choices} [, {default} [, {type}]]])
		Confirm() offers the user a dialog, from which a choice can be
		made.  It returns the number of the choice.  For the first
		choice this is 1.
		Note: confirm() is only supported when compiled with dialog
		support, see |+dialog_con| and |+dialog_gui|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{confirm()}
@findex confirm()
@item confirm(@{msg@} [, @{choices@} [, @{default@} [, @{type@}]]])
confirm() はユーザーに選択させるためのダイアログを提供する。戻り値は選択した番号になる。最初の選択肢が 1 である。
@quotation
@strong{Note:} @*
confirm() は、ダイアログサポートを有効にしてコンパイルした時にだけ動作する。|@ref{+dialog_con}| と |@ref{+dialog_gui}| を参照。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{msg} is displayed in a |dialog| with {choices} as the
		alternatives.  When {choices} is missing or empty, "&OK" is
		used (and translated).
		{msg} is a String, use '\n' to include a newline.  Only on
		some systems the string is wrapped when it doesn't fit.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ダイアログ |@ref{dialog}| には @{msg@} に加えて @{choices@} の選択肢が表示される。@{choices@} が指定されない、または空の場合は選択肢 "&OK" が表示される (使用している言語に翻訳される)。@{msg@} は文字列で '\n' を改行として使用できる。幾つかのシステムでは、長すぎる行は自動的に折り返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{choices} is a String, with the individual choices separated
		by '\n', e.g. >
			confirm("Save changes?", "&Yes\n&No\n&Cancel")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{choices@} は文字列で、個々の選択肢は '\n' によって区切られる。例:
@example
confirm("Save changes?", "&Yes\n&No\n&Cancel")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		The letter after the '&' is the shortcut key for that choice.
		Thus you can type 'c' to select "Cancel".  The shortcut does
		not need to be the first letter: >
			confirm("file has been modified", "&Save\nSave &All")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'&' の後の文字は選択肢のショートカットキーになる。この場合 "Cancel" を選択するのに 'c' をタイプすることができる。ショートカットキーは最初の文字である必要は無い:
@example
confirm("file has been modified", "&Save\nSave &All")
@end example

@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		For the console, the first letter of each choice is used as
		the default shortcut key.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コンソールでは、デフォルトのショートカットキーとして、各選択肢の最初の文字が使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The optional {default} argument is the number of the choice
		that is made if the user hits <CR>.  Use 1 to make the first
		choice the default one.  Use 0 to not set a default.  If
		{default} is omitted, 1 is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
省略可能な引数 @{default@} は @key{<CR>} キーを叩いた時に選択される選択肢の番号を指定する。最初の選択肢をデフォルトにするならば1を使用する。デフォルトを設定したくないのならば 0 を使用する。@{default@} を省略した場合、1 が使用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The optional {type} argument gives the type of dialog.  This
		is only used for the icon of the GTK, Mac, Motif and Win32
		GUI.  It can be one of these values: "Error", "Question",
		"Info", "Warning" or "Generic".  Only the first character is
		relevant.  When {type} is omitted, "Generic" is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
省略可能な引数 @{type@} はダイアログの種類を指定する。これは GTK, Mac, Motif, Win32 の GUI でアイコンを指定するのに使われる。"Error", "Question", "Info", "Warning", "Generic" のうちどれか 1 つを指定する。以上のうちの先頭の文字だけで指定できる。@{type@} が省略された場合、"Generic" が使用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If the user aborts the dialog by pressing <Esc>, CTRL-C,
		or another valid interrupt key, confirm() returns 0.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザーが @key{<Esc>} や @kbd{CTRL-C} や、その他の割りこみキーでダイアログを中断した場合、confirm() は 0 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		An example: >
   :let choice = confirm("What do you want?", "&Apples\n&Oranges\n&Bananas", 2)
   :if choice == 0
   :	echo "make up your mind!"
   :elseif choice == 3
   :	echo "tasteful"
   :else
   :	echo "I prefer bananas myself."
   :endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@verbatim
:let choice = confirm("What do you want?", "&Apples\n&Oranges\n&Bananas", 2)
:if choice == 0
:	echo "make up your mind!"
:elseif choice == 3
:	echo "tasteful"
:else
:	echo "I prefer bananas myself."
:endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		In a GUI dialog, buttons are used.  The layout of the buttons
		depends on the 'v' flag in 'guioptions'.  If it is included,
		the buttons are always put vertically.  Otherwise,  confirm()
		tries to put the buttons in one horizontal line.  If they
		don't fit, a vertical layout is used anyway.  For some systems
		the horizontal layout is always used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
GUI のダイアログではボタンが使用される。ボタンの配置は '@option{guioptions}' の '@var{v}' フラグに依存する。もしも '@var{v}' フラグが含まれているのなら、ボタンは常に垂直に配置される。そうでなければ水平に配置しようと試みられる。水平配置がうまくマッチしない場合は、垂直配置が使われる。幾つかのシステムでは常に水平配置が使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*copy()*
copy({expr})	Make a copy of {expr}.  For Numbers and Strings this isn't
		different from using {expr} directly.
		When {expr} is a |List| a shallow copy is created.  This means
		that the original |List| can be changed without changing the
		copy, and vice versa.  But the items are identical, thus
		changing an item changes the contents of both |Lists|.
		A |Dictionary| is copied in a similar way as a |List|.
		Also see |deepcopy()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{copy()}
@findex copy()
@item copy(@{expr@})
@{expr@} のコピーを作る。数値と文字列の場合は、@{expr@} そのものとコピーの間に違いはない。@{expr@} がリスト |@ref{List}| の場合は浅いコピーを作る。つまり元のリストを変更してもコピーは変更されず、逆も同じである。しかし要素は共通で、片方の要素に対し変更を加えると、もう一方の要素も変更される |@ref{Lists}|。辞書 |@ref{Dictionary}| はリスト |@ref{List}| と同様な方法でコピーされる。|@ref{deepcopy()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
cos({expr})						*cos()*
		Return the cosine of {expr}, measured in radians, as a |Float|.
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo cos(100)
<			0.862319 >
			:echo cos(-4.01)
<			-0.646043
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cos()}
@findex cos()
@item cos(@{expr@})
@{expr@} の余弦 (コサイン) をラジアンで浮動小数点数 |@ref{Float}| で返す。@{expr@} は |@ref{Float}| または |@ref{Number}| に評価されなければならない。

例:
@example
:echo cos(100)
0.862319
:echo cos(-4.01)
-0.646043
@end example
@{|@ref{+float}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
cosh({expr})						*cosh()*
		Return the hyperbolic cosine of {expr} as a |Float| in the range
		[1, inf].
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo cosh(0.5)
<			1.127626 >
			:echo cosh(-0.5)
<			-1.127626
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cosh()}
@findex cosh()
@item cosh(@{expr@})
@{expr@} の双曲線余弦 (ハイパボリックコサイン) を返す。値は [1, inf] の範囲の浮動小数点数 (|@ref{Float}|)。@{expr@} は浮動小数点数 (|@ref{Float}|) か 数値 (|@ref{Number}|) でなければならない。

例:
@example
:echo cosh(0.5)
1.127626
:echo cosh(-0.5)
-1.127626
@end example
@{|@ref{+float}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
count({comp}, {expr} [, {ic} [, {start}]])			*count()*
		Return the number of times an item with value {expr} appears
		in |String|, |List| or |Dictionary| {comp}.

		If {start} is given then start with the item with this index.
		{start} can only be used with a |List|.

		When {ic} is given and it's |TRUE| then case is ignored.

		When {comp} is a string then the number of not overlapping
		occurrences of {expr} is returned. Zero is returned when
		{expr} is an empty string.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{count()}
@findex count()
@item count(@{comp@}, @{expr@} [, @{ic@} [, @{start@}]])
文字列 |@ref{String}|、リスト |@ref{List}| または辞書 |@ref{Dictionary}| @{comp@} の中に値 @{expr@} が何回現れるかを返す。

@{start@} が指定されたときはそのインデックスの要素から検索を開始する。@{start@} は @{comp@} がリストの場合のみ使用できる。

@{ic@} が指定され、|@ref{TRUE}| の場合は大文字・小文字は区別されない。

@{comp@} が文字列なら、@{expr@} が重複することなく出現する数が返される。@{expr@} が空文字列ならゼロが返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
							*cscope_connection()*
cscope_connection([{num} , {dbpath} [, {prepend}]])
		Checks for the existence of a |cscope| connection.  If no
		parameters are specified, then the function returns:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cscope_connection()}
@findex cscope_connection()
@item cscope_connection([@{num@} , @{dbpath@} [, @{prepend@}]])
|@ref{cscope}| 接続が存在するかどうか判定する。引数が 1 個も指定されなかった場合、戻り値は以下のようになる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			0, if cscope was not available (not compiled in), or
			   if there are no cscope connections;
			1, if there is at least one cscope connection.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item 0 @tab cscope が利用できない (コンパイル時に無効化されている) または cscope 接続が存在しない場合
@item 1 @tab 1 個以上の cscope 接続が存在する場合
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If parameters are specified, then the value of {num}
		determines how existence of a cscope connection is checked:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数が与えられた場合は次のようになる。@{num@} は、接続の存在を確認する際のマッチング方法を指定する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{num}	Description of existence check
		-----	------------------------------
		0	Same as no parameters (e.g., "cscope_connection()").
		1	Ignore {prepend}, and use partial string matches for
			{dbpath}.
		2	Ignore {prepend}, and use exact string matches for
			{dbpath}.
		3	Use {prepend}, use partial string matches for both
			{dbpath} and {prepend}.
		4	Use {prepend}, use exact string matches for both
			{dbpath} and {prepend}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@headitem @{num@} @tab 存在確認の方法
@item 0 @tab 引数なしの場合と同じ (例: "cscope_connection()")。
@item 1 @tab @{prepend@} を無視し、@{dbpath@} に部分マッチを行う。
@item 2 @tab @{prepend@} を無視し、@{dbpath@} に部分マッチを行う。
@item 3 @tab @{prepend@} を使用し、@{dbpath@} と @{prepend@} に部分マッチを行う。
@item 4 @tab @{prepend@} を使用し、@{dbpath@} と @{prepend@} に完全マッチを行う。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Note: All string comparisons are case sensitive!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
以上のどの場合も文字列の比較は大文字・小文字を区別する。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Examples.  Suppose we had the following (from ":cs show"): >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例: "@command{:cs show}" の表示が以下のようになったとする:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  # pid    database name			prepend path
  0 27664  cscope.out				/usr/local
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
# pid    database name                        prepend path
0 27664  cscope.out                           /usr/local
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Invocation					Return Val ~
		----------					---------- >
		cscope_connection()					1
		cscope_connection(1, "out")				1
		cscope_connection(2, "out")				0
		cscope_connection(3, "out")				0
		cscope_connection(3, "out", "local")			1
		cscope_connection(4, "out")				0
		cscope_connection(4, "out", "local")			0
		cscope_connection(4, "cscope.out", "/usr/local")	1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
実行                                            戻り値
cscope_connection()                                     1
cscope_connection(1, "out")                             1
cscope_connection(2, "out")                             0
cscope_connection(3, "out")                             0
cscope_connection(3, "out", "local")                    1
cscope_connection(4, "out")                             0
cscope_connection(4, "out", "local")                    0
cscope_connection(4, "cscope.out", "/usr/local")        1
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
cursor({lnum}, {col} [, {off}])				*cursor()*
cursor({list})
		Positions the cursor at the column (byte count) {col} in the
		line {lnum}.  The first column is one.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cursor()}
@findex cursor()
@item cursor(@{lnum@}, @{col@} [, @{off@}]) または
@itemx cursor(@{list@})
@{lnum@} 行目の @{col@} 桁目 (バイトで数える) にカーソルを移動させる。桁番号 @{col@} は 1 から始まる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When there is one argument {list} this is used as a |List|
		with two, three or four item:
			[{lnum}, {col}]
			[{lnum}, {col}, {off}]
			[{lnum}, {col}, {off}, {curswant}]
		This is like the return value of |getpos()| or |getcurpos()|,
		but without the first item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数に @{list@} が 1 つだけ指定された場合は、それは要素が 2 個か 3 個、または 4 個の |@ref{List}| として解釈される:
@multitable @columnfractions .99
@item [@{lnum@}, @{col@}]
@item [@{lnum@}, @{col@}, @{off@}]
@item [@{lnum@}, @{col@}, @{off@}, @{curswant@}]
@end multitable
これは |@ref{getpos()}| や |@ref{getcurpos()}| の戻り値とほぼ同じである。違いは最初の要素がないこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Does not change the jumplist.
		If {lnum} is greater than the number of lines in the buffer,
		the cursor will be positioned at the last line in the buffer.
		If {lnum} is zero, the cursor will stay in the current line.
		If {col} is greater than the number of bytes in the line,
		the cursor will be positioned at the last character in the
		line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この関数を呼んでもジャンプリストは変更されない。@{lnum@} がバッファの行数よりも大きい場合は、最後の行へ移動する。@{lnum@} が 0 の場合はカレント行に留まる。@{col@} がその行のバイト数より大きい場合は、その行の最後の文字へ移動する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If {col} is zero, the cursor will stay in the current column.
		If {curswant} is given it is used to set the preferred column
		for vertical movement.  Otherwise {col} is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@{col@} が 0 の場合は、カレント桁に留まる。@{curswant@} が与えられた場合は、縦方向移動の優先的列番号として使われる。指定がない場合は @{col@} が使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When 'virtualedit' is used {off} specifies the offset in
		screen columns from the start of the character.  E.g., a
		position within a <Tab> or after the last character.
		Returns 0 when the position could be set, -1 otherwise.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{virtualedit}' が有効のとき、@{off@} は文字の先頭からの画面上のオフセットを指定する。例えば、<Tab> の中の位置や最後の文字より後などへも移動できる。カーソルを移動できたときは 0 を、できなかったときは -1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
debugbreak({pid})					*debugbreak()*
		Specifically used to interrupt a program being debugged.  It
		will cause process {pid} to get a SIGTRAP.  Behavior for other
		processes is undefined. See |terminal-debugger|.
		{only available on MS-Windows}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{debugbreak()}
@cindex debugbreak()
@item debugbreak(@{pid@})
デバッグしているプログラムを明確に中断するために使われる。プロセス @{pid@} が SIGTRAP を受け取ることになるだろう。他のプロセスに対する挙動は未定義。|@ref{terminal-debugger}| を参照。

@{MS-Windows 上でのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
deepcopy({expr} [, {noref}])				*deepcopy()* *E698*
		Make a copy of {expr}.  For Numbers and Strings this isn't
		different from using {expr} directly.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{deepcopy()}
@anchor{E698}
@findex deepcopy()
@erindex E698
@item deepcopy(@{expr@} [, @{noref@}])
@{expr@} のコピーを作る。数値と文字列の場合は、@{expr@} そのものとコピーの間に違いはない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When {expr} is a |List| a full copy is created.  This means
		that the original |List| can be changed without changing the
		copy, and vice versa.  When an item is a |List| or
		|Dictionary|, a copy for it is made, recursively.  Thus
		changing an item in the copy does not change the contents of
		the original |List|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@{expr@} がリスト |@ref{List}| の場合は完全なコピーを作る。つまり元のリストを変更してもコピーは変更されず、逆も同じである。要素の 1 つがリストまたは辞書 |@ref{Dictionary}| であるときは、再帰的にコピーが作成される。よってコピーの要素に変更を加えても元のリストの要素は変更を受けない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		A |Dictionary| is copied in a similar way as a |List|.
		When {noref} is omitted or zero a contained |List| or
		|Dictionary| is only copied once.  All references point to
		this single copy.  With {noref} set to 1 every occurrence of a
		|List| or |Dictionary| results in a new copy.  This also means
		that a cyclic reference causes deepcopy() to fail.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

辞書 |@ref{Dictionary}| はリスト |@ref{List}| と同様な方法でコピーされる。@{noref@} が省略された、または 0 のとき、含まれているリストや辞書は 1 度だけコピーされる。全ての参照はこのただ 1 つのコピーを指す。@{noref@} が 1 の場合、リストや辞書は現れるたびに新しいコピーが作られる。そのため循環参照があると deepcopy() は失敗する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
								*E724*
		Nesting is possible up to 100 levels.  When there is an item
		that refers back to a higher level making a deep copy with
		{noref} set to 1 will fail.
		Also see |copy()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@anchor{E724}
@erindex E724
ネストは 100 レベルまで可能である。それ以上参照を繰り返している要素があると、@{noref@} が 1 の場合は失敗する。|@ref{copy()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
delete({fname} [, {flags}])					*delete()*
		Without {flags} or with {flags} empty: Deletes the file by the
		name {fname}.  This also works when {fname} is a symbolic link.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{delete()}
@findex delete()
@item delete(@{fname@} [, @{flags@}])
@{flags@} を指定しないもしくは @{flags@} を空で指定した場合: ファイル @{fname@} を削除する。これは @{fname@} がシンボリックリンクの時でも動作する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {flags} is "d": Deletes the directory by the name
		{fname}.  This fails when directory {fname} is not empty.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{flags@}が "d" の場合: ディレクトリ @{fname@} を削除する。これはディレクトリ @{fname@} が空でない場合は失敗する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {flags} is "rf": Deletes the directory by the name
		{fname} and everything in it, recursively.  BE CAREFUL!
		Note: on MS-Windows it is not possible to delete a directory
		that is being used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{flags@} が "rf" の場合: ディレクトリ @{fname@}、その中に含むすべてのものを再帰的に削除する。気をつけて！
@quotation
@strong{Note:} @*
MS-Windows では、使用中のディレクトリを削除することはできない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		A symbolic link itself is deleted, not what it points to.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シンボリックリンクは、それが示すものではなく、リンク自身が削除される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The result is a Number, which is 0 if the delete operation was
		successful and -1 when the deletion failed or partly failed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
結果は数値であり、削除に成功すれば 0、削除に失敗すれば -1 である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Use |remove()| to delete an item from a |List|.
		To delete a line from the buffer use |:delete| or
		|deletebufline()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リスト |@ref{List}| から項目を削除するには |@ref{remove()}| を使う。バッファから行を削除するには |@ref{:delete}| もしくは |@ref{deletebufline()}| を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
deletebufline({expr}, {first} [, {last}])		*deletebufline()*
		Delete lines {first} to {last} (inclusive) from buffer {expr}.
		If {last} is omitted then delete line {first} only.
		On success 0 is returned, on failure 1 is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{deletebufline()}
@cindex deletebufline()
@item deletebufline(@{expr@}, @{first@} [, @{last@}])
バッファ @{expr@} から、行 @{first@} から @{last@} (を含む) までの行を削除する。もしも @{last@} が省略されているなら、行 @{first@} のみ削除する。成功すると 0 が返され、失敗すると 1 が返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For the use of {expr}, see |bufname()| above.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr@} の使い方は上記の |@ref{bufname()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{first} and {last} are used like with |setline()|. Note that
		when using |line()| this refers to the current buffer. Use "$"
		to refer to the last line in buffer {expr}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{first@} と @{last@} は |@ref{setline()}| と同じように使われる。
@quotation
@strong{Note:} @*
|@ref{line()}| を使用するときはカレントバッファに適用されることに注意。バッファ @{expr@} 内の最終行に適用するには "$" を使う。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*did_filetype()*
did_filetype()	Returns |TRUE| when autocommands are being executed and the
		FileType event has been triggered at least once.  Can be used
		to avoid triggering the FileType event again in the scripts
		that detect the file type. |FileType|
		Returns |FALSE| when `:setf FALLBACK` was used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{did_filetype()}
@findex did_filetype()
@item did_filetype()
autocommand が実行され FileType イベントが一度でも起こっていれば、|@ref{TRUE}| が返る。スクリプトの FileType イベントが、複数回呼び出されるのを回避するのに使える。|@ref{FileType}|

`@command{:setf FALLBACK}` が使われたときは |@ref{FALSE}| が返る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When editing another file, the counter is reset, thus this
		really checks if the FileType event has been triggered for the
		current buffer.  This allows an autocommand that starts
		editing another buffer to set 'filetype' and load a syntax
		file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
他のファイルへ移動すると、このカウンタはリセットされる。よって実際は、カレントバッファに対して FileType イベントが発生したかどうかを判定する。他のバッファを開くオートコマンドの中でこの関数を使って '@option{filetype}' を設定し、構文ファイルを読み込むために使える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
diff_filler({lnum})					*diff_filler()*
		Returns the number of filler lines above line {lnum}.
		These are the lines that were inserted at this point in
		another diff'ed window.  These filler lines are shown in the
		display but don't exist in the buffer.
		{lnum} is used like with |getline()|.  Thus "." is the current
		line, "'m" mark m, etc.
		Returns 0 if the current window is not in diff mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{diff_filler()}
@findex diff_filler()
@item diff_filler(@{lnum@})
@{lnum@} 行目より上にある削除行の数を返す。削除行とは、差分モードで他方のウィンドウにテキストが挿入されていることを表す行のことである。削除行は表示はされているが、実際にはバッファに存在しない。

@{lnum@} は |@ref{getline()}| と同様に扱われる。つまり "." はカレント行となり、"'m" はマーク m を表す。

カレントウィンドウが差分モードでないときは 0 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
diff_hlID({lnum}, {col})				*diff_hlID()*
		Returns the highlight ID for diff mode at line {lnum} column
		{col} (byte index).  When the current line does not have a
		diff change zero is returned.
		{lnum} is used like with |getline()|.  Thus "." is the current
		line, "'m" mark m, etc.
		{col} is 1 for the leftmost column, {lnum} is 1 for the first
		line.
		The highlight ID can be used with |synIDattr()| to obtain
		syntax information about the highlighting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{diff_hlID()}
@findex diff_hlID()
@item diff_hlID(@{lnum@}, @{col@})
差分モードで @{lnum@} 行 @{col@} 桁 (バイト単位) の位置のハイライト ID を返す。カレント行に変更がないときは 0 を返す。

@{lnum@} は |@ref{getline()}| と同様に扱われる。つまり "." はカレント行となり、"'m" はマーク m を表す。

先頭の桁の @{col@} は 1 となり、最初の行の @{lnum@} は 1 となる。

ハイライト ID は |@ref{synIDattr()}| を使って構文情報を得るために使える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
empty({expr})						*empty()*
		Return the Number 1 if {expr} is empty, zero otherwise.
		- A |List| or |Dictionary| is empty when it does not have any
		  items.
		- A String is empty when its length is zero.
		- A Number and Float is empty when its value is zero.
		- |v:false|, |v:none| and |v:null| are empty, |v:true| is not.
		- A Job is empty when it failed to start.
		- A Channel is empty when it is closed.

		For a long |List| this is much faster than comparing the
		length with zero.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{empty()}
@findex empty()
@item empty(@{expr@})
@{expr@} が空なら 1 を、そうでなければ 0 を返す。
@itemize
@item リスト |@ref{List}| または辞書 |@ref{Dictionary}| は要素を 1 個も持たないとき空とみなされる。
@item 長さが 0 のとき文字列は空である。
@item 数値と浮動小数点数は値が 0 のとき空とみなされる。
@item |@ref{v:false}|, |@ref{v:none}|, |@ref{v:null}| は空であり、|@ref{v:true}| は空ではない。
@item ジョブは開始に失敗したときは空である。
@item チャネルは閉じられていると空である。
@end itemize
長いリスト |@ref{List}| に対しては長さを 0 と比較するよりこちらの方がずっと高速である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
escape({string}, {chars})				*escape()*
		Escape the characters in {chars} that occur in {string} with a
		backslash.  Example: >
			:echo escape('c:\program files\vim', ' \')
<		results in: >
			c:\\program\ files\\vim
<		Also see |shellescape()| and |fnameescape()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{escape()}
@findex escape()
@item escape(@{string@}, @{chars@})
@{string@} 内に現れる @{chars@} の文字をバックスラッシュでエスケープする。例:
@example
:echo escape('c:\program files\vim', ' \')
@end example
結果:
@example
c:\\program\ files\\vim
@end example
|@ref{shellescape()}| と |@ref{fnameescape()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*eval()*
eval({string})	Evaluate {string} and return the result.  Especially useful to
		turn the result of |string()| back into the original value.
		This works for Numbers, Floats, Strings and composites of
		them.  Also works for |Funcref|s that refer to existing
		functions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{eval()}
@findex eval()
@item eval(@{string@})
@{string@} を評価し、値を返す。|@ref{string()}| の戻り値を元の値に戻すのに非常に便利である。数値、浮動小数点数文字列、それらの複合に対して動作する。実際に存在する関数への |@ref{Funcref}| に対しても動作する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
eventhandler()						*eventhandler()*
		Returns 1 when inside an event handler.  That is that Vim got
		interrupted while waiting for the user to type a character,
		e.g., when dropping a file on Vim.  This means interactive
		commands cannot be used.  Otherwise zero is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{eventhandler()}
@findex eventhandler()
@item eventhandler()
イベントハンドラの中では 1 を返す。つまり、ユーザーの文字入力を待っている間に、例えばファイルをドラッグ＆ドロップするなどの割り込みがされたことを表す。このときは対話的なコマンドは使えない。イベントハンドラの中でないときは 0 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
executable({expr})					*executable()*
		This function checks if an executable with the name {expr}
		exists.  {expr} must be the name of the program without any
		arguments.
		executable() uses the value of $PATH and/or the normal
		searchpath for programs.		*PATHEXT*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{executable()}
@findex executable()
@item executable(@{expr@})
@{expr@} という名前の実行可能ファイルが存在するかどうか判定する。@{expr@} は引数を何もつけないプログラム名でなければならない。executable() は @env{$PATH} と通常のプログラム検索ディレクトリを参照する。
@anchor{PATHEXT}
@cindex PATHEXT
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		On MS-DOS and MS-Windows the ".exe", ".bat", etc. can
		optionally be included.  Then the extensions in $PATHEXT are
		tried.  Thus if "foo.exe" does not exist, "foo.exe.bat" can be
		found.  If $PATHEXT is not set then ".exe;.com;.bat;.cmd" is
		used.  A dot by itself can be used in $PATHEXT to try using
		the name without an extension.  When 'shell' looks like a
		Unix shell, then the name is also tried without adding an
		extension.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

MS-DOS と MS-Windows では ".exe", ".bat" などの拡張子は含めても含めなくてもよい。省略された場合は @env{$PATHEXT} の拡張子を検索する。よって "@file{foo.exe}" が存在しなければ "@file{foo.exe.bat}" が見つかることもありうる。@env{$PATHEXT} が存在しなければ ".exe;.com;.bat;.cmd" が使われる。@env{$PATHEXT} にドットだけを含めると拡張子なしの名前を検索することができる。'@option{shell}' が Unix シェルのように思われるときは、@{expr@} の後に拡張子をつけない名前も検索される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		On MS-DOS and MS-Windows it only checks if the file exists and
		is not a directory, not if it's really executable.
		On MS-Windows an executable in the same directory as Vim is
		always found.  Since this directory is added to $PATH it
		should also work to execute it |win32-PATH|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

MS-DOS と MS-Windows ではファイルが存在するかどうかだけを判定し、それがディレクトリでないことや、それが本当に実行可能であるかどうかは判定されない。MS-Windows では Vim と同じディレクトリにある実行ファイルは必ず発見できる。Vim がこのディレクトリを @env{$PATH} に加えるためである。|@ref{win32-PATH}|。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The result is a Number:
			1	exists
			0	does not exist
			-1	not implemented on this system
		|exepath()| can be used to get the full path of an executable.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
戻り値は数値:
@multitable @columnfractions .1 .9
@item 1 @tab 存在する
@item 0 @tab 存在しない
@item -1 @tab このシステム上では実装されていない
@end multitable
|@ref{exepath()}| は実行ファイルのフルパスを取得するのに使うことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
execute({command} [, {silent}])					*execute()*
		Execute an Ex command or commands and return the output as a
		string.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{execute()}
@findex execute()
@item execute(@{command@} [, @{silent@}])
単一あるいは複数の Ex コマンドを実行して、出力を文字列として返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{command} can be a string or a List.  In case of a List the
		lines are executed one by one.
		This is equivalent to: >
			redir => var
			{command}
			redir END
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{command@} は文字列かリストを使える。リストの場合はそれらの行は一行ずつ実行される。

以下と同等である:
@example
redir => var
@{command@}
redir END
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The optional {silent} argument can have these values:
			""		no `:silent` used
			"silent"	`:silent` used
			"silent!"	`:silent!` used
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプションの @{silent@} の引数は以下の値を取ることができる:
@multitable @columnfractions .4 .6
@item "" @tab `:silent` を使わない
@item "silent" @tab `:silent` を使う
@item "silent!" @tab `:silent!`を使う
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The default is "silent".  Note that with "silent!", unlike
		`:redir`, error messages are dropped.  When using an external
		command the screen may be messed up, use `system()` instead.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デフォルトは "silent" である。
@quotation
@strong{Note:} @*
"silent!" は `redir` とは異なり、エラーメッセージは削除されることに注意すること。もし外部コマンドを使って画面がおかしくなる様であれば、代わりに `system()` を使うことができる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*E930*
		It is not possible to use `:redir` anywhere in {command}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E930}
@erindex E930
@{command@} の中のどこかで `:redir` を使うことができない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		To get a list of lines use |split()| on the result: >
			split(execute('args'), "\n")

<		When used recursively the output of the recursive call is not
		included in the output of the higher level call.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
行のリストを得るために、出力に |@ref{split()}| を使うことができる:
@example
split(execute('args'), "\n")
@end example
再帰的に使用されると、再帰呼び出しの出力は、上位呼び出しの出力に含まれません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
exepath({expr})						*exepath()*
		If {expr} is an executable and is either an absolute path, a
		relative path or found in $PATH, return the full path.
		Note that the current directory is used when {expr} starts
		with "./", which may be a problem for Vim: >
			echo exepath(v:progpath)
<		If {expr} cannot be found in $PATH or is not executable then
		an empty string is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{exepath()}
@findex exepath()
@item exepath(@{expr@})
@{expr@} が実行ファイルで、それが絶対パス、相対パス、または @env{$PATH} の中に存在する場合は、そのフルパスを返す。
@quotation
@strong{Note:} @*
@{expr@} が "./" で開始している場合はカレントディレクトリが使われる。Vim のパスを得る場合に問題になるかもしれない:
@example
echo exepath(v:progpath)
@end example
@{expr@} が @env{$PATH} の中に見つからないか、それが実行ファイルではなかった場合は空文字列が返る。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*exists()*
exists({expr})	The result is a Number, which is |TRUE| if {expr} is defined,
		zero otherwise.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{exists()}
@findex exists()
@item exists(@{expr@})
結果は数値で、変数 @{expr@} が存在すれば |@ref{TRUE}| となり、そうでなければ 0 となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For checking for a supported feature use |has()|.
		For checking if a file exists use |filereadable()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ある機能がサポートされているか判定するには |@ref{has()}| を使う。

ファイルが存在するかを判定するには |@ref{filereadable()}| を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The {expr} argument is a string, which contains one of these:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数 @{expr@} は文字列で次のうちいずれかである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			&option-name	Vim option (only checks if it exists,
					not if it really works)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item &option-name
Vim オプション (存在するかだけを判定し、本当に動作するかは判定しない)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			+option-name	Vim option that works.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item +option-name
動作する Vim オプション
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			$ENVNAME	environment variable (could also be
					done by comparing with an empty
					string)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item $ENVNAME
環境変数 (空文字列と比較することでも判定できる)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			*funcname	built-in function (see |functions|)
					or user defined function (see
					|user-functions|). Also works for a
					variable that is a Funcref.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item *funcname
組み込み関数 (|@ref{functions}| 参照) かユーザーが定義した関数 (|@ref{user-functions}| 参照)。また Funcref である変数に対しても動作する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			varname		internal variable (see
					|internal-variables|).  Also works
					for |curly-braces-names|, |Dictionary|
					entries, |List| items, etc.  Beware
					that evaluating an index may cause an
					error message for an invalid
					expression.  E.g.: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item varname
内部変数(|@ref{internal-variables}|)。|@ref{curly-braces-names}|, |@ref{Dictionary}| の要素、|@ref{List}| の要素などに対しても動作する。インデックスの評価で無効な式であるとエラーメッセージが出る可能性があることに注意。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					   :let l = [1, 2, 3]
					   :echo exists("l[5]")
<					   0 >
					   :echo exists("l[xx]")
<					   E121: Undefined variable: xx
					   0
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:let l = [1, 2, 3]
:echo exists("l[5]")
0
:echo exists("l[xx]")
E121: Undefined variable: xx
0
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			:cmdname	Ex command: built-in command, user
					command or command modifier |:command|.
					Returns:
					1  for match with start of a command
					2  full match with a command
					3  matches several user commands
					To check for a supported command
					always check the return value to be 2.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :cmdname
ex コマンド: 組み込みコマンド、ユーザー定義コマンド、コマンド修飾子 |@ref{:command}|。

戻り値:
@enumerate
@item コマンド名の先頭に一致
@item コマンド名に完全一致
@item 複数のユーザー定義コマンドに一致
@end enumerate
コマンドが定義されているかどうかを判定するには、必ず戻り値が2であるかを確認すること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			:2match		The |:2match| command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :2match
|@ref{:2match}| のコマンド。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			:3match		The |:3match| command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :3match
|@ref{:3match}| のコマンド。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			#event		autocommand defined for this event
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item #event
このイベントに対するオートコマンド定義
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			#event#pattern	autocommand defined for this event and
					pattern (the pattern is taken
					literally and compared to the
					autocommand patterns character by
					character)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item #event#pattern
このイベントとパターンに対するオートコマンド定義(パターンは文字そのままに解釈され、オートコマンドのパターンと 1 文字ずつ比較される)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			#group		autocommand group exists
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item #group
オートコマンドグループが存在するか
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			#group#event	autocommand defined for this group and
					event.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item #group#event
このグループとイベントに対してオートコマンドが定義されているか
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			#group#event#pattern
					autocommand defined for this group,
					event and pattern.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item #group#event#pattern
このグループ、イベント、パターンに対するオートコマンド定義
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			##event		autocommand for this event is
					supported.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ##event
このイベントに対するオートコマンドがサポートされているか
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Examples: >
			exists("&shortname")
			exists("$HOSTNAME")
			exists("*strftime")
			exists("*s:MyFunc")
			exists("bufcount")
			exists(":Make")
			exists("#CursorHold")
			exists("#BufReadPre#*.gz")
			exists("#filetypeindent")
			exists("#filetypeindent#FileType")
			exists("#filetypeindent#FileType#*")
			exists("##ColorScheme")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
exists("&shortname")
exists("$HOSTNAME")
exists("*strftime")
exists("*s:MyFunc")
exists("bufcount")
exists(":Make")
exists("#CursorHold")
exists("#BufReadPre#*.gz")
exists("#filetypeindent")
exists("#filetypeindent#FileType")
exists("#filetypeindent#FileType#*")
exists("##ColorScheme")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		There must be no space between the symbol (&/$/*/#) and the
		name.
		There must be no extra characters after the name, although in
		a few cases this is ignored.  That may become more strict in
		the future, thus don't count on it!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シンボルである&/$/*と名前の間には、空白文字があってはならない。

ある少数の場合では無視されるが、名前の後に余計な文字があってはならない。将来はもっと厳格になる可能性があるので、現在許されるからといって頼ってはならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Working example: >
			exists(":make")
<		NOT working example: >
			exists(":make install")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
正しい例:
@example
exists(":make")
@end example
正しくない例:
@example
exists(":make install")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		Note that the argument must be a string, not the name of the
		variable itself.  For example: >
			exists(bufcount)
<		This doesn't check for existence of the "bufcount" variable,
		but gets the value of "bufcount", and checks if that exists.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
引数は変数そのものではなく、文字列でなければならない。例えば、次は動作しない:
@example
exists(bufcount)
@end example
これは変数 "bufcount" の存在を判定するのではなく、bufcount の値を渡し、それが存在するかどうか判定してしまう。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
exp({expr})						*exp()*
		Return the exponential of {expr} as a |Float| in the range
		[0, inf].
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo exp(2)
<			7.389056 >
			:echo exp(-1)
<			0.367879
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{exp()}
@findex exp()
@item exp(@{expr@})
@{expr@} の指数を返す。値は [0, inf] の範囲の浮動小数点数 (|@ref{Float}|)。@{expr@} は浮動小数点数 (|@ref{Float}|) か数値 (|@ref{Number}|) でなければならない。
例:
@example
:echo exp(2)
7.389056
:echo exp(-1)
0.367879
@end example
@{|@ref{+float}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
expand({expr} [, {nosuf} [, {list}]])				*expand()*
		Expand wildcards and the following special keywords in {expr}.
		'wildignorecase' applies.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expand()}
@findex expand()
@item expand(@{expr@} [, @{nosuf@} [, @{list@}]])
ワイルドカードと @{expr@} 内の特殊なキーワードを展開する。'@option{wildignorecase}' が適用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {list} is given and it is |TRUE|, a List will be returned.
		Otherwise the result is a String and when there are several
		matches, they are separated by <NL> characters.  [Note: in
		version 5.0 a space was used, which caused problems when a
		file name contains a space]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{list@} が指定されその値が |@ref{TRUE}| なら、結果はリストで返される。そうでない場合は結果は文字列で返される。その場合、複数のマッチがあるときはそれらは文字 <NL> で区切られる。
@quotation
@strong{Note:} @*
バージョン5.0 では空白文字が用いられ、スペースを含むファイル名について問題を引き起こしていた
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If the expansion fails, the result is an empty string.  A name
		for a non-existing file is not included, unless {expr} does
		not start with '%', '#' or '<', see below.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
展開が失敗した場合、結果は空文字列となる。@{expr@} が '%', '#', '<' で始まらない限り、存在しないファイル名というのは、結果の文字列には含まれない。下記を参照のこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {expr} starts with '%', '#' or '<', the expansion is done
		like for the |cmdline-special| variables with their associated
		modifiers.  Here is a short overview:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr@} が '%' か '#' か '<' で始まる場合には、展開は |@ref{cmdline-special}| のように、変換子を受け付け、それらに関連付けられた変換が施される。ここに簡単な概略を示す:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			%		current file name
			#		alternate file name
			#n		alternate file name n
			<cfile>		file name under the cursor
			<afile>		autocmd file name
			<abuf>		autocmd buffer number (as a String!)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item % @tab 現在のファイル名
@item # @tab 代替バッファのファイル名
@item #n @tab n 番の代替バッファのファイル名
@item <cfile> @tab カーソルの下のファイル名
@item <afile> @tab autocmd のファイル名
@item <abuf> @tab autocmd のバッファ名
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			<amatch>	autocmd matched name
			<sfile>		sourced script file or function name
			<slnum>		sourced script file line number
			<cword>		word under the cursor
			<cWORD>		WORD under the cursor
			<client>	the {clientid} of the last received
					message |server2client()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item <sfile> @tab 取り込み (source) 中のファイル名、関数名
@item <slnum> @tab 取り込み (source) 中の行番号
@item <cword> @tab カーソル下の単語 (word)
@item <cWORD> @tab カーソル下の単語 (WORD)
@item <client> @tab 最後に受け取ったメッセージの @{clientid@} |@ref{server2client()}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Modifiers:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変換子:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			:p		expand to full path
			:h		head (last path component removed)
			:t		tail (last path component only)
			:r		root (one extension removed)
			:e		extension only
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item :p @tab フルパス名を展開
@item :h @tab ヘッド (ディレクトリ)
@item :t @tab テイル (ファイル名だけ)
@item :r @tab 拡張子が削除される
@item :e @tab 拡張子だけ
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example: >
			:let &tags = expand("%:p:h") . "/tags"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:let &tags = expand("%:p:h") . "/tags"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		Note that when expanding a string that starts with '%', '#' or
		'<', any following text is ignored.  This does NOT work: >
			:let doesntwork = expand("%:h.bak")
<		Use this: >
			:let doeswork = expand("%:h") . ".bak"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
'%' や '#' や '<' で始まる文字列を展開する時には、それに続くテキストは無視されることに注意。従ってこれは正しくない:
@example
:let doesntwork = expand("%:h.bak")
@end example
こうすると良い:
@example
:let doeswork = expand("%:h") . ".bak"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		Also note that expanding "<cfile>" and others only returns the
		referenced file name without further expansion.  If "<cfile>"
		is "~/.cshrc", you need to do another expand() to have the
		"~/" expanded into the path of the home directory: >
			:echo expand(expand("<cfile>"))
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"<cfile>" やそれらを展開する時には、戻り値が完全な展開をされない参照名であることにも注意が必要。もしも "<cfile>" が "~/.cshrc" であった場合、"~/" を展開してホームディレクトリにするために、もう一度 expand() を呼び出す必要がある:
@example
:echo expand(expand("<cfile>"))
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		There cannot be white space between the variables and the
		following modifier.  The |fnamemodify()| function can be used
		to modify normal file names.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数と変換子の間には空白文字があってはならない。関数 |@ref{fnamemodify()}| が通常のファイル名の変換には使用可能である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When using '%' or '#', and the current or alternate file name
		is not defined, an empty string is used.  Using "%:p" in a
		buffer with no name, results in the current directory, with a
		'/' added.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カレントバッファや代替バッファの名前が未定義のときに '%' や '#' を使うと空文字列になる。"%:p" を名無しのバッファに使用した場合、結果はカレントディレクトリに '/' が付加されたものになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {expr} does not start with '%', '#' or '<', it is
		expanded like a file name is expanded on the command line.
		'suffixes' and 'wildignore' are used, unless the optional
		{nosuf} argument is given and it is |TRUE|.
		Names for non-existing files are included.  The "**" item can
		be used to search in a directory tree.  For example, to find
		all "README" files in the current directory and below: >
			:echo expand("**/README")
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'%' や '#' や '<' で始まらない @{expr@} は、コマンドラインのファイル名と同じように展開される。@{nosuf@} 引数に |@ref{TRUE}| を指定しない限り、'@option{suffixes}' と '@option{wildignore}' が使用される。存在しないファイルの名前も結果の文字列に含まれる。"**" を使うとディレクトリツリーを検索できる。例えば、カレントディレクトリ以下にある全ての "README" を見つけるには次のようにする:
@example
:echo expand("**/README")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Expand() can also be used to expand variables and environment
		variables that are only known in a shell.  But this can be
		slow, because a shell may be used to do the expansion.  See
		|expr-env-expand|.
		The expanded variable is still handled like a list of file
		names.  When an environment variable cannot be expanded, it is
		left unchanged.  Thus ":echo expand('$FOOBAR')" results in
		"$FOOBAR".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
expand() はシェルの持っている変数や環境変数を展開できる。しかし展開のためにシェルを起動するかもしれないので速度が遅くなることがある。|@ref{expr-env-expand}| 参照。展開された変数はファイル名のリストのように扱われる。環境変数を展開できないときはそのままになる。よって、"@command{:echo expand('$FOOBAR')}" の結果は "$FOOBAR" となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		See |glob()| for finding existing files.  See |system()| for
		getting the raw output of an external command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
存在するファイルを探すには |@ref{glob()}| を参照。外部コマンドの「生の」実行結果を扱うには |@ref{system()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
extend({expr1}, {expr2} [, {expr3}])			*extend()*
		{expr1} and {expr2} must be both |Lists| or both
		|Dictionaries|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{extend()}
@findex extend()
@item extend(@{expr1@}, @{expr2@} [, @{expr3@}])
@{expr1@} と @{expr2@} は両方ともリスト |@ref{List}| であるか、両方とも辞書 |@ref{Dictionaries}| でなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If they are |Lists|: Append {expr2} to {expr1}.
		If {expr3} is given insert the items of {expr2} before item
		{expr3} in {expr1}.  When {expr3} is zero insert before the
		first item.  When {expr3} is equal to len({expr1}) then
		{expr2} is appended.
		Examples: >
			:echo sort(extend(mylist, [7, 5]))
			:call extend(mylist, [2, 3], 1)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
両方ともリスト |@ref{Lists}| であるなら、@{expr2@} を @{expr1@} に付け加える。@{expr3@} が指定された場合は、@{expr1@} の第 @{expr3@} 番目の要素の前に @{expr2@} の要素を挿入する。@{expr3@} が 0 のときは最初の要素の前に挿入する。@{expr3@} が len(@{expr1@}) に等しいときは末尾に @{expr2@} が付け加えられる。

例:
@example
:echo sort(extend(mylist, [7, 5]))
:call extend(mylist, [2, 3], 1)
@end example                
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		When {expr1} is the same List as {expr2} then the number of
		items copied is equal to the original length of the List.
		E.g., when {expr3} is 1 you get N new copies of the first item
		(where N is the original length of the List).
		Use |add()| to concatenate one item to a list.  To concatenate
		two lists into a new list use the + operator: >
			:let newlist = [1, 2, 3] + [4, 5]
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr1@} が @{expr2@} と同じリストである場合、コピーされる要素の数はリストの元の長さと同じである。例として @{expr3@} が 1 のとき、最初の要素の N 個の新しいコピーが挿入される (ここで N はリストの元の長さ)。

リストに 1 個の要素を加えるには |@ref{add()}| を使う。2 つのリストを連結して新しいリストを作るには演算子 + を使う:
@example
:let newlist = [1, 2, 3] + [4, 5]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If they are |Dictionaries|:
		Add all entries from {expr2} to {expr1}.
		If a key exists in both {expr1} and {expr2} then {expr3} is
		used to decide what to do:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
両方とも辞書 |@ref{Dictionaries}| である場合: @{expr2@} の全要素を @{expr1@} に加える。

@{expr1@} と @{expr2@} で共通のキーがある場合は、@{expr3@} によって動作が決まる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{expr3} = "keep": keep the value of {expr1}
		{expr3} = "force": use the value of {expr2}
		{expr3} = "error": give an error message		*E737*
		When {expr3} is omitted then "force" is assumed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .5 .5
@item @{expr3@} = "keep" の場合: @tab @{expr1@} の値そのままにする
@item @{expr3@} = "force" の場合: @tab @{expr2@} の値で上書きする
@item @{expr3@} = "error" の場合: @tab エラーメッセージを表示する
@end multitable
@anchor{E737}
@erindex E737
@{expr3@} が省略された場合は "force" と同じになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{expr1} is changed when {expr2} is not empty.  If necessary
		make a copy of {expr1} first.
		{expr2} remains unchanged.
		When {expr1} is locked and {expr2} is not empty the operation
		fails.
		Returns {expr1}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr2@} が空でないならば @{expr1@} が変更される。必要ならば最初に @{expr1@} のコピーを作ること。

@{expr2@} は変更されない。

@{expr1@} がロックされていて、かつ @{expr2@} が空でない場合は操作は失敗する。

@{expr1@} を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
feedkeys({string} [, {mode}])				*feedkeys()*
		Characters in {string} are queued for processing as if they
		come from a mapping or were typed by the user.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{feedkeys()}
@findex feedkeys()
@item feedkeys(@{string@} [, @{mode@}])
@{string@} 中の各文字を、あたかもマッピングまたはユーザーによってタイプされたかのように、処理キューに入れる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		By default the string is added to the end of the typeahead
		buffer, thus if a mapping is still being executed the
		characters come after them.  Use the 'i' flag to insert before
		other characters, they will be executed next, before any
		characters from a mapping.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

デフォルトではこれらの文字は先行入力バッファの末尾に付け足される。そのためマッピングを展開している途中であれば、これらの文字はマッピングを展開した後に来ることになる。他の文字の前に挿入するには、'i' フラグを使用する。それらはマッピングからの任意の文字の前の挿入の次に実行される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The function does not wait for processing of keys contained in
		{string}.
		To include special keys into {string}, use double-quotes
		and "\..." notation |expr-quote|. For example,
		feedkeys("\<CR>") simulates pressing of the <Enter> key. But
		feedkeys('\<CR>') pushes 5 characters.
		If {mode} is absent, keys are remapped.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

この関数は、@{string@} 中の文字が処理されるまでは待たない。特殊なキーを @{string@} に含めるにはダブルクォートと "\..." 記法を使う (|@ref{expr-quote}| を参照)。例えば、feedkeys("\<CR>") は @key{<Enter>} キーの押下をシミュレートする。しかし feedkeys('\<CR>') とすると、この文字の通り 5 文字を挿入する。@{mode@} が省略されたときは、挿入されたキーはマップ展開の対象になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{mode} is a String, which can contain these character flags:
		'm'	Remap keys. This is default.
		'n'	Do not remap keys.
		't'	Handle keys as if typed; otherwise they are handled as
			if coming from a mapping.  This matters for undo,
			opening folds, etc.
		'i'	Insert the string instead of appending (see above).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@{mode@} は以下の文字フラグを含む文字列:
@multitable @columnfractions .1 .9
@item 'm' @tab キーをマップ展開する。これが既定である。
@item 'n' @tab キーをマップ展開しない。
@item 't' @tab キーをタイプされたかのように扱う。そうでない場合はマッピングから展開されたかのように扱われる。これは undo や折り畳みの展開などで違いが現れる。
@item 'i' @tab 追加する代わりに文字を挿入する。(上記参照)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		'x'	Execute commands until typeahead is empty.  This is
			similar to using ":normal!".  You can call feedkeys()
			several times without 'x' and then one time with 'x'
			(possibly with an empty {string}) to execute all the
			typeahead.  Note that when Vim ends in Insert mode it
			will behave as if <Esc> is typed, to avoid getting
			stuck, waiting for a character to be typed before the
			script continues.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 'x' @tab 先行入力が空になるまでコマンドを実行する。これは "@command{:normal!}" を使うのと似ている。'x' なしで数回 feedkeys() を呼んだ後、'x' ありで 1 回 (@{string@} が空でも可能) feedkeys() を呼ぶことで先行入力をすべて実行できる。
@quotation
@strong{Note:} @*
Vim が挿入モードを終了したときは、スクリプト続行前の文字入力待ちによる立ち往生を避けるために、@key{<Esc>} が入力されたかのように振る舞う。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		'!'	When used with 'x' will not end Insert mode. Can be
			used in a test when a timer is set to exit Insert mode
			a little later.  Useful for testing CursorHoldI.

		Return value is always 0.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item '!' @tab 'x' と一緒に使用すると挿入モードを終了しない。タイマーが少し後で挿入モードを終了するように設定されているときにテストで使用できる。CursorHoldI のテストに便利である。
@end multitable
戻り値は常に0。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
filereadable({file})					*filereadable()*
		The result is a Number, which is |TRUE| when a file with the
		name {file} exists, and can be read.  If {file} doesn't exist,
		or is a directory, the result is |FALSE|.  {file} is any
		expression, which is used as a String.
		If you don't care about the file being readable you can use
		|glob()|.
							*file_readable()*
		Obsolete name: file_readable().
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{filereadable()}
@findex filereadable()
@item filereadable(@{file@})
結果は数値で、@{file@} というファイルが存在し、読み込むことが可能ならば |@ref{TRUE}| となる。ファイル @{file@} が存在しないかディレクトリだった場合には、結果は |@ref{FALSE}| となる。引数 @{file@} は文字列として使えればどのような表現でもよい。ファイルが読み込み可能でなくてもよい場合には |@ref{glob()}| を使う。
@anchor{file_readable()}
@findex file_readable()
以前の名前: file_readable().
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
filewritable({file})					*filewritable()*
		The result is a Number, which is 1 when a file with the
		name {file} exists, and can be written.  If {file} doesn't
		exist, or is not writable, the result is 0.  If {file} is a
		directory, and we can write to it, the result is 2.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{filewritable()}
@findex filewritable()
@item filewritable(@{file@})
結果は数値で、@{file@} というファイルが存在し、書き込むことが可能ならば 1 となる。ファイル @{file@} が存在しないか書き込み不可能である場合には、結果は 0 となる。@{file@} がディレクトリであり、書き込み可能な場合、結果は 2 となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
filter({expr1}, {expr2})				*filter()*
		{expr1} must be a |List| or a |Dictionary|.
		For each item in {expr1} evaluate {expr2} and when the result
		is zero remove the item from the |List| or |Dictionary|.
		{expr2} must be a |string| or |Funcref|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{filter()}
@findex filter()
@item filter(@{expr1@}, @{expr2@})
@{expr1@} はリスト |@ref{List}| または辞書 |@ref{Dictionary}| でなければならない。@{expr1@} の各要素に対して @{expr2@} を評価し、その結果が 0 ならばリストまたは辞書からその要素を削除する。@{expr2@} は文字列 |@ref{string}| または関数参照 |@ref{Funcref}| でなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {expr2} is a |string|, inside {expr2} |v:val| has the value
		of the current item.  For a |Dictionary| |v:key| has the key
		of the current item and for a |List| |v:key| has the index of
		the current item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr2@} が文字列 |@ref{string}| の場合、@{expr2@} の内部では |@ref{v:val}| が現在の要素の値を保持している。辞書の場合は |@ref{v:key}| が現在の要素のキーを保持しており、リストの場合は |@ref{v:key}| が現在の要素のインデックスを保持している。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
			call filter(mylist, 'v:val !~ "OLD"')
<		Removes the items where "OLD" appears. >
			call filter(mydict, 'v:key >= 8')
<		Removes the items with a key below 8. >
			call filter(var, 0)
<		Removes all the items, thus clears the |List| or |Dictionary|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
call filter(mylist, 'v:val !~ "OLD"')
@end example
は要素 "OLD" を削除する。
@example
call filter(mydict, 'v:key >= 8')
@end example
は 8 未満のキーを持つ要素を削除する。
@example
call filter(var, 0)
@end example
は全要素を削除する。つまりリスト |@ref{List}| または辞書 |@ref{Dictionary}| をクリアする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Note that {expr2} is the result of expression and is then
		used as an expression again.  Often it is good to use a
		|literal-string| to avoid having to double backslashes.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
@{expr2@} は式を表す文字列である。バックスラッシュを二重にしなくても済むように |@ref{literal-string}| を使うとよいだろう。ただしその場合はシングルクォートを二重にしなければならない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {expr2} is a |Funcref| it must take two arguments:
			1. the key or the index of the current item.
			2. the value of the current item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr2@} が |@ref{Funcref}| の場合は、2 つの引数で呼び出される:
@enumerate
@item 現在の要素のキーまたはインデックス。
@item 現在の要素の値。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The function must return |TRUE| if the item should be kept.
		Example that keeps the odd items of a list: >
			func Odd(idx, val)
			  return a:idx % 2 == 1
			endfunc
			call filter(mylist, function('Odd'))
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数は、その要素を保持すべきときは |@ref{TRUE}| を返さなければならない。リストの奇数版目の要素を保持する例:
@verbatim
func Odd(idx, val)
  return a:idx % 2 == 1
endfunc
call filter(mylist, function('Odd'))
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		It is shorter when using a |lambda|: >
			call filter(myList, {idx, val -> idx * val <= 42})
<		If you do not use "val" you can leave it out: >
			call filter(myList, {idx -> idx % 2 == 1})
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{lambda}| を使えばより短く書ける:
@example
call filter(myList, @{idx, val -> idx * val <= 42@})
@end example
"val" を使わない場合は省略できる:
@example
call filter(myList, @{idx -> idx % 2 == 1@})
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The operation is done in-place.  If you want a |List| or
		|Dictionary| to remain unmodified make a copy first: >
			:let l = filter(copy(mylist), 'v:val =~ "KEEP"')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この操作はその場で (in-place) 行われる。リスト |@ref{List}| や辞書 |@ref{Dictionary}| を変更したくない場合は最初にコピーを作ること:
@example
:let l = filter(copy(mylist), 'v:val =~ "KEEP"')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		Returns {expr1}, the |List| or |Dictionary| that was filtered.
		When an error is encountered while evaluating {expr2} no
		further items in {expr1} are processed.  When {expr2} is a
		Funcref errors inside a function are ignored, unless it was
		defined with the "abort" flag.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr1@} のリスト |@ref{List}| または辞書 |@ref{Dictionary}| をフィルターした結果を返す。@{expr2@} を評価している最中にエラーが発生した場合は、@{expr1@} 内のそれ以降の要素の処理は行われない。@{expr2@} が関数参照の場合、関数が "abort" フラグつきで定義されていない限り、関数内のエラーは無視される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
finddir({name} [, {path} [, {count}]])				*finddir()*
		Find directory {name} in {path}.  Supports both downwards and
		upwards recursive directory searches.  See |file-searching|
		for the syntax of {path}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{finddir()}
@findex finddir()
@item finddir(@{name@} [, @{path@} [, @{count@}]])
@{path@} から @{name@} という名前のディレクトリを探す。ディレクトリを上方・下方のどちらにも再帰的に検索できる。@{path@} の記法については |@ref{file-searching}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Returns the path of the first found match.  When the found
		directory is below the current directory a relative path is
		returned.  Otherwise a full path is returned.
		If {path} is omitted or empty then 'path' is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

最初に見つかったディレクトリのパスを返す。そのディレクトリがカレントディレクトリの下にある場合は相対パスを返す。そうでなければ絶対パスを返す。@{path@} が省略されたとき、または空のときはオプション '@option{path}' の値が使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If the optional {count} is given, find {count}'s occurrence of
		{name} in {path} instead of the first one.
		When {count} is negative return all the matches in a |List|.
		This is quite similar to the ex-command |:find|.
		{only available when compiled with the |+file_in_path|
		feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

省略可能な引数 @{count@} が指定されたときは、最初に見つかったディレクトリでなく、@{count@} 番目に見つかったディレクトリを返す。@{count@} が負の場合は、見つかったディレクトリ全てのリスト |@ref{List}| を返す。これは ex コマンド |@ref{:find}| によく似ている。

@{|@ref{+file_in_path}| 機能付きでコンパイルされたときのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
findfile({name} [, {path} [, {count}]])				*findfile()*
		Just like |finddir()|, but find a file instead of a directory.
		Uses 'suffixesadd'.
		Example: >
			:echo findfile("tags.vim", ".;")
<		Searches from the directory of the current file upwards until
		it finds the file "tags.vim".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{findfile()}
@findex findfile()
@item findfile(@{name@} [, @{path@} [, @{count@}]])
|@ref{finddir()}| と同様だが、ディレクトリでなくファイルを検索する。'@option{suffixesadd}' が適用される。

例:
@example
:echo findfile("tags.vim", ".;")
@end example
この例は、カレントファイルがあるディレクトリから上方に "tags.vim" を見つけるまで再帰的に検索する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
float2nr({expr})					*float2nr()*
		Convert {expr} to a Number by omitting the part after the
		decimal point.
		{expr} must evaluate to a |Float| or a Number.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{float2nr()}
@findex float2nr()
@item float2nr(@{expr@})
@{expr@} の小数点以下を切り捨てて |@ref{Number}| に変換する。@{expr@} は |@ref{Float}| または Number に評価されなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When the value of {expr} is out of range for a |Number| the
		result is truncated to 0x7fffffff or -0x7fffffff (or when
		64-bit Number support is enabled, 0x7fffffffffffffff or
		-0x7fffffffffffffff).  NaN results in -0x80000000 (or when
		64-bit Number support is enabled, -0x8000000000000000).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr@} の値が |@ref{Number}| の範囲外の場合、結果は 0x7fffffff または -0x7fffffff になる (64 ビット数値が有効化されている場合は 0x7fffffffffffffff または -0x7fffffffffffffff)。NaN は -0x80000000 になる (64 ビット数値が有効化されている場合は -0x8000000000000000)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
			echo float2nr(3.95)
<			3  >
			echo float2nr(-23.45)
<			-23  >
			echo float2nr(1.0e100)
<			2147483647  (or 9223372036854775807) >
			echo float2nr(-1.0e150)
<			-2147483647 (or -9223372036854775807) >
			echo float2nr(1.0e-100)
<			0
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
echo float2nr(3.95)
3
echo float2nr(-23.45)
-23
echo float2nr(1.0e100)
2147483647  (または 9223372036854775807)
echo float2nr(-1.0e150)
-2147483647  (または -9223372036854775807)
echo float2nr(1.0e-100)
0
@end example
@{|@ref{+float}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
floor({expr})							*floor()*
		Return the largest integral value less than or equal to
		{expr} as a |Float| (round down).
		{expr} must evaluate to a |Float| or a |Number|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{floor()}
@findex floor()
@item floor(@{expr@})
@{expr@} 以下の最大の整数を |@ref{Float}| で返す (切り捨て)。@{expr@} は |@ref{Float}| または |@ref{Number}| に評価されなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
			echo floor(1.856)
<			1.0  >
			echo floor(-5.456)
<			-6.0  >
			echo floor(4.0)
<			4.0
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
echo floor(1.856)
1.0
echo floor(-5.456)
-6.0
echo floor(4.0)
4.0
@end example
@{|@ref{+float}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
fmod({expr1}, {expr2})					*fmod()*
		Return the remainder of {expr1} / {expr2}, even if the
		division is not representable.  Returns {expr1} - i * {expr2}
		for some integer i such that if {expr2} is non-zero, the
		result has the same sign as {expr1} and magnitude less than
		the magnitude of {expr2}.  If {expr2} is zero, the value
		returned is zero.  The value returned is a |Float|.
		{expr1} and {expr2} must evaluate to a |Float| or a |Number|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{fmod()}
@findex fmod()
@item fmod(@{expr1@}, @{expr2@})
@{expr1@} / @{expr2@} の余りを返す (割り算が表現できなくても)。@{expr2@} が非ゼロなら @{expr1@} - i * @{expr2@} の結果を返す (i は戻り値が @{expr1@} と同じ符号を持ちその絶対値が @{expr2@} よりも小さくなるような値)。

@{expr2@} がゼロならゼロが返る。戻り値の型は浮動小数点数 (|@ref{Float}|)。@{expr1@} と @{expr2@} は浮動小数点数 (|@ref{Float}|) か数値 (|@ref{Number}|) でなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
			:echo fmod(12.33, 1.22)
<			0.13 >
			:echo fmod(-12.33, 1.22)
<			-0.13
		{only available when compiled with |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:echo fmod(12.33, 1.22)
0.13
:echo fmod(-12.33, 1.22)
-0.13
@end example
@{|@ref{+float}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
fnameescape({string})					*fnameescape()*
		Escape {string} for use as file name command argument.  All
		characters that have a special meaning, such as '%' and '|'
		are escaped with a backslash.
		For most systems the characters escaped are
		" \t\n*?[{`$\\%#'\"|!<".  For systems where a backslash
		appears in a filename, it depends on the value of 'isfname'.
		A leading '+' and '>' is also escaped (special after |:edit|
		and |:write|).  And a "-" by itself (special after |:cd|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{fnameescape()}
@findex fnameescape()
@item fnameescape(@{string@})
コマンド引数のファイル名として使うために @{string@} をエスケープする。'%' や '|' など特別な意味を持つ全ての文字がバックスラッシュでエスケープされる。

特別な文字とは、ほとんどのシステムにおいて" \t\n*?[@{`$\\%#'\"|!<" である。ファイル名にバックスラッシュが現れるシステムにおいては '@option{isfname}' の値に依存する。

先頭の '+' と '>' もエスケープされる (|@ref{:edit}| と |@ref{:write}| の引数では特別な意味を持つ)。@{string@} が "-" である場合もエスケープされる (|@ref{:cd}| の引数では意味を持つ)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example: >
			:let fname = '+some str%nge|name'
			:exe "edit " . fnameescape(fname)
<		results in executing: >
			edit \+some\ str\%nge\|name
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:let fname = '+some str%nge|name'
:exe "edit " . fnameescape(fname)
@end example
上記は次と同じ結果になる:
@example
edit \+some\ str\%nge\|name
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
fnamemodify({fname}, {mods})				*fnamemodify()*
		Modify file name {fname} according to {mods}.  {mods} is a
		string of characters like it is used for file names on the
		command line.  See |filename-modifiers|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{fnamemodify()}
@findex fnamemodify()
@item fnamemodify(@{fname@}, @{mods@})
ファイル名 @{fname@} を @{mods@} にしたがって変更する。@{mods@} はコマンドラインで使われるのと同様な文字列である。詳細は |@ref{filename-modifiers}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example: >
			:echo fnamemodify("main.c", ":p:h")
<		results in: >
			/home/mool/vim/vim/src
<		Note: Environment variables don't work in {fname}, use
		|expand()| first then.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:echo fnamemodify("main.c", ":p:h")
@end example
結果:
@example
/home/mool/vim/vim/src/
@end example
@quotation
@strong{Note:} @*
@{fname@} の中の環境変数は展開されない。環境変数を展開させるには |@ref{expand()}| を使うこと。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
foldclosed({lnum})					*foldclosed()*
		The result is a Number.  If the line {lnum} is in a closed
		fold, the result is the number of the first line in that fold.
		If the line {lnum} is not in a closed fold, -1 is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{foldclosed()}
@findex foldclosed()
@item foldclosed(@{lnum@})
結果は数値。@{lnum@} 行目が閉じた折り畳みの中にあるなら、その折り畳みを構成する最初の行の行番号を返す。@{lnum@} 行目が閉じた折り畳みに入っていないなら -1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
foldclosedend({lnum})					*foldclosedend()*
		The result is a Number.  If the line {lnum} is in a closed
		fold, the result is the number of the last line in that fold.
		If the line {lnum} is not in a closed fold, -1 is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{foldclosedend()}
@findex foldclosedend()
@item foldclosedend(@{lnum@})
結果は数値。@{lnum@} 行目が閉じた折り畳みの中にあるなら、その折り畳みを構成する最後の行の行番号を返す。@{lnum@} 行目が閉じた折り畳みに入っていないなら -1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
foldlevel({lnum})					*foldlevel()*
		The result is a Number, which is the foldlevel of line {lnum}
		in the current buffer.  For nested folds the deepest level is
		returned.  If there is no fold at line {lnum}, zero is
		returned.  It doesn't matter if the folds are open or closed.
		When used while updating folds (from 'foldexpr') -1 is
		returned for lines where folds are still to be updated and the
		foldlevel is unknown.  As a special case the level of the
		previous line is usually available.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{foldlevel()}
@findex foldlevel()
@item foldlevel(@{lnum@})
カレントバッファの @{lnum@} 行目の折り畳みレベルを表す数値を返す。折り畳みがネストしているときは一番下のレベルを返す。@{lnum@} 行目に折り畳みがまったくないときは 0 を返す。折り畳みが開いているか閉じているかは関係ない。('@option{foldexpr}' の中で) 折り畳みを更新している最中に呼ぶと、まだ折り畳みを更新していなく、折り畳みレベルが未知の行に対しては -1 を返す。特別な場合として、普通は 1 行前のレベルは取得できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*foldtext()*
foldtext()	Returns a String, to be displayed for a closed fold.  This is
		the default function used for the 'foldtext' option and should
		only be called from evaluating 'foldtext'.  It uses the
		|v:foldstart|, |v:foldend| and |v:folddashes| variables.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{foldtext()}
@findex foldtext()
@item foldtext()
閉じた折り畳みに表示する文字列を返す。これはオプション '@option{foldtext}' のデフォルトの関数であり、'@option{foldtext}' を評価しているときにだけ呼ぶようにすべきである。この関数は変数 |@ref{v:foldstart}|, |@ref{v:foldend}|, |@ref{v:folddashes}| を使用する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The returned string looks like this: >
			+-- 45 lines: abcdef
<		The number of leading dashes depends on the foldlevel.  The
		"45" is the number of lines in the fold.  "abcdef" is the text
		in the first non-blank line of the fold.  Leading white space,
		"//" or "/*" and the text from the 'foldmarker' and
		'commentstring' options is removed.
		When used to draw the actual foldtext, the rest of the line
		will be filled with the fold char from the 'fillchars'
		setting.
		{not available when compiled without the |+folding| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
戻り値の文字列は次のようになる:
@verbatim
+-- 45 lines: abcdef
@end verbatim
先頭のダッシュ (-) の数は折り畳みレベルによって決まる。"45" はその折り畳みに含まれている行数である。"abcdef" はその折り畳みの中の最初の空行でない行のテキストである。行頭の空白と、"//" や "/*"、'@option{foldmarker}' と '@option{commentstring}' に設定されている文字列は削除される。

実際に折り畳まれたテキストを表示するために使うと、行の残りは '@option{fillchars}' で設定している文字で埋められる。

@{|@ref{+folding}| 機能付きでコンパイルされたときのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
foldtextresult({lnum})					*foldtextresult()*
		Returns the text that is displayed for the closed fold at line
		{lnum}.  Evaluates 'foldtext' in the appropriate context.
		When there is no closed fold at {lnum} an empty string is
		returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{foldtextresult()}
@findex foldtextresult()
@item foldtextresult(@{lnum@})
@{lnum@} 行目の閉じた折り畳みに表示される文字列を返す。'@option{foldtext}' を適切なコンテキストの中で評価する。@{lnum@} 行目に閉じた折り畳みがないときは空文字列を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{lnum} is used like with |getline()|.  Thus "." is the current
		line, "'m" mark m, etc.
		Useful when exporting folded text, e.g., to HTML.
		{not available when compiled without the |+folding| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{lnum@}は |@ref{getline()}| のときと同様に扱われる。つまり "." はカレント行、"'m" はマーク m を表す。折り畳まれたテキストを HTML などにエクスポートするときに有用。

@{|@ref{+folding}| 機能付きでコンパイルされたときのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*foreground()*
foreground()	Move the Vim window to the foreground.  Useful when sent from
		a client to a Vim server. |remote_send()|
		On Win32 systems this might not work, the OS does not always
		allow a window to bring itself to the foreground.  Use
		|remote_foreground()| instead.
		{only in the Win32, Athena, Motif and GTK GUI versions and the
		Win32 console version}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{foreground()}
@findex foreground()
@item foreground()
Vim のウィンドウを前面に移動する。この関数はクライアントから Vim サーバーへ送ると便利である。|@ref{remote_send()}| Win32 では自分自身のウィンドウを前面に持ってくることが必ずしも許可されていないので、動作しないかもしれない。そのときは代わりに |@ref{remote_foreground()}| を使うこと。

@{Win32, Athena, Motif, GTK いずれかの GUI 版と Win32 コンソール版でのみ利用できる@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*funcref()*
funcref({name} [, {arglist}] [, {dict}])
		Just like |function()|, but the returned Funcref will lookup
		the function by reference, not by name.  This matters when the
		function {name} is redefined later.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{funcref()}
@findex funcref()
@item funcref(@{name@} [, @{arglist@}] [, @{dict@}])
|@ref{function()}| と同様である。ただし、返された Funcref は関数を名前ではなく参照で検索する。これは関数 @{name@} が後で再定義されるときに重要である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Unlike |function()|, {name} must be an existing user function.
		Also for autoloaded functions. {name} cannot be a builtin
		function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{function()}| とは違い、@{name@} はユーザー定義関数として存在していなければならない。また、autoload 関数についても同様である。@{name@} は組込み関数であってはならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*function()* *E700* *E922* *E923*
function({name} [, {arglist}] [, {dict}])
		Return a |Funcref| variable that refers to function {name}.
		{name} can be the name of a user defined function or an
		internal function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{function()}
@anchor{E700}
@anchor{E922}
@anchor{E923}
@findex function()
@erindex E700
@erindex E922
@erindex E923
@item function(@{name@} [, @{arglist@}] [, @{dict@}])
関数 @{name@} を参照する |@ref{Funcref}| の変数を返す。@{name@} はユーザー定義関数でも組み込み関数でもよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{name} can also be a Funcref or a partial.  When it is a
		partial the dict stored in it will be used and the {dict}
		argument is not allowed. E.g.: >
			let FuncWithArg = function(dict.Func, [arg])
			let Broken = function(dict.Func, [arg], dict)
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここで @{name@} は関数の参照、もしくは部分適用である。部分適用であるとき、それに格納されている辞書が使用され、@{dict@} 引数が使用できない。例:
@example
let FuncWithArg = function(dict.Func, [arg])
let Broken = function(dict.Func, [arg], dict)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When using the Funcref the function will be found by {name},
		also when it was redefined later.  Use |funcref()| to keep the
		same function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Funcref が利用されるとき、その関数は @{name@} から見つけられる。これは後で再定義された場合も同様である。常に同じ関数を見つけるためには |@ref{funcref()}| を使うこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {arglist} or {dict} is present this creates a partial.
		That means the argument list and/or the dictionary is stored in
		the Funcref and will be used when the Funcref is called.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{arglist@} もしくは @{dict@} が与えられると、関数の部分適用が作られる。すなわち引数のリスト及び/または辞書は Funcref に格納され、その Funcref が呼ばれるときに使用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The arguments are passed to the function in front of other
		arguments.  Example: >
			func Callback(arg1, arg2, name)
			...
			let Func = function('Callback', ['one', 'two'])
			...
			call Func('name')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
格納された引数は他の引数よりも前に関数に渡される。例えば:
@verbatim
func Callback(arg1, arg2, name)
...
let Func = function('Callback', ['one', 'two'])
...
call Func('name')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		Invokes the function as with: >
			call Callback('one', 'two', 'name')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数は次のように呼び出す:
@example
call Callback('one', 'two', 'name')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		The function() call can be nested to add more arguments to the
		Funcref.  The extra arguments are appended to the list of
		arguments.  Example: >
			func Callback(arg1, arg2, name)
			...
			let Func = function('Callback', ['one'])
			let Func2 = function(Func, ['two'])
			...
			call Func2('name')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
function() は Funcref により多くの引数を加えるためにネストして呼び出すことができる。余分な引数は、引数のリストに追加される。例えば:
@verbatim
func Callback(arg1, arg2, name)
...
let Func = function('Callback', ['one'])
let Func2 = function(Func, ['two'])
...
call Func2('name')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		Invokes the function as with: >
			call Callback('one', 'two', 'name')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは次のように関数を呼び出す:
@example
call Callback('one', 'two', 'name')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		The Dictionary is only useful when calling a "dict" function.
		In that case the {dict} is passed in as "self". Example: >
			function Callback() dict
			   echo "called for " . self.name
			endfunction
			...
			let context = {"name": "example"}
			let Func = function('Callback', context)
			...
			call Func()	" will echo: called for example
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
辞書は "dict" 関数を呼び出すときのみ有用である。この場合、@{dict@} は "self" として渡される。例えば:
@verbatim
function Callback() dict
echo "called for " . self.name
endfunction
...
let context = @{"name": "example"@}
let Func = function('Callback', context)
...
call Func()	" will echo: called for example
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		The use of function() is not needed when there are no extra
		arguments, these two are equivalent: >
			let Func = function('Callback', context)
			let Func = context.Callback
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
余分な引数がない場合、function() は必要ない。以下の 2 つは同等である:
@example
let Func = function('Callback', context)
let Func = context.Callback
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		The argument list and the Dictionary can be combined: >
			function Callback(arg1, count) dict
			...
			let context = {"name": "example"}
			let Func = function('Callback', ['one'], context)
			...
			call Func(500)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数のリストと辞書を同時に使用することもできる:
@verbatim
function Callback(arg1, count) dict
...
let context = {"name": "example"}
let Func = function('Callback', ['one'], context)
...
call Func(500)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		Invokes the function as with: >
			call context.Callback('one', 500)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは次のように関数を呼び出す:
@example
call context.Callback('one', 500)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
garbagecollect([{atexit}])				*garbagecollect()*
		Cleanup unused |Lists|, |Dictionaries|, |Channels| and |Jobs|
		that have circular references.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{garbagecollect()}
@findex garbagecollect()
@item garbagecollect([@{atexit@}])
循環参照を持ち、使われていないリスト |@ref{List}|、辞書 |@ref{Dictionaries}|、チャネル |@ref{Channels}|、ジョブ |@ref{Jobs}| をクリーンアップする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		There is hardly ever a need to invoke this function, as it is
		automatically done when Vim runs out of memory or is waiting
		for the user to press a key after 'updatetime'.  Items without
		circular references are always freed when they become unused.
		This is useful if you have deleted a very big |List| and/or
		|Dictionary| with circular references in a script that runs
		for a long time.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはメモリ不足に陥ったときや、'@option{updatetime}' 経過後ユーザーのキー入力を待っているときに自動的に行われるので、この関数を呼ぶ必要があることはほとんどない。循環参照を持たない要素は、使われなくなったとき必ず解放される。長時間実行されるスクリプトの中で循環参照を持つ非常に大きなリスト |@ref{List}| や辞書 |@ref{Dictionary}| を削除したときに有用である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When the optional {atexit} argument is one, garbage
		collection will also be done when exiting Vim, if it wasn't
		done before.  This is useful when checking for memory leaks.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
省略可能な引数 @{atexit@} に 1 を指定すると、Vim を終了するときにもガーベッジコレクションが行われる。これはメモリリークを発見するのに役に立つ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The garbage collection is not done immediately but only when
		it's safe to perform.  This is when waiting for the user to
		type a character.  To force garbage collection immediately use
		|test_garbagecollect_now()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ガーベッジコレクションはすぐには実行されず、安全な場合のみ実行される。これはユーザーが文字を入力するのを待っているときである。ガーベッジコレクションを強制するには、すぐに |@ref{test_garbagecollect_now()}| を使用すること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
get({list}, {idx} [, {default}])			*get()*
		Get item {idx} from |List| {list}.  When this item is not
		available return {default}.  Return zero when {default} is
		omitted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{get()}
@findex get()
@item get(@{list@}, @{idx@} [, @{default@}])
リスト |@ref{List}| @{list@} から @{idx@} 番目の要素を取得する。この要素を取得できないときは @{default@} を返す。@{default@} が省略されたときは 0 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
get({dict}, {key} [, {default}])
		Get item with key {key} from |Dictionary| {dict}.  When this
		item is not available return {default}.  Return zero when
		{default} is omitted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item get(@{dict@}, @{key@} [, @{default@}])
辞書 |@ref{Dictionary}| @{dict@} からキー @{key@} に関連づけられた値を取得する。この要素を取得できないときは @{default@} を返す。@{default@} が省略されたときは 0 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
get({func}, {what})
		Get an item with from Funcref {func}.  Possible values for
		{what} are:
			"name"	The function name
			"func"	The function
			"dict"	The dictionary
			"args"	The list with arguments
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item get(@{func@}, @{what@})
Funcref @{func@} から項目を取得する。@{what@} の可能な値は:
@multitable @columnfractions .1 .9
@item "name" @tab 関数名
@item "func" @tab 関数
@item "dict" @tab 辞書
@item "args" @tab 引数リスト
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*getbufinfo()*
getbufinfo([{expr}])
getbufinfo([{dict}])
		Get information about buffers as a List of Dictionaries.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getbufinfo()}
@findex getbufinfo()
@item getbufinfo([@{expr@}]) または
@itemx getbufinfo([@{dict@}])
バッファの情報を辞書のリストとして取得する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Without an argument information about all the buffers is
		returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数なしの場合、すべてのバッファに関する情報が返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When the argument is a Dictionary only the buffers matching
		the specified criteria are returned.  The following keys can
		be specified in {dict}:
			buflisted	include only listed buffers.
			bufloaded	include only loaded buffers.
			bufmodified	include only modified buffers.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数が辞書の場合、指定された条件を満たすバッファのみが返される。@{dict@} には以下のキーを指定できる：
@multitable @columnfractions .2 .8
@item buflisted @tab リストされたバッファのみを含む。
@item bufloaded @tab ロードされたバッファのみを含む。
@item bufmodified @tab 変更されたバッファのみを含む。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Otherwise, {expr} specifies a particular buffer to return
		information for.  For the use of {expr}, see |bufname()|
		above.  If the buffer is found the returned List has one item.
		Otherwise the result is an empty list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
それ以外の場合、@{expr@} は情報を返す特定のバッファを指定する。@{expr@} の使用については、上記の |@ref{bufname()}| を参照。バッファが見つかった場合、返される List には 1 つの項目がある。それ以外の場合、結果は空のリストになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Each returned List item is a dictionary with the following
		entries:
			bufnr		buffer number.
			changed		TRUE if the buffer is modified.
			changedtick	number of changes made to the buffer.
			hidden		TRUE if the buffer is hidden.
			listed		TRUE if the buffer is listed.
			lnum		current line number in buffer.
			loaded		TRUE if the buffer is loaded.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
返される各 List 項目は、次のエントリを持つ辞書である:
@multitable @columnfractions .2 .8
@item bufnr @tab バッファ番号。
@item changed @tab バッファが変更されている場合は TRUE。
@item changedtick @tab バッファに加えられた変更の数。
@item hidden @tab バッファが隠されている場合は TRUE。
@item listed @tab バッファがリストされている場合は TRUE。
@item lnum @tab バッファ内の現在の行番号。
@item loaded @tab バッファがロードされている場合は TRUE。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			name		full path to the file in the buffer.
			signs		list of signs placed in the buffer.
					Each list item is a dictionary with
					the following fields:
					    id	  sign identifier
					    lnum  line number
					    name  sign name
			variables	a reference to the dictionary with
					buffer-local variables.
			windows		list of |window-ID|s that display this
					buffer
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item name @tab バッファ内のファイルへのフルパス。
@item signs @tab バッファに配置された目印のリスト。各リスト項目は、次のフィールドを含む辞書である:
@multitable @columnfractions .1 .9
@item id @tab 目印識別子
@item lnum @tab 行番号
@item name @tab 目印名
@end multitable
@item variables @tab バッファローカル変数の辞書への参照。
@item windows @tab バッファを表示する |@ref{window-ID}| のリスト
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Examples: >
			for buf in getbufinfo()
			    echo buf.name
			endfor
			for buf in getbufinfo({'buflisted':1})
			    if buf.changed
				....
			    endif
			endfor
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@verbatim
for buf in getbufinfo()
    echo buf.name
endfor
for buf in getbufinfo({'buflisted':1})
    if buf.changed
        ....
    endif
endfor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		To get buffer-local options use: >
			getbufvar({bufnr}, '&option_name')

<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バッファローカルオプションを取得するには:
@example
getbufvar(@{bufnr@}, '&option_name')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*getbufline()*
getbufline({expr}, {lnum} [, {end}])
		Return a |List| with the lines starting from {lnum} to {end}
		(inclusive) in the buffer {expr}.  If {end} is omitted, a
		|List| with only the line {lnum} is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getbufline()}
@findex getbufline()
@item getbufline(@{expr@}, @{lnum@} [, @{end@}])
バッファ @{expr@} の @{lnum@} 行目から @{end@} 行目まで (両端含む) の行からなるリスト |@ref{List}| を返す。@{end@} が省略されたときは @{lnum@} 行目だけからなるリストを返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For the use of {expr}, see |bufname()| above.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr@} の指定の仕方については |@ref{bufname()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For {lnum} and {end} "$" can be used for the last line of the
		buffer.  Otherwise a number must be used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{lnum@} と @{end@} では "$" でバッファの最後の行を表すことができる。それ以外は数値でなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {lnum} is smaller than 1 or bigger than the number of
		lines in the buffer, an empty |List| is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{lnum@} が 1 より小さいときや、バッファの行数より大きいときは空リスト |@ref{List}| を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {end} is greater than the number of lines in the buffer,
		it is treated as {end} is set to the number of lines in the
		buffer.  When {end} is before {lnum} an empty |List| is
		returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{end@} がバッファの行数より大きいときは、バッファの行数が設定されたものとして扱う。@{end@} が @{lnum@} 行目より前に設定された場合は空リスト |@ref{List}| を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		This function works only for loaded buffers.  For unloaded and
		non-existing buffers, an empty |List| is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この関数は読み込まれているバッファに対してのみ動作する。既にアンロードされているバッファや存在しないバッファに対しては空リスト |@ref{List}| を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example: >
			:let lines = getbufline(bufnr("myfile"), 1, "$")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:let lines = getbufline(bufnr("myfile"), 1, "$")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getbufvar({expr}, {varname} [, {def}])				*getbufvar()*
		The result is the value of option or local buffer variable
		{varname} in buffer {expr}.  Note that the name without "b:"
		must be used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getbufvar()}
@findex getbufvar()
@item getbufvar(@{expr@}, @{varname@} [, @{def@}])
バッファ @{expr@} のオプションの値やバッファローカル変数 @{varname@} の値を返す。
@quotation
@strong{Note:} @*
"b:" をつけない変数名を指定すること。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When {varname} is empty returns a dictionary with all the
		buffer-local variables.
		When {varname} is equal to "&" returns a dictionary with all
		the buffer-local options.
		Otherwise, when {varname} starts with "&" returns the value of
		a buffer-local option.
		This also works for a global or buffer-local option, but it
		doesn't work for a global variable, window-local variable or
		window-local option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{varname@} が空文字列の場合、全てのバッファローカル変数からなる辞書を返す。

@{varname@} が "&" に等しいとき、すべてのバッファローカルオプションを持つ辞書を返す。そうでなく、@{varname@} が "&" で始まるとき、バッファローカルオプションの値を返す。

グローバルオプション、バッファローカルオプションのどちらに対しても動作するが、グローバル変数、ウィンドウローカル変数、ウィンドウローカルオプションに対しては動作しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		For the use of {expr}, see |bufname()| above.
		When the buffer or variable doesn't exist {def} or an empty
		string is returned, there is no error message.
		Examples: >
			:let bufmodified = getbufvar(1, "&mod")
			:echo "todo myvar = " . getbufvar("todo", "myvar")
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr@} の指定の仕方については |@ref{bufname()}| を参照。

バッファや変数が存在しないときは @{def@} または空文字列を返し、エラーメッセージは表示されない。

例:
@example
:let bufmodified = getbufvar(1, "&mod")
:echo "todo myvar = " . getbufvar("todo", "myvar")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
getchangelist({expr})					*getchangelist()*
		Returns the |changelist| for the buffer {expr}. For the use
		of {expr}, see |bufname()| above. If buffer {expr} doesn't
		exist, an empty list is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getchangelist()}
@findex getchangelist()
@item getchangelist(@{expr@})
バッファの @{expr@} の |@ref{changelist}| を返す。@{expr@} の使用は、上記の |@ref{bufname()}| を参照。もしもバッファの @{expr@} が存在しないのなら、空リストが返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The returned list contains two entries: a list with the change
		locations and the current position in the list.  Each
		entry in the change list is a dictionary with the following
		entries:
			col		column number
			coladd		column offset for 'virtualedit'
			lnum		line number
		If buffer {expr} is the current buffer, then the current
		position refers to the position in the list. For other
		buffers, it is set to the length of the list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
返されるリストは 2 つのエントリを含んでいる: それは、変更ロケーションリストとリスト内の現在のポジションである。変更リストのそれぞれのエントリは、次の項目を持つ辞書である:
@multitable @columnfractions .3 .7
@item col @tab 桁番号
@item coladd @tab '@option{virtualedit}' のための桁番号
@item lnum @tab 行番号
@end multitable
もしもバッファ @{expr@} がカレンノバッファなら、現在の位置はリスト内の場所を示す。他のバッファなら、リストの長さに設定される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getchar([expr])						*getchar()*
		Get a single character from the user or input stream.
		If [expr] is omitted, wait until a character is available.
		If [expr] is 0, only get a character when one is available.
			Return zero otherwise.
		If [expr] is 1, only check if a character is available, it is
			not consumed.  Return zero if no character available.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getchar()}
@findex getchar()
@item getchar([expr])
ユーザーまたは入力ストリームから 1 文字を取得する。

[expr] が省略されたときは 1 文字を取得できるまで待つ。

[expr] が 0 のときは 1 文字を取得できる場合のみ取得する。取得できなければ 0 を返す。

[expr] が 1 のときは 1 文字を取得できるか判定し、実際には取得しない。取得できないときは 0 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Without [expr] and when [expr] is 0 a whole character or
		special key is returned.  If it is a single character, the
		result is a number.  Use nr2char() to convert it to a String.
		Otherwise a String is returned with the encoded character.
		For a special key it's a String with a sequence of bytes
		starting with 0x80 (decimal: 128).  This is the same value as
		the String "\<Key>", e.g., "\<Left>".  The returned value is
		also a String when a modifier (shift, control, alt) was used
		that is not included in the character.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[expr] が省略されたときや [expr] が 0 のときは、文字全体または特殊キーを返す。それが 1 文字なら戻り値は数値である。これを文字列に戻すには nr2char() を使う。8 ビット文字でないならばエンコードして文字列にして返す。

特殊キーとは 0x80 (10 進数で 128) で始まるバイト列を持つ文字列である。これは文字列 "\<Key>" と同じ値である (例: "\<Left>")。戻り値は文字列であり、修飾キー (shift, control, alt) は含まれない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When [expr] is 0 and Esc is typed, there will be a short delay
		while Vim waits to see if this is the start of an escape
		sequence.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[expr] が 0 や Esc が入力された場合は、これがエスケープシーケンスの始まりであるかどうかを Vim が知るために待つ間、短い遅延があるだろう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When [expr] is 1 only the first byte is returned.  For a
		one-byte character it is the character itself as a number.
		Use nr2char() to convert it to a String.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[expr] が 1 のときは最初のバイトだけを返す。1 バイト文字の場合、これはその文字そのものを表す数値である。これを文字列に変換するには nr2char() を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Use getcharmod() to obtain any additional modifiers.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
修飾キーを取得するには getcharmod() を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When the user clicks a mouse button, the mouse event will be
		returned.  The position can then be found in |v:mouse_col|,
		|v:mouse_lnum|, |v:mouse_winid| and |v:mouse_win|.  This
		example positions the mouse as it would normally happen: >
			let c = getchar()
			if c == "\<LeftMouse>" && v:mouse_win > 0
			  exe v:mouse_win . "wincmd w"
			  exe v:mouse_lnum
			  exe "normal " . v:mouse_col . "|"
			endif
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザーがマウスをクリックしたときはマウスイベントを返す。クリックした位置は |@ref{v:mouse_col}|, |@ref{v:mouse_lnum}|, |@ref{v:mouse_winid}|, |@ref{v:mouse_win}| で得られる。以下の例は、普通にマウスがクリックされたときと同じようにカーソルを移動させる。
@verbatim
let c = getchar()
if c == "\<LeftMouse>" && v:mouse_win > 0
  exe v:mouse_win . "wincmd w"
  exe v:mouse_lnum
  exe "normal " . v:mouse_col . "|"
endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When using bracketed paste only the first character is
		returned, the rest of the pasted text is dropped.
		|xterm-bracketed-paste|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
bracketed paste を使用しているときは最初の文字のみが返され、ペーストされた残りのテキストは切り捨てられる。|@ref{xterm-bracketed-paste}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		There is no prompt, you will somehow have to make clear to the
		user that a character has to be typed.
		There is no mapping for the character.
		Key codes are replaced, thus when the user presses the <Del>
		key you get the code for the <Del> key, not the raw character
		sequence.  Examples: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この関数を呼んだときプロンプトは表示されない。文字入力を待っていることをなんらかの方法でユーザーがわかるようにしなければならないだろう。

入力された文字に対してマッピングは適用されない。

キーコードは置換される。つまりユーザーが @key{<Del>} を押した場合、「生の」文字シーケンスでなく @key{<Del>} キーに対応するコードが得られる。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			getchar() == "\<Del>"
			getchar() == "\<S-Left>"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
getchar() == "\<Del>"
getchar() == "\<S-Left>"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		This example redefines "f" to ignore case: >
			:nmap f :call FindChar()<CR>
			:function FindChar()
			:  let c = nr2char(getchar())
			:  while col('.') < col('$') - 1
			:    normal l
			:    if getline('.')[col('.') - 1] ==? c
			:      break
			:    endif
			:  endwhile
			:endfunction
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下の例は大文字・小文字を区別しないように "f" を再定義する:
@verbatim
:nmap f :call FindChar()<CR>
:function FindChar()
:  let c = nr2char(getchar())
:  while col('.') < col('$') - 1
:    normal l
:    if getline('.')[col('.') - 1] ==? c
:      break
:    endif
:  endwhile
:endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		You may also receive synthetic characters, such as
		|<CursorHold>|. Often you will want to ignore this and get
		another character: >
			:function GetKey()
			:  let c = getchar()
			:  while c == "\<CursorHold>"
			:    let c = getchar()
			:  endwhile
			:  return c
			:endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
あなたは |@ref{<CursorHold>}| のような合成文字も取得するかもしれない。多くの場合、あなたはこれを無視して別の文字を取得することになる:
@verbatim
:function GetKey()
:  let c = getchar()
:  while c == "\<CursorHold>"
:    let c = getchar()
:  endwhile
:  return c
:endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getcharmod()						*getcharmod()*
		The result is a Number which is the state of the modifiers for
		the last obtained character with getchar() or in another way.
		These values are added together:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getcharmod()}
@findex getcharmod()
@item getcharmod()
最後に getchar() などで得た文字に対する修飾キーの状態を表す数値を返す。以下の値の和となる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			2	shift
			4	control
			8	alt (meta)
			16	meta (when it's different from ALT)
			32	mouse double click
			64	mouse triple click
			96	mouse quadruple click (== 32 + 64)
			128	command (Macintosh only)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item 2 @tab shift
@item 4 @tab control
@item 8 @tab alt (meta)
@item 16 @tab meta (ALT と META が区別される場合)
@item 32 @tab マウスのダブルクリック
@item 64 @tab マウスのトリプルクリック
@item 96 @tab マウスのクアドラプルクリック (== 32 + 64)
@item 128 @tab command (Macintosh のみ)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Only the modifiers that have not been included in the
		character itself are obtained.  Thus Shift-a results in "A"
		without a modifier.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字自身に含まれていない修飾キーのみ取得できる。つまり、Shift-a は修飾キーなしの "A" となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getcharsearch()						*getcharsearch()*
		Return the current character search information as a {dict}
		with the following entries:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getcharsearch()}
@findex getcharsearch()
@item getcharsearch()
現在の文字検索の情報である @{dict@} を返し、この辞書は下記のエントリを持つ:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		    char	character previously used for a character
				search (|t|, |f|, |T|, or |F|); empty string
				if no character search has been performed
		    forward	direction of character search; 1 for forward,
				0 for backward
		    until	type of character search; 1 for a |t| or |T|
				character search, 0 for an |f| or |F|
				character search
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item char @tab 文字検索 (|@ref{t}|, |@ref{f}|, |@ref{T}|, |@ref{F}|) で以前に使われた文字。もし文字検索が実行されていないなら空文字列。
@item forward @tab 文字検索の方向。1 は前方、0 は後方。
@item until @tab 文字検索の種類。1 は |@ref{t}| もしくは |@ref{T}| の文字検索、0 は |@ref{f}| もしくは |@ref{F}| の文字検索。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		This can be useful to always have |;| and |,| search
		forward/backward regardless of the direction of the previous
		character search: >
			:nnoremap <expr> ; getcharsearch().forward ? ';' : ','
			:nnoremap <expr> , getcharsearch().forward ? ',' : ';'
<		Also see |setcharsearch()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
下記の設定は前回の文字検索の方向にかかわらず、|@ref{;}| で前方検索、|@ref{@comma{}}| で後方検索を常に行えるようになり便利である:
@example
:nnoremap <expr> ; getcharsearch().forward ? ';' : ','
:nnoremap <expr> , getcharsearch().forward ? ',' : ';'
@end example
|@ref{setcharsearch()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getcmdline()						*getcmdline()*
		Return the current command-line.  Only works when the command
		line is being edited, thus requires use of |c_CTRL-\_e| or
		|c_CTRL-R_=|.
		Example: >
			:cmap <F7> <C-\>eescape(getcmdline(), ' \')<CR>
<		Also see |getcmdtype()|, |getcmdpos()| and |setcmdpos()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getcmdline()}
@findex getcmdline()
@item getcmdline()
現在のコマンドラインの内容を取得する。コマンドラインを編集しているときのみ動作する。つまり |@ref{c_CTRL-\_e}| または |@ref{c_CTRL-R_=}| を使っているときのみ有効。

例:
@example
:cmap <F7> <C-\>eescape(getcmdline(), ' \')<CR>
@end example
|@ref{getcmdtype()}|, |@ref{getcmdpos()}|, |@ref{setcmdpos()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getcmdpos()						*getcmdpos()*
		Return the position of the cursor in the command line as a
		byte count.  The first column is 1.
		Only works when editing the command line, thus requires use of
		|c_CTRL-\_e| or |c_CTRL-R_=| or an expression mapping.
		Returns 0 otherwise.
		Also see |getcmdtype()|, |setcmdpos()| and |getcmdline()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getcmdpos()}
@findex getcmdpos()
@item getcmdpos()
コマンドラインにおけるカーソル位置をバイト単位で取得する。最初の桁は 1 となる。

コマンドラインを編集しているときのみ動作する。つまり |@ref{c_CTRL-\_e}| または |@ref{c_CTRL-R_=}| または式マッピングを使っているときのみ有効。そうでないときは 0 を返す。

|@ref{getcmdtype()}|, |@ref{setcmdpos()}|, |@ref{getcmdline()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getcmdtype()						*getcmdtype()*
		Return the current command-line type. Possible return values
		are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getcmdtype()}
@findex getcmdtype()
@item getcmdtype()
現在のコマンドラインの種類を返す。戻り値は次のいずれか:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		    :	normal Ex command
		    >	debug mode command |debug-mode|
		    /	forward search command
		    ?	backward search command
		    @	|input()| command
		    -	|:insert| or |:append| command
		    =	|i_CTRL-R_=|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item : @tab 通常の ex コマンド
@item > @tab デバッグモードコマンド |@ref{debug-mode}|
@item / @tab 前方検索コマンド
@item ? @tab 後方検索コマンド
@item @ @tab |@ref{input()}| コマンド
@item - @tab |@ref{:insert}| または |@ref{:append}| コマンド
@item = @tab |@ref{i_CTRL-R_=}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Only works when editing the command line, thus requires use of
		|c_CTRL-\_e| or |c_CTRL-R_=| or an expression mapping.
		Returns an empty string otherwise.
		Also see |getcmdpos()|, |setcmdpos()| and |getcmdline()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインを編集しているときのみ動作する。つまり |@ref{c_CTRL-\_e}| または |@ref{c_CTRL-R_=}| または式マッピングを使っているときのみ有効。そうでないときは空文字列を返す。

|@ref{getcmdpos()}|, |@ref{setcmdpos()}|, |@ref{getcmdline()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getcmdwintype()						*getcmdwintype()*
		Return the current |command-line-window| type. Possible return
		values are the same as |getcmdtype()|. Returns an empty string
		when not in the command-line window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getcmdwintype()}
@findex getcmdwintype()
@item getcmdwintype()
現在のコマンドラインウィンドウ (|@ref{command-line-window}|) の種類を返す。戻り値の意味は |@ref{getcmdtype()}| と同じ。コマンドラインウィンドウでなければ空文字列を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getcompletion({pat}, {type} [, {filtered}])		*getcompletion()*
		Return a list of command-line completion matches. {type}
		specifies what for.  The following completion types are
		supported:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getcompletion()}
@findex getcompletion()
@item getcompletion(@{pat@}, @{type@} [, @{filtered@}])
コマンドライン補完のマッチするリストを返す。@{type@} は何のためのものかを指定する。 次の補完タイプがサポートされている:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		arglist		file names in argument list
		augroup		autocmd groups
		buffer		buffer names
		behave		:behave suboptions
		color		color schemes
		command		Ex command (and arguments)
		compiler	compilers
		cscope		|:cscope| suboptions
		dir		directory names
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item arglist @tab 引数リストのファイル名
@item augroup @tab 自動コマンドグループ
@item buffer @tab バッファ名
@item behave @tab |@ref{:behave}| サブオプション
@item color @tab カラースキーム
@item command @tab Ex コマンド (および引数)
@item compiler @tab コンパイラ
@item cscope @tab |@ref{:cscope}| のサブオプション
@item dir @tab ディレクトリ名
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		environment	environment variable names
		event		autocommand events
		expression	Vim expression
		file		file and directory names
		file_in_path	file and directory names in |'path'|
		filetype	filetype names |'filetype'|
		function	function name
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item environment @tab 環境変数名
@item event @tab 自動コマンドのイベント
@item expression @tab Vim 式
@item file @tab ファイルおよびディレクトリ名
@item file_in_path @tab |@ref{'path'}| のファイルおよびディレクトリ名
@item filetype @tab ファイルタイプ名 |@ref{'filetype'}|
@item function @tab 関数名
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		help		help subjects
		highlight	highlight groups
		history		:history suboptions
		locale		locale names (as output of locale -a)
		mapclear        buffer argument
		mapping		mapping name
		menu		menus
		messages	|:messages| suboptions
		option		options
		packadd		optional package |pack-add| names
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item help @tab ヘルプ項目
@item highlight @tab ハイライトグループ
@item history @tab |@ref{:history}| サブオプション
@item locale @tab ロケール名 (locale -a の出力)
@item mapclear @tab バッファ引数
@item mapping @tab マッピング名
@item menu @tab メニュー
@item messages @tab |@ref{:messages}| サブオプション
@item option @tab オプション
@item packadd @tab 任意パッケージ |@ref{pack-add}| 名
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		shellcmd	Shell command
		sign		|:sign| suboptions
		syntax		syntax file names |'syntax'|
		syntime		|:syntime| suboptions
		tag		tags
		tag_listfiles	tags, file names
		user		user names
		var		user variables
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item shellcmd @tab シェルコマンド
@item sign @tab |@ref{:sign}| サブオプション
@item syntax @tab 構文ファイル名 |@ref{'syntax'}|
@item syntime @tab |@ref{:syntime}| サブオプション
@item tag @tab タグ
@item tag_listfiles @tab タグ、ファイル名
@item user @tab ユーザー名
@item var @tab ユーザー変数
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {pat} is an empty string, then all the matches are returned.
		Otherwise only items matching {pat} are returned. See
		|wildcards| for the use of special characters in {pat}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{pat@} が空文字列の場合、すべてのマッチが返される。それ以外の場合、@{pat@} と一致する項目のみが返される。@{pat@} での特殊文字の使用については、|@ref{wildcards}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If the optional {filtered} flag is set to 1, then 'wildignore'
		is applied to filter the results.  Otherwise all the matches
		are returned. The 'wildignorecase' option always applies.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプションの @{filtered@} フラグが 1 に設定されている場合、結果をフィルタリングするために '@option{wildignore}' が適用される。そうでなければ、すべての一致が返される。'@option{wildignorecase}' オプションは常に適用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If there are no matches, an empty list is returned.  An
		invalid value for {type} produces an error.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
一致するものがなければ、空のリストが返される。@{type@} の値が無効だと、エラーが発生する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*getcurpos()*
getcurpos()	Get the position of the cursor.  This is like getpos('.'), but
		includes an extra item in the list:
		    [bufnum, lnum, col, off, curswant] ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getcurpos()}
@findex getcurpos()
@item getcurpos()
カーソルの位置を返す。これは getpos('.') に似ているが、追加の情報を含む:
@example
[bufnum, lnum, col, off, curswant]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The "curswant" number is the preferred column when moving the
		cursor vertically.  Also see |getpos()|.

		This can be used to save and restore the cursor position: >
			let save_cursor = getcurpos()
			MoveTheCursorAround
			call setpos('.', save_cursor)
<		Note that this only works within the window.  See
		|winrestview()| for restoring more state.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"curswant" は縦方向移動の優先的列番号である。|@ref{getpos()}| を参照。

次のようにしてカーソル位置の保存と復元ができる:
@example
let save_cursor = getcurpos()
MoveTheCursorAround
call setpos('.', save_cursor)
@end example
@quotation
@strong{Note:} @*
これはウィンドウ内のみで動作することに注意。復元するより多くの状態については |@ref{winrestview()}| を参照。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*getcwd()*
getcwd([{winnr} [, {tabnr}]])
		The result is a String, which is the name of the current
		working directory.
		Without arguments, for the current window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getcwd()}
@findex getcwd()
@item getcwd([@{winnr@} [, @{tabnr@}]])
結果は現在の作業ディレクトリ名の文字列である。引数が指定されない場合、現在のウィンドウである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		With {winnr} return the local current directory of this window
		in the current tab page.  {winnr} can be the window number or
		the |window-ID|.
		If {winnr} is -1 return the name of the global working
		directory.  See also |haslocaldir()|.

		With {winnr} and {tabnr} return the local current directory of
		the window in the specified tab page.
		Return an empty string if the arguments are invalid.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{winnr@} が指定された場合、現在のタブページ内の @{winnr@} のウィンドウのローカルカレントディレクトリを返す。@{winnr@} にはウィンドウ番号または |@ref{window-ID}| が使える。

もしも @{winnr@} が -1 なら、グローバルワーキングディレクトリの名前を返す。|@ref{haslocaldir()}| を参照。

@{winnr@} と @{tabnr@} が指定された場合、@{tabnr@} のタブページ内の @{winnr@} のウィンドウのローカルカレントディレクトリを返す。

もし引数が不正の場合、空文字列を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getfsize({fname})					*getfsize()*
		The result is a Number, which is the size in bytes of the
		given file {fname}.
		If {fname} is a directory, 0 is returned.
		If the file {fname} can't be found, -1 is returned.
		If the size of {fname} is too big to fit in a Number then -2
		is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getfsize()}
@findex getfsize()
@item getfsize(@{fname@})
結果は数値で、@{fname@} で指定されるファイルのサイズをバイト単位で返す。

@{fname@} がディレクトリのときは 0 を返す。

ファイル @{fname@} が見つからないときは -1 を返す。

@{fname@} のサイズが |@ref{Number}| の範囲外の場合は -2 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getfontname([{name}])					*getfontname()*
		Without an argument returns the name of the normal font being
		used.  Like what is used for the Normal highlight group
		|hl-Normal|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getfontname()}
@findex getfontname()
@item getfontname([@{name@}])
引数なしで使われた場合には現在の通常のフォント名を返す。ハイライトグループ Normal に対して使われるものと同様 |@ref{hl-Normal}|。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		With an argument a check is done whether {name} is a valid
		font name.  If not then an empty string is returned.
		Otherwise the actual font name is returned, or {name} if the
		GUI does not support obtaining the real name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数が指定された場合には @{name@} が有効なフォント名であるか判定される。有効でないときは空文字列を返す。

有効なときは実際のフォント名を返す。または GUI が実際の名前の取得をサポートしていないときは @{name@} をそのまま返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Only works when the GUI is running, thus not in your vimrc or
		gvimrc file.  Use the |GUIEnter| autocommand to use this
		function just after the GUI has started.
		Note that the GTK GUI accepts any font name, thus checking for
		a valid name does not work.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
GUI モードで実行しているときのみ動作する。よって vimrc や gvimrc の中では使えない。GUI モードが起動した直後にこの関数を呼ぶには、オートコマンド |@ref{GUIEnter}| を使うこと。
@quotation
@strong{Note:} @*
GTK の GUI はどんなフォント名でも受け付けてしまうため、名前が有効であるかのチェックは機能しない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getfperm({fname})					*getfperm()*
		The result is a String, which is the read, write, and execute
		permissions of the given file {fname}.
		If {fname} does not exist or its directory cannot be read, an
		empty string is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getfperm()}
@findex getfperm()
@item getfperm(@{fname@})
@{fname@} で指定されたファイルの読み込み、書き込み、実行の許可属性を示す文字列を返す。

@{fname@} が存在しない、またはそのディレクトリが読み込み不可能なときは空文字列を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The result is of the form "rwxrwxrwx", where each group of
		"rwx" flags represent, in turn, the permissions of the owner
		of the file, the group the file belongs to, and other users.
		If a user does not have a given permission the flag for this
		is replaced with the string "-".  Examples: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
戻り値は "rwxrwxrwx" の形で、"rwx" フラグの各グループは順にファイルの所有者、ファイルが所属するグループ、その他のユーザーを表す。許可属性が与えられていないフラグは "-" で置き換えられる。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			:echo getfperm("/etc/passwd")
			:echo getfperm(expand("~/.vimrc"))
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:echo getfperm("/etc/passwd")
:echo getfperm(expand("~/.vimrc"))
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		This will hopefully (from a security point of view) display
		the string "rw-r--r--" or even "rw-------".

		For setting permissions use |setfperm()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この例は、(セキュリティの観点から望ましい設定がされているならば) "@samp{rw-r--r--}" あるいは "@samp{rw-------}" と表示する。

許可属性を設定するには |@ref{setfperm()}| を使用する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getftime({fname})					*getftime()*
		The result is a Number, which is the last modification time of
		the given file {fname}.  The value is measured as seconds
		since 1st Jan 1970, and may be passed to strftime().  See also
		|localtime()| and |strftime()|.
		If the file {fname} can't be found -1 is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getftime()}
@findex getftime()
@item getftime(@{fname@})
結果は @{fname@} で与えられたファイルの、最終更新時間を示す数値。1970年1月1日からの経過時間(秒)で、strftime() に渡すことができるだろう。|@ref{localtime()}| と |@ref{strftime()}| も参照。

ファイル @{fname@} が見つからなかった場合には -1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getftype({fname})					*getftype()*
		The result is a String, which is a description of the kind of
		file of the given file {fname}.
		If {fname} does not exist an empty string is returned.
		Here is a table over different kinds of files and their
		results:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getftype()}
@findex getftype()
@item getftype(@{fname@})
@{fname@} で指定されたファイルの種別を示す文字列を返す。

@{fname@} が存在しないときは空文字列を返す。

ファイルの種別とそれらの結果の表を以下に示す:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Normal file		"file"
			Directory		"dir"
			Symbolic link		"link"
			Block device		"bdev"
			Character device	"cdev"
			Socket			"socket"
			FIFO			"fifo"
			All other		"other"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .7 .3
@item 通常ファイル @tab "file"
@item ディレクトリ @tab "dir"
@item シンボリックリンク @tab "link"
@item ブロックデバイス @tab "bdev"
@item キャラクタデバイス @tab "cdev"
@item ソケット @tab "socket"
@item FIFO @tab "fifo"
@item それ以外 @tab "other"
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example: >
			getftype("/home")
<		Note that a type such as "link" will only be returned on
		systems that support it.  On some systems only "dir" and
		"file" are returned.  On MS-Windows a symbolic link to a
		directory returns "dir" instead of "link".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
getftype("/home")
@end example
@quotation
@strong{Note:} @*
"link" などの種別はそれをサポートしているシステムでのみ返される。"dir" と "file" しか返らないシステムもある。MS-Windows では、ディレクトリへのシンボリックリンクは "link" の代わりに "dir" を返す。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getjumplist([{winnr} [, {tabnr}]])			*getjumplist()*
		Returns the |jumplist| for the specified window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getjumplist()}
@findex getjumplist()
@item getjumplist([@{winnr@} [, @{tabnr@}]])
指定したウィンドウのためのジャンプリスト |@ref{jumplist}| を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Without arguments use the current window.
		With {winnr} only use this window in the current tab page.
		{winnr} can also be a |window-ID|.
		With {winnr} and {tabnr} use the window in the specified tab
		page.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数が無い場合はカレントウィンドウを使う。@{winnr@} の場合はカレントタブページのウィンドウのみを使う。@{winnr@} はまた |@ref{window-ID}| になる。@{winnr@} と @{tabnr@} の場合は 指定したタブページのウィンドウを使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The returned list contains two entries: a list with the jump
		locations and the last used jump position number in the list.
		Each entry in the jump location list is a dictionary with
		the following entries:
			bufnr		buffer number
			col		column number
			coladd		column offset for 'virtualedit'
			filename	filename if available
			lnum		line number
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
返されるリストは 2 つのエントリを含んでいる: それは、ジャンプロケーションリストとリスト内で最後に使用したジャンプポジションの番号である。ジャンプロケーションリスト内のそれぞれのエントリは、次の項目を持つ辞書である:
@multitable @columnfractions .3 .7
@item bufnr @tab バッファ番号
@item col @tab カラム番号
@item coladd @tab '@option{virtualedit}' のカラムオフセット
@item filename @tab もし得られるならファイル名
@item lnum @tab 行番号
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*getline()*
getline({lnum} [, {end}])
		Without {end} the result is a String, which is line {lnum}
		from the current buffer.  Example: >
			getline(1)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getline()}
@findex getline()
@item getline(@{lnum@} [, @{end@}])
@{end@} が指定されない場合は、カレントバッファの @{lnum@} 行目の内容を文字列にして返す。例:
@example
getline(1)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		When {lnum} is a String that doesn't start with a
		digit, |line()| is called to translate the String into a Number.
		To get the line under the cursor: >
			getline(".")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{lnum@} が数字ではない文字で始まる文字列であった場合、|@ref{line()}| によってその文字列が数字に変換される。よって、カーソルのある行の文字列を取得するには:
@example
getline(".")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		When {lnum} is smaller than 1 or bigger than the number of
		lines in the buffer, an empty string is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{lnum@} が 1 より小さいかバッファの行数よりも大きい数値の場合、空文字列が返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {end} is given the result is a |List| where each item is
		a line from the current buffer in the range {lnum} to {end},
		including line {end}.
		{end} is used in the same way as {lnum}.
		Non-existing lines are silently omitted.
		When {end} is before {lnum} an empty |List| is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{end@} が指定された場合は、カレントバッファの @{lnum@} 行目から @{end@} 行目までを要素とするリスト |@ref{List}| を返す。@{end@} は @{lnum@} と同様に解釈される。

存在しない行は省略され、エラーメッセージは表示されない。

@{end@} が @{lnum@} より前になる場合は空リスト |@ref{List}| を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example: >
			:let start = line('.')
			:let end = search("^$") - 1
			:let lines = getline(start, end)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:let start = line('.')
:let end = search("^$") - 1
:let lines = getline(start, end)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		To get lines from another buffer see |getbufline()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
他のバッファの行を取得するには |@ref{getbufline()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getloclist({nr} [, {what}])				*getloclist()*
		Returns a list with all the entries in the location list for
		window {nr}.  {nr} can be the window number or the |window-ID|.
		When {nr} is zero the current window is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getloclist()}
@findex getloclist()
@item getloclist(@{nr@} [, @{what@}])
ウィンドウ @{nr@} のロケーションリストの全項目からなるリストを返す。@{nr@} にはウィンドウ番号または |@ref{window-ID}| が使える。@{nr@} に 0 を指定するとカレントウィンドウになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For a location list window, the displayed location list is
		returned.  For an invalid window number {nr}, an empty list is
		returned. Otherwise, same as |getqflist()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ロケーションリストウィンドウに対して使用すると、そこに表示されているロケーションリストが返る。ウィンドウ番号 @{nr@} が無効な場合は、空リストが返る。それ以外は |@ref{getqflist()}| と同じ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If the optional {what} dictionary argument is supplied, then
		returns the items listed in {what} as a dictionary. Refer to
		|getqflist()| for the supported items in {what}.
		If {what} contains 'filewinid', then returns the id of the
		window used to display files from the location list. This
		field is applicable only when called from a location list
		window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプションの @{what@} 辞書引数が指定されている場合、@{what@} にリストされている項目を辞書として返す。@{what@} のサポートされている項目については、|@ref{getqflist()}| を参照。

もしも @{what@} に 'filewinid' が含まれているなら、ロケーションリストからファイルの表示に使われているウィンドウ ID が返される。このフィールドはロケーションリストウィンドウから呼ばれた時のみ適用できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getmatches()						*getmatches()*
		Returns a |List| with all matches previously defined by
		|matchadd()| and the |:match| commands.  |getmatches()| is
		useful in combination with |setmatches()|, as |setmatches()|
		can restore a list of matches saved by |getmatches()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getmatches()}
@findex getmatches()
@item getmatches()
|@ref{matchadd()}| と |@ref{:match}| により定義された全てのマッチの |@ref{List}| を返す。|@ref{setmatches()}| は |@ref{getmatches()}| で保存されたマッチのリストを復元できるので、|@ref{getmatches()}| と |@ref{setmatches()}| は組み合わせて使うと便利である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example: >
			:echo getmatches()
<			[{'group': 'MyGroup1', 'pattern': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
			:let m = getmatches()
			:call clearmatches()
			:echo getmatches()
<			[] >
			:call setmatches(m)
			:echo getmatches()
<			[{'group': 'MyGroup1', 'pattern': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
			:unlet m
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:echo getmatches()
[@{'group': 'MyGroup1', 'pattern': 'TODO',
'priority': 10, 'id': 1@}, @{'group': 'MyGroup2',
'pattern': 'FIXME', 'priority': 10, 'id': 2@}]
:let m = getmatches()
:call clearmatches()
:echo getmatches()
[]
:call setmatches(m)
:echo getmatches()
[@{'group': 'MyGroup1', 'pattern': 'TODO',
'priority': 10, 'id': 1@}, @{'group': 'MyGroup2',
'pattern': 'FIXME', 'priority': 10, 'id': 2@}]
:unlet m
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*getpid()*
getpid()	Return a Number which is the process ID of the Vim process.
		On Unix and MS-Windows this is a unique number, until Vim
		exits.  On MS-DOS it's always zero.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getpid()}
@findex getpid()
@item getpid()
Vim のプロセス ID を数値で返す。Unix と MS-Windows では Vim が終了するまでこれは一意な数値である。MS-DOS では常にゼロである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*getpos()*
getpos({expr})	Get the position for {expr}.  For possible values of {expr}
		see |line()|.  For getting the cursor position see
		|getcurpos()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getpos()}
@findex getpos()
@item getpos(@{expr@})
@{expr@} の位置を返す。@{expr@} として指定できる値については |@ref{line()}| を参照。カーソル位置を得るには |@ref{getcurpos()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The result is a |List| with four numbers:
		    [bufnum, lnum, col, off]
		"bufnum" is zero, unless a mark like '0 or 'A is used, then it
		is the buffer number of the mark.
		"lnum" and "col" are the position in the buffer.  The first
		column is 1.
		The "off" number is zero, unless 'virtualedit' is used.  Then
		it is the offset in screen columns from the start of the
		character.  E.g., a position within a <Tab> or after the last
		character.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
結果は次の 4 個の要素を持つリスト |@ref{List}|:
@example
[bufnum, lnum, col, off]
@end example
"bufnum" は、'0 や 'A のようなマークが指定されたときは、そのマークのバッファ番号となる。それ以外では 0 となる。

"lnum" と "col" はバッファ中の位置。桁番号は 1 から始まる。

"off" の値は、'@option{virtualedit}' がオフのときは常に 0 で、オンのときはその文字の始点からの画面上の桁のオフセットである。つまり、カーソルが <Tab> の中や、その行の最後の文字より後にあるとき意味を持つ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that for '< and '> Visual mode matters: when it is "V"
		(visual line mode) the column of '< is zero and the column of
		'> is a large number.
		This can be used to save and restore the position of a mark: >
			let save_a_mark = getpos("'a")
			...
			call setpos("'a", save_a_mark)
<		Also see |getcurpos()| and |setpos()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ビジュアルモードの '< と '> について: ビジュアルモードが "V" (行選択モード) のとき、'< の桁番号はゼロ、'> の桁番号は大きな値になる。

この関数はマークの位置を保存し、復元するために使われる:
@example
let save_a_mark = getpos("'a")
...
call setpos("'a", save_a_mark)
@end example
|@ref{getcurpos()}| と |@ref{setpos()}|も参照。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
getqflist([{what}])					*getqflist()*
		Returns a list with all the current quickfix errors.  Each
		list item is a dictionary with these entries:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getqflist()}
@findex getqflist()
@item getqflist([@{what@}])
現在の全 quickfix エラーのリストを返す。リストの各要素は辞書で、以下の要素を持つ:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			bufnr	number of buffer that has the file name, use
				bufname() to get the name
			module	module name
			lnum	line number in the buffer (first line is 1)
			col	column number (first column is 1)
			vcol	|TRUE|: "col" is visual column
				|FALSE|: "col" is byte index
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item bufnr @tab ファイル名を持つバッファの番号。その名前を取得するには bufname() を使う。
@item module @tab モジュール名
@item lnum @tab バッファ中の行番号 (最初の行は 1)
@item col @tab 桁番号 (最初の桁は 1)
@item vcol @tab |@ref{TRUE}|: "col" は画面上の桁 @* |@ref{FALSE}|: "col" はバイトインデックス
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			nr	error number
			pattern	search pattern used to locate the error
			text	description of the error
			type	type of the error, 'E', '1', etc.
			valid	|TRUE|: recognized error message
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item nr @tab エラー番号
@item pattern @tab エラーの位置を特定するために使う検索パターン
@item text @tab エラーの説明
@item type @tab エラーメッセージの種類。'E', '1' など。
@item valid @tab |@ref{TRUE}|: エラーメッセージが認識されている
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When there is no error list or it's empty, an empty list is
		returned. Quickfix list entries with non-existing buffer
		number are returned with "bufnr" set to zero.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
エラーリストがまったくないか、空であるときは空リストを返す。存在しないバッファ番号を持つ quickfix リストの項目は "bufnr" を 0 にして返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Useful application: Find pattern matches in multiple files and
		do something with them: >
			:vimgrep /theword/jg *.c
			:for d in getqflist()
			:   echo bufname(d.bufnr) ':' d.lnum '=' d.text
			:endfor
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
役に立つ応用例: 複数のファイルから正規表現検索を行い、見つかったものに対してなんらかの操作をする:
@example
:vimgrep /theword/jg *.c
:for d in getqflist()
:   echo bufname(d.bufnr) ':' d.lnum '=' d.text
:endfor
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If the optional {what} dictionary argument is supplied, then
		returns only the items listed in {what} as a dictionary. The
		following string items are supported in {what}:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプションの @{what@} 辞書引数が指定されている場合は、@{what@} にリストされている項目のみを辞書として返す。@{what@} では、以下の文字列項目がサポートされている:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			changedtick	get the total number of changes made
					to the list |quickfix-changedtick|
			context	get the |quickfix-context|
			efm	errorformat to use when parsing "lines". If
				not present, then the 'errorformat' option
				value is used.
			id	get information for the quickfix list with
				|quickfix-ID|; zero means the id for the
				current list or the list specified by "nr"
			idx	index of the current entry in the list
			items	quickfix list entries
			lines	parse a list of lines using 'efm' and return
				the resulting entries.  Only a |List| type is
				accepted.  The current quickfix list is not
				modified. See |quickfix-parse|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item changedtick @tab リストを変更した総数を取得する |@ref{quickfix-changedtick}|
@item context @tab |@ref{quickfix-context}| を取得する
@item efm @tab "lines" をパースする時に使う errorformat。もしも存在しなければ '@option{errorformat}' オプションの値が使われる
@item id @tab |@ref{quickfix-ID}| の quickfix リストの情報を取得する。0 はカレントリストの id もしくは "nr" で指定されたリストということを意味する
@item idx @tab リスト内の現在のエントリのインデックス
@item items @tab quickfix リストのエントリ
@item lines @tab '@option{efm}' を使って行のリストをパースし、項目の結果を返す。|@ref{List}| 型のみ受け取られる。現在の quickfix リストは変更されない。|@ref{quickfix-parse}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			nr	get information for this quickfix list; zero
				means the current quickfix list and "$" means
				the last quickfix list
			size	number of entries in the quickfix list
			title	get the list title |quickfix-title|
			winid	get the quickfix |window-ID|
			all	all of the above quickfix properties
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item nr @tab この quickfix リストの情報を取得。0 は現在の quickfix リストを意味する。"$" は quickfix リストの最後を意味する
@item size @tab quickfix リスト内のエントリ数
@item title @tab |@ref{quickfix-title}| のリストタイトルを取得
@item winid @tab quickfix の |@ref{window-ID}| を取得
@item all @tab 上記の quickfix のすべてのプロパティ
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Non-string items in {what} are ignored. To get the value of a
		particular item, set it to zero.
		If "nr" is not present then the current quickfix list is used.
		If both "nr" and a non-zero "id" are specified, then the list
		specified by "id" is used.
		To get the number of lists in the quickfix stack, set "nr" to
		"$" in {what}. The "nr" value in the returned dictionary
		contains the quickfix stack size.
		When "lines" is specified, all the other items except "efm"
		are ignored.  The returned dictionary contains the entry
		"items" with the list of entries.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{what@} の文字列以外の項目は無視される。特別なアイテムの値を取得するために、0 に設定する。

"nr" が存在しない場合、現在の quickfix リストが使用される。

"nr" と 0 ではない "id" が指定されているなら、"id" で指定されているリストが使われる。

quickfix スタックのリスト数を得るために、@{what@} の "nr" を "$" に設定する。返された辞書内の "nr" の値は quickfix スタックのサイズを含む。

"lines" が指定された場合、"efm" を除く他の全ての項目は無視される。返された辞書はエントリリストの "items" エントリを含む。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The returned dictionary contains the following entries:
			changedtick	total number of changes made to the
					list |quickfix-changedtick|
			context	quickfix list context. See |quickfix-context|
				If not present, set to "".
			id	quickfix list ID |quickfix-ID|. If not
				present, set to 0.
			idx	index of the current entry in the list. If not
				present, set to 0.
			items	quickfix list entries. If not present, set to
				an empty list.
			nr	quickfix list number. If not present, set to 0
			size	number of entries in the quickfix list. If not
				present, set to 0.
			title	quickfix list title text. If not present, set
				to "".
			winid	quickfix |window-ID|. If not present, set to 0
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
返される辞書には、次のエントリが含まれる:
@multitable @columnfractions .2 .8
@item changedtick @tab quickfix リストのコンテキスト。|@ref{quickfix-context}| を参照。
@item context @tab |@ref{setqflist()}| に格納されたコンテキスト情報。もし存在しなければ "" に設定する。
@item id @tab quickfix リストの ID |@ref{quickfix-ID}|。もし存在しなければ 0 に設定する。
@item idx @tab リスト内の現在のエントリのインデックス。もし存在しなければ 0 に設定する。
@item items @tab quickfix リストのエントリ。もし存在しなければ空リストに設定する。
@item nr @tab quickfix リスト番号。もし存在しなければ 0 に設定する。
@item size @tab quickfix リスト内のエントリ数。もし存在しなければ 0 に設定する。
@item title @tab quickfix リストのタイトルテキスト。もし存在しなければ "" に設定する。
@item winid @tab quickfix の |@ref{window-ID}|。もし存在しなければ 0 に設定する。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Examples (See also |getqflist-examples|): >
			:echo getqflist({'all': 1})
			:echo getqflist({'nr': 2, 'title': 1})
			:echo getqflist({'lines' : ["F1:10:L10"]})
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例 (|@ref{getqflist-examples}| も参照):
@example
:echo getqflist(@{'all': 1@})
:echo getqflist(@{'nr': 2, 'title': 1@})
:echo getqflist(@{'lines' : ["F1:10:L10"]@})
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getreg([{regname} [, 1 [, {list}]]])			*getreg()*
		The result is a String, which is the contents of register
		{regname}.  Example: >
			:let cliptext = getreg('*')
<		When {regname} was not set the result is an empty string.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getreg()}
@findex getreg()
@item getreg([@{regname@} [, 1 [, @{list@}]]])
レジスタ @{regname@} の中身を文字列にして返す。例:
@example
:let cliptext = getreg('*')
@end example
@{regname@} がセットされていないときは、結果は空文字列となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		getreg('=') returns the last evaluated value of the expression
		register.  (For use in maps.)
		getreg('=', 1) returns the expression itself, so that it can
		be restored with |setreg()|.  For other registers the extra
		argument is ignored, thus you can always give it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
getreg('=') は最後に評価した式レジスタの値を返す。(マップの中で使用する)。

getreg('=', 1) はその式そのものを返す。これを使って |@ref{setreg()}| で復元することができる。他のレジスタの場合は、この引数は無視されるので、常に指定していても害はない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {list} is present and |TRUE|, the result type is changed
		to |List|. Each list item is one text line. Use it if you care
		about zero bytes possibly present inside register: without
		third argument both NLs and zero bytes are represented as NLs
		(see |NL-used-for-Nul|).
		When the register was not set an empty list is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{list@} が指定され、その値が |@ref{TRUE}| のときは、戻り値はリスト (|@ref{List}|) になる。リストの各要素はテキスト 1 行である。これはレジスタの中に値ゼロのバイトが含まれる場合に使用する。@{list@} を指定しなかった場合は NL 文字と値ゼロのバイトは両方とも NL 文字として扱われる (|@ref{NL-used-for-Nul}| 参照)。

指定したレジスタがセットされていないときは、空のリストが返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {regname} is not specified, |v:register| is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{regname@} を指定しないときは |@ref{v:register}| が使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
getregtype([{regname}])					*getregtype()*
		The result is a String, which is type of register {regname}.
		The value will be one of:
		    "v"			for |characterwise| text
		    "V"			for |linewise| text
		    "<CTRL-V>{width}"	for |blockwise-visual| text
		    ""			for an empty or unknown register
		<CTRL-V> is one character with value 0x16.
		If {regname} is not specified, |v:register| is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getregtype()}
@findex getregtype()
@item getregtype([@{regname@}])
レジスタ @{regname@} の種類を表す文字列を返す。戻り値は次のいずれかとなる:
@multitable @columnfractions .4 .6
@item "v" @tab 文字単位 |@ref{characterwise}| の場合
@item "V" @tab 行単位 |@ref{linewise}| の場合
@item "<CTRL-V>@{width@}" @tab 矩形 |@ref{blockwise-visual}| の場合
@item "" @tab 空、または未知のレジスタの場合
@end multitable
@kbd{<CTRL-V>} は値 0x16 の 1 文字である。

@{regname@} を指定しないときは |@ref{v:register}| が使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
gettabinfo([{arg}])					*gettabinfo()*
		If {arg} is not specified, then information about all the tab
		pages is returned as a List. Each List item is a Dictionary.
		Otherwise, {arg} specifies the tab page number and information
		about that one is returned.  If the tab page does not exist an
		empty List is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gettabinfo()}
@findex gettabinfo()
@item gettabinfo([@{arg@}])
@{arg@} を指定しないと、すべてのタブページに関する情報がリストとして返される。各リスト項目は辞書である。それ以外の場合、@{arg@} はタブページ番号を指定し、それに関する情報が返される。タブページが存在しない場合、空のリストが返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Each List item is a Dictionary with the following entries:
			tabnr		tab page number.
			variables	a reference to the dictionary with
					tabpage-local variables
			windows		List of |window-ID|s in the tag page.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
各リストアイテムは、次のエントリを持つ辞書である:
@multitable @columnfractions .2 .8
@item tabnr @tab タブページ番号。
@item variables @tab タブページローカル変数の辞書への参照。
@item windows @tab タブページの |@ref{window-ID}| のリスト。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
gettabvar({tabnr}, {varname} [, {def}])				*gettabvar()*
		Get the value of a tab-local variable {varname} in tab page
		{tabnr}. |t:var|
		Tabs are numbered starting with one.
		When {varname} is empty a dictionary with all tab-local
		variables is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gettabvar()}
@findex gettabvar()
@item gettabvar(@{tabnr@}, @{varname@} [, @{def@}])
タブページ @{tabnr@} のタブローカル変数 @{varname@} を取得する。|@ref{t:var}|

タブの番号は 1 から始まる。

@{varname@} が空のときは全タブローカル変数からなる辞書を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that the name without "t:" must be used.
		When the tab or variable doesn't exist {def} or an empty
		string is returned, there is no error message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
指定する変数名は "t:" を除いた名前。タブや変数が存在しないときは @{def@} または空文字列を返し、エラーメッセージは表示されない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
gettabwinvar({tabnr}, {winnr}, {varname} [, {def}])		*gettabwinvar()*
		Get the value of window-local variable {varname} in window
		{winnr} in tab page {tabnr}.
		When {varname} is empty a dictionary with all window-local
		variables is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gettabwinvar()}
@findex gettabwinvar()
@item gettabwinvar(@{tabnr@}, @{winnr@}, @{varname@} [, @{def@}])
タブページ @{tabnr@} 内のウィンドウ @{winnr@} のウィンドウローカル変数 @{varname@} の値を取得する。

@{varname@} が空のときは全ウィンドウローカル変数からなる辞書を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When {varname} is equal to "&" get the values of all
		window-local options in a Dictionary.
		Otherwise, when {varname} starts with "&" get the value of a
		window-local option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{varname@} が "&" と等しい場合はすべてのウィンドウローカルオプションの値を辞書に入れて返す。

@{varname@} が文字 "&" で始まるときはウィンドウローカルオプションの値を取得する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that {varname} must be the name without "w:".
		Tabs are numbered starting with one.  For the current tabpage
		use |getwinvar()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
@{varname@} は "w:" をつけずに指定しなければならない。タブページ番号は 1 から始まる。カレントタブページを指定するには |@ref{getwinvar()}| を指定する。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{winnr} can be the window number or the |window-ID|.
		When {winnr} is zero the current window is used.
		This also works for a global option, buffer-local option and
		window-local option, but it doesn't work for a global variable
		or buffer-local variable.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{winnr@} にはウィンドウ番号または |@ref{window-ID}| が使える。

@{winnr@} が 0 のときはカレントウィンドウとなる。

グローバルオプション、バッファローカルオプション、ウィンドウローカルオプションに対しても動作するが、グローバル変数やバッファローカル変数に対しては動作しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When the tab, window or variable doesn't exist {def} or an
		empty string is returned, there is no error message.
		Examples: >
			:let list_is_on = gettabwinvar(1, 2, '&list')
			:echo "myvar = " . gettabwinvar(3, 1, 'myvar')
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ウィンドウやタブや変数が存在しないときは @{def@} または空文字列を返し、エラーメッセージは表示されない。

例:
@example
:let list_is_on = gettabwinvar(1, 2, '&list')
:echo "myvar = " . gettabwinvar(3, 1, 'myvar')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		To obtain all window-local variables use: >
			gettabwinvar({tabnr}, {winnr}, '&')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
すべてのウィンドウローカル変数を取得するには:
@example
gettabwinvar(@{tabnr@}, @{winnr@}, '&')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getwininfo([{winid}])					*getwininfo()*
		Returns information about windows as a List with Dictionaries.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getwininfo()}
@findex getwininfo()
@item getwininfo([@{winid@}])
ウィンドウに関する情報を、辞書のリストとして返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {winid} is given Information about the window with that ID
		is returned.  If the window does not exist the result is an
		empty list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{winid@} が与えられた場合、その ID を持つウィンドウに関する情報が返される。ウィンドウが存在しない場合、結果は空のリストになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Without {winid} information about all the windows in all the
		tab pages is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{winid@} がなければすべてのタブページのすべてのウィンドウに関する情報が返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Each List item is a Dictionary with the following entries:
			bufnr		number of buffer in the window
			height		window height (excluding winbar)
			loclist		1 if showing a location list
					{only with the +quickfix feature}
			quickfix	1 if quickfix or location list window
					{only with the +quickfix feature}
			terminal	1 if a terminal window
					{only with the +terminal feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
各 List アイテムは次のエントリを持つ辞書である:
@multitable @columnfractions .2 .8
@item bufnr @tab ウィンドウ内のバッファ数
@item height @tab ウィンドウの高さ (winbar は除外)
@item loclist @tab ロケーションリストを表示してる場合は 1

@{Vim が |@ref{+quickfix}| 機能付きでコンパイルされたときのみ有効@}
@item quickfix @tab quickfix またはロケーションリストウィンドウの場合は 1

@{Vim が |@ref{+quickfix}| 機能付きでコンパイルされたときのみ有効@}
@item terminal @tab ターミナルウィンドウの場合は 1

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			tabnr		tab page number
			variables	a reference to the dictionary with
					window-local variables
			width		window width
			winbar		1 if the window has a toolbar, 0
					otherwise
			wincol		leftmost screen column of the window,
					col from |win_screenpos()|
			winid		|window-ID|
			winnr		window number
			winrow		topmost screen column of the window,
					row from |win_screenpos()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item tabnr @tab タブページ番号
@item variables @tab ウィンドウローカル変数の辞書への参照
@item width @tab ウィンドウ幅
@item winbar @tab ウィンドウがツールバーを持っている場合は 1、そうでなければ 0
@item wincol @tab ウィンドウのいちばん左のスクリーン桁、|@ref{win_screenpos()}| からの桁
@item winid @tab |@ref{window-ID}|
@item winnr @tab ウィンドウ番号
@item winrow @tab ウィンドウの一番上のスクリーン桁、|@ref{win_screenpos()}| からの列
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getwinpos([{timeout}])					*getwinpos()*
		The result is a list with two numbers, the result of
		getwinposx() and getwinposy() combined: 
			[x-pos, y-pos]
		{timeout} can be used to specify how long to wait in msec for
		a response from the terminal.  When omitted 100 msec is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getwinpos()}
@findex getwinpos()
@item getwinpos([@{timeout@}])
結果は getwinposx() と getwinposy() の結果を合わせた 2 数のリスト:
@example
[x-pos, y-pos]
@end example
@{timeout@} はターミナルからの応答を何ミリ秒待つのかを指定するのに使える。省略されば場合は 100 ミリ秒が使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Use a longer time for a remote terminal.
		When using a value less than 10 and no response is received
		within that time, a previously reported position is returned,
		if available.  This can be used to poll for the position and
		do some work in the mean time: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

リモートターミナルを長時間使用する。

値が 10 よりも小さく、またその時間内に応答が無い場合、可能ならば以前に伝えられた位置が返される。これは位置を把握し、その間に何かをするのに使うことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			while 1
			  let res = getwinpos(1)
			  if res[0] >= 0
			    break
			  endif
			  " Do some work here
			endwhile
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
while 1
  let res = getwinpos(1)
  if res[0] >= 0
    break
  endif
  " Do some work here
endwhile
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*getwinposx()*
getwinposx()	The result is a Number, which is the X coordinate in pixels of
		the left hand side of the GUI Vim window. Also works for an
		xterm (uses a timeout of 100 msec).
		The result will be -1 if the information is not available.
		The value can be used with `:winpos`.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getwinposx()}
@findex getwinposx()
@item getwinposx()
結果は GUI の Vim ウィンドウの左端の、デスクトップ上での X 座標値 (数値)。xterm でも動作する (タイムアウトは 100 ミリ秒が使われる)。情報が存在しない (コンソールの) 場合は -1 となる。`:winpos` の値が使える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*getwinposy()*
getwinposy()	The result is a Number, which is the Y coordinate in pixels of
		the top of the GUI Vim window.  Also works for an xterm (uses
		a timeout of 100 msec).
		The result will be -1 if the information is not available.
		The value can be used with `:winpos`.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getwinposy()}
@findex getwinposy()
@item getwinposy()
結果は GUI の Vim ウィンドウの上端の、デスクトップ上での Y 座標値 (数値)。xterm でも動作する (タイムアウトは 100 ミリ秒が使われる)。情報が存在しない (コンソールの) 場合は -1 となる。`:winpos` の値が使える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
getwinvar({winnr}, {varname} [, {def}])				*getwinvar()*
		Like |gettabwinvar()| for the current tabpage.
		Examples: >
			:let list_is_on = getwinvar(2, '&list')
			:echo "myvar = " . getwinvar(1, 'myvar')
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{getwinvar()}
@findex getwinvar()
@item getwinvar(@{winnr@}, @{varname@} [, @{def@}])
カレントタブページに対する |@ref{gettabwinvar()}| と同様。

例:
@example
:let list_is_on = getwinvar(2, '&list')
:echo "myvar = " . getwinvar(1, 'myvar')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])		*glob()*
		Expand the file wildcards in {expr}.  See |wildcards| for the
		use of special characters.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{glob()}
@findex glob()
@item glob(@{expr@} [, @{nosuf@} [, @{list@} [, @{alllinks@}]]])
@{expr@} 内のファイル名のワイルドカードを展開する。特殊文字については |@ref{wildcards}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Unless the optional {nosuf} argument is given and is |TRUE|,
		the 'suffixes' and 'wildignore' options apply: Names matching
		one of the patterns in 'wildignore' will be skipped and
		'suffixes' affect the ordering of matches.
		'wildignorecase' always applies.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{nosuf@} に |@ref{TRUE}| を指定しない限り、'@option{suffixes}' と '@option{wildignore}' が適用される。つまり '@option{wildignore}' のパターンにマッチする名前はスキップされ、'@option{suffixes}' がマッチの順番に影響を与える。'@option{wildignorecase}' は常に適用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {list} is present and it is |TRUE| the result is a List
		with all matching files. The advantage of using a List is,
		you also get filenames containing newlines correctly.
		Otherwise the result is a String and when there are several
		matches, they are separated by <NL> characters.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{list@} が指定されその値が |@ref{TRUE}| なら、マッチしたすべてのファイルがリストとして返される。リストを使うことで、改行を含むファイル名があっても結果を正しく受け取ることができる。

そうでない場合は結果は文字列で返される。その場合、複数のマッチがあるときはそれらは文字 <NL> で区切られる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If the expansion fails, the result is an empty String or List.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
展開が失敗した場合、空の文字列またはリストが返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		A name for a non-existing file is not included.  A symbolic
		link is only included if it points to an existing file.
		However, when the {alllinks} argument is present and it is
		|TRUE| then all symbolic links are included.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
存在しないファイル名は結果に含まれない。シンボリックリンクは、それが存在するファイルを指す場合のみ含まれる。ただし、@{alllinks@} 引数が存在し、それが |@ref{TRUE}| である場合はすべてのシンボリックリンクが含まれる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For most systems backticks can be used to get files names from
		any external command.  Example: >
			:let tagfiles = glob("`find . -name tags -print`")
			:let &tags = substitute(tagfiles, "\n", ",", "g")
<		The result of the program inside the backticks should be one
		item per line.  Spaces inside an item are allowed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
多くのシステムではバッククォート (「`」という文字のこと) を、外部コマンドの実行結果からファイル名を取得するために使用できる。例:
@example
:let tagfiles = glob("`find . -name tags -print`")
:let &tags = substitute(tagfiles, "\n", ",", "g")
@end example
バッククォート内のプログラムの実行結果は、一行に 1 つずつの項目が含まれてなければならない。項目内のスペースは許容される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		See |expand()| for expanding special Vim variables.  See
		|system()| for getting the raw output of an external command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
特殊な Vim の変数を展開するためには |@ref{expand()}| を参照。外部コマンドの生の出力を得るためには |@ref{system()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
glob2regpat({expr})					 *glob2regpat()*
		Convert a file pattern, as used by glob(), into a search
		pattern.  The result can be used to match with a string that
		is a file name.  E.g. >
			if filename =~ glob2regpat('Make*.mak')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{glob2regpat()}
@findex glob2regpat()
@item glob2regpat(@{expr@})
glob() に使われるファイルパターンを検索パターンに変換する。結果はファイル名の文字列とのマッチに使用できる。例えば、
@example
if filename =~ glob2regpat('Make*.mak')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		This is equivalent to: >
			if filename =~ '^Make.*\.mak$'
<		When {expr} is an empty string the result is "^$", match an
		empty string.
		Note that the result depends on the system.  On MS-Windows
		a backslash usually means a path separator.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上記は次と同じである:
@example
if filename =~ '^Make.*\.mak$'
@end example
@{expr@} が空文字列の場合、結果は "^$" で、空文字列にマッチする。
@quotation
@strong{Note:} @*
結果はシステムによって異なることに注意すること。MS-Windows では、バックスラッシュは通常、パス区切りを意味する。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
								*globpath()*
globpath({path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]])
		Perform glob() on all directories in {path} and concatenate
		the results.  Example: >
			:echo globpath(&rtp, "syntax/c.vim")
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{globpath()}
@findex globpath()
@item globpath(@{path@}, @{expr@} [, @{nosuf@} [, @{list@} [, @{alllinks@}]]])
@{path@} の中の全ディレクトリに対して |@ref{glob()}| を実行し、結果を連結する。例:
@example
:echo globpath(&rtp, "syntax/c.vim")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{path} is a comma-separated list of directory names.  Each
		directory name is prepended to {expr} and expanded like with
		|glob()|.  A path separator is inserted when needed.
		To add a comma inside a directory name escape it with a
		backslash.  Note that on MS-Windows a directory may have a
		trailing backslash, remove it if you put a comma after it.
		If the expansion fails for one of the directories, there is no
		error message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{path@} はコンマ区切りのディレクトリのリスト。各ディレクトリを @{expr@} の前に付加し、|@ref{glob()}| と同様にそれを展開する。必要に応じてパスの区切り文字が挿入される。

ディレクトリ名の中にコンマを含めるには、バックスラッシュでエスケープすること。
@quotation
@strong{Note:} @*
MS-Windows ではディレクトリ名の末尾にバックスラッシュがつくことがある。その後に区切りのコンマを書くとエスケープと見なされてしまうので、バックスラッシュは削除すること。どれかのディレクトリに対して展開が失敗してもエラーメッセージは表示されない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Unless the optional {nosuf} argument is given and is |TRUE|,
		the 'suffixes' and 'wildignore' options apply: Names matching
		one of the patterns in 'wildignore' will be skipped and
		'suffixes' affect the ordering of matches.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{nosuf@} に |@ref{TRUE}| が指定されない限り、オプション '@option{wildignore}' が適用される。つまり、'@option{wildignore}' のパターンにマッチする名前はスキップされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {list} is present and it is |TRUE| the result is a List
		with all matching files. The advantage of using a List is, you
		also get filenames containing newlines correctly. Otherwise
		the result is a String and when there are several matches,
		they are separated by <NL> characters.  Example: >
			:echo globpath(&rtp, "syntax/c.vim", 0, 1)
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{list@} が指定され、その値が |@ref{TRUE}| なら、マッチしたすべてのファイルがリストとして返る。リストとして受け取る利点は、改行文字を含んだファイル名も正しく扱えることである。@{list@} を指定しなかった場合は、戻り値は文字列であり、マッチした複数のファイル名は <NL> 文字で連結されてしまう。例:
@example
:echo globpath(&rtp, "syntax/c.vim", 0, 1)
@end example                
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{alllinks} is used as with |glob()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{alllinks@} は |@ref{glob()}| の場合と同様に扱われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The "**" item can be used to search in a directory tree.
		For example, to find all "README.txt" files in the directories
		in 'runtimepath' and below: >
			:echo globpath(&rtp, "**/README.txt")
<		Upwards search and limiting the depth of "**" is not
		supported, thus using 'path' will not always work properly.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"**" を使ってディレクトリツリーを再帰的に検索することができる。例えば、'@option{runtimepath}' とそれ以下のディレクトリから全ての "README.txt" を探すには次のようにする:
@example
:echo globpath(&rtp, "**/README.txt")
@end example
上向き検索と、"**" の深さの限界はサポートされていない。よってオプション '@option{path}' の値をそのまま使うとうまく動かないことがある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*has()*
has({feature})	The result is a Number, which is 1 if the feature {feature} is
		supported, zero otherwise.  The {feature} argument is a
		string.  See |feature-list| below.
		Also see |exists()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{has()}
@findex has()
@item has(@{feature@})
結果は機能 @{feature@} がサポートされる場合 1、されない場合 0 となる。引数 @{feature@} は文字列。下記の |@ref{feature-list}| を参照。|@ref{exists()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
has_key({dict}, {key})					*has_key()*
		The result is a Number, which is 1 if |Dictionary| {dict} has
		an entry with key {key}.  Zero otherwise.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{has_key()}
@findex has_key()
@item has_key(@{dict@}, @{key@})
結果は数値で、辞書 |@ref{Dictionary}| @{dict@} がキー @{key@} の要素を持つなら 1、持たないなら 0 となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
haslocaldir([{winnr} [, {tabnr}]])			*haslocaldir()*
		The result is a Number, which is 1 when the window has set a
		local path via |:lcd|, and 0 otherwise.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{haslocaldir()}
@findex haslocaldir()
@item haslocaldir([@{winnr@} [, @{tabnr@}]])
結果は数値でウィンドウが |@ref{:lcd}| によってローカルなカレントディレクトリを持つようセットされているなら 1、そうでないなら 0 となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Without arguments use the current window.
		With {winnr} use this window in the current tab page.
		With {winnr} and {tabnr} use the window in the specified tab
		page.
		{winnr} can be the window number or the |window-ID|.
		Return 0 if the arguments are invalid.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数が指定されない場合、現在のウィンドウを対象とする。

@{winnr@} が指定された場合、現在のタブページ内の @{winnr@} のウィンドウを対象とする。
@{winnr@} と @{tabnr@} が指定された場合、@{tabnr@} のタブページ内の @{winnr@} のウィンドウを対象とする。

@{winnr@} にはウィンドウ番号または |@ref{window-ID}| が使える。

もし引数が不正の場合、0  を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
hasmapto({what} [, {mode} [, {abbr}]])			*hasmapto()*
		The result is a Number, which is 1 if there is a mapping that
		contains {what} in somewhere in the rhs (what it is mapped to)
		and this mapping exists in one of the modes indicated by
		{mode}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hasmapto()}
@findex hasmapto()
@item hasmapto(@{what@} [, @{mode@} [, @{abbr@}]])
結果は数値。右辺側 (マップした先) の一部分に @{what@} を含むマッピングが存在し、それが @{mode@} で指定されたモードのいずれかで定義されているなら 1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When {abbr} is there and it is |TRUE| use abbreviations
		instead of mappings.  Don't forget to specify Insert and/or
		Command-line mode.
		Both the global mappings and the mappings local to the current
		buffer are checked for a match.
		If no matching mapping is found 0 is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{abbr@} が指定されていて |@ref{TRUE}| のときはマッピングでなく短縮入力の存在を判定する。挿入モードまたはコマンドモードを指定することを忘れないように。

グローバルマップとバッファローカルマップの両方をチェックする。

マッピングが 1 個も見つからなかったときは 0 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The following characters are recognized in {mode}:
			n	Normal mode
			v	Visual mode
			o	Operator-pending mode
			i	Insert mode
			l	Language-Argument ("r", "f", "t", etc.)
			c	Command-line mode
		When {mode} is omitted, "nvo" is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{mode@} に対しては以下の文字が利用できる:
@multitable @columnfractions .1 .9
@item n @tab ノーマルモード
@item v @tab ビジュアルモード
@item o @tab オペレータ待機モード (Operator-pending)
@item i @tab 挿入モード
@item l @tab Language-Argument モード ("r", "f", "t" など)
@item c @tab コマンドラインモード
@end multitable
@{mode@} が省略されたときは "nvo" となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		This function is useful to check if a mapping already exists
		to a function in a Vim script.  Example: >
			:if !hasmapto('\ABCdoit')
			:   map <Leader>d \ABCdoit
			:endif
<		This installs the mapping to "\ABCdoit" only if there isn't
		already a mapping to "\ABCdoit".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この関数は Vim script の中で、ある関数へのマッピングが既に存在するか判定するために有用である。例:
@example
:if !hasmapto('\ABCdoit')
:   map <Leader>d \ABCdoit
:endif
@end example
この例は、"\ABCdoit" へのマッピングが存在しないときだけ "\ABCdoit" へのマッピングを作成する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
histadd({history}, {item})				*histadd()*
		Add the String {item} to the history {history} which can be
		one of:					*hist-names*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{histadd()}
@findex histadd()
@item histadd(@{history@}, @{item@})
文字列 @{item@} を履歴 @{history@} に追加する。履歴 @{history@} は以下のうちどれか 1 つから選択:
@anchor{hist-names}
@cindex hist-names
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			"cmd"	 or ":"	  command line history
			"search" or "/"   search pattern history
			"expr"	 or "="   typed expression history
			"input"  or "@"	  input line history
			"debug"  or ">"   debug command history
			empty		  the current or last used history
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item "cmd" or ":" @tab コマンドライン履歴
@item "search" or "/" @tab 検索パターン履歴
@item "expr" or "=" @tab タイプされた式の履歴
@item "input" or "@@" @tab input() の履歴
@item "debug" or ">" @tab デバッグコマンドの履歴
@item empty @tab 最新もしくは最後に使われた履歴
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The {history} string does not need to be the whole name, one
		character is sufficient.
		If {item} does already exist in the history, it will be
		shifted to become the newest entry.
		The result is a Number: 1 if the operation was successful,
		otherwise 0 is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{history@} 文字列はフルネームで指定する必要はありません。頭文字だけでも構いません。

@{item@} が履歴内に既に存在する場合、それが最新の項目の位置へシフトされる。

結果は数値: 操作が成功した場合 1、そうでなければ 0
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example: >
			:call histadd("input", strftime("%Y %b %d"))
			:let date=input("Enter date: ")
<		This function is not available in the |sandbox|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:call histadd("input", strftime("%Y %b %d"))
:let date=input("Enter date: ")
@end example
サンドボックス |@ref{sandbox}| の中では利用できない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
histdel({history} [, {item}])				*histdel()*
		Clear {history}, i.e. delete all its entries.  See |hist-names|
		for the possible values of {history}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{histdel()}
@findex histdel()
@item histdel(@{history@} [, @{item@}])
@{history@} の内容を削除する。例えば全てのエントリを消すこともできる。@{history@} の部分に可能な値は |@ref{hist-names}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If the parameter {item} evaluates to a String, it is used as a
		regular expression.  All entries matching that expression will
		be removed from the history (if there are any).
		Upper/lowercase must match, unless "\c" is used |/\c|.
		If {item} evaluates to a Number, it will be interpreted as
		an index, see |:history-indexing|.  The respective entry will
		be removed if it exists.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
パラメーター @{item@} が文字列に評価される場合、これは正規表現として扱われる。その表現にマッチする全てのエントリが history から削除される (複数あっても)。

"\c" をつけない場合、大文字・小文字が一致しなければならない。|@ref{/\c}|。

@{item@} が数値に評価される場合、インデックスとして解釈される。インデックスについては |@ref{:history-indexing}| を参照。

関連するエントリ @{訳注: The respective entry@} も 、存在すれば削除される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The result is a Number: 1 for a successful operation,
		otherwise 0 is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
結果は数値: 削除に成功すれば 1 を、そうでなければ 0 が返る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Examples:
		Clear expression register history: >
			:call histdel("expr")
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:

式レジスタの履歴を削除する:
@example
:call histdel("expr")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Remove all entries starting with "*" from the search history: >
			:call histdel("/", '^\*')
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
検索履歴から、"*" で始まるエントリを全て削除する:
@example
:call histdel("/", '^\*')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The following three are equivalent: >
			:call histdel("search", histnr("search"))
			:call histdel("search", -1)
			:call histdel("search", '^'.histget("search", -1).'$')
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次の 3 つは等価である:
@example
:call histdel("search", histnr("search"))
:call histdel("search", -1)
:call histdel("search", '^'.histget("search", -1).'$')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		To delete the last search pattern and use the last-but-one for
		the "n" command and 'hlsearch': >
			:call histdel("search", -1)
			:let @/ = histget("search", -1)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最後の検索パターンを削除し、1 つ前のパターンを "n" コマンド (次のマッチへ移動) と '@option{hlsearch}' の為に設定する:
@example
:call histdel("search", -1)
:let @@/ = histget("search", -1) 
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
histget({history} [, {index}])				*histget()*
		The result is a String, the entry with Number {index} from
		{history}.  See |hist-names| for the possible values of
		{history}, and |:history-indexing| for {index}.  If there is
		no such entry, an empty String is returned.  When {index} is
		omitted, the most recent item from the history is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{histget()}
@findex histget()
@item histget(@{history@} [, @{index@}])
結果は @{history@} の第 @{index@} エントリを表わす文字列。@{history@} の部分に可能な値は |@ref{hist-names}| を、@{index@} については |@ref{:history-indexing}| を参照。指定されたエントリが存在しない場合は空文字列が返される。@{index@} が省略された場合には、履歴中の最新のエントリが戻り値として使用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Examples:
		Redo the second last search from history. >
			:execute '/' . histget("search", -2)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:

2 つ前に行われた検索をやり直す:
@example
:execute '/' . histget("search", -2)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		Define an Ex command ":H {num}" that supports re-execution of
		the {num}th entry from the output of |:history|. >
			:command -nargs=1 H execute histget("cmd", 0+<args>)
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:history}| によって出力される @{num@} 番目のエントリを、再度実行するための ":H @{num@}" というコマンドを定義する。
@example
:command -nargs=1 H execute histget("cmd",0+<args>)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
histnr({history})					*histnr()*
		The result is the Number of the current entry in {history}.
		See |hist-names| for the possible values of {history}.
		If an error occurred, -1 is returned.

		Example: >
			:let inp_index = histnr("expr")
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{histnr()}
@findex histnr()
@item histnr(@{history@})
結果は数値で @{history@} の現在のエントリ数。@{history@} の部分に可能な値は |@ref{hist-names}| を参照。エラーが起こった場合、-1 が返される。

例:
@example
:let inp_index = histnr("expr")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
hlexists({name})					*hlexists()*
		The result is a Number, which is non-zero if a highlight group
		called {name} exists.  This is when the group has been
		defined in some way.  Not necessarily when highlighting has
		been defined for it, it may also have been used for a syntax
		item.
							*highlight_exists()*
		Obsolete name: highlight_exists().
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hlexists()}
@findex hlexists()
@item hlexists(@{name@})
結果は数値で、@{name@} という名のハイライトグループが存在すれば、非ゼロの値が返される。これはなんらかの方法でそのグループが既に定義されている時にのみ起こる。これの為に実際に何らかのハイライティングアイテムが設定されている必要はなく、単に構文アイテムとしても使われるだろう。
@anchor{highlight_exists()}
@findex highlight_exists()
以前の名前: highlight_exists().
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*hlID()*
hlID({name})	The result is a Number, which is the ID of the highlight group
		with name {name}.  When the highlight group doesn't exist,
		zero is returned.
		This can be used to retrieve information about the highlight
		group.  For example, to get the background color of the
		"Comment" group: >
	:echo synIDattr(synIDtrans(hlID("Comment")), "bg")
<							*highlightID()*
		Obsolete name: highlightID().
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hlID()}
@findex hlID()
@item hlID(@{name@})
結果は数値で、@{name@} という名前のハイライトグループの ID 番号。そのハイライトグループが存在しない場合は 0 が返される。これはハイライトグループについての情報を獲得するために使用される。例えば "Comment" グループの背景色を取得するにはこのようにする:
@example
:echo synIDattr(synIDtrans(hlID("Comment")), "bg")
@end example
@anchor{highlightID()}
@findex highlightID()
以前の名前: highlightID()
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
hostname()						*hostname()*
		The result is a String, which is the name of the machine on
		which Vim is currently running.  Machine names greater than
		256 characters long are truncated.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hostname()}
@findex hostname()
@item hostname()
結果は文字列で、現在 Vim が実行されているマシンの名前。名前が 256 文字を超える場合、超えた部分は切り捨てられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
iconv({expr}, {from}, {to})				*iconv()*
		The result is a String, which is the text {expr} converted
		from encoding {from} to encoding {to}.
		When the conversion completely fails an empty string is
		returned.  When some characters could not be converted they
		are replaced with "?".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{iconv()}
@findex iconv()
@item iconv(@{expr@}, @{from@}, @{to@})
文字列 @{expr@} をエンコーディング @{from@} からエンコーディング @{to@} に変換した文字列を返す。

変換が完全に失敗したときは空文字列を返す。一部の文字が変換できなかった場合、その文字は "?" に置き換わる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The encoding names are whatever the iconv() library function
		can accept, see ":!man 3 iconv".
		Most conversions require Vim to be compiled with the |+iconv|
		feature.  Otherwise only UTF-8 to latin1 conversion and back
		can be done.
		This can be used to display messages with special characters,
		no matter what 'encoding' is set to.  Write the message in
		UTF-8 and use: >
			echo iconv(utf8_str, "utf-8", &enc)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

エンコーディング名はライブラリ関数 iconv() が受け付けるものならなんでもよい。":!man 3 iconv" を参照。

ほとんどの変換は、Vim が |@ref{+iconv}| 機能つきでコンパイルされているときのみ利用可能。|@ref{+iconv}| つきでないときも UTF-8 から latin1 への変換とその逆は行える。

オプション '@option{encoding}' の値に関係なく、特殊な文字を含むメッセージを表示するために使える。UTF-8 でエンコードされたメッセージを表示するには次のようにする:
@example
echo iconv(utf8_str, "utf-8", &enc)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		Note that Vim uses UTF-8 for all Unicode encodings, conversion
		from/to UCS-2 is automatically changed to use UTF-8.  You
		cannot use UCS-2 in a string anyway, because of the NUL bytes.
		{only available when compiled with the |+multi_byte| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
Vim は全ての Unicode エンコーディングに対して UTF-8 を使う。UCS-2 との変換を行おうとしても、自動的に UTF-8 との変換に変更される。いずれにせよ、UCS-2 は NUL バイトを含むため、文字列に UCS-2 を使うことはできない。
@end quotation
@{|@ref{+multi_byte}| 機能付きでコンパイルされたときのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*indent()*
indent({lnum})	The result is a Number, which is indent of line {lnum} in the
		current buffer.  The indent is counted in spaces, the value
		of 'tabstop' is relevant.  {lnum} is used just like in
		|getline()|.
		When {lnum} is invalid -1 is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{indent()}
@findex indent()
@item indent(@{lnum@})
カレントバッファの @{lnum@} 行目のインデント量を数値で返す。このインデント量はスペース単位で数えられ、'@option{tabstop}' の値が関係する。@{lnum@} は |@ref{getline()}| の場合と同様に扱われる。

@{lnum@} が無効なときは -1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
index({list}, {expr} [, {start} [, {ic}]])			*index()*
		Return the lowest index in |List| {list} where the item has a
		value equal to {expr}.  There is no automatic conversion, so
		the String "4" is different from the Number 4.  And the number
		4 is different from the Float 4.0.  The value of 'ignorecase'
		is not used here, case always matters.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{index()}
@findex index()
@item index(@{list@}, @{expr@} [, @{start@} [, @{ic@}]])
リスト |@ref{List}| @{list@} の中で、@{expr@} に等しい要素の最小のインデックスを返す。自動的な変換は行われないので、文字列の "4" は数値の 4 とは異なると判定される。そして数値の 4 は浮動小数点数の 4.0 とも異なる。'@option{ignorecase}' はここでは適用されず、常に大文字・小文字は区別される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If {start} is given then start looking at the item with index
		{start} (may be negative for an item relative to the end).
		When {ic} is given and it is |TRUE|, ignore case.  Otherwise
		case must match.
		-1 is returned when {expr} is not found in {list}.
		Example: >
			:let idx = index(words, "the")
			:if index(numbers, 123) >= 0
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{start@} が指定された場合はインデックス @{start@} から要素の検索を始める (負数を指定すると末尾からの相対位置となる)。@{ic@} に |@ref{TRUE}| が指定された場合、大文字・小文字は区別されない。そうでない場合は区別される。

@{list@} の中に @{expr@} が見つからない場合は -1 を返す。

例:
@example
:let idx = index(words, "the")
:if index(numbers, 123) >= 0
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
input({prompt} [, {text} [, {completion}]])		*input()*
		The result is a String, which is whatever the user typed on
		the command-line.  The {prompt} argument is either a prompt
		string, or a blank string (for no prompt).  A '\n' can be used
		in the prompt to start a new line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item input(@{prompt@} [, @{text@} [, @{completion@}]])
@anchor{input()}
@findex input()
結果は文字列で、ユーザーがコマンドラインに入力したものが返される。引数 @{prompt@} にはプロンプト文字列か空文字列を指定する。空文字列の場合はプロンプトなしになる。'\n' を使ってプロンプトに改行を含めることができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The highlighting set with |:echohl| is used for the prompt.
		The input is entered just like a command-line, with the same
		editing commands and mappings.  There is a separate history
		for lines typed for input().
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:echohl}| によるハイライトの設定がプロンプトに適用される。入力はコマンドラインと同様に行え、同じ編集コマンドやキーマップが使用できる。input() に入力された文字列には、他の履歴とは独立した履歴が与えられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example: >
			:if input("Coffee or beer? ") == "beer"
			:  echo "Cheers!"
			:endif
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:if input("Coffee or beer? ") == "beer"
:  echo "Cheers!"
:endif
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If the optional {text} argument is present and not empty, this
		is used for the default reply, as if the user typed this.
		Example: >
			:let color = input("Color? ", "white")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
省略可能な引数 @{text@} が与えられ、空でないならば、それが入力の初期値として、ユーザーが入力したのと同じ様に表示される。例:
@example
:let color = input("Color? ", "white")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		The optional {completion} argument specifies the type of
		completion supported for the input.  Without it completion is
		not performed.  The supported completion types are the same as
		that can be supplied to a user-defined command using the
		"-complete=" argument.  Refer to |:command-completion| for
		more information.  Example: >
			let fname = input("File: ", "", "file")
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
省略可能な引数 @{completion@} はこの入力において利用できる補完の種類を指定する。この引数がないときは補完は行われない。対応している補完の種類は、ユーザー定義コマンドにおいて引数 "-complete=" で指定するものと同じである。詳しくは |@ref{:command-completion}| を参照。

例:
@example
let fname = input("File: ", "", "file")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		NOTE: This function must not be used in a startup file, for
		the versions that only run in GUI mode (e.g., the Win32 GUI).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
この関数は GUI モードしか持たないバージョン (例、Win32 GUI) の Vim では、スタートアップファイルの中で使用することはできない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note: When input() is called from within a mapping it will
		consume remaining characters from that mapping, because a
		mapping is handled like the characters were typed.
		Use |inputsave()| before input() and |inputrestore()|
		after input() to avoid that.  Another solution is to avoid
		that further characters follow in the mapping, e.g., by using
		|:execute| or |:normal|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
マッピングの中から input() を呼ぶと、そのマッピングの残りの文字が消費される。マッピングは、その文字が入力されたときと同じように処理されるためである。

これを避けるには、input() の前に |@ref{inputsave()}| を呼び、input() の後に |@ref{inputrestore()}| を呼ぶ。もう 1 つの対策は、|@ref{:execute}| や |@ref{:normal}| を使うなどして、そのマッピングでそれ以上文字を続けないようにすることである。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example with a mapping: >
			:nmap \x :call GetFoo()<CR>:exe "/" . Foo<CR>
			:function GetFoo()
			:  call inputsave()
			:  let g:Foo = input("enter search pattern: ")
			:  call inputrestore()
			:endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マッピングと同時に使う例:
@verbatim
:nmap \x :call GetFoo()<CR>:exe "/" . Foo<CR>
:function GetFoo()
:  call inputsave()
:  let g:Foo = input("enter search pattern: ")
:  call inputrestore()
:endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
inputdialog({prompt} [, {text} [, {cancelreturn}]])		*inputdialog()*
		Like |input()|, but when the GUI is running and text dialogs
		are supported, a dialog window pops up to input the text.
		Example: >
		   :let n = inputdialog("value for shiftwidth", shiftwidth())
		   :if n != ""
		   :  let &sw = n
		   :endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item inputdialog(@{prompt@} [, @{text@} [, @{cancelreturn@}]])
@anchor{inputdialog()}
@findex inputdialog()
|@ref{input()}| と同様。GUI で動作していて、テキストダイアログがサポートされている場合はダイアログを表示してテキストを入力させる。

例:
@example
:let n = inputdialog("value for shiftwidth", shiftwidth())
:if n != ""
:  let &sw = n
:endif
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		When the dialog is cancelled {cancelreturn} is returned.  When
		omitted an empty string is returned.
		Hitting <Enter> works like pressing the OK button.  Hitting
		<Esc> works like pressing the Cancel button.
		NOTE: Command-line completion is not supported.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ダイアログがキャンセルされたときは @{cancelreturn@} を返す。@{cancelreturn@} が省略されているときは空文字列を返す。@key{<Enter>} を押すと OK ボタンを押すのと同じ動作になる。@key{<Esc>} を押すとキャンセルボタンを押すのと同じ動作になる。
@quotation
@strong{Note:} @*
コマンドライン補完は対応していない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
inputlist({textlist})					*inputlist()*
		{textlist} must be a |List| of strings.  This |List| is
		displayed, one string per line.  The user will be prompted to
		enter a number, which is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{inputlist()}
@findex inputlist()
@item inputlist(@{textlist@})
@{textlist@} は文字列のリスト |@ref{List}| でなければならない。1 行につきリストの要素を 1 個表示し、ユーザーに数字を入力するよう促す。入力された数字を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The user can also select an item by clicking on it with the
		mouse.  For the first string 0 is returned.  When clicking
		above the first item a negative number is returned.  When
		clicking on the prompt one more than the length of {textlist}
		is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

ユーザーはマウスで文字列をクリックすることでも選択できる。最初の文字列を選択すると 0 が返る。最初の文字列より上をクリックすると負数が返る。プロンプト自身をクリックすると @{textlist@} の長さ +1 が返る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Make sure {textlist} has less than 'lines' entries, otherwise
		it won't work.  It's a good idea to put the entry number at
		the start of the string.  And put a prompt in the first item.
		Example: >
			let color = inputlist(['Select color:', '1. red',
				\ '2. green', '3. blue'])
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@{textlist@} の要素数はオプション '@option{lines}' の値より少なくなければならない。そうでないと動作しない。最初の要素にメッセージを書き、各文字列の先頭に番号をつけておくとよい。

例:
@example
let color = inputlist(['Select color:', '1. red',
        \ '2. green', '3. blue'])
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
inputrestore()						*inputrestore()*
		Restore typeahead that was saved with a previous |inputsave()|.
		Should be called the same number of times inputsave() is
		called.  Calling it more often is harmless though.
		Returns 1 when there is nothing to restore, 0 otherwise.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{inputrestore()}
@findex inputrestore()
@item inputrestore()
前回の |@ref{inputsave()}| で保存しておいた先行入力を復元する。inputsave() と同じ回数だけ呼ぶようにしなければならない。しかし多く呼びすぎても害はない。復元するものがなければ 1 を、そうでなければ 0 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
inputsave()						*inputsave()*
		Preserve typeahead (also from mappings) and clear it, so that
		a following prompt gets input from the user.  Should be
		followed by a matching inputrestore() after the prompt.  Can
		be used several times, in which case there must be just as
		many inputrestore() calls.
		Returns 1 when out of memory, 0 otherwise.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{inputsave()}
@findex inputsave()
@item inputsave()
先行入力 (マッピングにより入力された文字も含む) を保存し、クリアすることにより、これ以降のプロンプトがユーザーからの入力を得るようにする。プロンプトの後で、対応する inputrestore() を呼び出さねばならない。複数回呼ぶこともできる。ただしその場合は同じ回数だけ inputrestore() を呼ばなくてはならない。メモリ不足のときは 1 を、そうでなければ 0 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
inputsecret({prompt} [, {text}])			*inputsecret()*
		This function acts much like the |input()| function with but
		two exceptions:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{inputsecret()}
@findex inputsecret()
@item inputsecret(@{prompt@} [, @{text@}])
|@ref{input()}| とほぼ同じだが、以下の 2 点が異なる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		a) the user's response will be displayed as a sequence of
		asterisks ("*") thereby keeping the entry secret, and
		b) the user's response will not be recorded on the input
		|history| stack.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .05 .95
@item a) @tab ユーザーの入力をアスタリスク ("*") の列として表示し、入力内容を読めないようにする。
@item b) @tab ユーザーの入力が入力履歴 |@ref{history}| に残らない。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The result is a String, which is whatever the user actually
		typed on the command-line in response to the issued prompt.
		NOTE: Command-line completion is not supported.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザーの入力内容を文字列として返す。
@quotation
@strong{Note:} @*
コマンドライン補完には対応していない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
insert({list}, {item} [, {idx}])			*insert()*
		Insert {item} at the start of |List| {list}.
		If {idx} is specified insert {item} before the item with index
		{idx}.  If {idx} is zero it goes before the first item, just
		like omitting {idx}.  A negative {idx} is also possible, see
		|list-index|.  -1 inserts just before the last item.
		Returns the resulting |List|.  Examples: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item insert(@{list@}, @{item@} [, @{idx@}])
@anchor{insert()}
@findex insert()
リスト |@ref{List}| @{list@} の初めに @{item@} を挿入する。

@{idx@} が指定されたときはインデックス @{idx@} の要素の前に @{item@} を挿入する。@{idx@} が 0 のときは @{idx@} を省略した場合と同じ様に最初の要素の前に挿入する。@{idx@} は負数でもよい (|@ref{list-index}| 参照)。-1 を指定すると最後の要素の前に挿入する。

挿入した結果のリストを返す。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			:let mylist = insert([2, 3, 5], 1)
			:call insert(mylist, 4, -1)
			:call insert(mylist, 6, len(mylist))
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:let mylist = insert([2, 3, 5], 1)
:call insert(mylist, 4, -1)
:call insert(mylist, 6, len(mylist))
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		The last example can be done simpler with |add()|.
		Note that when {item} is a |List| it is inserted as a single
		item.  Use |extend()| to concatenate |Lists|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最後の例は |@ref{add()}| を使うともっと簡単に書ける。
@quotation
@strong{Note:} @*
@{item@} がリスト |@ref{List}| の場合は、1個の要素として追加される。リスト |@ref{Lists}| を連結するには |@ref{extend()}| を使うこと。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
invert({expr})						*invert()*
		Bitwise invert.  The argument is converted to a number.  A
		List, Dict or Float argument causes an error.  Example: >
			:let bits = invert(bits)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item invert(@{expr@})
@anchor{invert()}
@findex invert()
ビット反転。引数は数値に変換される。リスト、辞書、浮動小数点数を指定するとエラーになる。例:
@example
:let bits = invert(bits)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
isdirectory({directory})				*isdirectory()*
		The result is a Number, which is |TRUE| when a directory
		with the name {directory} exists.  If {directory} doesn't
		exist, or isn't a directory, the result is |FALSE|.  {directory}
		is any expression, which is used as a String.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item isdirectory(@{directory@})
@anchor{isdirectory()}
@findex isdirectory()
結果は数値で、@{directory@} という名前のディレクトリが存在すれば |@ref{TRUE}| となる。@{directory@} が存在しないか、存在したとしてもディレクトリではなかった場合には、|@ref{FALSE}| が返される。文字列として解釈できるのならば @{directory@} の表現はどのようなものであってもかまわない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
islocked({expr})					*islocked()* *E786*
		The result is a Number, which is |TRUE| when {expr} is the
		name of a locked variable.
		{expr} must be the name of a variable, |List| item or
		|Dictionary| entry, not the variable itself!  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{islocked()}
@anchor{E786}
@findex islocked()
@erindex E786
@item islocked(@{expr@})
結果は数値で、@{expr@} がロックされている変数の名前ならば |@ref{TRUE}| を返す。

@{expr@} は変数の名前、リスト |@ref{List}| の要素、辞書 |@ref{Dictionary}| の要素のいずれかでなければならない。変数そのものを指定しないように注意。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			:let alist = [0, ['a', 'b'], 2, 3]
			:lockvar 1 alist
			:echo islocked('alist')		" 1
			:echo islocked('alist[1]')	" 0
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:let alist = [0, ['a', 'b'], 2, 3]
:lockvar 1 alist
:echo islocked('alist')		" 1
:echo islocked('alist[1]')	" 0
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		When {expr} is a variable that does not exist you get an error
		message.  Use |exists()| to check for existence.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr@} が存在しない変数のときはエラーメッセージが表示される。変数の存在を確認するには |@ref{exists()}| を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
isnan({expr})						*isnan()*
		Return |TRUE| if {expr} is a float with value NaN. >
			echo isnan(0.0 / 0.0)
<			1 ~

		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item isnan(@{expr@})
@anchor{isnan()}
@findex isnan()
@{expr@} が NaN の値を持つ浮動小数点数ならば |@ref{TRUE}| を返す。
@example
echo isnan(0.0 / 0.0)
1
@end example

@{|@ref{+float}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
items({dict})						*items()*
		Return a |List| with all the key-value pairs of {dict}.  Each
		|List| item is a list with two items: the key of a {dict}
		entry and the value of this entry.  The |List| is in arbitrary
		order.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{items()}
@findex items()
@item items(@{dict@})
@{dict@} の全要素のキー・値のペアからなるリスト |@ref{List}| を返す。戻り値の各要素はリスト |@ref{List}| であり、キーと値の 2 個の要素を持つ。戻り値のリスト |@ref{List}| の要素の順序は不定である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
job_getchannel({job})					 *job_getchannel()*
		Get the channel handle that {job} is using.
		To check if the job has no channel: >
			if string(job_getchannel()) == 'channel fail'
<
		{only available when compiled with the |+job| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job_getchannel()}
@findex job_getchannel()
@item job_getchannel(@{job@})
@{job@} が使用しているチャネルハンドルを取得する。ジョブにチャネルがないかどうかを確認するには:
@example
if string(job_getchannel()) == 'channel fail'
@end example

@{Vim が |@ref{+job}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
job_info([{job}])					*job_info()*
		Returns a Dictionary with information about {job}:
		   "status"	what |job_status()| returns
		   "channel"	what |job_getchannel()| returns
		   "cmd"	List of command arguments used to start the job
		   "process"	process ID
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job_info()}
@findex job_info()
@item job_info([@{job@}])
@{job@} に関する情報を持つ辞書を返す:
@multitable @columnfractions .3 .7
@item "status" @tab |@ref{job_status()}| が返すもの
@item "channel" @tab |@ref{job_getchannel()}| が返すもの
@item "cmd" @tab ジョブをスタートするために使われたコマンド引数のリスト
@item "process" @tab プロセス ID
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "tty_in"	terminal input name, empty when none
		   "tty_out"	terminal output name, empty when none
		   "exitval"	only valid when "status" is "dead"
		   "exit_cb"	function to be called on exit
		   "stoponexit"	|job-stoponexit|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "tty_in" @tab ターミナルの入力名。なければ空
@item "tty_out" @tab ターミナルの出力名。なければ空
@item "exitval" @tab "status" が "dead" のときのみ有効
@item "exit_cb" @tab 終了時に呼び出される関数
@item "stoponexit" @tab |@ref{job-stoponexit}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Without any arguments, returns a List with all Job objects.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数なしでは、すべてのジョブオブジェクトのリストを返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
job_setoptions({job}, {options})			*job_setoptions()*
		Change options for {job}.  Supported are:
		   "stoponexit"	|job-stoponexit|
		   "exit_cb"	|job-exit_cb|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item job_setoptions(@{job@}, @{options@})
@anchor{job_setoptions()}
@findex job_setoptions()
@{job@} のオプションを変更する。サポートされているものは:
@multitable @columnfractions .2 .8
@item "stoponexit" @tab |@ref{job-stoponexit}|
@item "exit_cb" @tab |@ref{job-exit_cb}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
job_start({command} [, {options}])			*job_start()*
		Start a job and return a Job object.  Unlike |system()| and
		|:!cmd| this does not wait for the job to finish.
		To start a job in a terminal window see |term_start()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job_start()}
@findex job_start()
@item job_start(@{command@} [, @{options@}])
ジョブを開始し、ジョブオブジェクトを返す。|@ref{system()}| と |@ref{:!cmd}| とは異なり、これはジョブが終了するのを待つことはない。

ターミナルウィンドウでジョブを開始するには |@ref{term_start()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{command} can be a String.  This works best on MS-Windows.  On
		Unix it is split up in white-separated parts to be passed to
		execvp().  Arguments in double quotes can contain white space.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{command@} は文字列にできる。これは MS-Windows で最も効果的である。Unix では、それは execvp() に渡すために空白で区切られたパーツに分割される。二重引用符で囲まれた引数には空白を含められる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{command} can be a List, where the first item is the executable
		and further items are the arguments.  All items are converted
		to String.  This works best on Unix.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{command@} はリストにでき、最初の項目は実行可能ファイルであり、残りの項目は引数である。すべての項目は文字列に変換される。これは Unix で最も効果的である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		On MS-Windows, job_start() makes a GUI application hidden. If
		want to show it, Use |:!start| instead.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
MS-Windows では、|@ref{job_start()}| は GUI アプリケーションを隠す。それを表示したい場合は、|@ref{:!start}| を代わりに使用すること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The command is executed directly, not through a shell, the
		'shell' option is not used.  To use the shell: >
	let job = job_start(["/bin/sh", "-c", "echo hello"])
<		Or: >
	let job = job_start('/bin/sh -c "echo hello"')
<		Note that this will start two processes, the shell and the
		command it executes.  If you don't want this use the "exec"
		shell command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドはシェルではなく直接実行され、'@option{shell}' オプションは使用されない。シェルを使用するには:
@example
let job = job_start(["/bin/sh", "-c", "echo hello"])
@end example
または:
@example
let job = job_start('/bin/sh -c "echo hello"')
@end example
@quotation
@strong{Note:} @*
これは 2 つのプロセス、シェルとそれが実行するコマンドを開始することに注意すること。これを望まない場合は、"exec" シェルコマンドを使用する。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		On Unix $PATH is used to search for the executable only when
		the command does not contain a slash.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Unix では $PATH は、コマンドにスラッシュが含まれていない場合にのみ実行可能ファイルを検索するために使用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The job will use the same terminal as Vim.  If it reads from
		stdin the job and Vim will be fighting over input, that
		doesn't work.  Redirect stdin and stdout to avoid problems: >
	let job = job_start(['sh', '-c', "myserver </dev/null >/dev/null"])
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブは Vim と同じ端末を使用する。ジョブが stdin を読む場合、ジョブと Vim が入力を奪い合うことになるのでうまく動作しない。問題を避けるために stdin と stdout をリダイレクトする:
@example
let job = job_start(['sh', '-c', "myserver </dev/null >/dev/null"])
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The returned Job object can be used to get the status with
		|job_status()| and stop the job with |job_stop()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
返されたジョブオブジェクトを使用して、|@ref{job_status()}| でステータスを取得し、|@ref{job_stop()}| でジョブを停止することができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Note that the job object will be deleted if there are no
		references to it.  This closes the stdin and stderr, which may
		cause the job to fail with an error.  To avoid this keep a
		reference to the job.  Thus instead of: >
	call job_start('my-command')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ジョブオブジェクトはそれに対する参照がなくなると、削除されるだろうことに注意。これはジョブがエラーを引き起す失敗を生ずる、標準入力と標準エラーを閉じる。これを回避するためにはジョブを参照し続ける。それゆえ、次の代わりに：
@example
call job_start('my-command')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		use: >
	let myjob = job_start('my-command')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
こちらを使う:
@example
let myjob = job_start('my-command')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		and unlet "myjob" once the job is not needed or is past the
		point where it would fail (e.g. when it prints a message on
		startup).  Keep in mind that variables local to a function
		will cease to exist if the function returns.  Use a
		script-local variable if needed: >
	let s:myjob = job_start('my-command')
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ひとたびジョブが不要になったり、失敗するような過去のもの (例えばスタートアップ時にメッセージを指す時) になったら "myjob" を削除する。もしも関数が返るなら、関数へのローカル変数は存在しなくなるだろうことに留意すること。もしも必要であればスクリプトローカル変数を使う:
@example
let s:myjob = job_start('my-command')
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{options} must be a Dictionary.  It can contain many optional
		items, see |job-options|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{options@} は辞書でなければならない。多くのオプション項目を含めることができる。|@ref{job-options}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{only available when compiled with the |+job| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{Vim が |@ref{+job}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
job_status({job})					*job_status()* *E916*
		Returns a String with the status of {job}:
			"run"	job is running
			"fail"	job failed to start
			"dead"	job died or was stopped after running
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job_status()}
@anchor{E916}
@findex job_status()
@erindex E916
@item job_status(@{job@})
@{job@} のステータスを String で返す:
@multitable @columnfractions .1 .9
@item "run" @tab ジョブが実行中
@item "fail" @tab ジョブを開始できなかった
@item "dead" @tab ジョブが死んだか実行後にジョブが停止した
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		On Unix a non-existing command results in "dead" instead of
		"fail", because a fork happens before the failure can be
		detected.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Unix では存在しないコマンドは、失敗が検出される前にフォークが発生するため、"fail" ではなく "dead" になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If an exit callback was set with the "exit_cb" option and the
		job is now detected to be "dead" the callback will be invoked.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
exit コールバックが "exit_cb" オプションで設定され、ジョブが "dead" と検出された場合、コールバックが呼び出される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For more information see |job_info()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
詳細は |@ref{job_info()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{only available when compiled with the |+job| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{Vim が |@ref{+job}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
job_stop({job} [, {how}])					*job_stop()*
		Stop the {job}.  This can also be used to signal the job.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job_stop()}
@findex job_stop()
@item job_stop(@{job@} [, @{how@}])
@{job@} を停止する。これはジョブを通知するためにも使用できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {how} is omitted or is "term" the job will be terminated.
		For Unix SIGTERM is sent.  On MS-Windows the job will be
		terminated forcedly (there is no "gentle" way).
		This goes to the process group, thus children may also be
		affected.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{how@} が省略されたり、"term" の場合、ジョブは終了する。Unix では SIGTERM が送信される。MS-Windows では、ジョブは強制的に終了する ("優しい"方法は存在しない)。これはプロセスグループに行くので、子供たちも影響を受けるかもしれない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Effect for Unix:
			"term"	 SIGTERM (default)
			"hup"	 SIGHUP
			"quit"	 SIGQUIT
			"int"	 SIGINT
			"kill"	 SIGKILL (strongest way to stop)
			number	 signal with that number
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
UNIX への影響:
@multitable @columnfractions .1 .9
@item "term" @tab SIGTERM (既定)
@item "hup" @tab SIGHUP
@item "quit" @tab SIGQUIT
@item "int" @tab SIGINT
@item "kill" @tab SIGKILL (停止するための最も強い方法)
@item number @tab その番号の信号
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Effect for MS-Windows:
			"term"	 terminate process forcedly (default)
			"hup"	 CTRL_BREAK
			"quit"	 CTRL_BREAK
			"int"	 CTRL_C
			"kill"	 terminate process forcedly
			Others	 CTRL_BREAK
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
MS-Windows への影響:
@multitable @columnfractions .1 .9
@item "term" @tab プロセスを強制終了 (既定)
@item "hup" @tab CTRL_BREAK
@item "quit" @tab CTRL_BREAK
@item "int" @tab CTRL_C
@item "kill" @tab プロセスを強制終了
@item Others @tab CTRL_BREAK
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		On Unix the signal is sent to the process group.  This means
		that when the job is "sh -c command" it affects both the shell
		and the command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Unix では、シグナルはプロセスグループに送られる。これは、ジョブが "sh -c command" であるときにシェルとコマンドの両方に影響を与えることを意味する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The result is a Number: 1 if the operation could be executed,
		0 if "how" is not supported on the system.
		Note that even when the operation was executed, whether the
		job was actually stopped needs to be checked with
		|job_status()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
結果は数値で、操作が実行できる場合は1、システムでは "how" がサポートされていない場合は 0。
@quotation
@strong{Note:} @*
ジョブが実際に停止したかどうかは、操作が実行された場合でも、|@ref{job_status()}| でチェックする必要があることに注意すること。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If the status of the job is "dead", the signal will not be
		sent.  This is to avoid to stop the wrong job (esp. on Unix,
		where process numbers are recycled).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もしもジョブのステータスが "dead" ならシグナルは送信されない。これは (プロセス番号が再利用されるような Unix では特に) 誤ったジョブを停止するのを防ぐため。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When using "kill" Vim will assume the job will die and close
		the channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
When using "kill" Vim will assume the job will die and close the channel.
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{only available when compiled with the |+job| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{Vim が |@ref{+job}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
join({list} [, {sep}])					*join()*
		Join the items in {list} together into one String.
		When {sep} is specified it is put in between the items.  If
		{sep} is omitted a single space is used.
		Note that {sep} is not added at the end.  You might want to
		add it there too: >
			let lines = join(mylist, "\n") . "\n"
<		String items are used as-is.  |Lists| and |Dictionaries| are
		converted into a string like with |string()|.
		The opposite function is |split()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{join()}
@findex join()
@item join(@{list@} [, @{sep@}])
リスト @{list@} の要素を連結し、1個の文字列にして返す。

@{sep@} が指定されたときは、要素の間にそれを挿入する。@{sep@} が指定されなかったときは 1 個のスペースが使われる。
@quotation
@strong{Note:} @*
末尾には @{sep@} がつかない。末尾にもつけたければ以下のようにする:
@example
let lines = join(mylist, "\n") . "\n"
@end example
@end quotation
@{list@} の要素が文字列なら、そのまま使われる。リスト |@ref{Lists}| と辞書 |@ref{Dictionaries}| は |@ref{string()}| を使ったときと同じようにして文字列に変換される。この逆を行う関数は |@ref{split()}| である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
js_decode({string})					*js_decode()*
		This is similar to |json_decode()| with these differences:
		- Object key names do not have to be in quotes.
		- Strings can be in single quotes.
		- Empty items in an array (between two commas) are allowed and
		  result in v:none items.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{js_decode()}
@findex js_decode()
@item js_decode(@{string@})
|@ref{json_decode()}| に似ているが以下が異なる:
@itemize
@item オブジェクトのキー名はクォートされてなくてもよい。
@item 文字列はシングルクォートでくくることができる。
@item 配列内の (2 つのコンマで区切られた) 空アイテムが許可され結果として v:none のアイテムとなる。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
js_encode({expr})					*js_encode()*
		This is similar to |json_encode()| with these differences:
		- Object key names are not in quotes.
		- v:none items in an array result in an empty item between
		  commas.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item js_encode(@{expr@})
@anchor{js_encode()}
@findex js_encode()
|@ref{json_encode()}| に似ているが以下が異なる:
@itemize
@item オブジェクトのキー名がクォートされない
@item 配列の中のアイテム v:none はコンマで区切られた空のアイテムになる。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		For example, the Vim object:
			[1,v:none,{"one":1},v:none] ~
		Will be encoded as:
			[1,,{one:1},,] ~
		While json_encode() would produce:
			[1,null,{"one":1},null] ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば Vim オブジェクト:
@example
[1,v:none,@{"one":1@},v:none]
@end example
は以下にエンコードされ:
@example
[1,,@{one:1@},,]
@end example
json_encode() であれば以下にエンコードされる:
@example
[1,null,@{"one":1@},null]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		This encoding is valid for JavaScript. It is more efficient
		than JSON, especially when using an array with optional items.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このエンコードは JavaScript では妥当である。特に配列内でオプショナルアイテムを扱う場合には JSON より能率的である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
json_decode({string})					*json_decode()*
		This parses a JSON formatted string and returns the equivalent
		in Vim values.  See |json_encode()| for the relation between
		JSON and Vim values.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{json_decode()}
@findex json_decode()
@item json_decode(@{string@})
これは JSON フォーマットの文字列を解析し、それと同等の Vim の値を返す。JSON と Vim の値の関係は |@ref{json_encode()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The decoding is permissive:
		- A trailing comma in an array and object is ignored, e.g.
		  "[1, 2, ]" is the same as "[1, 2]".
		- More floating point numbers are recognized, e.g. "1." for
		  "1.0", or "001.2" for "1.2". Special floating point values
		  "Infinity" and "NaN" (capitalization ignored) are accepted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デコードは寛容である:
@itemize
@item 配列やオブジェクトの末尾コンマは無視される。例えば "[1, 2, ]" は "[1, 2]" と同じ。
@item 多くの浮動小数点数を認識する。例えば "1." は "1.0" として、"001.2" は "1.2" として認識される。特別な浮動小数点の値 "Infinity" と "NaN" (大文字は無視 @{訳注: "nan" や "NAN" も OK@}) を受付ける。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		- Leading zeroes in integer numbers are ignored, e.g. "012"
		  for "12" or "-012" for "-12".
		- Capitalization is ignored in literal names null, true or
		  false, e.g. "NULL" for "null", "True" for "true".
		- Control characters U+0000 through U+001F which are not
		  escaped in strings are accepted, e.g. "	" (tab
		  character in string) for "\t".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 整数の先頭の 0 は無視される。例えば "012" は "12"、"-012" は "-12" となる。
@item リテラルの名前、null, true や false の大文字は無視される。例えば "NULL" は "null"、"True" は "true" となる。
@item 文字列中のエスケープされていない U+0000 から U+001F までのコントロールキャラクターは受け取られる。例えば "	" (文字列中のタブ文字) は "\t" となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		- Backslash in an invalid 2-character sequence escape is
		  ignored, e.g. "\a" is decoded as "a".
		- A correct surrogate pair in JSON strings should normally be
		  a 12 character sequence such as "\uD834\uDD1E", but
		  json_decode() silently accepts truncated surrogate pairs
		  such as "\uD834" or "\uD834\u"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 不正な 2 文字のエスケープ文字中のバックスラッシュは無視される。例えば "\a" は  "a" にデコードされる。
@item JSON 文字列中の正しいサロゲートペアは、通常は "\uD834\uDD1E" のように 12 文字の列であるべきだが、json_decode() は "\uD834" や "\uD834\u" のように分断されたサロゲートペアを黙って受け取る。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
								*E938*
		A duplicate key in an object, valid in rfc7159, is not
		accepted by json_decode() as the result must be a valid Vim
		type, e.g. this fails: {"a":"b", "a":"c"}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E938}
@erindex E938
オブジェクトの重複するキー (rfc7159 では妥当だが) は、正しい Vim タイプの結果でなければならないので、json_decode() によって受け入れられない。例えば、次のものは失敗する: @{"a":"b", "a":"c"@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
json_encode({expr})					*json_encode()*
		Encode {expr} as JSON and return this as a string.
		The encoding is specified in:
		https://tools.ietf.org/html/rfc7159.html
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{json_encode()}
@findex json_encode()
@item json_encode(@{expr@})
@{expr@} を JSON フォーマットの文字列にエンコードし、この文字列を返す。

このエンコード方式の詳細はここに記載されている:

@url{https://tools.ietf.org/html/rfc7159.html}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Vim values are converted as follows:
		   Number		decimal number
		   Float		floating point number
		   Float nan		"NaN"
		   Float inf		"Infinity"
		   String		in double quotes (possibly null)
		   Funcref		not possible, error
		   List			as an array (possibly null); when
					used recursively: []
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

Vim の値は以下の通りに変換される:
@multitable @columnfractions .3 .7
@item 数値 @tab 10 進数
@item 浮動小数点数 @tab 浮動小数点数
@item 浮動小数点数 nan @tab "NaN"
@item 浮動小数点数 inf @tab "Infinity"
@item 文字列 @tab ダブルクォートで括られた文字列 (null 可)
@item Funcref @tab 不可、エラー
@item リスト @tab 配列 (null可) 再帰的に使用された場合: []
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   Dict			as an object (possibly null); when
					used recursively: {}
		   v:false		"false"
		   v:true		"true"
		   v:none		"null"
		   v:null		"null"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 辞書 @tab オブジェクト (null可) 再帰的に使用された場合: @{@}
@item v:false @tab "false"
@item v:true @tab "true"
@item v:none @tab "null"
@item v:null @tab "null"
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that NaN and Infinity are passed on as values.  This is
		missing in the JSON standard, but several implementations do
		allow it.  If not then you will get an error.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
NaN と Infinity は値として渡されることに注意すること。これは JSON 標準には存在しないが、いくつかの実装でそれが可能である。そうでない場合、エラーが発生する。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
keys({dict})						*keys()*
		Return a |List| with all the keys of {dict}.  The |List| is in
		arbitrary order.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{keys()}
@findex keys()
@item keys(@{dict@})
@{dict@} の全キーからなるリスト |@ref{List}| を返す。リスト |@ref{List}| の順序は不定である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*len()* *E701*
len({expr})	The result is a Number, which is the length of the argument.
		When {expr} is a String or a Number the length in bytes is
		used, as with |strlen()|.
		When {expr} is a |List| the number of items in the |List| is
		returned.
		When {expr} is a |Dictionary| the number of entries in the
		|Dictionary| is returned.
		Otherwise an error is given.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{len()}
@anchor{E701}
@findex len()
@erindex E701
@item len(@{expr@})
結果は数値で、引数 @{expr@} の長さ。@{expr@} が文字列または数値のときは |@ref{strlen()}| と同じようにバイト単位での長さを返す。

@{expr@} がリスト |@ref{List}| のときは要素数を返す。

@{expr@} が辞書 |@ref{Dictionary}| のときは要素数を返す。

それ以外のときはエラーとなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*libcall()* *E364* *E368*
libcall({libname}, {funcname}, {argument})
		Call function {funcname} in the run-time library {libname}
		with single argument {argument}.
		This is useful to call functions in a library that you
		especially made to be used with Vim.  Since only one argument
		is possible, calling standard library functions is rather
		limited.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{libcall()}
@anchor{E364}
@anchor{E368}
@findex libcall()
@erindex E364
@erindex E368
@item libcall(@{libname@}, @{funcname@}, @{argument@})
ランタイムライブラリ @{libname@} の関数 @{funcname@} を、単一の引数 @{argument@} で呼び出す。

Vim で使うように特別に作ったライブラリの関数を呼ぶために使われる。引数は 1 個しか指定できないため、普通のライブラリ関数を呼ぶにはかなり制限がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The result is the String returned by the function.  If the
		function returns NULL, this will appear as an empty string ""
		to Vim.
		If the function returns a number, use libcallnr()!
		If {argument} is a number, it is passed to the function as an
		int; if {argument} is a string, it is passed as a
		null-terminated string.
		This function will fail in |restricted-mode|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

結果には、呼び出した関数から返された文字列が返される。呼び出した関数が NULL を返した場合には、Vim には空文字列 "" が戻される。

関数の戻り値が数値である場合には |@ref{libcallnr()}| を使うこと！

もしも引数が数値ならば、関数には int 型の引数が 1 つ渡される。引数が文字列の場合には、関数にはヌル終端記号を持つ文字列が引数として渡される。

|@ref{restricted-mode}| の中で呼ぶと失敗する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		libcall() allows you to write your own 'plug-in' extensions to
		Vim without having to recompile the program.  It is NOT a
		means to call system functions!  If you try to do so Vim will
		very probably crash.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
libcall() によって Vim を再コンパイルすることなく 'plug-in' と呼ばれる独自の拡張を行うことができるようになる。それは (直接) システムの関数を呼ぶ、ということではない。システム関数を呼ぶとおそらく Vim がクラッシュするだろう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For Win32, the functions you write must be placed in a DLL
		and use the normal C calling convention (NOT Pascal which is
		used in Windows System DLLs).  The function must take exactly
		one parameter, either a character pointer or a long integer,
		and must return a character pointer or NULL.  The character
		pointer returned must point to memory that will remain valid
		after the function has returned (e.g. in static data in the
		DLL).  If it points to allocated memory, that memory will
		leak away.  Using a static buffer in the function should work,
		it's then freed when the DLL is unloaded.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Win32 では、あなたが書いた関数を DLL に置かなければならず、また通常の C 呼出し規約を使用しなければならない (Windows のシステム DLL が使う Pascal ではない)。関数は正確に 1 つのパラメーター、char 型ポインタもしくは int 型を取らなければならず、戻り値として char 型ポインタか NULL を返さなければならない。

返される char 型ポインタは、関数終了後も有効なポインタ (例えば DLL 内の静的なデータ) を指さなければならない。(malloc 等で) 割り当てられたメモリを保持していた場合、それはリークしてしまう。DLL 内のスタティックバッファを用いる方法は動くかもしれないが、使用済み DLL がメモリから削除されると同時に解放されてしまう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		WARNING: If the function returns a non-valid pointer, Vim may
		crash!	This also happens if the function returns a number,
		because Vim thinks it's a pointer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{警告:} @*
もしも関数が有効ではないポインタを返すと、Vim はクラッシュしてしまう。関数が数値を返してしまった場合、Vim はそれをポインタとして扱ってしまうので、やはりクラッシュが起こる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		For Win32 systems, {libname} should be the filename of the DLL
		without the ".DLL" suffix.  A full path is only required if
		the DLL is not in the usual places.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Win32 のシステムでは、@{libname@} は DLL のファイル名の拡張子 ".DLL" を付けてはならない。通常の (パスの通った) 場所に DLL がない場合には、フルパスで指定する必要がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		For Unix: When compiling your own plugins, remember that the
		object code must be compiled as position-independent ('PIC').
		{only in Win32 and some Unix versions, when the |+libcall|
		feature is present}
		Examples: >
			:echo libcall("libc.so", "getenv", "HOME")
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

Unix では、独自のプラグインをコンパイルするときはオブジェクトコードを位置独立 ('PIC') としてコンパイルしなければならない。

@{Win32 といくつかの Unix で |@ref{+libcall}| 機能が有効になっているときのみ利用可能@}

例:
@example
:echo libcall("libc.so", "getenv", "HOME")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*libcallnr()*
libcallnr({libname}, {funcname}, {argument})
		Just like |libcall()|, but used for a function that returns an
		int instead of a string.
		{only in Win32 on some Unix versions, when the |+libcall|
		feature is present}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{libcallnr()}
@findex libcallnr()
@item libcallnr(@{libname@}, @{funcname@}, @{argument@})
|@ref{libcall()}| とほぼ同様だが、文字列でなく int を返す関数に使う。@{Win32と |@ref{+libcall}| 機能が有効になっている Unix でのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
			:echo libcallnr("/usr/lib/libc.so", "getpid", "")
			:call libcallnr("libc.so", "printf", "Hello World!\n")
			:call libcallnr("libc.so", "sleep", 10)
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:echo libcallnr("/usr/lib/libc.so", "getpid", "")
:call libcallnr("libc.so", "printf", "Hello World!\n")
:call libcallnr("libc.so", "sleep", 10)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*line()*
line({expr})	The result is a Number, which is the line number of the file
		position given with {expr}.  The accepted positions are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{line()}
@findex line()
@item line(@{expr@})
結果は数値で、@{expr@} で与えられた位置のファイル内での行番号。受け付けられる位置指定は次の通り:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		    .	    the cursor position
		    $	    the last line in the current buffer
		    'x	    position of mark x (if the mark is not set, 0 is
			    returned)
		    w0	    first line visible in current window (one if the
			    display isn't updated, e.g. in silent Ex mode)
		    w$	    last line visible in current window (this is one
			    less than "w0" if no lines are visible)
		    v	    In Visual mode: the start of the Visual area (the
			    cursor is the end).  When not in Visual mode
			    returns the cursor position.  Differs from |'<| in
			    that it's updated right away.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item . @tab カーソルの位置
@item $ @tab 現在のバッファの最後の位置
@item 'x @tab マーク x の位置 (マークが設定されていない場合、0 が返る)
@item w0 @tab カレントウィンドウの最上行 (ディスプレイがアップデートされていない場合は最上行。例えば silent Ex モード中)
@item w$ @tab カレントウィンドウの最下行 (行が見えなければ、これは "w0" 未満の最下行)
@item v @tab ビジュアルモードでは: ビジュアル選択領域の開始行 (カーソルがその端)。ビジュアルモード以外ではカーソル位置を返す。すぐに更新される点が |@ref{'<}| と違う。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that a mark in another file can be used.  The line number
		then applies to another buffer.
		To get the column number use |col()|.  To get both use
		|getpos()|.
		Examples: >
			line(".")		line number of the cursor
			line("'t")		line number of mark t
			line("'" . marker)	line number of mark marker
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
他のファイルのマークも使える。その場合、戻り値はそのファイルの行番号となる。桁番号を取得するには |@ref{col()}| を使う。両方を取得するには |@ref{getpos()}| を使う。

例:
@multitable @columnfractions .4 .6
@item line(".") @tab カーソルの行番号
@item line("'t") @tab マーク t の位置の行番号
@item line("'" . marker) @tab マーク marker の位置の行番号
@end multitable
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<							*last-position-jump*
		This autocommand jumps to the last known position in a file
		just after opening it, if the '" mark is set: >
     :au BufReadPost *
	 \ if line("'\"") > 1 && line("'\"") <= line("$") && &ft !~# 'commit'
	 \ |   exe "normal! g`\""
	 \ | endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{last-position-jump}
@cindex last-position-jump
このオートコマンドはファイルを開いた時に、最後に開かれていた時の行へ自動的にジャンプするものである。これは '" マークがセットされている時にのみ有効である:
@example
:au BufReadPost *
    \ if line("'\"") > 1 && line("'\"") <= line("$") && &ft !~# 'commit'
    \ |   exe "normal! g`\""
    \ | endif
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
line2byte({lnum})					*line2byte()*
		Return the byte count from the start of the buffer for line
		{lnum}.  This includes the end-of-line character, depending on
		the 'fileformat' option for the current buffer.  The first
		line returns 1. 'encoding' matters, 'fileencoding' is ignored.
		This can also be used to get the byte count for the line just
		below the last line: >
			line2byte(line("$") + 1)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{line2byte()}
@findex line2byte()
@item line2byte(@{lnum@})
バッファの先頭から、@{lnum@} 行目までのバイト数を返す。これには現在のバッファのオプション '@option{fileformat}' に従った、end-of-line (行終端) 文字も含まれている。最初の行においては 1 が返る。バイト数は '@option{encoding}' に基づく。'@option{fileencoding}' は無視される。次のようにすることで最終行を含むバイトサイズを獲得することができる:
@example
line2byte(line("$") + 1)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		This is the buffer size plus one.  If 'fileencoding' is empty
		it is the file size plus one.
		When {lnum} is invalid, or the |+byte_offset| feature has been
		disabled at compile time, -1 is returned.
		Also see |byte2line()|, |go| and |:goto|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはバッファの大きさプラス1になる。もし '@option{fileencoding}' が空ならその値はファイルの大きさプラス 1 に等しい。

@{lnum@} が無効であるか、|@ref{+byte_offset}| 機能がコンパイル時に無効にされている場合、-1 が返される。

|@ref{byte2line()}|、|@ref{go}| 及び |@ref{:goto}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
lispindent({lnum})					*lispindent()*
		Get the amount of indent for line {lnum} according the lisp
		indenting rules, as with 'lisp'.
		The indent is counted in spaces, the value of 'tabstop' is
		relevant.  {lnum} is used just like in |getline()|.
		When {lnum} is invalid or Vim was not compiled the
		|+lispindent| feature, -1 is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{lispindent()}
@findex lispindent()
@item lispindent(@{lnum@})
'@option{lisp}' をオンにしたときと同じ lisp 用のインデント規則に従った場合の @{lnum@} 行目のインデント量を返す。

インデント量はスペースで数えられ、'@option{tabstop}' の値は関係ない。@{lnum@} は |@ref{getline()}| の場合と同様に扱われる。@{lnum@} が無効な値のときや |@ref{+lispindent}| 機能なしでコンパイルされているときは -1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
localtime()						*localtime()*
		Return the current time, measured as seconds since 1st Jan
		1970.  See also |strftime()| and |getftime()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{localtime()}
@findex localtime()
@item localtime()
現在の時刻、1970 年 1 月 1 日からの経過秒数を返す。|@ref{strftime()}| と |@ref{getftime()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
log({expr})						*log()*
		Return the natural logarithm (base e) of {expr} as a |Float|.
		{expr} must evaluate to a |Float| or a |Number| in the range
		(0, inf].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{log()}
@findex log()
@item log(@{expr@})
@{expr@} の自然対数 (底 e) を浮動小数点数 (|@ref{Float}|) で返す。@{expr@} は (0, inf] の範囲の浮動小数点数 (|@ref{Float}|) か数値 (|@ref{Number}|) でなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
			:echo log(10)
<			2.302585 >
			:echo log(exp(5))
<			5.0
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:echo log(10)
2.302585
:echo log(exp(5))
5.0
@end example
@{|@ref{+float}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
log10({expr})						*log10()*
		Return the logarithm of Float {expr} to base 10 as a |Float|.
		{expr} must evaluate to a |Float| or a |Number|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{log10()}
@findex log10()
@item log10(@{expr@})
浮動小数点数 @{expr@} の 10 を底とする対数を |@ref{Float}| で返す。@{expr@} は |@ref{Float}| または |@ref{Number}| に評価されなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
			:echo log10(1000)
<			3.0 >
			:echo log10(0.01)
<			-2.0
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:echo log10(1000)
3.0
:echo log10(0.01)
-2.0
@end example
@{|@ref{+float}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
luaeval({expr} [, {expr}])					*luaeval()*
		Evaluate Lua expression {expr} and return its result converted
		to Vim data structures. Second {expr} may hold additional
		argument accessible as _A inside first {expr}.
		Strings are returned as they are.
		Boolean objects are converted to numbers.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{luaeval()}
@findex luaeval()
@item luaeval(@{expr@} [, @{expr@}])
Lua の式 @{expr@} を評価し、その結果を Vim のデータ構造に変換したものを返す。2 番目の @{expr@} は、最初の @{expr@} の中では _A としてアクセスできる追加の引数を保持する。

文字列はそのまま返される。

ブーリアンオブジェクトは数値に変換される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Numbers are converted to |Float| values if vim was compiled
		with |+float| and to numbers otherwise.
		Dictionaries and lists obtained by vim.eval() are returned
		as-is.
		Other objects are returned as zero without any errors.
		See |lua-luaeval| for more details.
		{only available when compiled with the |+lua| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
数値は、vim が |@ref{+float}| つきでコンパイルされたときは |@ref{Float}| 値に変換され、そうでなければ数値に変換される。

vim.eval() で取得される辞書とリストはそのまま返される。それ以外のオブジェクトは 0 が返され、エラーにはならない。詳細は |@ref{lua-luaeval}| を参照。

@{|@ref{+lua}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
map({expr1}, {expr2})					*map()*
		{expr1} must be a |List| or a |Dictionary|.
		Replace each item in {expr1} with the result of evaluating
		{expr2}.  {expr2} must be a |string| or |Funcref|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{map()}
@findex map()
@item map(@{expr1@}, @{expr2@})
@{expr1@} はリスト |@ref{List}| または辞書 |@ref{Dictionary}|。

@{expr1@} の各要素を、@{expr2@} を評価した結果で置き換える。@{expr2@} は文字列 |@ref{string}| または関数参照 |@ref{Funcref}| でなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {expr2} is a |string|, inside {expr2} |v:val| has the value
		of the current item.  For a |Dictionary| |v:key| has the key
		of the current item and for a |List| |v:key| has the index of
		the current item.
		Example: >
			:call map(mylist, '"> " . v:val . " <"')
<		This puts "> " before and " <" after each item in "mylist".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr2@} が文字列 |@ref{string}| の場合、@{expr2@} の内部では |@ref{v:val}| が現在の要素の値を保持している。辞書の場合は |@ref{v:key}| が現在の要素のキーを保持している。リスト |@ref{List}| の場合は |@ref{v:key}| が現在の要素のインデックスを保持している。
例:
@example
:call map(mylist, '"> " . v:val . " <"')
@end example
これは "mylist" の各要素の前に "> " をつけ、後に " <" をつける。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Note that {expr2} is the result of an expression and is then
		used as an expression again.  Often it is good to use a
		|literal-string| to avoid having to double backslashes.  You
		still have to double ' quotes
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
@{expr2@} は式を表す文字列である。バックスラッシュを二重にしなくても済むように |@ref{literal-string}| を使うとよいだろう。ただしその場合はシングルクォートを二重にしなければならない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {expr2} is a |Funcref| it is called with two arguments:
			1. The key or the index of the current item.
			2. the value of the current item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr2@} が |@ref{Funcref}| の場合は、2 つの引数で呼び出される:
@enumerate
@item 現在の要素のキーまたはインデックス。
@item 現在の要素の値。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The function must return the new value of the item. Example
		that changes each value by "key-value": >
			func KeyValue(key, val)
			  return a:key . '-' . a:val
			endfunc
			call map(myDict, function('KeyValue'))
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数は、その要素の新しい値を返さなければならない。それぞれの値を "key-value" に置き換える例:
@verbatim
func KeyValue(key, val)
  return a:key . '-' . a:val
endfunc
call map(myDict, function('KeyValue'))
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		It is shorter when using a |lambda|: >
			call map(myDict, {key, val -> key . '-' . val})
<		If you do not use "val" you can leave it out: >
			call map(myDict, {key -> 'item: ' . key})
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{lambda}| を使えばより短く書ける:
@example
call map(myDict, @{key, val -> key . '-' . val@})
@end example
"val" を使わない場合は省略できる:
@example
call map(myDict, @{key -> 'item: ' . key@})
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The operation is done in-place.  If you want a |List| or
		|Dictionary| to remain unmodified make a copy first: >
			:let tlist = map(copy(mylist), ' v:val . "\t"')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この操作はその場で (in-place) 行われる。リスト |@ref{List}| や辞書 |@ref{Dictionary}| を変更したくない場合は最初にコピーを作ること:
@example
:let tlist = map(copy(mylist), ' v:val . "\t"')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		Returns {expr1}, the |List| or |Dictionary| that was filtered.
		When an error is encountered while evaluating {expr2} no
		further items in {expr1} are processed.  When {expr2} is a
		Funcref errors inside a function are ignored, unless it was
		defined with the "abort" flag.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr1@} のリスト |@ref{List}| または辞書 |@ref{Dictionary}| に式を適用した結果を返す。@{expr2@} を評価している最中にエラーが発生した場合は、@{expr1@} 内のそれ以降の要素の処理は行われない。@{expr2@} が関数参照の場合、関数が "abort" フラグつきで定義されていない限り、関数内のエラーは無視される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
maparg({name} [, {mode} [, {abbr} [, {dict}]]])			*maparg()*
		When {dict} is omitted or zero: Return the rhs of mapping
		{name} in mode {mode}.  The returned String has special
		characters translated like in the output of the ":map" command
		listing.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{maparg()}
@findex maparg()
@item maparg(@{name@} [, @{mode@} [, @{abbr@} [, @{dict@}]]])
@{dict@} が省略されたかゼロのとき: モード @{mode@} におけるキーマップ @{name@} の rhs を返す。結果の文字列内の特殊文字は、"@command{:map}" コマンドでリスト表示した時のように変換される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When there is no mapping for {name}, an empty String is
		returned.  When the mapping for {name} is empty, then "<Nop>"
		is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{name@} というキーマップが存在しない場合、空文字列が返される。@{name@} のマッピングが空の場合、"<Nop>" が返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The {name} can have special key names, like in the ":map"
		command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{name@} には "@command{:map}" コマンドで使用可能な、特殊なキー名が指定できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{mode} can be one of these strings:
			"n"	Normal
			"v"	Visual (including Select)
			"o"	Operator-pending
			"i"	Insert
			"c"	Cmd-line
			"s"	Select
			"x"	Visual
			"l"	langmap |language-mapping|
			"t"	Terminal-Job
			""	Normal, Visual and Operator-pending
		When {mode} is omitted, the modes for "" are used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{mode@} には次の文字が使用可能:
@multitable @columnfractions .1 .9
@item "n" @tab ノーマル
@item "v" @tab ビジュアル (選択含む)
@item "o" @tab オペレータ待機 (Operator-pending)
@item "i" @tab 挿入
@item "c" @tab コマンドライン
@item "s" @tab 選択
@item "x" @tab ビジュアル
@item "l" @tab langmap |@ref{language-mapping}|
@item "t" @tab Terminal-Job
@item "" @tab ノーマル、ビジュアル、及びオペレータ待機
@end multitable
@{mode@} が省略された場合、"" が使用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {abbr} is there and it is |TRUE| use abbreviations
		instead of mappings.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{abbr@} が指定され、|@ref{TRUE}| の場合はマッピングでなく短縮入力を対象とする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {dict} is there and it is |TRUE| return a dictionary
		containing all the information of the mapping with the
		following items:
		  "lhs"	     The {lhs} of the mapping.
		  "rhs"	     The {rhs} of the mapping as typed.
		  "silent"   1 for a |:map-silent| mapping, else 0.
		  "noremap"  1 if the {rhs} of the mapping is not remappable.
		  "expr"     1 for an expression mapping (|:map-<expr>|).
		  "buffer"   1 for a buffer local mapping (|:map-local|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{dict@} に |@ref{TRUE}| が指定されたときはマッピングのすべての情報を含んだ辞書が返る:
@multitable @columnfractions .2 .8
@item "lhs" @tab マッピングの @{lhs@}
@item "rhs" @tab マッピングの @{rhs@} (入力されたまま)
@item "silent" @tab |@ref{:map-silent}| マッピングなら 1。そうでなければ 0。
@item "noremap" @tab マッピングの @{rhs@} が再マップ可能なら 1。
@item "expr" @tab 式マッピング (|@ref{:map-<expr>}|) なら 1。
@item "buffer" @tab バッファローカルマッピング (|@ref{:map-local}|) なら 1。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		  "mode"     Modes for which the mapping is defined. In
			     addition to the modes mentioned above, these
			     characters will be used:
			     " "     Normal, Visual and Operator-pending
			     "!"     Insert and Commandline mode
				     (|mapmode-ic|)
		  "sid"	     The script local ID, used for <sid> mappings
			     (|<SID>|).
		  "nowait"   Do not wait for other, longer mappings.
			     (|:map-<nowait>|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "mode" @tab マッピングが定義されているモード。上述のモードに加え、次の文字が使用される:
@multitable @columnfractions .1 .9
@item " " @tab ノーマル、ビジュアル、オペレータ待機
@item "!" @tab 挿入、コマンドラインモード (|@ref{mapmode-ic}|)
@end multitable
@item "sid" @tab <sid> マッピングで使用されるスクリプトローカル ID (|@ref{<SID>}|)。
@item "nowait" @tab 他の長いマッピングを待たない。(|@ref{:map-<nowait>}|)。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The mappings local to the current buffer are checked first,
		then the global mappings.
		This function can be used to map a key even when it's already
		mapped, and have it do the original mapping too.  Sketch: >
			exe 'nnoremap <Tab> ==' . maparg('<Tab>', 'n')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
まずカレントバッファにローカルなマッピングを探し、次のグローバルマッピングを探す。

この関数を使うと、あるキーに対して既にマップがされているとき、その動作を行いつつ、再マップすることができる。概要:
@example
exe 'nnoremap <Tab> ==' . maparg('<Tab>', 'n')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
mapcheck({name} [, {mode} [, {abbr}]])			*mapcheck()*
		Check if there is a mapping that matches with {name} in mode
		{mode}.  See |maparg()| for {mode} and special names in
		{name}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{mapcheck()}
@findex mapcheck()
@item mapcheck(@{name@} [, @{mode@} [, @{abbr@}]])
モード @{mode@} におけるキーマップ @{name@} が存在するかチェックする。@{name@} に指定できる特殊文字は |@ref{maparg()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When {abbr} is there and it is |TRUE| use abbreviations
		instead of mappings.
		A match happens with a mapping that starts with {name} and
		with a mapping which is equal to the start of {name}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@{abbr@} が指定され、|@ref{TRUE}| の場合はマッピングでなく短縮入力を対象とする。

マッピングが @{name@} で始まるとき、またはマッピングが @{name@} のはじめに等しいときマッチすると見なされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			matches mapping "a"	"ab"	"abc" ~
		   mapcheck("a")	yes	yes	 yes
		   mapcheck("abc")	yes	yes	 yes
		   mapcheck("ax")	yes	no	 no
		   mapcheck("b")	no	no	 no
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .2 .2 .2
@headitem マッチするか @tab "a" @tab "ab" @tab "abc"
@item mapcheck("a") @tab yes @tab yes @tab yes
@item mapcheck("abc") @tab yes @tab yes @tab yes
@item mapcheck("ax") @tab yes @tab no @tab no
@item mapcheck("b") @tab no @tab no @tab no
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The difference with maparg() is that mapcheck() finds a
		mapping that matches with {name}, while maparg() only finds a
		mapping for {name} exactly.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
maparg() との違いは、mapcheck() は @{name@} にマッチするマップを見つけるが、maparg() はぴったり @{name@} に一致するマッピングのみを見つける。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When there is no mapping that starts with {name}, an empty
		String is returned.  If there is one, the RHS of that mapping
		is returned.  If there are several mappings that start with
		{name}, the RHS of one of them is returned.  This will be
		"<Nop>" if the RHS is empty.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@{name@} にマッチするキーマップが存在しない時には、空文字列が返される。結果が 1 つならばマップされた RHS が返される。複数見つかった場合には、それらのうちどれか 1 つの RHS が返される。RHS が空ならば "<Nop>" になるだろう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The mappings local to the current buffer are checked first,
		then the global mappings.
		This function can be used to check if a mapping can be added
		without being ambiguous.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

まずカレントバッファにローカルなマッピングを探し、次のグローバルマッピングを探す。

この関数はマッピングが曖昧にならないかチェックするために使うことができる。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:if mapcheck("_vv") == ""
	:   map _vv :set guifont=7x13<CR>
	:endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:if mapcheck("_vv") == ""
:   map _vv :set guifont=7x13<CR>
:endif
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		This avoids adding the "_vv" mapping when there already is a
		mapping for "_v" or for "_vvv".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは、"_vv" というマッピングが "_v" とか "_vvv" といったマッピングと衝突しないように事前にチェックしている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
match({expr}, {pat} [, {start} [, {count}]])			*match()*
		When {expr} is a |List| then this returns the index of the
		first item where {pat} matches.  Each item is used as a
		String, |Lists| and |Dictionaries| are used as echoed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{match()}
@findex match()
@item match(@{expr@}, @{pat@} [, @{start@} [, @{count@}]])
@{expr@} がリスト |@ref{List}| の場合は、@{pat@} にマッチする最初の要素のインデックスを返す。各要素は文字列として扱われる。リスト |@ref{Lists}| と辞書 |@ref{Dictionaries}| は echo したときと同じように文字列表現に変換される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Otherwise, {expr} is used as a String.  The result is a
		Number, which gives the index (byte offset) in {expr} where
		{pat} matches.
		A match at the first character or |List| item returns zero.
		If there is no match -1 is returned.
		For getting submatches see |matchlist()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

それ以外の場合は、@{expr@} は文字列として扱われる。@{expr@} の中で @{pat@} にマッチするインデックス (バイト単位のオフセット) を表す数値を返す。

最初の文字またはリスト |@ref{List}| の最初の要素にマッチしたときは 0 を返す。マッチがないときは -1 を返す。サブマッチを取得するには |@ref{matchlist()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example: >
			:echo match("testing", "ing")	" results in 4
			:echo match([1, 'x'], '\a')	" results in 1
<		See |string-match| for how {pat} is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
:echo match("testing", "ing")	" 結果は 4
:echo match([1, 'x'], '\a')	" 結果は 1
@end example
@{pat@} の扱われ方については |@ref{string-match}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
								*strpbrk()*
		Vim doesn't have a strpbrk() function.  But you can do: >
			:let sepidx = match(line, '[.,;: \t]')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@anchor{strpbrk()}
@findex strpbrk()
strpbrk() に相当する関数は Vim に存在しない。しかし同じことを次のようにしてできる:
@example
:let sepidx = match(line, '[.,;: \t]')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<								*strcasestr()*
		Vim doesn't have a strcasestr() function.  But you can add
		"\c" to the pattern to ignore case: >
			:let idx = match(haystack, '\cneedle')
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@anchor{strcasestr()}
@findex strcasestr()
strcasestr() に相当する関数はVimに存在しない。しかし正規表現に "\c" をつければ大文字・小文字の違いを無視できる:
@example
:let idx = match(haystack, '\cneedle')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If {start} is given, the search starts from byte index
		{start} in a String or item {start} in a |List|.
		The result, however, is still the index counted from the
		first character/item.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{start@} が指定されたときは、文字列のバイトインデックス @{start@} の位置、またはリスト |@ref{List}| の @{start@} の要素から検索を始める。その場合も戻り値は最初の文字/要素から数えたインデックスであることに注意。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			:echo match("testing", "ing", 2)
<		result is again "4". >
			:echo match("testing", "ing", 4)
<		result is again "4". >
			:echo match("testing", "t", 2)
<		result is "3".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:echo match("testing", "ing", 2)
@end example
の結果は "4"。
@example
:echo match("testing", "ing", 4)
@end example
の結果は "4"。
@example
:echo match("testing", "t", 2)
@end example
の結果は "3"。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		For a String, if {start} > 0 then it is like the string starts
		{start} bytes later, thus "^" will match at {start}.  Except
		when {count} is given, then it's like matches before the
		{start} byte are ignored (this is a bit complicated to keep it
		backwards compatible).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

文字列の場合、@{start@} > 0 のときは、その文字列が @{start@} バイト後から始まるかのように扱われる。そのため、"^" は @{start@} の位置にマッチする。ただし @{count@} が指定されたときは、@{start@} より前におけるマッチを無視しているかのように振る舞う (これは後方互換性を保つのを少々複雑にしている)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		For a String, if {start} < 0, it will be set to 0.  For a list
		the index is counted from the end.
		If {start} is out of range ({start} > strlen({expr}) for a
		String or {start} > len({expr}) for a |List|) -1 is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

文字列の場合、@{start@} < 0 のときは @{start@} に 0 をセットする。リストの場合は、末尾からインデックスを数えるという意味になる。@{start@} が範囲外の場合 (文字列で @{start@} > strlen(@{expr@}) となった場合、リスト |@ref{List}| で @{start@} > len(@{expr@}) となった場合) は -1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {count} is given use the {count}'th match.  When a match
		is found in a String the search for the next one starts one
		character further.  Thus this example results in 1: >
			echo match("testing", "..", 0, 2)
<		In a |List| the search continues in the next item.
		Note that when {count} is added the way {start} works changes,
		see above.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{count@} が指定されたときは @{count@} 番目のマッチ位置を返す。文字列でマッチが見つかったとき、次のマッチングは 1 文字先から行われる。よって次の例は 1 を返す:
@example
echo match("testing", "..", 0, 2)
@end example
リスト |@ref{List}| の場合は次の要素から検索を続ける。
@quotation
@strong{Note:} @*
@{count@} を指定すると、@{start@} の扱い方が変わってしまう。前の段落を参照。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		See |pattern| for the patterns that are accepted.
		The 'ignorecase' option is used to set the ignore-caseness of
		the pattern.  'smartcase' is NOT used.  The matching is always
		done like 'magic' is set and 'cpoptions' is empty.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
受け付ける正規表現については |@ref{pattern}| を参照。オプション '@option{ignorecase}' により、大文字・小文字を区別するかどうかを設定できる。'@option{smartcase}' は適用されない。マッチングは常に '@option{magic}' をオン、'@option{cpoptions}' を空にした状態で行われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*matchadd()* *E798* *E799* *E801* *E957*
matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])
		Defines a pattern to be highlighted in the current window (a
		"match").  It will be highlighted with {group}.  Returns an
		identification number (ID), which can be used to delete the
		match using |matchdelete()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{matchadd()}
@anchor{E798}
@anchor{E799}
@anchor{E801}
@anchor{E957}
@findex matchadd()
@erindex E798
@erindex E799
@erindex E801
@erindex E957
@item matchadd(@{group@}, @{pattern@} [, @{priority@} [, @{id@} [, @{dict@}]]])
カレントウィンドウで強調表示するパターンを定義する。このパターンのことを「マッチ」と呼ぶ。構文グループ @{group@} で強調する。戻り値は、マッチを識別する ID である。|@ref{matchdelete()}| でこの ID を指定してマッチを削除することができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Matching is case sensitive and magic, unless case sensitivity
		or magicness are explicitly overridden in {pattern}.  The
		'magic', 'smartcase' and 'ignorecase' options are not used.
		The "Conceal" value is special, it causes the match to be
		concealed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

パターンは大文字小文字を区別し、magic (|@ref{/magic}|) として解釈される (@{pattern@} の中で明示的に変更しない限り)。オプションの '@option{magic}', '@option{smartcase}', '@option{ignorecase}' は使用されない。Conceal は特別であり、マッチを隠す作用がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The optional {priority} argument assigns a priority to the
		match.  A match with a high priority will have its
		highlighting overrule that of a match with a lower priority.
		A priority is specified as an integer (negative numbers are no
		exception).  If the {priority} argument is not specified, the
		default priority is 10.  The priority of 'hlsearch' is zero,
		hence all matches with a priority greater than zero will
		overrule it.  Syntax highlighting (see 'syntax') is a separate
		mechanism, and regardless of the chosen priority a match will
		always overrule syntax highlighting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
省略可能な引数 @{priority@} はマッチの優先度を指定する。優先度が高いマッチは、より低いマッチの強調を上書きする。

優先度は整数で指定する (負の数も可能)。@{priority@} が指定されない場合は既定の優先度 10 となる。'@option{hlsearch}' の優先度はゼロで、したがってゼロより大きい優先度のマッチはすべてそれを上書きする。構文ハイライト ('@option{syntax}' を参照) は独立したメカニズムであり、優先度がいくつであろうとマッチは構文ハイライトより優先する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The optional {id} argument allows the request for a specific
		match ID.  If a specified ID is already taken, an error
		message will appear and the match will not be added.  An ID
		is specified as a positive integer (zero excluded).  IDs 1, 2
		and 3 are reserved for |:match|, |:2match| and |:3match|,
		respectively.  If the {id} argument is not specified or -1,
		|matchadd()| automatically chooses a free ID.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{id@} は特定のマッチ ID を返すことを要求する。指定された ID がすでに使われていたら、エラーメッセージが表示され、そのマッチは登録されない。ID は正の整数を指定する (ゼロは除く)。ID 1, 2, 3 は |@ref{:match}|, |@ref{:2match}|, |@ref{:3match}| 用に予約されている。@{id@} が指定されないか -1 のときは、|@ref{matchadd()}| が自動的に空いている ID を取得する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The optional {dict} argument allows for further custom
		values. Currently this is used to specify a match specific
		conceal character that will be shown for |hl-Conceal|
		highlighted matches. The dict can have the following members:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
省略可能な引数 @{dict@} はより一層カスタマイズ可能な値を許す。現在、これは |@ref{hl-Conceal}| でハイライトされたマッチを conceal 文字で表示されるのを明示するために使われる。この辞書は下記のメンバを持つことができる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			conceal	    Special character to show instead of the
				    match (only for |hl-Conceal| highlighted
				    matches, see |:syn-cchar|)
			window	    Instead of the current window use the
				    window with this number or window ID.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item conceal
マッチ (|@ref{hl-Conceal}| のためだけにハイライトされたマッチ、|@ref{:syn-cchar}| を参照) の代わりに表示する特別な文字
@item window
現在のウィンドウの代わりに、この番号もしくはウィンドウ ID のウィンドウを使用する
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The number of matches is not limited, as it is the case with
		the |:match| commands.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンド |@ref{:match}| と異なり、マッチの個数に上限はない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example: >
			:highlight MyGroup ctermbg=green guibg=green
			:let m = matchadd("MyGroup", "TODO")
<		Deletion of the pattern: >
			:call matchdelete(m)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:highlight MyGroup ctermbg=green guibg=green
:let m = matchadd("MyGroup", "TODO")
@end example
このパターンを削除するには:
@example
:call matchdelete(m)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		A list of matches defined by |matchadd()| and |:match| are
		available from |getmatches()|.  All matches can be deleted in
		one operation by |clearmatches()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{matchadd()}| と |@ref{:match}| で定義したマッチのリストは |@ref{getmatches()}| で取得できる。全てのマッチを削除するのは |@ref{clearmatches()}| 一発でできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*matchaddpos()*
matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])
		Same as |matchadd()|, but requires a list of positions {pos}
		instead of a pattern. This command is faster than |matchadd()|
		because it does not require to handle regular expressions and
		sets buffer line boundaries to redraw screen. It is supposed
		to be used when fast match additions and deletions are
		required, for example to highlight matching parentheses.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{matchaddpos()}
@findex matchaddpos()
@item matchaddpos(@{group@}, @{pos@} [, @{priority@} [, @{id@} [, @{dict@}]]])
|@ref{matchadd()}| と同じだが、パターンを指定するのではなく、位置のリスト @{pos@} を指定する。このコマンドは正規表現を扱う必要もなく、画面更新のためにバッファ行の境界を設定するため、|@ref{matchadd()}| よりも速い。これは、例えば括弧の対応を強調表示するような、マッチの追加と削除を高速に実行したい状況を想定している。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The list {pos} can contain one of these items:
		- A number.  This whole line will be highlighted.  The first
		  line has number 1.
		- A list with one number, e.g., [23]. The whole line with this
		  number will be highlighted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リスト @{pos@} は以下のいずれかの値を要素として持つことができる:
@itemize
@item 数値。指定した行全体が強調表示される。最初の行の行番号は 1 である。
@item 数値を 1 つ持ったリスト。例 [23]。指定した行全体が強調表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		- A list with two numbers, e.g., [23, 11]. The first number is
		  the line number, the second one is the column number (first
		  column is 1, the value must correspond to the byte index as
		  |col()| would return).  The character at this position will
		  be highlighted.
		- A list with three numbers, e.g., [23, 11, 3]. As above, but
		  the third number gives the length of the highlight in bytes.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 数値を 2 つ持ったリスト。例 [23, 11]。最初の数値は行番号、2 番目の数値は列番号である (最初の列は 1 である。値は |@ref{col()}| の戻り値と同じようにバイト単位である)。指定した位置の文字が強調表示される。
@item 数値を 3 つ持ったリスト。例 [23, 11, 3]。数値 2 つの場合と同じだが、3 つ目に強調表示する文字の長さ (バイト単位) を指定する。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The maximum number of positions is 8.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
指定できる位置は最大で 8 個である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example: >
			:highlight MyGroup ctermbg=green guibg=green
			:let m = matchaddpos("MyGroup", [[23, 24], 34])
<		Deletion of the pattern: >
			:call matchdelete(m)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:highlight MyGroup ctermbg=green guibg=green
:let m = matchaddpos("MyGroup", [[23, 24], 34])
@end example
パターンの削除:
@example
:call matchdelete(m)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		Matches added by |matchaddpos()| are returned by
		|getmatches()| with an entry "pos1", "pos2", etc., with the
		value a list like the {pos} item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{matchaddpos()}| で追加されたマッチは |@ref{getmatches()}| で取得する際には "pos1", "pos2", ... という項目を持つ。それぞれの値は @{pos@} で指定された値である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
matcharg({nr})							*matcharg()*
		Selects the {nr} match item, as set with a |:match|,
		|:2match| or |:3match| command.
		Return a |List| with two elements:
			The name of the highlight group used
			The pattern used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{matcharg()}
@findex matcharg()
@item matcharg(@{nr@})
|@ref{:match}|, |@ref{:2match}|, |@ref{:3match}| によって設定されているマッチパターンの情報を返す。@{nr@} が 1 のときは |@ref{:match}| の情報、2 のときは |@ref{:2match}| の情報、3 のときは |@ref{:3match}| の情報を返す。

戻り値は次の 2 個の要素を持つリスト |@ref{List}| である:
@itemize @bullet
@item 引数で指定したハイライトグループ名
@item 引数で指定した検索パターン
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When {nr} is not 1, 2 or 3 returns an empty |List|.
		When there is no match item set returns ['', ''].
		This is useful to save and restore a |:match|.
		Highlighting matches using the |:match| commands are limited
		to three matches. |matchadd()| does not have this limitation.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{nr@} が 1、2、3 のどれでもないときは空リスト |@ref{List}| を返す。マッチパターンがセットされていないときは ['', ''] を返す。|@ref{:match}| を保存し、復元するのに便利である。|@ref{:match}| を使った強調は 3 個までに限られている。|@ref{matchadd()}| にはこの制限はない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
matchdelete({id})			       *matchdelete()* *E802* *E803*
		Deletes a match with ID {id} previously defined by |matchadd()|
		or one of the |:match| commands.  Returns 0 if successful,
		otherwise -1.  See example for |matchadd()|.  All matches can
		be deleted in one operation by |clearmatches()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{matchdelete()}
@anchor{E802}
@anchor{E803}
@findex matchdelete()
@erindex E802
@erindex E803
@item matchdelete(@{id@})
|@ref{matchadd()}| または |@ref{:match}| で定義したマッチの中で ID が @{id@} であるものを削除する。成功したときは 0、失敗したときは -1 を返す。|@ref{matchadd()}| の例を参照。すべてのマッチを削除するのは |@ref{clearmatches()}| 一発でできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
matchend({expr}, {pat} [, {start} [, {count}]])			*matchend()*
		Same as |match()|, but return the index of first character
		after the match.  Example: >
			:echo matchend("testing", "ing")
<		results in "7".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{matchend()}
@findex matchend()
@item matchend(@{expr@}, @{pat@} [, @{start@} [, @{count@}]])
|@ref{match()}| と同じだが、返されるのはマッチした部分文字列の終了後のインデックスである。例:
@example
:echo matchend("testing", "ing")
@end example
結果は "7"。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*strspn()* *strcspn()*
		Vim doesn't have a strspn() or strcspn() function, but you can
		do it with matchend(): >
			:let span = matchend(line, '[a-zA-Z]')
			:let span = matchend(line, '[^a-zA-Z]')
<		Except that -1 is returned when there are no matches.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@anchor{strspn()}
@anchor{strcspn()}
@findex strspn()
@findex strcspn()
Vim には strspn() や strcspn() に相当する関数はないが、matchend() を使えば同じことができる:
@example
:let span = matchend(line, '[a-zA-Z]')
:let span = matchend(line, '[^a-zA-Z]')
@end example
ただしマッチがないときには -1 を返すところが異なる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The {start}, if given, has the same meaning as for |match()|. >
			:echo matchend("testing", "ing", 2)
<		results in "7". >
			:echo matchend("testing", "ing", 5)
<		result is "-1".
		When {expr} is a |List| the result is equal to |match()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{start@} は |@ref{match()}| の場合と同じ意味を持つ。
@example
:echo matchend("testing", "ing", 2)
@end example
結果は "7"。
@example
:echo matchend("testing", "ing", 5)
@end example
結果は "-1"。

@{expr@} がリスト |@ref{List}| の場合、戻り値は |@ref{match()}| と等しくなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
matchlist({expr}, {pat} [, {start} [, {count}]])		*matchlist()*
		Same as |match()|, but return a |List|.  The first item in the
		list is the matched string, same as what matchstr() would
		return.  Following items are submatches, like "\1", "\2", etc.
		in |:substitute|.  When an optional submatch didn't match an
		empty string is used.  Example: >
			echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')
<		Results in: ['acd', 'a', '', 'c', 'd', '', '', '', '', '']
		When there is no match an empty list is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{matchlist()}
@findex matchlist()
@item matchlist(@{expr@}, @{pat@} [, @{start@} [, @{count@}]])
|@ref{match()}| と同じだがリスト |@ref{List}| を返す。リストの最初の要素は、matchstr() が返すのと同じマッチした文字列。それ以降の要素は |@ref{:substitute}| における "\1", "\2" のようなサブマッチである。\1 から \9 までの間で、指定されなかったものは空文字列となる。例:
@example
echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')
@end example
結果は ['acd', 'a', '', 'c', 'd', '', '', '', '', ''] となる。マッチしなかったときは空リストを返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
matchstr({expr}, {pat} [, {start} [, {count}]])			*matchstr()*
		Same as |match()|, but return the matched string.  Example: >
			:echo matchstr("testing", "ing")
<		results in "ing".
		When there is no match "" is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{matchstr()}
@findex matchstr()
@item matchstr(@{expr@}, @{pat@} [, @{start@} [, @{count@}]])
|@ref{match()}| と同じだが、マッチした文字列を返す。例:
@example
:echo matchstr("testing", "ing")
@end example
結果は "ing"。

マッチしなかったときは "" を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The {start}, if given, has the same meaning as for |match()|. >
			:echo matchstr("testing", "ing", 2)
<		results in "ing". >
			:echo matchstr("testing", "ing", 5)
<		result is "".
		When {expr} is a |List| then the matching item is returned.
		The type isn't changed, it's not necessarily a String.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{start@} の意味は |@ref{match()}| の場合と同じ。
@example
:echo matchstr("testing", "ing", 2)
@end example
結果は "ing"。
@example
:echo matchstr("testing", "ing", 5)
@end example
結果は ""。

@{expr@} がリスト |@ref{List}| のときはマッチした要素を返す。その要素の型は変換されないため、必ずしも文字列であるとは限らない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
matchstrpos({expr}, {pat} [, {start} [, {count}]])		*matchstrpos()*
		Same as |matchstr()|, but return the matched string, the start
		position and the end position of the match.  Example: >
			:echo matchstrpos("testing", "ing")
<		results in ["ing", 4, 7].
		When there is no match ["", -1, -1] is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{matchstrpos()}
@findex matchstrpos()
@item matchstrpos(@{expr@}, @{pat@} [, @{start@} [, @{count@}]])
|@ref{matchstr()}| と同じだがマッチした文字列とマッチした開始位置と終了位置を返す。例:
@example
:echo matchstrpos("testing", "ing")
@end example
結果は ["ing", 4, 7] である。

マッチが無い場合は ["", -1, -1] が返る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The {start}, if given, has the same meaning as for |match()|. >
			:echo matchstrpos("testing", "ing", 2)
<		results in ["ing", 4, 7]. >
			:echo matchstrpos("testing", "ing", 5)
<		result is ["", -1, -1].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{start@} が指定されている場合は |@ref{match()}| と同じ意味になる。
@example
:echo matchstrpos("testing", "ing", 2)
@end example
結果は ["ing", 4, 7] である。 >
@example
:echo matchstrpos("testing", "ing", 5)
@end example
結果は ["", -1, -1] である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When {expr} is a |List| then the matching item, the index
		of first item where {pat} matches, the start position and the
		end position of the match are returned. >
			:echo matchstrpos([1, '__x'], '\a')
<		result is ["x", 1, 2, 3].
		The type isn't changed, it's not necessarily a String.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@{expr@} が リスト |@ref{List}| の場合、マッチしたアイテム、@{pat@} でマッチした最初のインデックス、マッチの開始位置と終了位置が返る。
@example
:echo matchstrpos([1, '__x'], '\a')
@end example
結果は ["x", 1, 2, 3] である。

型は変更されない。必ずしも文字列である必要はない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*max()*
max({expr})	Return the maximum value of all items in {expr}.
		{expr} can be a list or a dictionary.  For a dictionary,
		it returns the maximum of all values in the dictionary.
		If {expr} is neither a list nor a dictionary, or one of the
		items in {expr} cannot be used as a Number this results in
		an error.  An empty |List| or |Dictionary| results in zero.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{max()}
@findex max()
@item max(@{expr@})
@{expr@} の全要素の値の最大値を返す。@{expr@} はリストか辞書である。辞書の場合、辞書に含まれるすべての値の最大値を返す。@{expr@} がリストでも辞書でもなかったり、要素のどれかが数値に変換できない場合はエラーとなる。空のリスト |@ref{List}| または辞書 |@ref{Dictionary}| の場合は 0 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*min()*
min({expr})	Return the minimum value of all items in {expr}.
		{expr} can be a list or a dictionary.  For a dictionary,
		it returns the minimum of all values in the dictionary.
		If {expr} is neither a list nor a dictionary, or one of the
		items in {expr} cannot be used as a Number this results in
		an error.  An empty |List| or |Dictionary| results in zero.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{min()}
@findex min()
@item min(@{expr@})
@{expr@} の全要素の値の最小値を返す。@{expr@} はリストか辞書である。辞書の場合、辞書に含まれるすべての値の最小値を返す。@{expr@} がリストでも辞書でもなかったり、要素のどれかが数値に変換できない場合はエラーとなる。空のリスト |@ref{List}| または辞書 |@ref{Dictionary}| の場合は 0 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*mkdir()* *E739*
mkdir({name} [, {path} [, {prot}]])
		Create directory {name}.
		If {path} is "p" then intermediate directories are created as
		necessary.  Otherwise it must be "".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{mkdir()}
@anchor{E739}
@findex mkdir()
@erindex E739
@item mkdir(@{name@} [, @{path@} [, @{prot@}]])
ディレクトリ @{name@} を作成する。

@{path@} が "p" のときは必要に応じて途中のディレクトリも作成される。そうでないときは "" にすること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If {prot} is given it is used to set the protection bits of
		the new directory.  The default is 0755 (rwxr-xr-x: r/w for
		the user readable for others).  Use 0700 to make it unreadable
		for others.  This is only used for the last part of {name}.
		Thus if you create /tmp/foo/bar then /tmp/foo will be created
		with 0755.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{prot@} は作成するディレクトリの保護ビット。デフォルトは 0755 (rwxr-xr-x: 所有者は読み書き可能、他の人は読み込み可能)。

他の人が読み込めないようにするには0700とすること。@{prot@} は @{name@} の最後の部分にのみ適用される。なので、/tmp/foo/bar を作成すると /tmp/foo は 0755 で作成される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example: >
			:call mkdir($HOME . "/tmp/foo/bar", "p", 0700)
<		This function is not available in the |sandbox|.
		There is no error if the directory already exists and the "p"
		flag is passed (since patch 8.0.1708).
		Not available on all systems.  To check use: >
			:if exists("*mkdir")
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
:call mkdir($HOME . "/tmp/foo/bar", "p", 0700)
@end example
|@ref{sandbox}| の中ではこの関数は使用できない。

もしもディレクトリがすでに存在し、"p" フラグが渡されているなら、エラーは生じない (patch 8.0.1708 以降)。

システムによっては利用できない場合がある。これを確認するには次のようにする:
@example
:if exists("*mkdir")
@end example                
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*mode()*
mode([expr])	Return a string that indicates the current mode.
		If [expr] is supplied and it evaluates to a non-zero Number or
		a non-empty String (|non-zero-arg|), then the full mode is
		returned, otherwise only the first letter is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{mode()}
@findex mode()
@item mode([expr])
現在のモードを示す文字列を返す。

[expr] に 0 でない数値か空でない文字列 (|@ref{non-zero-arg}|) を指定した場合、フルモードが返される。それ以外の場合は最初の 1 文字だけが返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		   n	    Normal, Terminal-Normal
		   no	    Operator-pending
		   niI	    Normal using |i_CTRL-O| in |Insert-mode|
		   niR	    Normal using |i_CTRL-O| in |Replace-mode|
		   niV	    Normal using |i_CTRL-O| in |Virtual-Replace-mode|
		   v	    Visual by character
		   V	    Visual by line
		   CTRL-V   Visual blockwise
		   s	    Select by character
		   S	    Select by line
		   CTRL-S   Select blockwise
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item n @tab ノーマル、Terminal-Normal
@item no @tab オペレータ待機
@item niI @tab |@ref{Insert-mode}| で |@ref{i_CTRL-O}| を使用しているノーマル
@item niR @tab |@ref{Replace-mode}| で |@ref{i_CTRL-O}| を使用しているノーマル
@item niV @tab |@ref{Virtual-Replace-mode}| で |@ref{i_CTRL-O}| を使用しているノーマル
@item v @tab 文字単位ビジュアル
@item V @tab 行単位ビジュアル
@item @kbd{CTRL-V} @tab 矩形ビジュアル
@item s @tab 文字単位選択
@item S @tab 行単位選択
@item @kbd{CTRL-S} @tab 矩形選択
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   i	    Insert
		   ic	    Insert mode completion |compl-generic|
		   ix	    Insert mode |i_CTRL-X| completion
		   R	    Replace |R|
		   Rc	    Replace mode completion |compl-generic|
		   Rv	    Virtual Replace |gR|
		   Rx	    Replace mode |i_CTRL-X| completion
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item i @tab 挿入
@item ic @tab 挿入モード補完 |@ref{compl-generic}|
@item ix @tab 挿入モード |@ref{i_CTRL-X}| 補完
@item R @tab 置換 |@ref{R}|
@item Rc @tab 置換モード補完 |@ref{compl-generic}|
@item Rv @tab 仮想置換 |@ref{gR}|
@item Rx @tab 置換モード |@ref{i_CTRL-X}| 補完
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   c	    Command-line editing
		   cv	    Vim Ex mode |gQ|
		   ce	    Normal Ex mode |Q|
		   r	    Hit-enter prompt
		   rm	    The -- more -- prompt
		   r?	    A |:confirm| query of some sort
		   !	    Shell or external command is executing
		   t	    Terminal-Job mode: keys go to the job
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item c @tab コマンドライン編集
@item cv @tab Vim Ex モード |@ref{gQ}|
@item ce @tab ノーマル Ex モード |@ref{Q}|
@item r @tab Hit-enter プロンプト
@item rm @tab @samp{-- more --} プロンプト
@item r? @tab ある種の |@ref{:confirm}| 問い合わせ
@item ! @tab シェルまたは外部コマンド実行中
@item t @tab Terminal-Job モード: ジョブに渡るキー
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		This is useful in the 'statusline' option or when used
		with |remote_expr()| In most other places it always returns
		"c" or "n".
		Note that in the future more modes and more specific modes may
		be added. It's better not to compare the whole string but only
		the leading character(s).
		Also see |visualmode()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらはオプション '@option{statusline}' の中や、|@ref{remote_expr()}| といっしょに使うと便利である。他のほとんどの場所では "c" または "n" しか返さない。
@quotation
@strong{Note:} @*
将来的にはより多くのモードとより多くの特殊なモードが追加されるであろうことに注意。文字列全体を比較することよりも文字列を読み込むことのみの方が良い。
@end quotation
|@ref{visualmode()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
mzeval({expr})							*mzeval()*
		Evaluate MzScheme expression {expr} and return its result
		converted to Vim data structures.
		Numbers and strings are returned as they are.
		Pairs (including lists and improper lists) and vectors are
		returned as Vim |Lists|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{mzeval()}
@findex mzeval()
@item mzeval(@{expr@})
MzScheme の式 @{expr@} を評価してその結果を Vim の変数に変換した結果を返す。

数値と文字列はそのまま返る。

ペア (リストと不適切なリスト (improper list) を含む) とベクタは Vim のリスト (|@ref{Lists}|) に変換される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Hash tables are represented as Vim |Dictionary| type with keys
		converted to strings.
		All other types are converted to string with display function.
		Examples: >
		    :mz (define l (list 1 2 3))
		    :mz (define h (make-hash)) (hash-set! h "list" l)
		    :echo mzeval("l")
		    :echo mzeval("h")
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ハッシュテーブルは Vim の辞書 (|@ref{Dictionary}|) に変換され、そのキーは文字列に変換される。

その他のすべての型は display 関数を使って文字列に変換される。

例:
@example
:mz (define l (list 1 2 3))
:mz (define h (make-hash)) (hash-set! h "list" l)
:echo mzeval("l")
:echo mzeval("h")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{only available when compiled with the |+mzscheme| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{|@ref{+mzscheme}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
nextnonblank({lnum})					*nextnonblank()*
		Return the line number of the first line at or below {lnum}
		that is not blank.  Example: >
			if getline(nextnonblank(1)) =~ "Java"
<		When {lnum} is invalid or there is no non-blank line at or
		below it, zero is returned.
		See also |prevnonblank()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{nextnonblank()}
@findex nextnonblank()
@item nextnonblank(@{lnum@})
@{lnum@} 行以降 (@{lnum@} 行を含む) の最初の非空行の行番号を返す。例:
@example
if getline(nextnonblank(1)) =~ "Java"
@end example
@{lnum@} が無効なときや、それ以降に非空行がないときは 0 を返す。|@ref{prevnonblank()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
nr2char({expr} [, {utf8}])				*nr2char()*
		Return a string with a single character, which has the number
		value {expr}.  Examples: >
			nr2char(64)		returns "@"
			nr2char(32)		returns " "
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{nr2char()}
@findex nr2char()
@item nr2char(@{expr@} [, @{utf8@}])
コード @{expr@} で表される1文字からなる文字列を返す。例:
@multitable @columnfractions .5 .5
@item nr2char(64) @tab "@"を返す
@item nr2char(32) @tab " "を返す
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		When {utf8} is omitted or zero, the current 'encoding' is used.
		Example for "utf-8": >
			nr2char(300)		returns I with bow character
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{utf8@} を省略、またはゼロを指定すると、現在の '@option{encoding}' が適用される。"@var{utf-8}" の場合の例:
@multitable @columnfractions .5 .5
@item nr2char(300) @tab 短音記号つきの I を返す
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		With {utf8} set to 1, always return utf-8 characters.
		Note that a NUL character in the file is specified with
		nr2char(10), because NULs are represented with newline
		characters.  nr2char(0) is a real NUL and terminates the
		string, thus results in an empty string.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{utf8@} に 1 を指定すると、常に utf-8 文字が返る。
@quotation
@strong{Note:} @*
Vim 内部では、ファイル中の NUL 文字を改行文字 (0x0A) に変換して保持している。そのため、nr2char(10) とすれば NUL 文字を指定できる。nr2char(0) は真の NUL 文字 (文字列の終端) となるので、空文字列を返す。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
or({expr}, {expr})					*or()*
		Bitwise OR on the two arguments.  The arguments are converted
		to a number.  A List, Dict or Float argument causes an error.
		Example: >
			:let bits = or(bits, 0x80)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{or()}
@findex or()
@item or(@{expr@}, @{expr@})
2 つの引数のビット論理和。引数は数値に変換される。リスト、辞書、浮動小数点数を指定するとエラーになる。

例:
@example
:let bits = or(bits, 0x80)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
pathshorten({expr})					*pathshorten()*
		Shorten directory names in the path {expr} and return the
		result.  The tail, the file name, is kept as-is.  The other
		components in the path are reduced to single letters.  Leading
		'~' and '.' characters are kept.  Example: >
			:echo pathshorten('~/.vim/autoload/myfile.vim')
<			~/.v/a/myfile.vim ~
		It doesn't matter if the path exists or not.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{pathshorten()}
@findex pathshorten()
@item pathshorten(@{expr@})
パス @{expr@} におけるディレクトリ名を短縮して返す。拡張子、ファイル名はそのまま保たれる。パスのその他の構成要素は1文字に縮められる。1 文字目の '~' と '.' はそのまま保たれる。例:
@example
:echo pathshorten('~/.vim/autoload/myfile.vim')
~/.v/a/myfile.vim
@end example
パスが実際に存在するかどうかは関係ない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
perleval({expr})					*perleval()*
		Evaluate Perl expression {expr} in scalar context and return
		its result converted to Vim data structures. If value can't be
		converted, it is returned as a string Perl representation.
		Note: If you want an array or hash, {expr} must return a
		reference to it.
		Example: >
			:echo perleval('[1 .. 4]')
<			[1, 2, 3, 4]
		{only available when compiled with the |+perl| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{perleval()}
@findex perleval()
@item perleval(@{expr@})
Perl の式 @{expr@} をスカラーコンテキストで評価して、結果を Vim のデータ形式にして返す。もし値が変換できない場合、Perl における文字列として返される。
@quotation
@strong{Note:} @*
もし配列かハッシュが必要ならば、@{expr@} ではそれらへの参照を返す必要がある。

例:
@example
:echo perleval('[1 .. 4]')
[1, 2, 3, 4]
@end example
@end quotation

@{|@ref{+perl}| 機能付きでコンパイルされたときのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
pow({x}, {y})						*pow()*
		Return the power of {x} to the exponent {y} as a |Float|.
		{x} and {y} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo pow(3, 3)
<			27.0 >
			:echo pow(2, 16)
<			65536.0 >
			:echo pow(32, 0.20)
<			2.0
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{pow()}
@findex pow()
@item pow(@{x@}, @{y@})
@{x@} の @{y@} 乗を |@ref{Float}| で返す。@{x@} と @{y@} は |@ref{Float}| または |@ref{Number}| に評価されなければならない。

例:
@example
:echo pow(3, 3)
27.0
:echo pow(2, 16)
65536.0
:echo pow(32, 0.20)
2.0
@end example

@{|@ref{+float}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
prevnonblank({lnum})					*prevnonblank()*
		Return the line number of the first line at or above {lnum}
		that is not blank.  Example: >
			let ind = indent(prevnonblank(v:lnum - 1))
<		When {lnum} is invalid or there is no non-blank line at or
		above it, zero is returned.
		Also see |nextnonblank()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{prevnonblank()}
@findex prevnonblank()
@item prevnonblank(@{lnum@})
@{lnum@} 行以前 (@{lnum@} 行を含む) の最初の非空行の行番号を返す。例:
@example
let ind = indent(prevnonblank(v:lnum - 1))
@end example
@{lnum@} が無効なときや、それ以前に非空行がないときは 0 を返す。|@ref{nextnonblank()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
printf({fmt}, {expr1} ...)				*printf()*
		Return a String with {fmt}, where "%" items are replaced by
		the formatted form of their respective arguments.  Example: >
			printf("%4d: E%d %.30s", lnum, errno, msg)
<		May result in:
			"  99: E42 asdfasdfasdfasdfasdfasdfasdfas" ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{printf()}
@findex printf()
@item printf(@{fmt@}, @{expr1@} ...)
@{fmt@} にしたがって組み立てた文字列を返す。@{fmt@} 中の "%" 変換指示子は、対応する引数の値で置き換えられる。例:
@example
printf("%4d: E%d %.30s", lnum, errno, msg)
@end example
結果は次のような形になる:
@example
"  99: E42 asdfasdfasdfasdfasdfasdfasdfas"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Often used items are:
		  %s	string
		  %6S	string right-aligned in 6 display cells
		  %6s	string right-aligned in 6 bytes
		  %.9s	string truncated to 9 bytes
		  %c	single byte
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
よく使われる変換指示子は次の通り:
@multitable @columnfractions .1 .9
@item %s @tab 文字列
@item %6S @tab 6 表示幅で右揃えした文字列
@item %6s @tab 6 バイトで右揃えした文字列
@item %.9s @tab 9 バイトに切り詰めた文字列
@item %c @tab 1 バイト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		  %d	decimal number
		  %5d	decimal number padded with spaces to 5 characters
		  %x	hex number
		  %04x	hex number padded with zeros to at least 4 characters
		  %X	hex number using upper case letters
		  %o	octal number
		  %08b	binary number padded with zeros to at least 8 chars
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item %d @tab 10 進数値
@item %5d @tab スペースで埋めて 5 文字にした 10 進数値
@item %x @tab 16 進数値
@item %04x @tab 0 で埋めて少なくとも 4 文字にした 16 進数値
@item %X @tab 16 進数値 (大文字)
@item %o @tab 8 進数値
@item %08b @tab 最低 8 文字の 0 埋めされた 2 進数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		  %f	floating point number as 12.23, inf, -inf or nan
		  %F	floating point number as 12.23, INF, -INF or NAN
		  %e	floating point number as 1.23e3, inf, -inf or nan
		  %E	floating point number as 1.23E3, INF, -INF or NAN
		  %g	floating point number, as %f or %e depending on value
		  %G	floating point number, as %F or %E depending on value
		  %%	the % character itself
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item %f @tab 浮動小数点数。12.23, inf, -inf, nan
@item %F @tab 浮動小数点数。12.23, INF, -INF, NAN
@item %e @tab 浮動小数点数。1.23e3, inf, -inf, nan
@item %E @tab 浮動小数点数。1.23E3, INF, -INF, NAN
@item %g @tab 浮動小数点数。値によって %f または %e となる
@item %G @tab 浮動小数点数。値によって %F または %E となる
@item %% @tab 文字 % そのもの
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Conversion specifications start with '%' and end with the
		conversion type.  All other characters are copied unchanged to
		the result.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変換指示子は '%' で始まり、変換文字で終わる。それ以外の全ての文字はそのままになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The "%" starts a conversion specification.  The following
		arguments appear in sequence:

			%  [flags]  [field-width]  [.precision]  type
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"%" は変換指示子の開始を意味する。以下の順序で引数を指定できる:

%  [flags]  [field-width]  [.precision]  type
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		flags
			Zero or more of the following flags:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item フラグ
0 個以上の以下のフラグを指定できる
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		    #	      The value should be converted to an "alternate
			      form".  For c, d, and s conversions, this option
			      has no effect.  For o conversions, the precision
			      of the number is increased to force the first
			      character of the output string to a zero (except
			      if a zero value is printed with an explicit
			      precision of zero).
			      For b and B conversions, a non-zero result has
			      the string "0b" (or "0B" for B conversions)
			      prepended to it.
			      For x and X conversions, a non-zero result has
			      the string "0x" (or "0X" for X conversions)
			      prepended to it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item #
@tab 値を「代替形式」に変換する。変換指示子 c, d, s に対してはこのオプションは効果を持たない。変換指示子 o に対しては数値の精度を上げ、出力文字列の最初の文字が 0 になる。(明示的な精度0で値0が表示されるときを除く)

変換指示子 b と B に対しては、値が 0 でない場合、文字列 "0b" (変換子 B の場合は "0B") を前につける。

変換指示子 x と X に対しては、値が 0 でない場合、文字列 "0x" (変換子 X の場合は "0X") を前につける。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		    0 (zero)  Zero padding.  For all conversions the converted
			      value is padded on the left with zeros rather
			      than blanks.  If a precision is given with a
			      numeric conversion (d, b, B, o, x, and X), the 0
			      flag is ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 0 (zero)
@tab ゼロパディングする。全ての変換に対し、変換された値の左側を空白でなく 0 で埋める。数値変換 (d, b, B, o, x, X) に対して精度が指定されている場合はフラグ 0 は無視される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		    -	      A negative field width flag; the converted value
			      is to be left adjusted on the field boundary.
			      The converted value is padded on the right with
			      blanks, rather than on the left with blanks or
			      zeros.  A - overrides a 0 if both are given.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item -
@tab 負のフィールド幅を示す。変換値がフィールド境界に左揃えされる。変換値の左に空白や 0 がつくのではなく、変換値の右に空白がつく。- と 0 を両方指定した場合は - が有効になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		    ' ' (space)  A blank should be left before a positive
			      number produced by a signed conversion (d).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ' ' (space)
@tab 空白。符号付き変換 (d) で作成される正の数値の前に空白が残る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		    +	      A sign must always be placed before a number
			      produced by a signed conversion.  A + overrides
			      a space if both are used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item +
@tab + 文字。符号付き変換で作成される数値の前に常に符号を付ける。+ と' '(space) を両方指定した場合は + が有効になる。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		field-width
			An optional decimal digit string specifying a minimum
			field width.  If the converted value has fewer bytes
			than the field width, it will be padded with spaces on
			the left (or right, if the left-adjustment flag has
			been given) to fill out the field width.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item フィールド幅
10 進数文字列 (省略可)。最低フィールド幅を指定する。変換値のバイト数がこのフィールド幅より少ない場合、左に空白がついて (左揃えフラグを指定した場合は右に空白がついて) フィールドの幅に合わせられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		.precision
			An optional precision, in the form of a period '.'
			followed by an optional digit string.  If the digit
			string is omitted, the precision is taken as zero.
			This gives the minimum number of digits to appear for
			d, o, x, and X conversions, or the maximum number of
			bytes to be printed from a string for s conversions.
			For floating point it is the number of digits after
			the decimal point.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item .精度
ピリオド '.' の次に数字文字列がつづく形式の精度 (省略可)。数字文字列を省略した場合、精度は 0 になる。d, o, x, X 変換における最低桁数を指定する。また、s 変換における最大バイト数を指定する。浮動小数点数の場合は小数点以下の桁数。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		type
			A character that specifies the type of conversion to
			be applied, see below.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 型
変換の型を指定する 1 文字。下記を参照。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		A field width or precision, or both, may be indicated by an
		asterisk '*' instead of a digit string.  In this case, a
		Number argument supplies the field width or precision.  A
		negative field width is treated as a left adjustment flag
		followed by a positive field width; a negative precision is
		treated as though it were missing.  Example: >
			:echo printf("%d: %.*s", nr, width, line)
<		This limits the length of the text used from "line" to
		"width" bytes.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
フィールド幅と精度には、数字文字列の代わりにアスタリスク '*' を指定できる。その場合、対応する数値の引数がフィールド幅または精度となる。負のフィールド幅を指定すると、絶対値がフィールド幅となり、左揃えフラグがオンになる。負の精度を指定すると、完全に無視される。例:
@example
:echo printf("%d: %.*s", nr, width, line)
@end example
この例は、テキスト "line" の長さを "width" バイトに制限する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The conversion specifiers and their meanings are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変換指示子の意味は以下の通り:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*printf-d* *printf-b* *printf-B* *printf-o*
				*printf-x* *printf-X*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{printf-d}
@anchor{printf-b}
@anchor{printf-B}
@anchor{printf-o}
@anchor{printf-x}
@anchor{printf-X}
@cindex printf-d
@cindex printf-b
@cindex printf-B
@cindex printf-o
@cindex printf-x
@cindex printf-X
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		dbBoxX	The Number argument is converted to signed decimal
			(d), unsigned binary (b and B), unsigned octal (o), or
			unsigned hexadecimal (x and X) notation.  The letters
			"abcdef" are used for x conversions; the letters
			"ABCDEF" are used for X conversions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item dbBoxX
@tab 数値の引数を符号付き 10 進数 (d)、符号なし 2 進数 (b または B)、符号なし 8 進数 (o)、符号なし 16 進数 (x または X) の書式に変換する。x の場合は "abcdef" と小文字を使い、X の場合は "ABCDEF" と大文字を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			The precision, if any, gives the minimum number of
			digits that must appear; if the converted value
			requires fewer digits, it is padded on the left with
			zeros.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

精度が指定されていれば出力する最小桁数を意味する。変換された値を出力するのにそれ以下しか必要としない場合は、左側にゼロを加えて埋める。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			In no case does a non-existent or small field width
			cause truncation of a numeric field; if the result of
			a conversion is wider than the field width, the field
			is expanded to contain the conversion result.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

フィールド幅が存在しない場合や小さすぎる場合でも、数値の幅を切り詰めることは決してない。変換結果がフィールド幅より多くの桁を必要とする場合は、十分な幅に広げられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			The 'h' modifier indicates the argument is 16 bits.
			The 'l' modifier indicates the argument is 32 bits.
			The 'L' modifier indicates the argument is 64 bits.
			Generally, these modifiers are not useful. They are
			ignored when type is known from the argument.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

モディファイア 'h' は引数が 16 ビット引数である事を示す。

モディファイア 'l' は引数が 32 ビット引数である事を示す。

モディファイア 'L' は引数が 64 ビット引数である事を示す。

一般的にモディファイアは便利ではない。引数から型が分かる時には無視されてしまう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		i	alias for d
		D	alias for ld
		U	alias for lu
		O	alias for lo
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item i @tab d のエイリアス
@item D @tab ld のエイリアス
@item U @tab lu のエイリアス
@item O @tab lo のエイリアス
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*printf-c*
		c	The Number argument is converted to a byte, and the
			resulting character is written.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{printf-c}
@cindex printf-c
@item c @tab 引数の数値を1バイトに変換し、結果の文字列を書き出す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*printf-s*
		s	The text of the String argument is used.  If a
			precision is specified, no more bytes than the number
			specified are used.
			If the argument is not a String type, it is
			automatically converted to text with the same format
			as ":echo".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{printf-s}
@cindex printf-s
@item s @tab 引数の文字列を出力する。精度を指定した場合、その数値以下のバイト数のみを書き出す。

引数が文字列型ではない場合、"@command{:echo}" と同じ形式のテキストに自動的に変換される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*printf-S*
		S	The text of the String argument is used.  If a
			precision is specified, no more display cells than the
			number specified are used.  Without the |+multi_byte|
			feature works just like 's'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{printf-S}
@cindex printf-S
@item S @tab 引数の文字列を出力する。精度を指定した場合、その数値以下の表示幅のみを書き出す。|@ref{+multi_byte}| 機能がない場合は 's' と同じ動作になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*printf-f* *E807*
		f F	The Float argument is converted into a string of the
			form 123.456.  The precision specifies the number of
			digits after the decimal point.  When the precision is
			zero the decimal point is omitted.  When the precision
			is not specified 6 is used.  A really big number
			(out of range or dividing by zero) results in "inf"
			or "-inf" with %f (INF or -INF with %F).
			"0.0 / 0.0" results in "nan" with %f (NAN with %F).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{printf-f}
@anchor{E807}
@cindex printf-f
@erindex E807
@item f F @tab Float の引数を 123.456 の形式の文字列に変換する。精度は小数点以下の桁数を指定する。精度が 0 のときは小数点以下は省略される。精度を指定しないときは 6 桁となる。とてつもなく大きい数 (範囲外またはゼロによる除算) のときは %f の場合 "inf" または "-inf" となる (%F の場合は "INF" または "-INF")。"0.0 / 0.0" は %f の場合 "nan" になる (%F の場合は "NAN")。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Example: >
				echo printf("%.2f", 12.115)
<				12.12
			Note that roundoff depends on the system libraries.
			Use |round()| when in doubt.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
echo printf("%.2f", 12.115)
12.12
@end example
@quotation
@strong{Note:} @*
丸めはシステムのライブラリに依存する。心配なときは |@ref{round()}| を使うこと。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*printf-e* *printf-E*
		e E	The Float argument is converted into a string of the
			form 1.234e+03 or 1.234E+03 when using 'E'.  The
			precision specifies the number of digits after the
			decimal point, like with 'f'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{printf-e}
@anchor{printf-E}
@cindex printf-e
@cindex printf-E
@item e E @tab Float の引数を 1.234e+03 という形式 ('E' のときは 1.234E+03) の文字列に変換する。精度は 'f' の場合と同じく小数点以下の桁数を指定する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*printf-g* *printf-G*
		g G	The Float argument is converted like with 'f' if the
			value is between 0.001 (inclusive) and 10000000.0
			(exclusive).  Otherwise 'e' is used for 'g' and 'E'
			for 'G'.  When no precision is specified superfluous
			zeroes and '+' signs are removed, except for the zero
			immediately after the decimal point.  Thus 10000000.0
			results in 1.0e7.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{printf-g}
@anchor{printf-G}
@cindex printf-g
@cindex printf-G
@item g G @tab 0.001 (を含む) から 10000000.0 (を除く) の間の場合は 'f' の形式で変換し、この間にない場合は 'g' は 'e'、'G' は 'E' の形式によって変換する。精度が指定されないときは余分なゼロ (小数点の直後のゼロ以外) と '+' 記号は省かれる。よって 10000000.0 は 1.0e7 になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*printf-%*
		%	A '%' is written.  No argument is converted.  The
			complete conversion specification is "%%".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{printf-%}
@cindex printf-%
@item % @tab 単一の '%' を書き出す。引数は変換しない。完全な変換指定は "%%" となる。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When a Number argument is expected a String argument is also
		accepted and automatically converted.
		When a Float or String argument is expected a Number argument
		is also accepted and automatically converted.
		Any other argument type results in an error message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
数値の引数を受け取る変換指示子には文字列を与えることもできる。変換は自動的に行われる。

浮動小数点数または文字列の引数を受け取る変換指示子には、数値を与えることもできる。変換は自動的に行われる。

それ以外の型の引数を与えるとエラーメッセージが表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*E766* *E767*
		The number of {exprN} arguments must exactly match the number
		of "%" items.  If there are not sufficient or too many
		arguments an error is given.  Up to 18 arguments can be used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E766}
@anchor{E767}
@erindex E766
@erindex E767
@{expr1@} 以降の引数の数と "%" 変換指示子の個数がちょうど一致しなければならない。そうでない場合はエラーとなる。引数は最大 18 個まで使える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
prompt_setcallback({buf}, {expr})			*prompt_setcallback()*
		Set prompt callback for buffer {buf} to {expr}.  When {expr}
		is an empty string the callback is removed.  This has only
		effect if {buf} has 'buftype' set to "prompt".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{prompt_setcallback()}
@findex prompt_setcallback()
@item prompt_setcallback(@{buf@}, @{expr@})
@{buf@} バッファのためのプロンプトコールバックを @{expr@} に設定する。@{expr@} が空文字のとき、コールバックは削除される。@{buf@} の '@option{buftype}' が "@var{prompt}" に設定されているときのみ効果がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The callback is invoked when pressing Enter.  The current
		buffer will always be the prompt buffer.  A new line for a
		prompt is added before invoking the callback, thus the prompt
		for which the callback was invoked will be in the last but one
		line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

コールバックは Enter を押した時に呼び出される。カレントバッファは常にプロンプトバッファになる。プロンプトのための改行は、コールバックが発動する前に追加される。したって、コールバックが呼び出されているプロンプトは、1 行ではない最後になるだろう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If the callback wants to add text to the buffer, it must
		insert it above the last line, since that is where the current
		prompt is.  This can also be done asynchronously.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

もしもコールバックがバッファにテキストを追加しようとするなら、最終行の手前に挿入されなければならない。そこがカレントプロンプトだから。非同期的に行なえる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The callback is invoked with one argument, which is the text
		that was entered at the prompt.  This can be an empty string
		if the user only typed Enter.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

コールバックは 1 つの引数で呼び出される。この引数はプロンプトで入力されたテキストだ。ユーザーが Enter だけを押した時は、空の文字列になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example: >
		   call prompt_setcallback(bufnr(''), function('s:TextEntered'))
		   func s:TextEntered(text)
		     if a:text == 'exit' || a:text == 'quit'
		       stopinsert
		       close
		     else
		       call append(line('$') - 1, 'Entered: "' . a:text . '"')
		       " Reset 'modified' to allow the buffer to be closed.
		       set nomodified
		     endif
		   endfunc
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@verbatim
call prompt_setcallback(bufnr(''), function('s:TextEntered'))
func s:TextEntered(text)
  if a:text == 'exit' || a:text == 'quit'
    stopinsert
    close
  else
    call append(line('$') - 1, 'Entered: "' . a:text . '"')
    " Reset 'modified' to allow the buffer to be closed.
    set nomodified
  endif
endfunc
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
prompt_setinterrupt({buf}, {expr})			*prompt_setinterrupt()*
		Set a callback for buffer {buf} to {expr}.  When {expr} is an
		empty string the callback is removed.  This has only effect if
		{buf} has 'buftype' set to "prompt".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{prompt_setinterrupt()}
@findex prompt_setinterrupt()
@item prompt_setinterrupt(@{buf@}, @{expr@})
@{expr@} するためにバッファ @{buf@} のコールバックを設定する。@{expr@} が空文字のときはコールバックは削除される。これは @{buf@} の '@option{buftype}' に "@var{prompt}" が設定されているときのみ効果がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		This callback will be invoked when pressing CTRL-C in Insert
		mode.  Without setting a callback Vim will exit Insert mode,
		as in any buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このコールバックは挿入モードで @kbd{CTRL-C} を押すことで呼び出される。コールバックの設定がないと、Vim はどのようなバッファであっても、挿入モードを抜けるだろう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
prompt_setprompt({buf}, {text})				*prompt_setprompt()*
		Set prompt for buffer {buf} to {text}.  You most likely want
		{text} to end in a space.
		The result is only visible if {buf} has 'buftype' set to
		"prompt".  Example: >
			call prompt_setprompt(bufnr(''), 'command: ')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{prompt_setprompt()}
@findex prompt_setprompt()
@item prompt_setprompt(@{buf@}, @{text@})
@{buf@} バッファのためのプロンプトを @{text@} に設定する。@{text@} の終わりは 1 つのスペースにしたいに違いない。

もしも @{buf@} の '@option{buftype}' が "@var{prompt}" に設定されているなら、結果は可視のものだけである。例:
@example
call prompt_setprompt(bufnr(''), 'command: ')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
pumvisible()						*pumvisible()*
		Returns non-zero when the popup menu is visible, zero
		otherwise.  See |ins-completion-menu|.
		This can be used to avoid some things that would remove the
		popup menu.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{pumvisible()}
@findex pumvisible()
@item pumvisible()
ポップアップメニューが表示されているときには非 0 を返す。表示されていないときは 0 を返す。|@ref{ins-completion-menu}| を参照。ポップアップメニューを消してしまうような操作を避けるために使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
py3eval({expr})						*py3eval()*
		Evaluate Python expression {expr} and return its result
		converted to Vim data structures.
		Numbers and strings are returned as they are (strings are
		copied though, Unicode strings are additionally converted to
		'encoding').
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{py3eval()}
@findex py3eval()
@item py3eval(@{expr@})
Python の式 @{expr@} を評価して、結果を Vim のデータ形式にして返す。

数値と文字列はそのまま返る (ただし文字列はコピーされ、Unicode から '@option{encoding}' に変換される)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Lists are represented as Vim |List| type.
		Dictionaries are represented as Vim |Dictionary| type with
		keys converted to strings.
		{only available when compiled with the |+python3| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

リストは Vim の |@ref{List}| 型に変換される。

辞書は Vim の |@ref{Dictionary}| 型に変換される。辞書のキーは文字列に変換される。

@{|@ref{+python3}| 機能付きでコンパイルされたときのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*E858* *E859*
pyeval({expr})						*pyeval()*
		Evaluate Python expression {expr} and return its result
		converted to Vim data structures.
		Numbers and strings are returned as they are (strings are
		copied though).
		Lists are represented as Vim |List| type.
		Dictionaries are represented as Vim |Dictionary| type,
		non-string keys result in error.
		{only available when compiled with the |+python| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E858}
@anchor{E859}
@anchor{pyeval()}
@erindex E858
@erindex E859
@findex pyeval()
@item pyeval(@{expr@})
Python の式 @{expr@} を評価して、結果を Vim のデータ形式にして返す。

数値と文字列はそのまま返る (ただし文字列はコピーされる)。

リストは Vim の |@ref{List}| 型に変換される。

辞書は Vim の |@ref{Dictionary}| 型に変換される。文字列ではない辞書のキーはエラーになる。

@{|@ref{+python}| 機能付きでコンパイルされたときのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
pyxeval({expr})						*pyxeval()*
		Evaluate Python expression {expr} and return its result
		converted to Vim data structures.
		Uses Python 2 or 3, see |python_x| and 'pyxversion'.
		See also: |pyeval()|, |py3eval()|
		{only available when compiled with the |+python| or the
		|+python3| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{pyxeval()}
@findex pyxeval()
@item pyxeval(@{expr@})
Python の式 @{expr@} を評価して、結果を Vim のデータ形式にして返す。

Python 2 または 3 を使用する。|@ref{python_x}| と '@option{pyxversion}' を参照。

|@ref{pyeval()}|, |@ref{py3eval()}| も参照。

@{|@ref{+python}| または |@ref{+python3}| 機能付きでコンパイルされたときのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*E726* *E727*
range({expr} [, {max} [, {stride}]])				*range()*
		Returns a |List| with Numbers:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E726}
@anchor{E727}
@anchor{range()}
@erindex E726
@erindex E727
@findex range()
@item range(@{expr@} [, @{max@} [, @{stride@}]])
以下のような数値のリスト |@ref{List}| を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		- If only {expr} is specified: [0, 1, ..., {expr} - 1]
		- If {max} is specified: [{expr}, {expr} + 1, ..., {max}]
		- If {stride} is specified: [{expr}, {expr} + {stride}, ...,
		  {max}] (increasing {expr} with {stride} each time, not
		  producing a value past {max}).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item @{expr@} のみを指定したときは: [0, 1, ..., @{expr@} - 1]
@item @{max@} を指定したときは: [@{expr@}, @{expr@} + 1, ..., @{max@}]
@item @{stride@} を指定したときは: [@{expr@}, @{expr@} + @{stride@}, ..., @{max@}] (@{max@} を超えないように @{expr@} を @{stride@} ずつ増加させる)
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When the maximum is one before the start the result is an
		empty list.  When the maximum is more than one before the
		start this is an error.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最大値が開始位置より 1 だけ前のときは空リストを返す。最大値が開始位置より 1 以上前のときはエラーになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
			range(4)		" [0, 1, 2, 3]
			range(2, 4)		" [2, 3, 4]
			range(2, 9, 3)		" [2, 5, 8]
			range(2, -2, -1)	" [2, 1, 0, -1, -2]
			range(0)		" []
			range(2, 0)		" error!
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@verbatim
range(4)                " [0, 1, 2, 3]
range(2, 4)             " [2, 3, 4]
range(2, 9, 3)          " [2, 5, 8]
range(2, -2, -1)        " [2, 1, 0, -1, -2]
range(0)                " []
range(2, 0)             " エラー！
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*readfile()*
readfile({fname} [, {binary} [, {max}]])
		Read file {fname} and return a |List|, each line of the file
		as an item.  Lines are broken at NL characters.  Macintosh
		files separated with CR will result in a single long line
		(unless a NL appears somewhere).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{readfile()}
@findex readfile()
@item readfile(@{fname@} [, @{binary@} [, @{max@}]])
ファイル @{fname@} を読み込み、各行を要素とするリスト |@ref{List}| を返す。行は NL 文字で終わるものとする。改行文字が CR である Macintosh のファイルは単一の長い行となる (どこかに NL が現れない限り)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		All NUL characters are replaced with a NL character.
		When {binary} contains "b" binary mode is used:
		- When the last line ends in a NL an extra empty list item is
		  added.
		- No CR characters are removed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
すべての NUL 文字は NL 文字に置換される。@{binary@} が "b" を含む場合、次のようにバイナリモードになる:
@itemize
@item 最後の行が NLで終わるときは、リストの末尾に余分な空文字列が追加される。
@item CR 文字を除去しない。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Otherwise:
		- CR characters that appear before a NL are removed.
		- Whether the last line ends in a NL or not does not matter.
		- When 'encoding' is Unicode any UTF-8 byte order mark is
		  removed from the text.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バイナリモードでない場合:
@itemize
@item NL の前に現れる CR 文字を除去する。
@item 最後の行が NL で終わるかどうかは関係ない。
@item '@option{encoding}' が Unicode のときは UTF-8 のバイトオーダーマークは取り除かれる。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When {max} is given this specifies the maximum number of lines
		to be read.  Useful if you only want to check the first ten
		lines of a file: >
			:for line in readfile(fname, '', 10)
			:  if line =~ 'Date' | echo line | endif
			:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{max@} を指定すると、読み込む行数の最大値となる。ファイルの最初の 10 行をチェックするときに役に立つ:
@example
:for line in readfile(fname, '', 10)
:  if line =~ 'Date' | echo line | endif
:endfor
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		When {max} is negative -{max} lines from the end of the file
		are returned, or as many as there are.
		When {max} is zero the result is an empty list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{max@} が負の場合は、ファイルの最後から -@{max@} 行を読み込んで返す。ファイルが @{max@} 行以下の場合は全行を返す。@{max@} が 0 の場合は空リストを返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that without {max} the whole file is read into memory.
		Also note that there is no recognition of encoding.  Read a
		file into a buffer if you need to.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
@{max@} を指定しない場合はファイル全体をメモリに読み込む。エンコーディング判定も行わないことに注意。必要ならバッファに読み込むこと。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When the file can't be opened an error message is given and
		the result is an empty list.
		Also see |writefile()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルを開けないときはエラーメッセージを表示し、空リストを返す。|@ref{writefile()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
reg_executing()						*reg_executing()*
		Returns the single letter name of the register being executed.
		Returns an empty string when no register is being executed.
		See |@|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{reg_executing()}
@findex reg_executing()
@item reg_executing()
実行されているレジスタ名の一文字を返す。実行されているレジスタが無ければ空文字を返す。|@ref{@@}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN

reg_recording()						*reg_recording()*
		Returns the single letter name of the register being recorded.
		Returns an empty string string when not recording.  See |q|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{reg_recording()}
@findex reg_recording()
@item reg_recording()
記録されているレジスタ名の一文字を返す。記録が無ければ空文字を返す。|@ref{q}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
reltime([{start} [, {end}]])				*reltime()*
		Return an item that represents a time value.  The format of
		the item depends on the system.  It can be passed to
		|reltimestr()| to convert it to a string  or |reltimefloat()|
		to convert to a Float.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{reltime()}
@findex reltime()
@item reltime([@{start@} [, @{end@}]])
時刻値を表す値を返す。値の形式はシステムに依存する。この値を |@ref{reltimestr()}| に渡すと文字列に変換でき、|@ref{reltimefloat()}| に渡すと浮動小数点数に変換できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Without an argument it returns the current time.
		With one argument is returns the time passed since the time
		specified in the argument.
		With two arguments it returns the time passed between {start}
		and {end}.
		The {start} and {end} arguments must be values returned by
		reltime().
		{only available when compiled with the |+reltime| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

引数を指定しないと現在時刻を返す。1 個の引数を指定すると、その引数で指定された時刻からの経過時間を返す。2 個の引数を指定すると、@{start@} と @{end@} の間の経過時間を返す。@{start@} と @{end@} は reltime() で返される値でなければならない。

@{|@ref{+reltime}| 機能付きでコンパイルされたときのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
reltimefloat({time})				*reltimefloat()*
		Return a Float that represents the time value of {time}.
		Example: >
			let start = reltime()
			call MyFunction()
			let seconds = reltimefloat(reltime(start))
<		See the note of reltimestr() about overhead.
		Also see |profiling|.
		{only available when compiled with the |+reltime| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{reltimefloat()}
@findex reltimefloat()
@item reltimefloat(@{time@})
@{time@} の値を代わりに浮動小数点で返す。

例:
@example
let start = reltime()
call MyFunction()
let seconds = reltimefloat(reltime(start))
@end example
オーバーヘッドについては reltimestr() の note を参照。|@ref{profiling}| も参照。

@{|@ref{+reltime}| 機能付きでコンパイルされたときのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
reltimestr({time})				*reltimestr()*
		Return a String that represents the time value of {time}.
		This is the number of seconds, a dot and the number of
		microseconds.  Example: >
			let start = reltime()
			call MyFunction()
			echo reltimestr(reltime(start))
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{reltimestr()}
@findex reltimestr()
@item reltimestr(@{time@})
時刻値 @{time@} を表現する文字列を返す。秒、ドット、マイクロ秒という形式になる。例:
@example
let start = reltime()
call MyFunction()
echo reltimestr(reltime(start))
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		Note that overhead for the commands will be added to the time.
		The accuracy depends on the system.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
このコマンドにかかるオーバーヘッドがこの時間に加算される。精度はシステムに依存する。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Leading spaces are used to make the string align nicely.  You
		can use split() to remove it. >
			echo split(reltimestr(reltime(start)))[0]
<		Also see |profiling|.
		{only available when compiled with the |+reltime| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列をきれいに揃えるために、先頭にスペースが挿入される。このスペースを取り除くには split() を使えばよい。
@example
echo split(reltimestr(reltime(start)))[0]
@end example
|@ref{profiling}| も参照。

@{|@ref{+reltime}| 機能付きでコンパイルされたときのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*remote_expr()* *E449*
remote_expr({server}, {string} [, {idvar} [, {timeout}]])
		Send the {string} to {server}.  The string is sent as an
		expression and the result is returned after evaluation.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{remote_expr()}
@anchor{E449}
@findex remote_expr()
@erindex E449
@item remote_expr(@{server@}, @{string@} [, @{idvar@} [, @{timeout@}]])
@{string@} を @{server@} に送信する。@{string@} は式と見なされ、評価した結果が返ってくる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The result must be a String or a |List|.  A |List| is turned
		into a String by joining the items with a line break in
		between (not at the end), like with join(expr, "\n").
		If {idvar} is present and not empty, it is taken as the name
		of a variable and a {serverid} for later use with
		|remote_read()| is stored there.
		If {timeout} is given the read times out after this many
		seconds.  Otherwise a timeout of 600 seconds is used.
		See also |clientserver| |RemoteReply|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
戻り値は文字列かリスト |@ref{List}| でなければならない。リスト |@ref{List}| の場合は要素を連結して文字列に変換される。要素間の区切りは改行文字となる (join(expr, "\n") と同様)。

もしも @{idvar@} が存在して空でなければ、それは変数名として受け取られれ、後で |@ref{remote_read()}| で使われる @{serverid@} がその変数に保存される。

もしも @{timeout@} が与えられているなら、読み込み時間はその秒数まで待つ。そうでなければ、タイムアウトの時間は 600 秒になる。

|@ref{clientserver}| と |@ref{RemoteReply}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		This function is not available in the |sandbox|.
		{only available when compiled with the |+clientserver| feature}
		Note: Any errors will cause a local error message to be issued
		and the result will be the empty string.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{sandbox}| の中ではこの関数は利用できない。

@{|@ref{+clientserver}| 機能付きでコンパイルされたときのみ利用可能@}
@quotation
@strong{Note:} @*
なんらかのエラーが発生した場合は、ローカルでエラーメッセージが表示され、戻り値は空文字列となる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Variables will be evaluated in the global namespace,
		independent of a function currently being active.  Except
		when in debug mode, then local function variables and
		arguments can be evaluated.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数が現在アクティブであるのとは無関係に、変数はグローバルなスコープで評価されるだろう。デバッグモードを除き、ローカル関数の変数と引数は評価されうる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Examples: >
			:echo remote_expr("gvim", "2+2")
			:echo remote_expr("gvim1", "b:current_syntax")
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:echo remote_expr("gvim", "2+2")
:echo remote_expr("gvim1", "b:current_syntax")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
remote_foreground({server})				*remote_foreground()*
		Move the Vim server with the name {server} to the foreground.
		This works like: >
			remote_expr({server}, "foreground()")
<		Except that on Win32 systems the client does the work, to work
		around the problem that the OS doesn't always allow the server
		to bring itself to the foreground.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{remote_foreground()}
@findex remote_foreground()
@item remote_foreground(@{server@})
サーバー名 @{server@} の Vim をフォアグラウンドに移動させる。次を実行するのと同様である:
@example
remote_expr(@{server@}, "foreground()")
@end example
ただし、次の点が異なる: Win32 では、OS が必ずしもサーバーが自分自身をフォアグラウンドにすることを許可しないので、対応策としてクライアントが仕事を行う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note: This does not restore the window if it was minimized,
		like foreground() does.
		This function is not available in the |sandbox|.
		{only in the Win32, Athena, Motif and GTK GUI versions and the
		Win32 console version}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
foreground() と違い、最小化されていたウィンドウを復元しない。
@end quotation
|@ref{sandbox}| の中ではこの関数は利用できない。

@{Win32, Athena, Motif, GTK の GUI 版と Win32 コンソール版でのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
remote_peek({serverid} [, {retvar}])		*remote_peek()*
		Returns a positive number if there are available strings
		from {serverid}.  Copies any reply string into the variable
		{retvar} if specified.  {retvar} must be a string with the
		name of a variable.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{remote_peek()}
@findex remote_peek()
@item remote_peek(@{serverid@} [, @{retvar@}])
@{serverid@} から文字列を取得可能ならば正の数値を返す。変数 @{retvar@} に返信文字列をコピーする。@{retvar@} は変数の名前を示す文字列でなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Returns zero if none are available.
		Returns -1 if something is wrong.
		See also |clientserver|.
		This function is not available in the |sandbox|.
		{only available when compiled with the |+clientserver| feature}
		Examples: >
			:let repl = ""
			:echo "PEEK: ".remote_peek(id, "repl").": ".repl
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
取得できないならば 0 を返す。なんらかの異状のときは -1 を返す。|@ref{clientserver}| も参照。

|@ref{sandbox}| の中ではこの関数は利用できない。

@{|@ref{+clientserver}| 機能付きでコンパイルされたときのみ利用可能@}

例:
@example
:let repl = ""
:echo "PEEK: ".remote_peek(id, "repl").": ".repl
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
remote_read({serverid}, [{timeout}])			*remote_read()*
		Return the oldest available reply from {serverid} and consume
		it.  Unless a {timeout} in seconds is given, it blocks until a
		reply is available.
		See also |clientserver|.
		This function is not available in the |sandbox|.
		{only available when compiled with the |+clientserver| feature}
		Example: >
			:echo remote_read(id)
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{remote_read()}
@findex remote_read()
@item remote_read(@{serverid@}, [@{timeout@}])
@{serverid@} からの返信の中で最も古いものを取り出して返す。取り出した返信はキューから取り除かれる。@{timeout@} が与えられていなければ、返信を取り出せるようになるまで待機する。|@ref{clientserver}| も参照。

|@ref{sandbox}| の中ではこの関数は利用できない。

@{|@ref{+clientserver}| 機能付きでコンパイルされたときのみ利用可能@}

例:
@example
:echo remote_read(id)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*remote_send()* *E241*
remote_send({server}, {string} [, {idvar}])
		Send the {string} to {server}.  The string is sent as input
		keys and the function returns immediately.  At the Vim server
		the keys are not mapped |:map|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{remote_send()}
@anchor{E241}
@findex remote_send()
@erindex E241
@item remote_send(@{server@}, @{string@} [, @{idvar@}])
@{string@} を @{server@} に送信する。@{string@} はキー入力として解釈され、この関数の呼び出しは即座に戻ってくる。Vim サーバーにおいて、受け取ったキー入力はマッピング展開されない。|@ref{:map}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If {idvar} is present, it is taken as the name of a variable
		and a {serverid} for later use with remote_read() is stored
		there.
		See also |clientserver| |RemoteReply|.
		This function is not available in the |sandbox|.
		{only available when compiled with the |+clientserver| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{idvar@} には変数名を指定する。後で remote_read() で使われる @{serverid@} がその変数に保存される。|@ref{clientserver}| と |@ref{RemoteReply}| も参照。

|@ref{sandbox}| の中ではこの関数は利用できない。

@{|@ref{+clientserver}| 機能付きでコンパイルされたときのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Note: Any errors will be reported in the server and may mess
		up the display.
		Examples: >
		:echo remote_send("gvim", ":DropAndReply ".file, "serverid").
		 \ remote_read(serverid)

		:autocmd NONE RemoteReply *
		 \ echo remote_read(expand("<amatch>"))
		:echo remote_send("gvim", ":sleep 10 | echo ".
		 \ 'server2client(expand("<client>"), "HELLO")<CR>')
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
なんらかのエラーが発生すると、サーバー側で報告され、表示が乱れてしまうかもしれない。

例:
@verbatim
:echo remote_send("gvim", ":DropAndReply ".file, "serverid").
 \ remote_read(serverid)

:autocmd NONE RemoteReply *
 \ echo remote_read(expand("<amatch>"))
:echo remote_send("gvim", ":sleep 10 | echo ".
 \ 'server2client(expand("<client>"), "HELLO")<CR>')
@end verbatim
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*remote_startserver()* *E941* *E942*
remote_startserver({name})
		Become the server {name}.  This fails if already running as a
		server, when |v:servername| is not empty.
		{only available when compiled with the |+clientserver| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{remote_startserver()}
@anchor{E941}
@anchor{E942}
@findex remote_startserver()
@erindex E941
@erindex E942
@item remote_startserver(@{name@})
サーバー @{name@} になる。|@ref{v:servername}| が空でないときに、すでにサーバーとして動作しているのであれば失敗する。

@{|@ref{+clientserver}| 機能付きでコンパイルされたときのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
remove({list}, {idx} [, {end}])				*remove()*
		Without {end}: Remove the item at {idx} from |List| {list} and
		return the item.
		With {end}: Remove items from {idx} to {end} (inclusive) and
		return a List with these items.  When {idx} points to the same
		item as {end} a list with one item is returned.  When {end}
		points to an item before {idx} this is an error.
		See |list-index| for possible values of {idx} and {end}.
		Example: >
			:echo "last item: " . remove(mylist, -1)
			:call remove(mylist, 0, 9)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{remove()}
@findex remove()
@item remove(@{list@}, @{idx@} [, @{end@}])
@{end@} を指定しなかった場合: リスト |@ref{List}| @{list@} から @{idx@} 位置の要素を削除し、その要素を返す。

@{end@} を指定した場合: @{idx@} から @{end@} まで (両端を含む) の要素を削除し、それらの要素からなるリストを返す。

@{idx@} と @{end@} が同じ要素を指す場合、1 個の要素からなるリストが返る。@{end@} が @{idx@} より前になる場合、エラーとなる。

@{idx@} と @{end@} として指定できる値については |@ref{list-index}| を参照。

例:
@example
:echo "last item: " . remove(mylist, -1)
:call remove(mylist, 0, 9)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
remove({dict}, {key})
		Remove the entry from {dict} with key {key}.  Example: >
			:echo "removed " . remove(dict, "one")
<		If there is no {key} in {dict} this is an error.

		Use |delete()| to remove a file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item remove(@{dict@}, @{key@})
@{dict@} からキー @{key@} を持つ要素を削除する。例:
@example
:echo "removed " . remove(dict, "one")
@end example
@{dict@} に @{key@} がない場合はエラーになる。ファイルを削除するには |@ref{delete()}| を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
rename({from}, {to})					*rename()*
		Rename the file by the name {from} to the name {to}.  This
		should also work to move files across file systems.  The
		result is a Number, which is 0 if the file was renamed
		successfully, and non-zero when the renaming failed.
		NOTE: If {to} exists it is overwritten without warning.
		This function is not available in the |sandbox|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{rename()}
@findex rename()
@item rename(@{from@}, @{to@})
ファイルの名前を @{from@} から @{to@} へ変える。ファイルシステムを越えてファイルを移動するのにも使用できる。結果は数値で、成功すれば 0、失敗すれば非ゼロになる。
@quotation
@strong{Note:} @*
ファイル @{to@} がすでに存在する場合、警告なしに上書きされる。|@ref{sandbox}| の中ではこの関数は利用できない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
repeat({expr}, {count})					*repeat()*
		Repeat {expr} {count} times and return the concatenated
		result.  Example: >
			:let separator = repeat('-', 80)
<		When {count} is zero or negative the result is empty.
		When {expr} is a |List| the result is {expr} concatenated
		{count} times.  Example: >
			:let longlist = repeat(['a', 'b'], 3)
<		Results in ['a', 'b', 'a', 'b', 'a', 'b'].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{repeat()}
@findex repeat()
@item repeat(@{expr@}, @{count@})
@{expr@} を @{count@} 回繰り返し、連結して返す。例:
@example
:let separator = repeat('-', 80)
@end example
@{count@} が 0 または負のときは空文字列を返す。@{expr@} がリスト |@ref{List}| のときは @{count@} 回連結した結果を返す。例:
@example
:let longlist = repeat(['a', 'b'], 3)
@end example
結果は ['a', 'b', 'a', 'b', 'a', 'b'] となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
resolve({filename})					*resolve()* *E655*
		On MS-Windows, when {filename} is a shortcut (a .lnk file),
		returns the path the shortcut points to in a simplified form.
		On Unix, repeat resolving symbolic links in all path
		components of {filename} and return the simplified result.
		To cope with link cycles, resolving of symbolic links is
		stopped after 100 iterations.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{resolve()}
@anchor{E655}
@findex resolve()
@erindex E655
@item resolve(@{filename@})
MS-Windows では @{filename@} がショートカット (.lnkファイル) ならばその指す先を単純化した形式で返す。Unix ではパス @{filename@} の中の全てのシンボリックリンクを解決し、単純化して返す。循環リンクがある場合に備えて、シンボリックリンクの解決は 100 回までに制限されている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		On other systems, return the simplified {filename}.
		The simplification step is done as by |simplify()|.
		resolve() keeps a leading path component specifying the
		current directory (provided the result is still a relative
		path name) and also keeps a trailing path separator.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

その他のシステムでは @{filename@} を単純化して返す。単純化の手順は |@ref{simplify()}| と同じである。resolve() は (結果も相対パスであるならば) カレントディレクトリを表す先頭のパスコンポーネントと、末尾のパス区切り文字をそのままにする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*reverse()*
reverse({list})	Reverse the order of items in {list} in-place.  Returns
		{list}.
		If you want a list to remain unmodified make a copy first: >
			:let revlist = reverse(copy(mylist))
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{reverse()}
@findex reverse()
@item reverse(@{list@})
@{list@} の要素の順序をその場で (in-place) 反転させる。@{list@} そのものを返す。リストを変更させないでおくには、最初にコピーを作る:
@example
:let revlist = reverse(copy(mylist))
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
round({expr})							*round()*
		Round off {expr} to the nearest integral value and return it
		as a |Float|.  If {expr} lies halfway between two integral
		values, then use the larger one (away from zero).
		{expr} must evaluate to a |Float| or a |Number|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item round(@{expr@})
@anchor{round()}
@findex round()
@{expr@} を最も近い整数に丸め、|@ref{Float}| を返す。@{expr@} が 2 つの整数の真ん中にある場合、大きい方 (0 から遠い方) になる。@{訳注: つまり四捨五入になる@}

@{expr@} は |@ref{Float}| または |@ref{Number}| に評価されなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
			echo round(0.456)
<			0.0  >
			echo round(4.5)
<			5.0 >
			echo round(-4.5)
<			-5.0
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
echo round(0.456)
0.0
echo round(4.5)
5.0
echo round(-4.5)
-5.0
@end example

@{|@ref{+float}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
screenattr({row}, {col})					*screenattr()*
		Like |screenchar()|, but return the attribute.  This is a rather
		arbitrary number that can only be used to compare to the
		attribute at other positions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{screenattr()}
@findex screenattr()
@item screenattr(@{row@}, @{col@})
|@ref{screenchar()}| と同様だが、属性を返す。これは他の位置の属性と比較するのに利用できるだけの適当な数値である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
screenchar({row}, {col})					*screenchar()*
		The result is a Number, which is the character at position
		[row, col] on the screen.  This works for every possible
		screen position, also status lines, window separators and the
		command line.  The top left position is row one, column one
		The character excludes composing characters.  For double-byte
		encodings it may only be the first byte.
		This is mainly to be used for testing.
		Returns -1 when row or col is out of range.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{screenchar()}
@findex screenchar()
@item screenchar(@{row@}, @{col@})
スクリーン上の位置 [row, col] の文字を数値で返す。これは全てのスクリーン位置、ステータスライン、ウィンドウセパレータ、コマンドラインで機能する。左上の位置は行番号が 1、列番号が 1 である。文字は合成文字を除く。2 バイトのエンコーディングでは最初のバイトだけであるかもしれない。

この関数は主にテスト用に使われる。row か col が範囲外である場合は -1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
screencol()							*screencol()*
		The result is a Number, which is the current screen column of
		the cursor. The leftmost column has number 1.
		This function is mainly used for testing.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{screencol()}
@findex screencol()
@item screencol()
現在のカーソルのスクリーン列を数値で返す。一番左の列番号は 1。この関数は主にテスト用。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Note: Always returns the current screen column, thus if used
		in a command (e.g. ":echo screencol()") it will return the
		column inside the command line, which is 1 when the command is
		executed. To get the cursor position in the file use one of
		the following mappings: >
			nnoremap <expr> GG ":echom ".screencol()."\n"
			nnoremap <silent> GG :echom screencol()<CR>
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
常に現在のスクリーン列を返す。したがって、コマンドで使われた場合 (例えば ":echo screencol()") は、コマンドライン内の列を返す (つまりコマンドが実行されたときその値は 1)。ファイル内でのカーソル位置を取得するには次のようなマップを使用する:
@example
nnoremap <expr> GG ":echom ".screencol()."\n"
nnoremap <silent> GG :echom screencol()<CR>
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
screenrow()							*screenrow()*
		The result is a Number, which is the current screen row of the
		cursor.  The top line has number one.
		This function is mainly used for testing.
		Alternatively you can use |winline()|.

		Note: Same restrictions as with |screencol()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{screenrow()}
@findex screenrow()
@item screenrow()
現在のカーソルのスクリーン行を数値で返す。一番上の行番号は 1。この関数は主にテスト用。代用として |@ref{winline()}| を使う事ができる。
@quotation
@strong{Note:} @*
|@ref{screencol()}| と同様の制約あり。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
search({pattern} [, {flags} [, {stopline} [, {timeout}]]])	*search()*
		Search for regexp pattern {pattern}.  The search starts at the
		cursor position (you can use |cursor()| to set it).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{search()}
@findex search()
@item search(@{pattern@} [, @{flags@} [, @{stopline@} [, @{timeout@}]]])
正規表現パターン @{pattern@} を検索する。検索はカーソル位置から開始する (検索位置を指定するには |@ref{cursor()}| を使えばよい)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When a match has been found its line number is returned.
		If there is no match a 0 is returned and the cursor doesn't
		move.  No error message is given.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マッチが見つかった場合はその行番号を返す。マッチがない場合は 0 を返し、カーソルは移動しない。エラーメッセージは表示されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{flags} is a String, which can contain these character flags:
		'b'	search Backward instead of forward
		'c'	accept a match at the Cursor position
		'e'	move to the End of the match
		'n'	do Not move the cursor
		'p'	return number of matching sub-Pattern (see below)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{flags@} は以下のフラグ文字からなる文字列:
@multitable @columnfractions .1 .9
@item 'b' @tab 後方 (上方) に検索する
@item 'c' @tab カーソル位置のマッチを受け入れる
@item 'e' @tab マッチの末尾へ移動する
@item 'n' @tab カーソルを移動させない
@item 'p' @tab 部分パターン (後述) のマッチの番号を返す
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		's'	Set the ' mark at the previous location of the cursor
		'w'	Wrap around the end of the file
		'W'	don't Wrap around the end of the file
		'z'	start searching at the cursor column instead of zero
		If neither 'w' or 'W' is given, the 'wrapscan' option applies.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 's' @tab 以前のカーソル位置をマーク ' に記録する
@item 'w' @tab ファイルの末尾で循環する
@item 'W' @tab ファイルの末尾で循環しない
@item 'z' @tab 0桁目からではなく、カーソル位置の桁から検索を開始する
@end multitable
'w' と 'W' の両方とも指定されない場合は '@option{wrapscan}' が適用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If the 's' flag is supplied, the ' mark is set, only if the
		cursor is moved. The 's' flag cannot be combined with the 'n'
		flag.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
フラグ 's' が指定された場合、カーソルが移動したときのみマーク ' が設定される。フラグ 's' は 'n' と組み合わせることはできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		'ignorecase', 'smartcase' and 'magic' are used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{ignorecase}', '@option{smartcase}', '@option{magic}' が適用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When the 'z' flag is not given, searching always starts in
		column zero and then matches before the cursor are skipped.
		When the 'c' flag is present in 'cpo' the next search starts
		after the match.  Without the 'c' flag the next search starts
		one column further.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
フラグ 'z' が指定されない場合、常に0列目から開始して検索する。そして、カーソルの前にあるマッチはスキップされる。'cpo' 内に 'c' フラグが存在する場合、次の検索はそのマッチの後から始まる。'cpo' 内に 'c' フラグが存在しない場合、次の検索は現在のカーソル位置から 1 桁進んで始まる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When the {stopline} argument is given then the search stops
		after searching this line.  This is useful to restrict the
		search to a range of lines.  Examples: >
			let match = search('(', 'b', line("w0"))
			let end = search('END', '', line("w$"))
<		When {stopline} is used and it is not zero this also implies
		that the search does not wrap around the end of the file.
		A zero value is equal to not giving the argument.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数 @{stopline@} が指定されたときはこの行を検索した後で検索を停止する。これは検索する行を制限するために有用である。例:
@example
let match = search('(', 'b', line("w0"))
let end = search('END', '', line("w$"))
@end example
@{stopline@} に 0 でない値が指定されたときは、暗黙にファイルの末尾で循環しなくなる。

0 の値は、引数を省略したときと同じになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When the {timeout} argument is given the search stops when
		more than this many milliseconds have passed.  Thus when
		{timeout} is 500 the search stops after half a second.
		The value must not be negative.  A zero value is like not
		giving the argument.
		{only available when compiled with the |+reltime| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{timeout@} が指定された場合、そのミリ秒が経過したところで検索が停止する。つまり、@{timeout@} が 500 なら検索は 500 ミリ秒で停止する。この値は負であってはならない。0 の値は、引数を省略したときと同じになる。

@{|@ref{+reltime}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*search()-sub-match*
		With the 'p' flag the returned value is one more than the
		first sub-match in \(\).  One if none of them matched but the
		whole pattern did match.
		To get the column number too use |searchpos()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{search()-sub-match}
@findex search()-sub-match
フラグ 'p' を指定すると、戻り値は \(\) によるグループ化のうち最初にマッチしたものの番号プラス 1 となる。パターン全体はマッチしたがどのグループもマッチしなかったときは 1 を返す。桁番号を取得するには |@ref{searchpos()}| を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The cursor will be positioned at the match, unless the 'n'
		flag is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
フラグ 'n' が指定されていない場合、マッチ位置にカーソルが移動する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example (goes over all files in the argument list): >
		    :let n = 1
		    :while n <= argc()	    " loop over all files in arglist
		    :  exe "argument " . n
		    :  " start at the last char in the file and wrap for the
		    :  " first search to find match at start of file
		    :  normal G$
		    :  let flags = "w"
		    :  while search("foo", flags) > 0
		    :	 s/foo/bar/g
		    :	 let flags = "W"
		    :  endwhile
		    :  update		    " write the file if modified
		    :  let n = n + 1
		    :endwhile
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例 (引数リストの全ファイルにわたって検索して置換する):
@verbatim
:let n = 1
:while n <= argc()   " arglist中の全ファイルに対してループ
:  exe "argument " . n
:  " ファイルの最後の文字から開始し、循環してファイルの
:  " 最初から検索する
:  normal G$
:  let flags = "w"
:  while search("foo", flags) > 0
:    s/foo/bar/g
:        let flags = "W"
:  endwhile
:  update           " 修正されていればファイルを保存する
:  let n = n + 1
:endwhile
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example for using some flags: >
		    :echo search('\<if\|\(else\)\|\(endif\)', 'ncpe')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
フラグの使い方の例:
@example
:echo search('\<if\|\(else\)\|\(endif\)', 'ncpe')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		This will search for the keywords "if", "else", and "endif"
		under or after the cursor.  Because of the 'p' flag, it
		returns 1, 2, or 3 depending on which keyword is found, or 0
		if the search fails.  With the cursor on the first word of the
		line:
		    if (foo == 0) | let foo = foo + 1 | endif ~
		the function returns 1.  Without the 'c' flag, the function
		finds the "endif" and returns 3.  The same thing happens
		without the 'e' flag if the cursor is on the "f" of "if".
		The 'n' flag tells the function not to move the cursor.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このコマンドは、カーソル下の文字以降からキーワード "if", "else", "endif" のいずれかを検索する。フラグ 'p' により、どのキーワードが見つかったかに応じて 1, 2, 3 を返す。見つからなかったときは 0 を返す。次の行の最初の単語にカーソルをおいて上のコマンドを実行すると:
@example
if (foo == 0) | let foo = foo + 1 | endif
@end example
1 が返る。フラグ 'c' を外すと "endif" にマッチし 3 を返すようになる。カーソルを "if" の "f" の上におき、フラグ 'e' を外して実行しても同じく3が返る。フラグ 'n' によりカーソルは移動しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
searchdecl({name} [, {global} [, {thisblock}]])			*searchdecl()*
		Search for the declaration of {name}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{searchdecl()}
@findex searchdecl()
@item searchdecl(@{name@} [, @{global@} [, @{thisblock@}]])
@{name@} の宣言を検索する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		With a non-zero {global} argument it works like |gD|, find
		first match in the file.  Otherwise it works like |gd|, find
		first match in the function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{global@} が 0 でないときは |@ref{gD}| と同じようにファイル中の最初のマッチを探す。そうでないときは |@ref{gd}| と同じ動作になり、現在の関数内から最初のマッチを探す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		With a non-zero {thisblock} argument matches in a {} block
		that ends before the cursor position are ignored.  Avoids
		finding variable declarations only valid in another scope.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{thisblock@} が 0 でないときはカーソル位置より前の位置で閉じている @{@} ブロックを無視し、そのスコープ内でだけ有効な変数宣言にマッチしないようになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Moves the cursor to the found match.
		Returns zero for success, non-zero for failure.
		Example: >
			if searchdecl('myvar') == 0
			   echo getline('.')
			endif
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マッチを見つけるとその位置へカーソルを移動する。成功すると0を返し、失敗すると非0を返す。

例:
@example
if searchdecl('myvar') == 0
   echo getline('.')
endif
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*searchpair()*
searchpair({start}, {middle}, {end} [, {flags} [, {skip}
				[, {stopline} [, {timeout}]]]])
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{searchpair()}
@findex searchpair()
@item searchpair(@{start@}, @{middle@}, @{end@} [, @{flags@} [, @{skip@} [, @{stopline@} [, @{timeout@}]]]])
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Search for the match of a nested start-end pair.  This can be
		used to find the "endif" that matches an "if", while other
		if/endif pairs in between are ignored.
		The search starts at the cursor.  The default is to search
		forward, include 'b' in {flags} to search backward.
		If a match is found, the cursor is positioned at it and the
		line number is returned.  If no match is found 0 or -1 is
		returned and the cursor doesn't move.  No error message is
		given.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ネストした start・end のペアを検索する。これを使うと、"if" に対応する "endif" を見つけることができる。それらの間にある他の if・endif のペアは無視される。

検索はカーソル位置から開始する。デフォルトでは下方に検索する。

@{flags@} に 'b' が含まれていると上方に検索する。マッチが見つかると、その位置へカーソルを移動し、行番号を返す。マッチが見つからなかったときは 0 または -1 を返し、カーソルは移動しない。エラーメッセージは表示されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{start}, {middle} and {end} are patterns, see |pattern|.  They
		must not contain \( \) pairs.  Use of \%( \) is allowed.  When
		{middle} is not empty, it is found when searching from either
		direction, but only when not in a nested start-end pair.  A
		typical use is: >
			searchpair('\<if\>', '\<else\>', '\<endif\>')
<		By leaving {middle} empty the "else" is skipped.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{start@}、@{middle@}、@{end@} は正規表現である。|@ref{pattern}| を参照。この正規表現に \( \) のペアを含めてはならない。\%( \) は含めてもよい。@{middle@} はネストした start・end ペアの中にないときのみマッチする。典型的な使用例:
@example
searchpair('\<if\>', '\<else\>', '\<endif\>')
@end example
ここで @{middle@} を空にすると "else" をスキップするようになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{flags} 'b', 'c', 'n', 's', 'w' and 'W' are used like with
		|search()|.  Additionally:
		'r'	Repeat until no more matches found; will find the
			outer pair.  Implies the 'W' flag.
		'm'	Return number of matches instead of line number with
			the match; will be > 1 when 'r' is used.
		Note: it's nearly always a good idea to use the 'W' flag, to
		avoid wrapping around the end of the file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{flags@} には |@ref{search()}| と同様に 'b', 'c', 'n', 's', 'w', 'W' が使える。それに加えて以下のフラグが利用できる。
@multitable @columnfractions .1 .9
@item 'r' @tab それ以上マッチが見つからなくなるまで繰り返す。つまり最も外側のペアを探す。'W' も自動的にオンになる。
@item 'm' @tab マッチ位置の行番号でなくマッチの個数を返す。'r' を使っているときは > 1 となる。
@end multitable
@quotation
@strong{Note:} @*
ほとんど常に 'W' を使ってファイルの末尾で循環しないようにするのがよい考えである。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When a match for {start}, {middle} or {end} is found, the
		{skip} expression is evaluated with the cursor positioned on
		the start of the match.  It should return non-zero if this
		match is to be skipped.  E.g., because it is inside a comment
		or a string.
		When {skip} is omitted or empty, every match is accepted.
		When evaluating {skip} causes an error the search is aborted
		and -1 returned.
		{skip} can be a string, a lambda, a funcref or a partial.
		Anything else makes the function fail.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{start@}、@{middle@}、@{end@} のマッチが見つかると、マッチの開始位置にカーソルを移動し、式 @{skip@} を評価する。このマッチがコメントや文字列の内側にある場合など、無視したいものであれば式 @{skip@} が非 0 を返すようにする。

@{skip@} を省略した、または空のときはどのマッチも無視しない。

@{skip@} を評価している最中にエラーが発生すると、検索は異常終了し -1 を返す。

@{skip@} は文字列、ラムダ、関数参照、部分適用になることができる。

他のものでは関数が失敗する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For {stopline} and {timeout} see |search()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{stopline@} と @{timeout@} については |@ref{search()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The value of 'ignorecase' is used.  'magic' is ignored, the
		patterns are used like it's on.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{ignorecase}' の値が適用される。'@option{magic}' の値は無視され、オンのときと同じ様に動作する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The search starts exactly at the cursor.  A match with
		{start}, {middle} or {end} at the next character, in the
		direction of searching, is the first one found.  Example: >
			if 1
			  if 2
			  endif 2
			endif 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
検索はカーソル位置から開始する。検索方向の次の文字における @{start@}、@{middle@}、@{end@} のマッチが最初に見つかる。例:
@example
if 1
  if 2
  endif 2
endif 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		When starting at the "if 2", with the cursor on the "i", and
		searching forwards, the "endif 2" is found.  When starting on
		the character just before the "if 2", the "endif 1" will be
		found.  That's because the "if 2" will be found first, and
		then this is considered to be a nested if/endif from "if 2" to
		"endif 2".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カーソルが "if 2" の "i" の上にある状態から下方に検索を開始すると "endif 2" にマッチする。"if 2" の直前の文字の上から検索を開始すると "endif 1" にマッチする。これは、"if 2" が最初に見つかり、"if 2" から "endif 2" までがネストしたペアと見なされるためである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When searching backwards and {end} is more than one character,
		it may be useful to put "\zs" at the end of the pattern, so
		that when the cursor is inside a match with the end it finds
		the matching start.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

上方検索で、@{end@} が 2 文字以上であるときはパターンの最後に "\zs" をつけるとよいかもしれない。するとカーソルが end のマッチの内側にあるとき、対応する start を見つけるようになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example, to find the "endif" command in a Vim script: >

	:echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',
			\ 'getline(".") =~ "^\\s*\""')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例: Vim script の "endif" コマンドを見つけるには:
@example
:echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',
                \ 'getline(".") =~ "^\\s*\""')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		The cursor must be at or after the "if" for which a match is
		to be found.  Note that single-quote strings are used to avoid
		having to double the backslashes.  The skip expression only
		catches comments at the start of a line, not after a command.
		Also, a word "en" or "if" halfway a line is considered a
		match.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これを使うには、マッチを見つけたい "if" の上、またはそれ以降にカーソルを置くこと。
@quotation
@strong{Note:} @*
バックスラッシュを二重にしなくてもよいようにシングルクォート文字列を使っている。式 skip により、コメントだけの行を無視するようにしている。コマンドの後のコメントは無視していない。また、行の途中の "en" や "if" という単語にマッチしてしまう。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Another example, to search for the matching "{" of a "}": >

	:echo searchpair('{', '', '}', 'bW')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

もう 1 つの例: "@}" に対応する "@{" を検索する:
@example
:echo searchpair('@{', '', '@}', 'bW')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		This works when the cursor is at or before the "}" for which a
		match is to be found.  To reject matches that syntax
		highlighting recognized as strings: >

	:echo searchpair('{', '', '}', 'bW',
	     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これを使うには、マッチを見つけたい "@}" の上、または前にカーソルを置くこと。構文ハイライトにより文字列と見なされるマッチを無視するには次のようにする:
@example
:echo searchpair('@{', '', '@}', 'bW',
     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*searchpairpos()*
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip}
				[, {stopline} [, {timeout}]]]])
		Same as |searchpair()|, but returns a |List| with the line and
		column position of the match. The first element of the |List|
		is the line number and the second element is the byte index of
		the column position of the match.  If no match is found,
		returns [0, 0]. >

			:let [lnum,col] = searchpairpos('{', '', '}', 'n')
<
		See |match-parens| for a bigger and more useful example.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{searchpairpos()}
@findex searchpairpos()
@item searchpairpos(@{start@}, @{middle@}, @{end@} [, @{flags@} [, @{skip@} [, @{stopline@} [, @{timeout@}]]]])
|@ref{searchpair()}| と同様だが、マッチの行番号と桁番号からなるリスト |@ref{List}| を返す。このリスト |@ref{List}| の最初の要素は行番号で、次の要素はマッチの桁位置のバイトインデックスである。マッチが見つからなかった場合は [0, 0] を返す。
@example
:let [lnum,col] = searchpairpos('@{', '', '@}', 'n')
@end example
より大規模で役に立つ例に関しては |@ref{match-parens}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]])	*searchpos()*
		Same as |search()|, but returns a |List| with the line and
		column position of the match. The first element of the |List|
		is the line number and the second element is the byte index of
		the column position of the match. If no match is found,
		returns [0, 0].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{searchpos()}
@findex searchpos()
@item searchpos(@{pattern@} [, @{flags@} [, @{stopline@} [, @{timeout@}]]])
|@ref{search()}| と同様だが、マッチの行番号と桁番号からなるリスト |@ref{List}| を返す。このリスト |@ref{List}| の最初の要素は行番号で、次の要素はマッチの桁位置のバイトインデックスである。マッチが見つからなかった場合は [0, 0] を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example: >
	:let [lnum, col] = searchpos('mypattern', 'n')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:let [lnum, col] = searchpos('mypattern', 'n')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		When the 'p' flag is given then there is an extra item with
		the sub-pattern match number |search()-sub-match|.  Example: >
	:let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')
<		In this example "submatch" is 2 when a lowercase letter is
		found |/\l|, 3 when an uppercase letter is found |/\u|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
フラグ 'p' を指定すると、戻り値にサブパターンのマッチ番号を示す要素が加わる |@ref{search()-sub-match}|。例:
@example
:let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')
@end example
この例において、"submatch" は小文字 |@ref{/\l}| が見つかったとき2となり、大文字 |@ref{/\u}| が見つかったとき 3 となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
server2client({clientid}, {string})			*server2client()*
		Send a reply string to {clientid}.  The most recent {clientid}
		that sent a string can be retrieved with expand("<client>").
		{only available when compiled with the |+clientserver| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{server2client()}
@findex server2client()
@item server2client(@{clientid@}, @{string@})
@{clientid@} に返信文字列を送る。最後に文字列を送った @{clientid@} は expand("<client>") で取得できる。

@{|@ref{+clientserver}| 機能付きでコンパイルしたときのみ利用可能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note:
		This id has to be stored before the next command can be
		received.  I.e. before returning from the received command and
		before calling any commands that waits for input.
		See also |clientserver|.
		Example: >
			:echo server2client(expand("<client>"), "HELLO")
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
この ID は次のコマンドを受け取る前に取得しなければならない。つまり、受け取ったコマンドから戻る前で、入力を待つコマンドを呼ぶ前。|@ref{clientserver}| も参照。

例:
@example
:echo server2client(expand("<client>"), "HELLO")
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
serverlist()					*serverlist()*
		Return a list of available server names, one per line.
		When there are no servers or the information is not available
		an empty string is returned.  See also |clientserver|.
		{only available when compiled with the |+clientserver| feature}
		Example: >
			:echo serverlist()
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{serverlist()}
@findex serverlist()
@item serverlist()
利用可能なサーバー名のリストを返す。1 行に 1 つの形式。サーバーが 1 つもないとき、または情報を取得できないときは空文字列を返す。|@ref{clientserver}| も参照。

@{|@ref{+clientserver}| 機能付きでコンパイルしたときのみ利用可能@}

例:
@example
:echo serverlist()
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
setbufline({expr}, {lnum}, {text})			*setbufline()*
		Set line {lnum} to {text} in buffer {expr}.  To insert
		lines use |append()|.

		For the use of {expr}, see |bufname()| above.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{setbufline()}
@findex setbufline()
@item setbufline(@{expr@}, @{lnum@}, @{text@})
バッファ @{expr@} の @{text@} に行 @{lnum@} を設定する。行を挿入するには |@ref{append()}| を使う。

@{expr@} の使い方については、上記の |@ref{bufname()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{lnum} is used like with |setline()|.
		This works like |setline()| for the specified buffer.
		On success 0 is returned, on failure 1 is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{lnum@} は |@ref{setline()}| と同じように使われる。明示されたバッファへの |@ref{setline()}| と同じように働く。成功ならば 0 を、失敗なら 1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {expr} is not a valid buffer or {lnum} is not valid, an
		error message is given.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もしも @{expr@} が妥当なバッファでないか @{lnum@} が妥当でなければ、エラーメッセージを受け取る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
setbufvar({expr}, {varname}, {val})			*setbufvar()*
		Set option or local variable {varname} in buffer {expr} to
		{val}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{setbufvar()}
@findex setbufvar()
@item setbufvar(@{expr@}, @{varname@}, @{val@})
バッファ @{expr@} のオプションまたはローカル変数 @{varname@} に @{val@} を代入する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		This also works for a global or local window option, but it
		doesn't work for a global or local window variable.
		For a local window option the global value is unchanged.
		For the use of {expr}, see |bufname()| above.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
グローバル・ウィンドウローカルオプションに対しても動作するが、グローバル・ウィンドウローカル変数に対しては動作しない。ウィンドウローカルオプションの場合、グローバルな値は変更されない。@{expr@} の解釈の仕方については |@ref{bufname()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that the variable name without "b:" must be used.
		Examples: >
			:call setbufvar(1, "&mod", 1)
			:call setbufvar("todo", "myvar", "foobar")
<		This function is not available in the |sandbox|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
変数名には "b:" をつけてはならない。

例:
@example
:call setbufvar(1, "&mod", 1)
:call setbufvar("todo", "myvar", "foobar")
@end example
サンドボックス |@ref{sandbox}| の中ではこの関数は使用できない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
setcharsearch({dict})					*setcharsearch()*
		Set the current character search information to {dict},
		which contains one or more of the following entries:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{setcharsearch()}
@findex setcharsearch()
@item setcharsearch(@{dict@})
現在の文字検索の情報を @{dict@} に設定する。この辞書は下記のエントリを 1 以上持つ:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		    char	character which will be used for a subsequent
				|,| or |;| command; an empty string clears the
				character search
		    forward	direction of character search; 1 for forward,
				0 for backward
		    until	type of character search; 1 for a |t| or |T|
				character search, 0 for an |f| or |F|
				character search
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item char @tab 続いて起こる |@ref{@comma{}}| や |@ref{;}| コマンドで使われる文字。空文字列の場合、文字検索を解除する。
@item forward @tab 文字検索の方向。1 は前方、0 は後方。
@item until @tab 文字検索の種類。1 は |@ref{t}| もしくは |@ref{T}| の文字検索、0 は |@ref{f}| もしくは |@ref{F}| の文字検索。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		This can be useful to save/restore a user's character search
		from a script: >
			:let prevsearch = getcharsearch()
			:" Perform a command which clobbers user's search
			:call setcharsearch(prevsearch)
<		Also see |getcharsearch()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはユーザーの文字検索のセーブ/リストアを使うことができる:
@example
:let prevsearch = getcharsearch()
:" ユーザーの検索に影響を与えるコマンドを実行する。
:call setcharsearch(prevsearch)
@end example
|@ref{getcharsearch()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
setcmdpos({pos})					*setcmdpos()*
		Set the cursor position in the command line to byte position
		{pos}.  The first position is 1.
		Use |getcmdpos()| to obtain the current position.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{setcmdpos()}
@findex setcmdpos()
@item setcmdpos(@{pos@})
コマンドラインの @{pos@} バイトの位置へカーソルを移動する。@{pos@} は 1 から始まる。現在の位置を取得するには |@ref{getcmdpos()}| を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Only works while editing the command line, thus you must use
		|c_CTRL-\_e|, |c_CTRL-R_=| or |c_CTRL-R_CTRL-R| with '='.  For
		|c_CTRL-\_e| and |c_CTRL-R_CTRL-R| with '=' the position is
		set after the command line is set to the expression.  For
		|c_CTRL-R_=| it is set after evaluating the expression but
		before inserting the resulting text.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

コマンドラインを編集している最中のみ機能する。よって、|@ref{c_CTRL-\_e}|, |@ref{c_CTRL-R_=}|, |@ref{c_CTRL-R_CTRL-R}| ＋ '=' と組み合わせて使うときだけ意味がある。

|@ref{c_CTRL-\_e}| と |@ref{c_CTRL-R_CTRL-R}| ＋ '=' の場合、コマンドラインにその式をセットした後でカーソルを移動する。

|@ref{c_CTRL-R_=}| の場合、式を評価した後、結果のテキストを挿入する前にカーソルを移動する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When the number is too big the cursor is put at the end of the
		line.  A number smaller than one has undefined results.
		Returns 0 when successful, 1 when not editing the command
		line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@{pos@} が大きすぎるときは行末にカーソルを移動する。@{pos@} が 1 より小さいときの結果は未定義である。成功なら 0、コマンドラインを編集しているとき以外には 1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
setfperm({fname}, {mode})				*setfperm()* *chmod*
		Set the file permissions for {fname} to {mode}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{setfperm()}
@anchor{chmod}
@findex setfperm()
@cindex chmod
@item setfperm(@{fname@}, @{mode@})
@{fname@} のファイル許可属性を @{mode@} に設定する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{mode} must be a string with 9 characters.  It is of the form
		"rwxrwxrwx", where each group of "rwx" flags represent, in
		turn, the permissions of the owner of the file, the group the
		file belongs to, and other users.  A '-' character means the
		permission is off, any other character means on.  Multi-byte
		characters are not supported.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{mode@} は 9 文字の文字列でなければならない。形式は "rwxrwxrwx" であり、それぞれはファイルの所有者権限、グループ権限、その他のユーザーを表す "rwx" というフラグのグループである。文字 "-" は許可属性がオフであり、その他の文字はオンである。マルチバイト文字はサポートされない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For example "rw-r-----" means read-write for the user,
		readable by the group, not accessible by others.  "xx-x-----"
		would do the same thing.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば "@samp{rw-r-----}" はそのユーザーの読み書き、グループでは読み取り専用、その他のユーザーはアクセス不可である。"@samp{xx-x-----}" は同じ意味となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Returns non-zero for success, zero for failure.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
成功するとゼロ以外を返し、失敗するとゼロを返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		To read permissions see |getfperm()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
許可属性の読み取りについては |@ref{getfperm()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
setline({lnum}, {text})					*setline()*
		Set line {lnum} of the current buffer to {text}.  To insert
		lines use |append()|. To set lines in another buffer use
		|setbufline()|.

		{lnum} is used like with |getline()|.
		When {lnum} is just below the last line the {text} will be
		added as a new line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{setline()}
@findex setline()
@item setline(@{lnum@}, @{text@})
カレントバッファの @{lnum@} 行目を @{text@} にする。行を挿入したい場合は |@ref{append()}| を使う。他のバッファの行を設定するには |@ref{setbufline()}| を使う。

@{lnum@} は |@ref{getline()}| のときと同じように解釈される。

@{lnum@} が最後の行の次の行の場合、新規行として @{text@} を追加する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If this succeeds, 0 is returned.  If this fails (most likely
		because {lnum} is invalid) 1 is returned.

		Example: >
			:call setline(5, strftime("%c"))
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
成功したら 0 を返す。失敗したら (大抵 @{lnum@} が無効な値のとき) 1 を返す。

例:
@example
:call setline(5, strftime("%c"))
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		When {text} is a |List| then line {lnum} and following lines
		will be set to the items in the list.  Example: >
			:call setline(5, ['aaa', 'bbb', 'ccc'])
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{text@} がリスト |@ref{List}| の場合、@{lnum@} 行目とそれ以降の行にリストの要素をセットする。例:
@example
:call setline(5, ['aaa', 'bbb', 'ccc'])
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		This is equivalent to: >
			:for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]
			:  call setline(n, l)
			:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上の例は次と同値である:
@example
:for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]
:  call setline(n, l)
:endfor
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		Note: The '[ and '] marks are not set.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
マーク '[ と '] はセットされない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
setloclist({nr}, {list} [, {action} [, {what}]])		*setloclist()*
		Create or replace or add to the location list for window {nr}.
		{nr} can be the window number or the |window-ID|.
		When {nr} is zero the current window is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{setloclist()}
@findex setloclist()
@item setloclist(@{nr@}, @{list@} [, @{action@} [, @{what@}]])
ウィンドウ @{nr@} のロケーションリストを作成・置き換え・追加する。@{nr@} にはウィンドウ番号または |@ref{window-ID}| が使える。@{nr@} が 0 のときはカレントウィンドウを対象にする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For a location list window, the displayed location list is
		modified.  For an invalid window number {nr}, -1 is returned.
		Otherwise, same as |setqflist()|.
		Also see |location-list|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ロケーションリストウィンドウの場合、そこに表示しているロケーションリストが修正される。ウィンドウ番号 @{nr@} が無効な場合、-1 を返す。それ以外は |@ref{setqflist()}| と同じ。

|@ref{location-list}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If the optional {what} dictionary argument is supplied, then
		only the items listed in {what} are set. Refer to |setqflist()|
		for the list of supported keys in {what}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプショナル引数の辞書 @{what@} が提供される場合、@{what@} で指定されるアイテムのみが設定される。サポートされる @{what@} の一覧は |@ref{setqflist()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
setmatches({list})					*setmatches()*
		Restores a list of matches saved by |getmatches()|.  Returns 0
		if successful, otherwise -1.  All current matches are cleared
		before the list is restored.  See example for |getmatches()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{setmatches()}
@findex setmatches()
@item setmatches(@{list@})
|@ref{getmatches()}| で取得したマッチのリストを復元する。成功なら 0、失敗なら -1 を返す。リストを復元するに先立って、現在のマッチはすべて消去される。|@ref{getmatches()}| の例を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*setpos()*
setpos({expr}, {list})
		Set the position for {expr}.  Possible values:
			.	the cursor
			'x	mark x
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{setpos()}
@findex setpos()
@item setpos(@{expr@}, @{list@})
@{expr@} の位置を設定する。@{expr@} として有効な値は次の通り:
@multitable @columnfractions .1 .9
@item . @tab カーソル位置
@item 'x @tab マーク x
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{list} must be a |List| with four or five numbers:
		    [bufnum, lnum, col, off]
		    [bufnum, lnum, col, off, curswant]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{list@} は 4 個か 5 個の要素を持つリスト |@ref{List}| である:

[bufnum, lnum, col, off]

[bufnum, lnum, col, off, curswant]
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		"bufnum" is the buffer number.  Zero can be used for the
		current buffer.  When setting an uppercase mark "bufnum" is
		used for the mark position.  For other marks it specifies the
		buffer to set the mark in.  You can use the |bufnr()| function
		to turn a file name into a buffer number.
		For setting the cursor and the ' mark "bufnum" is ignored,
		since these are associated with a window, not a buffer.
		Does not change the jumplist.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"bufnum" はバッファ番号。0 にするとカレントバッファを表す。大文字のマークを設定するとき、"bufnum" はマーク位置として用いられる。それ以外のマークの場合、"bufnum" はマークを設定するバッファを指定する。関数 |@ref{bufnr()}| を使ってファイル名をバッファ番号に変換することができる。

カーソルと ' マークを設定する場合、バッファ番号は無視される。なぜならそれらはバッファではなくウィンドウに関連付けられているからである。ジャンプリストは変更されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		"lnum" and "col" are the position in the buffer.  The first
		column is 1.  Use a zero "lnum" to delete a mark.  If "col" is
		smaller than 1 then 1 is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"lnum" と "col" はバッファ内の位置。桁番号は1から始まる。"lnum" を 0 にするとそのマークを削除する。"col" が 1 より小さいときは 1 が使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The "off" number is only used when 'virtualedit' is set. Then
		it is the offset in screen columns from the start of the
		character.  E.g., a position within a <Tab> or after the last
		character.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
数値 "off" は '@option{virtualedit}' がオンのときのみ使われ、その文字の開始位置からの画面上の桁のオフセットとなる。例えば、<Tab> の中、または最後の文字より後に設定したいときに使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The "curswant" number is only used when setting the cursor
		position.  It sets the preferred column for when moving the
		cursor vertically.  When the "curswant" number is missing the
		preferred column is not set.  When it is present and setting a
		mark position it is not used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"curswant" はカーソル位置を設定するときのみ使われる。これは縦方向移動の優先的列番号である。"curswant" を指定しなかった場合は優先値は設定されない。マークの位置を設定するときに "curswant" を指定した場合はその値は使用されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Note that for '< and '> changing the line number may result in
		the marks to be effectively be swapped, so that '< is always
		before '>.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
'< と '> の行番号を変更した場合は '< が '> の手前にくるように位置が交換される。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Returns 0 when the position could be set, -1 otherwise.
		An error message is given if {expr} is invalid.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
位置をセットできたときは 0 を、そうでなければ -1 を返す。@{expr@} が無効なときはエラーメッセージが出る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Also see |getpos()| and |getcurpos()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{getpos()}| と |@ref{getcurpos()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		This does not restore the preferred column for moving
		vertically; if you set the cursor position with this, |j| and
		|k| motions will jump to previous columns!  Use |cursor()| to
		also set the preferred column.  Also see the "curswant" key in
		|winrestview()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
縦方向移動の優先的列番号は復元されない。しかしカーソル位置を設定するときにこの値を設定した場合は、|@ref{j}| や |@ref{k}| で移動すると以前の列にジャンプようになるだろう。優先的列番号の設定については |@ref{cursor()}| も参照。|@ref{winrestview()}| の "curswant" キーも参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
setqflist({list} [, {action} [, {what}]])		*setqflist()*
		Create or replace or add to the quickfix list.

		When {what} is not present, use the items in {list}.  Each
		item must be a dictionary.  Non-dictionary items in {list} are
		ignored.  Each dictionary item can contain the following
		entries:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{setqflist()}
@findex setqflist()
@item setqflist(@{list@} [, @{action@} [, @{what@}]])
@{list@} の要素により QuickFix リストを作成・置き換え・追加する。


@{what@} が存在しないときは @{list@} の要素が使われる。@{list@} の各要素は辞書であること。辞書でない @{list@} の要素は無視される。各辞書は以下の要素を持つ:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		    bufnr	buffer number; must be the number of a valid
				buffer
		    filename	name of a file; only used when "bufnr" is not
				present or it is invalid.
		    module	name of a module; if given it will be used in
				quickfix error window instead of the filename.
		    lnum	line number in the file
		    pattern	search pattern used to locate the error
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item bufnr @tab バッファ番号。有効なバッファ番号でなければならない。
@item filename @tab ファイル名。"bufnr" がないとき、または無効であるときのみ使われる。
@item module @tab モジュールの名前; もしも与えられているなら、ファイル名の代わりに quickfix エラーウィンドウで使われる
@item lnum @tab ファイル中の行番号
@item pattern @tab エラーの位置を特定するための検索パターン
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		    col		column number
		    vcol	when non-zero: "col" is visual column
				when zero: "col" is byte index
		    nr		error number
		    text	description of the error
		    type	single-character error type, 'E', 'W', etc.
		    valid	recognized error message
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item col @tab 桁番号
@item vcol @tab 0 でない場合: "col" は表示上の桁 @* 0 の場合: "col" はバイトインデックス
@item nr @tab エラー番号
@item text @tab エラーの説明
@item type @tab エラータイプを示す 1 文字。'E', 'W' など。
@item valid @tab 認識されたエラーメッセージ
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The "col", "vcol", "nr", "type" and "text" entries are
		optional.  Either "lnum" or "pattern" entry can be used to
		locate a matching error line.
		If the "filename" and "bufnr" entries are not present or
		neither the "lnum" or "pattern" entries are present, then the
		item will not be handled as an error line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
辞書の要素 "col", "vcol", "nr", "type", "text" は省略可能である。"lnum" か "pattern" のどちらか一方のみがエラー行を特定するために使われる。"filename" と "bufnr" の両方ともない場合、または "lnum" と "pattern" の両方ともない場合、その要素はエラー行として扱われない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If both "pattern" and "lnum" are present then "pattern" will
		be used.
		If the "valid" entry is not supplied, then the valid flag is
		set when "bufnr" is a valid buffer or "filename" exists.
		If you supply an empty {list}, the quickfix list will be
		cleared.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"pattern" と "lnum" の両方があるときは "pattern" が使われる。

"valid" なエントリが与えられていないと、"bufnr" が正しいバッファであるか "filename" が存在した時に、正しいフラグを設定する。

@{list@} に空のリストを指定すると QuickFix リストはクリアされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that the list is not exactly the same as what
		|getqflist()| returns.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
このリストは |@ref{getqflist()}| が返すものと正確に同じではないことに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{action} values:				*E927*
		'a'	The items from {list} are added to the existing
			quickfix list. If there is no existing list, then a
			new list is created.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E927}
@erindex E927
@{action@} の値:
@multitable @columnfractions .1 .9
@item 'a' @tab @{list@} の要素を既存の quickfix リストに追加する。quickfix リストがまだ存在しない場合は新規に作成される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		'r'	The items from the current quickfix list are replaced
			with the items from {list}.  This can also be used to
			clear the list: >
				:call setqflist([], 'r')
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 'r' @tab @{list@} の要素で現在の quickFix リストを置き換える。これはリストをクリアするのにも使える:
@example
:call setqflist([], 'r')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		'f'	All the quickfix lists in the quickfix stack are
			freed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 'f' @tab quickfix スタックのすべての quickfix リストは解放される。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {action} is not present or is set to ' ', then a new list
		is created. The new quickfix list is added after the current
		quickfix list in the stack and all the following lists are
		freed. To add a new quickfix list at the end of the stack,
		set "nr" in {what} to "$".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{action@} が指定されないとき、または ' ' のときは新しい quickfix リストを作成する。新しい quickfix リストはスタックの現在の quickfix リストのうしろに追加され、すべての続くリストは解放される。quickfix リストをスタックの最後に 追加するためには、@{what@} の "nr" に "$" を設定する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If the optional {what} dictionary argument is supplied, then
		only the items listed in {what} are set. The first {list}
		argument is ignored.  The following items can be specified in
		{what}:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプショナル引数の辞書 @{what@} が提供される場合、@{what@} で指定されるアイテムのみが設定される。最初の @{list@} は無視される。@{what@} では以下のアイテムを指定する事ができる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		    context	quickfix list context. See |quickfix-context|
		    efm		errorformat to use when parsing text from
				"lines". If this is not present, then the
				'errorformat' option value is used.
		    id		quickfix list identifier |quickfix-ID|
		    items	list of quickfix entries. Same as the {list}
				argument.
		    lines	use 'errorformat' to parse a list of lines and
				add the resulting entries to the quickfix list
				{nr} or {id}.  Only a |List| value is supported.
		    nr		list number in the quickfix stack; zero
				means the current quickfix list and "$" means
				the last quickfix list
		    title	quickfix list title text
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item context @tab quickfix リストのコンテキスト。|@ref{quickfix-context}| を参照
@item efm @tab "lines" からテキストをパースする時に使われる errorformat。もしも存在しなければ '@option{errorformat}' オプションの値が使われる
@item id @tab quickfix リストの識別子 |@ref{quickfix-ID}|
@item items @tab quickfix エントリのリスト。@{list@} 引数と同じ
@item lines @tab 行のリストをパースするために '@option{errorformat}' を使う。その結果は quickfix リスト @{nr@} もしくは @{id@} に追加する。リスト |@ref{List}| の値だけがサポートされる
@item nr @tab quickfix スタックでのリスト番号。ゼロは現在の quickfix リストを意味し、"$" は直前の quickfix リストを意味する
@item title @tab quickfix リストのタイトルテキスト
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Unsupported keys in {what} are ignored.
		If the "nr" item is not present, then the current quickfix list
		is modified. When creating a new quickfix list, "nr" can be
		set to a value one greater than the quickfix stack size.
		When modifying a quickfix list, to guarantee that the correct
		list is modified, "id" should be used instead of "nr" to
		specify the list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{what@} 内でのサポートされていないキーは無視される。"nr" 番目のアイテムが提供されていない場合は現在の quickfix リストが変更される。新しく quickfix リストを作成すると、"nr" は quickfix のスタックサイズよりも大きい値に設定される。quickfix リストが変更されると、リストは正しく変更されることが保証され、リストを特定するために "nr" の代わりに "id" が使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Examples (See also |setqflist-examples|): >
		   :call setqflist([], 'r', {'title': 'My search'})
		   :call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})
		   :call setqflist([], 'a', {'id':qfid, 'lines':["F1:10:L10"]})
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例 (|@ref{setqflist-examples}| も参照):
@example
:call setqflist([], 'r', @{'title': 'My search'@})
:call setqflist([], 'r', @{'nr': 2, 'title': 'Errors'@})
:call setqflist([], 'a', @{'id':qfid, 'lines':["F1:10:L10"]@})
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Returns zero for success, -1 for failure.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
成功なら 0、失敗なら -1 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		This function can be used to create a quickfix list
		independent of the 'errorformat' setting.  Use a command like
		`:cc 1` to jump to the first position.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この関数は '@option{errorformat}' の設定とは無関係に QuickFix リストを作るために使える。その最初のエラーへジャンプするには `@command{:cc 1}` などのコマンドを使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
							*setreg()*
setreg({regname}, {value} [, {options}])
		Set the register {regname} to {value}.
		{value} may be any value returned by |getreg()|, including
		a |List|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{setreg()}
@findex setreg()
@item setreg(@{regname@}, @{value@} [, @{options@}])
レジスタ @{regname@} に @{value@} をセットする。
@{value@} には |@ref{getreg()}| の戻り値ならどんな値でも (リスト |@ref{List}| でも) 指定できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If {options} contains "a" or {regname} is upper case,
		then the value is appended.
		{options} can also contain a register type specification:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{options@} が "a" を含んでいるとき、または @{regname@} が大文字のときは、その値に追加する。
@{options@} は以下のレジスタの種類指定を含んでもよい:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		    "c" or "v"	      |characterwise| mode
		    "l" or "V"	      |linewise| mode
		    "b" or "<CTRL-V>" |blockwise-visual| mode
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .5 .5
@item "c" または "v" @tab |@ref{characterwise}| モード
@item "l" または "V" @tab |@ref{linewise}| モード
@item "b" または "<CTRL-V>" @tab |@ref{blockwise-visual}| モード
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If a number immediately follows "b" or "<CTRL-V>" then this is
		used as the width of the selection - if it is not specified
		then the width of the block is set to the number of characters
		in the longest line (counting a <Tab> as 1 character).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"b" または "<CTRL-V>" の直後に数値を続けると、それが選択範囲の幅となる。これを指定しない場合、選択範囲の幅は一番長い行の文字数となる (<Tab> は 1 文字と数えられる)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {options} contains no register settings, then the default
		is to use character mode unless {value} ends in a <NL> for
		string {value} and linewise mode for list {value}. Blockwise
		mode is never selected automatically.
		Returns zero for success, non-zero for failure.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{options@} にレジスタの設定が何も含まれていないときのデフォルト値は文字モードである。ただし、@{value@} が文字列で末尾が <NL> の場合や @{value@} がリストの場合は行モードになる。矩形モードは明示的に指定しない限り選択されない。
成功なら 0、失敗なら非 0 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*E883*
		Note: you may not use |List| containing more than one item to
		      set search and expression registers. Lists containing no
		      items act like empty strings.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E883}
@erindex E883
@quotation
@strong{Note:} @*
検索レジスタや式レジスタを設定するときは複数の要素を含んだリスト (|@ref{List}|) を指定することはできない。空のリストは空文字列と同様に扱われる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Examples: >
			:call setreg(v:register, @*)
			:call setreg('*', @%, 'ac')
			:call setreg('a', "1\n2\n3", 'b5')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:call setreg(v:register, @@*)
:call setreg('*', @@%, 'ac')
:call setreg('a', "1\n2\n3", 'b5')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		This example shows using the functions to save and restore a
		register: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次の例は、この関数を使ってレジスタを退避・復元する例である:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			:let var_a = getreg('a', 1, 1)
			:let var_amode = getregtype('a')
			    ....
			:call setreg('a', var_a, var_amode)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:let var_a = getreg('a', 1, 1)
:let var_amode = getregtype('a')
    ....
:call setreg('a', var_a, var_amode)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		Note: you may not reliably restore register value
		without using the third argument to |getreg()| as without it
		newlines are represented as newlines AND Nul bytes are
		represented as newlines as well, see |NL-used-for-Nul|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
|@ref{getreg()}| の 3 番目の引数を使用せずにレジスタの内容を完全に復元することはできない。改行文字と Nul 文字がどちらも改行文字として表現されてしまうため。|@ref{NL-used-for-Nul}| 参照。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		You can also change the type of a register by appending
		nothing: >
			:call setreg('a', '', 'al')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
空文字列を追加すると、レジスタの種類を変更することができる:
@example
:call setreg('a', '', 'al')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
settabvar({tabnr}, {varname}, {val})			*settabvar()*
		Set tab-local variable {varname} to {val} in tab page {tabnr}.
		|t:var|
		Note that the variable name without "t:" must be used.
		Tabs are numbered starting with one.
		This function is not available in the |sandbox|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{settabvar()}
@findex settabvar()
@item settabvar(@{tabnr@}, @{varname@}, @{val@})
タブページ @{tabnr@} のタブローカル変数 @{varname@} を @{val@} に設定する。|@ref{t:var}|
@quotation
@strong{Note:} @*
指定する変数名は "t:" を除いた名前。
@end quotation
タブの番号は 1 から始まる。
この関数はサンドボックス |@ref{sandbox}| の中では使えない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
settabwinvar({tabnr}, {winnr}, {varname}, {val})	*settabwinvar()*
		Set option or local variable {varname} in window {winnr} to
		{val}.
		Tabs are numbered starting with one.  For the current tabpage
		use |setwinvar()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{settabwinvar()}
@findex settabwinvar()
@item settabwinvar(@{tabnr@}, @{winnr@}, @{varname@}, @{val@})
ウィンドウ @{winnr@} のオプションやローカル変数 @{varname@} の値を @{val@} にセットする。

タブ番号は 1 から始まる。カレントタブページを対象とする場合は |@ref{setwinvar()}| を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{winnr} can be the window number or the |window-ID|.
		When {winnr} is zero the current window is used.
		This also works for a global or local buffer option, but it
		doesn't work for a global or local buffer variable.
		For a local buffer option the global value is unchanged.
		Note that the variable name without "w:" must be used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{winnr@} にはウィンドウ番号または |@ref{window-ID}| が使える。

@{winnr@} が 0 のときはカレントウィンドウが対象となる。

グローバルオプションやバッファローカルオプションを設定することもできるが、グローバル変数やバッファローカル変数を設定することはできない。

バッファローカルオプションを設定した場合、グローバル値は変更されない。
@quotation
@strong{Note:} @*
変数名には "w:" をつけてはならない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
			:call settabwinvar(1, 1, "&list", 0)
			:call settabwinvar(3, 2, "myvar", "foobar")
<		This function is not available in the |sandbox|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:call settabwinvar(1, 1, "&list", 0)
:call settabwinvar(3, 2, "myvar", "foobar")
@end example
この関数は |@ref{sandbox}| の中では使用できない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
setwinvar({nr}, {varname}, {val})			*setwinvar()*
		Like |settabwinvar()| for the current tab page.
		Examples: >
			:call setwinvar(1, "&list", 0)
			:call setwinvar(2, "myvar", "foobar")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{setwinvar()}
@findex setwinvar()
@item setwinvar(@{nr@}, @{varname@}, @{val@})
|@ref{settabwinvar()}| と同様。カレントタブページを対象とする。

例:
@example
:call setwinvar(1, "&list", 0)
:call setwinvar(2, "myvar", "foobar")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
sha256({string})						*sha256()*
		Returns a String with 64 hex characters, which is the SHA256
		checksum of {string}.
		{only available when compiled with the |+cryptv| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sha256()}
@findex sha256()
@item sha256(@{string@})
@{string@} の SHA256 チェックサムを 64 文字の 16 進文字列で返す。

@{|@ref{+cryptv}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
shellescape({string} [, {special}])			*shellescape()*
		Escape {string} for use as a shell command argument.
		On MS-Windows and MS-DOS, when 'shellslash' is not set, it
		will enclose {string} in double quotes and double all double
		quotes within {string}.
		Otherwise it will enclose {string} in single quotes and
		replace all "'" with "'\''".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{shellescape()}
@findex shellescape()
@item shellescape(@{string@} [, @{special@}])
シェルコマンドの引数として利用できるように @{string@} をエスケープする。
MS-Windows と MS-DOS では、'@option{shellslash}' が設定されていない場合、@{string@} をダブルクォートで囲み、@{string@} の中のダブルクォートを全て二重にする。
そうでなければ、@{string@} をシングルクォートで囲み、"'" を "'\''" で置き換える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When the {special} argument is present and it's a non-zero
		Number or a non-empty String (|non-zero-arg|), then special
		items such as "!", "%", "#" and "<cword>" will be preceded by
		a backslash.  This backslash will be removed again by the |:!|
		command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{special@} が指定され、0 でない数値または空でない文字列の場合 (|@ref{non-zero-arg}|)、"!", "%", "#", "<cword>" などの特殊なアイテムの前にはバックスラッシュがつく。コマンド |@ref{:!}| によってそのバックスラッシュは再び除かれる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The "!" character will be escaped (again with a |non-zero-arg|
		{special}) when 'shell' contains "csh" in the tail.  That is
		because for csh and tcsh "!" is used for history replacement
		even when inside single quotes.

		With a |non-zero-arg| {special} the <NL> character is also
		escaped.  When 'shell' containing "csh" in the tail it's
		escaped a second time.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{shell}' の値の末尾が "csh" である場合、@{special@} が |@ref{non-zero-arg}| ならば "!" の文字もエスケープされる。これは、csh と tcsh は シングルクォートの中であっても "!" を履歴置換と解釈するためである。

@{special@} が |@ref{non-zero-arg}| である <NL> 文字もエスケープされる。'@option{shell}' の末尾が "csh" である場合、これは 2 回エスケープされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example of use with a |:!| command: >
		    :exe '!dir ' . shellescape(expand('<cfile>'), 1)
<		This results in a directory listing for the file under the
		cursor.  Example of use with |system()|: >
		    :call system("chmod +w -- " . shellescape(expand("%")))
<		See also |::S|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:!}| コマンドを使う場合の例:
@example
:exe '!dir ' . shellescape(expand('<cfile>'), 1)
@end example
これはカーソル下のファイルを dir コマンドで表示する。|@ref{system()}| を使う場合の例:
@example
:call system("chmod +w -- " . shellescape(expand("%")))
@end example
|@ref{::S}| も参照のこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
shiftwidth()						*shiftwidth()*
		Returns the effective value of 'shiftwidth'. This is the
		'shiftwidth' value unless it is zero, in which case it is the
		'tabstop' value.  This function was introduced with patch
		7.3.694 in 2012, everybody should have it by now.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{shiftwidth()}
@findex shiftwidth()
@item shiftwidth()
実際に使用される '@option{shiftwidth}' の値を返す。'@option{shiftwidth}' がゼロ以外の場合はその値が返る。ゼロの場合は '@option{tabstop}' の値が返る。この関数は 2012 年のパッチ 7.3.694 で導入されたので、現在では皆使えるようになっているに違いない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
simplify({filename})					*simplify()*
		Simplify the file name as much as possible without changing
		the meaning.  Shortcuts (on MS-Windows) or symbolic links (on
		Unix) are not resolved.  If the first path component in
		{filename} designates the current directory, this will be
		valid for the result as well.  A trailing path separator is
		not removed either.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{simplify()}
@findex simplify()
@item simplify(@{filename@})
ファイル名を、意味を変えずにできるだけ簡略化する。MS-Windows でのショートカットや Unix でのシンボリックリンクは解決される。@{filename@} の最初のパスコンポーネントがカレントディレクトリを指す場合、結果にそのまま残される。末尾のパス区切り文字も取り除かれない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example: >
			simplify("./dir/.././/file/") == "./file/"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
simplify("./dir/.././/file/") == "./file/"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		Note: The combination "dir/.." is only removed if "dir" is
		a searchable directory or does not exist.  On Unix, it is also
		removed when "dir" is a symbolic link within the same
		directory.  In order to resolve all the involved symbolic
		links before simplifying the path name, use |resolve()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"dir/.." の組み合わせは、"dir" が検索可能なディレクトリであるか、存在しないときのみ取り除かれる。Unix では、"dir" が同じディレクトリ内にあるシンボリックリンクであるときも取り除かれる。パス名を簡略化する前に全てのシンボリックリンクを解決させるには |@ref{resolve()}| を使う。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
sin({expr})						*sin()*
		Return the sine of {expr}, measured in radians, as a |Float|.
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo sin(100)
<			-0.506366 >
			:echo sin(-4.01)
<			0.763301
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sin()}
@findex sin()
@item sin(@{expr@})
@{expr@} の正弦 (サイン) をラジアンで |@ref{Float}| で返す。@{expr@} は |@ref{Float}| または |@ref{Number}| に評価されなければならない。

例:
@example
:echo sin(100)
-0.506366
:echo sin(-4.01)
0.763301
@end example
@{|@ref{+float}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
sinh({expr})						*sinh()*
		Return the hyperbolic sine of {expr} as a |Float| in the range
		[-inf, inf].
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo sinh(0.5)
<			0.521095 >
			:echo sinh(-0.9)
<			-1.026517
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sinh()}
@findex sinh()
@item sinh(@{expr@})
@{expr@} の双曲線正弦 (ハイパボリックサイン) を返す。値は [-inf, inf] の範囲の浮動小数点数 (|@ref{Float}|)。

@{expr@} は浮動小数点数 (|@ref{Float}|) か数値 (|@ref{Number}|) でなければならない。

例:
@example
:echo sinh(0.5)
0.521095
:echo sinh(-0.9)
-1.026517
@end example
@{|@ref{+float}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
sort({list} [, {func} [, {dict}]])			*sort()* *E702*
		Sort the items in {list} in-place.  Returns {list}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sort()}
@anchor{E702}
@findex sort()
@erindex E702
@item sort(@{list@} [, @{func@} [, @{dict@}]])
@{list@} の要素をその場で (in-place) ソートする。@{list@} を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If you want a list to remain unmodified make a copy first: >
			:let sortedlist = sort(copy(mylist))
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リストを変更したくない場合は、最初にコピーを作っておくこと:
@example
:let sortedlist = sort(copy(mylist))
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		When {func} is omitted, is empty or zero, then sort() uses the
		string representation of each item to sort on.  Numbers sort
		after Strings, |Lists| after Numbers.  For sorting text in the
		current buffer use |:sort|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{func@} が省略されたか空かゼロの場合は、各項目の文字列表現を使ってソートする。数値は文字列より後になり、リスト |@ref{Lists}| は数値より後になる。カレントバッファのテキストをソートするには |@ref{:sort}| を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {func} is given and it is '1' or 'i' then case is
		ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{func@} が '1' か 'i' なら大文字小文字は区別されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {func} is given and it is 'n' then all items will be
		sorted numerical (Implementation detail: This uses the
		strtod() function to parse numbers, Strings, Lists, Dicts and
		Funcrefs will be considered as being 0).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{func@} が 'n' ならすべての要素は数値順にソートされる (実装詳細: 数値の読み込みには strtod() 関数が使われる。文字列、リスト、辞書、関数参照は 0 として扱われる)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {func} is given and it is 'N' then all items will be
		sorted numerical. This is like 'n' but a string containing
		digits will be used as the number they represent.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{func@} が 'N' ならすべての要素は数値順にソートされる。これは 'n' に似ているが、数値を含む文字列はその文字列が表す数値として扱われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {func} is given and it is 'f' then all items will be
		sorted numerical. All values must be a Number or a Float.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{func@} が 'f' ならすべての要素は数値順にソートされる。すべての値は数値か浮動小数点数でなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {func} is a |Funcref| or a function name, this function
		is called to compare items.  The function is invoked with two
		items as argument and must return zero if they are equal, 1 or
		bigger if the first one sorts after the second one, -1 or
		smaller if the first one sorts before the second one.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{func@} に |@ref{Funcref}| または関数名を指定すると、その関数を使って要素を比較する。その関数は 2 つの要素を引数として受け取り、それらが等しいときは 0、1 番目の引数を 2 番目より後にするなら 1 以上、1 番目の方を前にするなら -1 以下を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{dict} is for functions with the "dict" attribute.  It will be
		used to set the local variable "self". |Dictionary-function|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{dict@} は "dict" 属性付きの関数と一緒に使う。値はローカル変数 "self" として使われる。|@ref{Dictionary-function}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The sort is stable, items which compare equal (as number or as
		string) will keep their relative position. E.g., when sorting
		on numbers, text strings will sort next to each other, in the
		same order as they were originally.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ソートは安定である。(数値または文字列として) 等価な要素は元の順序関係が保持される。例えば数値としてソートした場合、文字列は元の順番通りに隣り合って並ぶ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Also see |uniq()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{uniq()}| も参照のこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example: >
			func MyCompare(i1, i2)
			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
			endfunc
			let sortedlist = sort(mylist, "MyCompare")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
func MyCompare(i1, i2)
   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
endfunc
let sortedlist = sort(mylist, "MyCompare")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		A shorter compare version for this specific simple case, which
		ignores overflow: >
			func MyCompare(i1, i2)
			   return a:i1 - a:i2
			endfunc
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この例の場合、より短く次のように書くことができる。ただしオーバーフローは無視される:
@example
func MyCompare(i1, i2)
   return a:i1 - a:i2
endfunc
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*soundfold()*
soundfold({word})
		Return the sound-folded equivalent of {word}.  Uses the first
		language in 'spelllang' for the current window that supports
		soundfolding.  'spell' must be set.  When no sound folding is
		possible the {word} is returned unmodified.
		This can be used for making spelling suggestions.  Note that
		the method can be quite slow.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{soundfold()}
@findex soundfold()
@item soundfold(@{word@})
@{word@} の soundfold 値を返す。カレントウィンドウの '@option{spelllang}' で設定された言語のうち、soundfold に対応している最初の言語が使用される。'@option{spell}' がオンでなければならない。soundfold ができない場合は @{word@} がそのまま返される。

この関数はスペル修正候補の作成に使える。
@quotation
@strong{Note:} @*
この方法はとても遅くなる可能性がある。
@end quotation
@{訳注: phonetic algorithm の一種@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*spellbadword()*
spellbadword([{sentence}])
		Without argument: The result is the badly spelled word under
		or after the cursor.  The cursor is moved to the start of the
		bad word.  When no bad word is found in the cursor line the
		result is an empty string and the cursor doesn't move.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{spellbadword()}
@findex spellbadword()
@item spellbadword([@{sentence@}])
引数なしの場合: カーソル下またはカーソル以降のスペルミスした単語を返す。その単語の先頭へカーソルを移動する。カレント行にスペルミスした単語が見つからない場合は空文字列を返し、カーソルは移動しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		With argument: The result is the first word in {sentence} that
		is badly spelled.  If there are no spelling mistakes the
		result is an empty string.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数ありの場合: @{sentence@} の中のスペルミスしている最初の単語を返す。スペルミスしている単語がない場合は空文字列を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The return value is a list with two items:
		- The badly spelled word or an empty string.
		- The type of the spelling error:
			"bad"		spelling mistake
			"rare"		rare word
			"local"		word only valid in another region
			"caps"		word should start with Capital
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
戻り値は、次の 2 個の要素を持つリスト:
@itemize
@item スペルミスした単語または空文字列
@item スペルミスの種類:
@multitable @columnfractions .3 .7
@item "bad" @tab スペルミス
@item "rare" @tab 頻度の低い単語
@item "local" @tab 他の地域でのみ有効な単語
@item "caps" @tab 大文字で始めるべき単語
@end multitable
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example: >
			echo spellbadword("the quik brown fox")
<			['quik', 'bad'] ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
echo spellbadword("the quik brown fox")
['quik', 'bad']
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The spelling information for the current window is used.  The
		'spell' option must be set and the value of 'spelllang' is
		used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カレントウィンドウに対するスペリング情報が適用される。オプション '@option{spell}' がオンでなければならない。'@option{spelllang}' の値が使用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*spellsuggest()*
spellsuggest({word} [, {max} [, {capital}]])
		Return a |List| with spelling suggestions to replace {word}.
		When {max} is given up to this number of suggestions are
		returned.  Otherwise up to 25 suggestions are returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{spellsuggest()}
@findex spellsuggest()
@item spellsuggest(@{word@} [, @{max@} [, @{capital@}]])
@{word@} の正しいスペルの候補のリスト |@ref{List}| を返す。@{max@} を指定すると、候補の数の最大値となる。@{max@} を指定しないと、25 個までの候補を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When the {capital} argument is given and it's non-zero only
		suggestions with a leading capital will be given.  Use this
		after a match with 'spellcapcheck'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{capital@} に 0 でない値を指定すると、先頭が大文字の候補だけを返す。これは '@option{spellcapcheck}' とのマッチの後に使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{word} can be a badly spelled word followed by other text.
		This allows for joining two words that were split.  The
		suggestions also include the following text, thus you can
		replace a line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{word@} はスペルの間違った単語で、後に他のテキストが続いてもよい。これにより、分割された 2 つの単語を連結することができる。候補もまた続きのテキストを含んでいるので、これによって行を置き換えることができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{word} may also be a good word.  Similar words will then be
		returned.  {word} itself is not included in the suggestions,
		although it may appear capitalized.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{word@} は正しい単語でもよい。すると似た単語が返ってくるだろう。@{word@} 自身は候補に含まれないが、大文字化されたものが含まれていることはある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The spelling information for the current window is used.  The
		'spell' option must be set and the values of 'spelllang' and
		'spellsuggest' are used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カレントウィンドウのスペリング情報が使われる。オプション '@option{spell}' がオンでなければならず、'@option{spelllang}' と '@option{spellsuggest}' の値が適用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
split({expr} [, {pattern} [, {keepempty}]])			*split()*
		Make a |List| out of {expr}.  When {pattern} is omitted or
		empty each white-separated sequence of characters becomes an
		item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{split()}
@findex split()
@item split(@{expr@} [, @{pattern@} [, @{keepempty@}]])
@{expr@} を分割して |@ref{List}| にする。@{pattern@} を省略した場合、または @{pattern@} が空文字列の場合は、@{expr@} を空白文字で区切った各文字列が要素となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Otherwise the string is split where {pattern} matches,
		removing the matched characters. 'ignorecase' is not used
		here, add \c to ignore case. |/\c|
		When the first or last item is empty it is omitted, unless the
		{keepempty} argument is given and it's non-zero.
		Other empty items are kept when {pattern} matches at least one
		character or when {keepempty} is non-zero.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{pattern@} を指定すると、@{pattern@} がマッチする位置で文字列を分割する。マッチした文字列は削除される。'@option{ignorecase}' はここでは適用されないので大文字小文字を無視するには \c を使う。|@ref{/\c}|

@{keepempty@} に非 0 を指定しない限り、最初または最後の要素が空文字列ならばリストから取り除かれる。それ以外の空文字列は、@{pattern@} が 1 文字以上にマッチすれば、または @{keepempty@} が非 0 ならばそのままリストの要素となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example: >
			:let words = split(getline('.'), '\W\+')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
:let words = split(getline('.'), '\W\+')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		To split a string in individual characters: >
			:for c in split(mystring, '\zs')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列を各文字に分割するには:
@example
:for c in split(mystring, '\zs')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		If you want to keep the separator you can also use '\zs' at
		the end of the pattern: >
			:echo split('abc:def:ghi', ':\zs')
<			['abc:', 'def:', 'ghi'] ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
区切り文字を削除せず、そのままにしておきたい場合は、'\zs' をパターンの最後で使う:
@example
:echo split('abc:def:ghi', ':\zs')
['abc:', 'def:', 'ghi']
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Splitting a table where the first element can be empty: >
			:let items = split(line, ':', 1)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最初の要素が空であるかもしれないテーブルを分割するには:
@example
:let items = split(line, ':', 1)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		The opposite function is |join()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これの逆を行う関数は |@ref{join()}| である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
sqrt({expr})						*sqrt()*
		Return the non-negative square root of Float {expr} as a
		|Float|.
		{expr} must evaluate to a |Float| or a |Number|.  When {expr}
		is negative the result is NaN (Not a Number).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sqrt()}
@findex sqrt()
@item sqrt(@{expr@})
浮動小数点数 @{expr@} の非負平方根を |@ref{Float}| で返す。@{expr@} は |@ref{Float}| または |@ref{Number}| に評価されなければならない。@{expr@} が負の場合、結果は NaN (Not a Number) になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
			:echo sqrt(100)
<			10.0 >
			:echo sqrt(-4.01)
<			nan
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
:echo sqrt(100)
10.0
:echo sqrt(-4.01)
nan
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		"nan" may be different, it depends on system libraries.
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"nan" はシステムのライブラリに依存するので、異なるかもしれない。

@{|@ref{+float}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
str2float({expr})					*str2float()*
		Convert String {expr} to a Float.  This mostly works the same
		as when using a floating point number in an expression, see
		|floating-point-format|.  But it's a bit more permissive.
		E.g., "1e40" is accepted, while in an expression you need to
		write "1.0e40".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{str2float()}
@findex str2float()
@item str2float(@{expr@})
文字列 @{expr@} を浮動小数点数に変換する。これは式の中で浮動小数点数を使っているときと同じように働く (|@ref{floating-point-format}| を参照)。しかしこちらの方がゆるやかである。例えばこちらでは "1e40" も許されるが、式の中では "1.0e+40" と書かなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Text after the number is silently ignored.
		The decimal point is always '.', no matter what the locale is
		set to.  A comma ends the number: "12,345.67" is converted to
		12.0.  You can strip out thousands separators with
		|substitute()|: >
			let f = str2float(substitute(text, ',', '', 'g'))
<		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

数値の後ろにある文字列は黙って無視される。

小数点数はロケールの設定にかかわらず常に '.' である。コンマを発見すると、そこで数値は終わりになる。つまり "12,345.67" は 12.0 に変換される。3 桁ごとのコンマ区切りを取り除くには |@ref{substitute()}| が使える:
@example
let f = str2float(substitute(text, ',', '', 'g'))
@end example
@{|@ref{+float}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
str2nr({expr} [, {base}])				*str2nr()*
		Convert string {expr} to a number.
		{base} is the conversion base, it can be 2, 8, 10 or 16.
		When {base} is omitted base 10 is used.  This also means that
		a leading zero doesn't cause octal conversion to be used, as
		with the default String to Number conversion.
		When {base} is 16 a leading "0x" or "0X" is ignored.  With a
		different base the result will be zero.  Similarly, when
		{base} is 8 a leading "0" is ignored, and when {base} is 2 a
		leading "0b" or "0B" is ignored.
		Text after the number is silently ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{str2nr()}
@findex str2nr()
@item str2nr(@{expr@} [, @{base@}])
文字列 @{expr@} を数値に変換する。@{base@} は変換の底。2, 8, 10, 16 のいずれか。

@{base@} を省略すると 10 となる。そのため、文字列の先頭に 0 があるとき、デフォルトの文字列・数値変換とは異なり、8 進数とは解釈されない。

@{base@} が 16 のとき、文字列の先頭の "0x" と "0X" は無視される。それ以外の底の場合は 0 となる。同様に、@{base@} が 8 のとき、文字列の先頭の "0" は無視される。そして、@{base@} が 2 のとき、文字列の先頭の "0b" と "0B" は無視される。

数値の後のテキストは暗黙に無視される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
strchars({expr} [, {skipcc}])					*strchars()*
		The result is a Number, which is the number of characters
		in String {expr}.
		When {skipcc} is omitted or zero, composing characters are
		counted separately.
		When {skipcc} set to 1, Composing characters are ignored.
		Also see |strlen()|, |strdisplaywidth()| and |strwidth()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{strchars()}
@findex strchars()
@item strchars(@{expr@} [, @{skipcc@}])
結果は数値で、文字列 @{expr@} の文字の数を返す。

@{skipcc@} を省略またはゼロを指定すると、合成文字は別々にカウントされる。

@{skipcc@} に 1 を指定すると、合成文字は無視される。

@{訳注: 基底文字と結合文字をまとめて 1 としてカウントする@}

|@ref{strlen()}|, |@ref{strdisplaywidth()}|, |@ref{strwidth()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{skipcc} is only available after 7.4.755.  For backward
		compatibility, you can define a wrapper function: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{skipcc@} は 7.4.755 以降でのみ有効である。それ以前では、ラッパー関数を定義すればよい:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		    if has("patch-7.4.755")
		      function s:strchars(str, skipcc)
			return strchars(a:str, a:skipcc)
		      endfunction
		    else
		      function s:strchars(str, skipcc)
			if a:skipcc
			  return strlen(substitute(a:str, ".", "x", "g"))
			else
			  return strchars(a:str)
			endif
		      endfunction
		    endif
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
if has("patch-7.4.755")
  function s:strchars(str, skipcc)
    return strchars(a:str, a:skipcc)
  endfunction
else
  function s:strchars(str, skipcc)
    if a:skipcc
      return strlen(substitute(a:str, ".", "x", "g"))
    else
      return strchars(a:str)
    endif
  endfunction
endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
strcharpart({src}, {start} [, {len}])			*strcharpart()*
		Like |strpart()| but using character index and length instead
		of byte index and length.
		When a character index is used where a character does not
		exist it is assumed to be one character.  For example: >
			strcharpart('abc', -1, 2)
<		results in 'a'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{strcharpart()}
@findex strcharpart()
@item strcharpart(@{src@}, @{start@} [, @{len@}])
|@ref{strpart()}| と同様だがバイトのインデックスおよび長さではなく文字のインデックスおよび長さを使用する。

文字インデックスが存在しない文字を指す場合、それは 1 文字であるとして扱われる。例:
@example
strcharpart('abc', -1, 2)
@end example
結果は "a" である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
strdisplaywidth({expr} [, {col}])			*strdisplaywidth()*
		The result is a Number, which is the number of display cells
		String {expr} occupies on the screen when it starts at {col}.
		When {col} is omitted zero is used.  Otherwise it is the
		screen column where to start.  This matters for Tab
		characters.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{strdisplaywidth()}
@findex strdisplaywidth()
@item strdisplaywidth(@{expr@} [, @{col@}])
結果は数値で、文字列 @{expr@} が @{col@} で始まる時のスクリーン上での表示セル幅を返す。

@{col@} が省略されたときはゼロが使われる。@{col@} には計算を開始するスクリーン上の列の位置を指定する。これはタブ文字の幅の計算に影響する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The option settings of the current window are used.  This
		matters for anything that's displayed differently, such as
		'tabstop' and 'display'.
		When {expr} contains characters with East Asian Width Class
		Ambiguous, this function's return value depends on 'ambiwidth'.
		Also see |strlen()|, |strwidth()| and |strchars()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
計算にはカレントウィンドウのオプションが使用される。'@option{tabstop}' や '@option{display}' のような表示を変更するようなオプションが影響する。

@{expr@} に幅が曖昧 (Ambiguous) な東アジアの文字が含まれているときは、文字幅は '@option{ambiwidth}' の設定に依存する。

|@ref{strlen()}|, |@ref{strwidth()}|, |@ref{strchars()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
strftime({format} [, {time}])				*strftime()*
		The result is a String, which is a formatted date and time, as
		specified by the {format} string.  The given {time} is used,
		or the current time if no time is given.  The accepted
		{format} depends on your system, thus this is not portable!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{strftime()}
@findex strftime()
@item strftime(@{format@} [, @{time@}])
結果は文字列で、@{format@} に従って日付や時間がフォーマットされたものになる。@{time@} が与えられた場合にはそれを使うが、省略された場合には現在時刻を使用する。受け付け可能な文字列 @{format@} は使用するシステムに依存するので、ポータブルとは言えない！
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		See the manual page of the C function strftime() for the
		format.  The maximum length of the result is 80 characters.
		See also |localtime()| and |getftime()|.
		The language can be changed with the |:language| command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
フォーマットについては C の関数 strftime() のマニュアルを参照。結果は最大 80 文字に制限される。|@ref{localtime()}| と |@ref{getftime()}| も参照。

ここで使われる言語はコマンド |@ref{:language}| で変更できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
		  :echo strftime("%c")		   Sun Apr 27 11:49:23 1997
		  :echo strftime("%Y %b %d %X")	   1997 Apr 27 11:53:25
		  :echo strftime("%y%m%d %T")	   970427 11:53:55
		  :echo strftime("%H:%M")	   11:55
		  :echo strftime("%c", getftime("file.c"))
						   Show mod time of file.c.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@verbatim
:echo strftime("%c")             Sun Apr 27 11:49:23 1997
:echo strftime("%Y %b %d %X")    1997 Apr 27 11:53:25
:echo strftime("%y%m%d %T")      970427 11:53:55
:echo strftime("%H:%M")          11:55
:echo strftime("%c", getftime("file.c"))
                                 file.cの更新時刻を表示
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		Not available on all systems.  To check use: >
			:if exists("*strftime")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この関数はどのシステムでも利用できるとは限らない。利用できるかチェックするには次のようにする:
@example
:if exists("*strftime")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
strgetchar({str}, {index})				*strgetchar()*
		Get character {index} from {str}.  This uses a character
		index, not a byte index.  Composing characters are considered
		separate characters here.
		Also see |strcharpart()| and |strchars()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{strgetchar()}
@findex strgetchar()
@item strgetchar(@{str@}, @{index@})
@{str@} 内の @{index@} 番目の文字インデックスを得る。これは文字のインデックスでありバイトのインデックスではない。合成文字は分割された文字として考慮される。

|@ref{strcharpart()}| と |@ref{strchars()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
stridx({haystack}, {needle} [, {start}])		*stridx()*
		The result is a Number, which gives the byte index in
		{haystack} of the first occurrence of the String {needle}.
		If {start} is specified, the search starts at index {start}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{stridx()}
@findex stridx()
@item stridx(@{haystack@}, @{needle@} [, @{start@}])
結果は数値で、@{heystack@} の中で文字列 @{needle@} が最初に現れる位置のバイトインデックスを表す。@{start@} を指定すると、インデックス @{start@} の位置から検索を開始する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		This can be used to find a second match: >
			:let colon1 = stridx(line, ":")
			:let colon2 = stridx(line, ":", colon1 + 1)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2 番目のマッチを探すには次のようにする:
@example
:let colon1 = stridx(line, ":")
:let colon2 = stridx(line, ":", colon1 + 1)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		The search is done case-sensitive.
		For pattern searches use |match()|.
		-1 is returned if the {needle} does not occur in {haystack}.
		See also |strridx()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
検索は大文字・小文字を区別する。検索パターンについては |@ref{match()}| を使う。@{haystack@} の中に @{needle@} がないときは-1を返す。|@ref{strridx()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
		  :echo stridx("An Example", "Example")	     3
		  :echo stridx("Starting point", "Start")    0
		  :echo stridx("Starting point", "start")   -1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
:echo stridx("An Example", "Example")      3
:echo stridx("Starting point", "Start")    0
:echo stridx("Starting point", "start")   -1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<						*strstr()* *strchr()*
		stridx() works similar to the C function strstr().  When used
		with a single character it works similar to strchr().
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{strstr()}
@anchor{strchr()}
@findex strstr()
@findex strchr()
stridx() は C の関数 strstr() と同じように動作する。@{needle@} が 1 文字のときは strchr() と同じように動作する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*string()*
string({expr})	Return {expr} converted to a String.  If {expr} is a Number,
		Float, String or a composition of them, then the result can be
		parsed back with |eval()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{string()}
@findex string()
@item string(@{expr@})
@{expr@} を文字列に変換して返す。@{expr@} が数値、浮動小数点数、文字列、それらの複合の場合は、この戻り値を |@ref{eval()}| でパースして復元できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			{expr} type	result ~
			String		'string' (single quotes are doubled)
			Number		123
			Float		123.123456 or 1.123456e8
			Funcref		function('name')
			List		[item, item]
			Dictionary	{key: value, key: value}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@headitem @{expr@} 型 @tab 結果
@item 文字列 @tab '@option{string}' (シングルクォートは二重化される)
@item 数値 @tab 123
@item 浮動小数点数 @tab 123.123456 or 1.123456e8
@item Funcref @tab function('name')
@item リスト @tab [item, item]
@item 辞書 @tab @{key: value, key: value@}
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When a List or Dictionary has a recursive reference it is
		replaced by "[...]" or "{...}".  Using eval() on the result
		will then fail.

		Also see |strtrans()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リストや辞書に循環参照がある場合、それらは "[...]" や "@{...@}" に置き換えられる。その結果に対して eval() を使用すると失敗する。

|@ref{strtrans()}|も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*strlen()*
strlen({expr})	The result is a Number, which is the length of the String
		{expr} in bytes.
		If the argument is a Number it is first converted to a String.
		For other types an error is given.
		If you want to count the number of multi-byte characters use
		|strchars()|.
		Also see |len()|, |strdisplaywidth()| and |strwidth()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{strlen()}
@findex strlen()
@item strlen(@{expr@})
結果は数値で、文字列 @{expr@} のバイト単位での長さ。引数が数値の場合は、まず文字列に変換される。それ以外の型の場合はエラーとなる。マルチバイト文字の数を数える場合は |@ref{strchars()}| を使用する。

|@ref{len()}|, |@ref{strdisplaywidth()}|, |@ref{strwidth()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
strpart({src}, {start} [, {len}])			*strpart()*
		The result is a String, which is part of {src}, starting from
		byte {start}, with the byte length {len}.
		To count characters instead of bytes use |strcharpart()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{strpart()}
@findex strpart()
@item strpart(@{src@}, @{start@} [, @{len@}])
結果は文字列で、@{src@} の @{start@} 番目の文字から始まる、長さ @{len@} の部分文字列。バイト数ではなく文字数で数えるには |@ref{strcharpart()}| を用いる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When bytes are selected which do not exist, this doesn't
		result in an error, the bytes are simply omitted.
		If {len} is missing, the copy continues from {start} till the
		end of the {src}. >
			strpart("abcdefg", 3, 2)    == "de"
			strpart("abcdefg", -2, 4)   == "ab"
			strpart("abcdefg", 5, 4)    == "fg"
			strpart("abcdefg", 3)	    == "defg"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
存在しない文字を含むように範囲を指定しても、エラーにはならない。単に文字が省略されるだけである。@{len@} を省略すると、@{start@} から @{src@} の末尾までの部分文字列を返す。
@verbatim
strpart("abcdefg", 3, 2)    == "de"
strpart("abcdefg", -2, 4)   == "ab"
strpart("abcdefg", 5, 4)    == "fg"
strpart("abcdefg", 3)       == "defg"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		Note: To get the first character, {start} must be 0.  For
		example, to get three bytes under and after the cursor: >
			strpart(getline("."), col(".") - 1, 3)
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
文字列の最初の文字を指定するためには、@{start@} は 0 でなければならない。カーソルのある位置から3文字を取得する例:
@example
strpart(getline("."), col(".") - 1, 3)
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
strridx({haystack}, {needle} [, {start}])			*strridx()*
		The result is a Number, which gives the byte index in
		{haystack} of the last occurrence of the String {needle}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{strridx()}
@findex strridx()
@item strridx(@{haystack@}, @{needle@} [, @{start@}])
結果は数値で、@{haystack@} の中で文字列 @{needle@} が最後に現れる位置のバイトインデックスとなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When {start} is specified, matches beyond this index are
		ignored.  This can be used to find a match before a previous
		match: >
			:let lastcomma = strridx(line, ",")
			:let comma2 = strridx(line, ",", lastcomma - 1)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{start@} を指定すると、そのインデックス以降でのマッチは無視される。前のマッチより前にあるものを見つけるには次のようにする:
@example
:let lastcomma = strridx(line, ",")
:let comma2 = strridx(line, ",", lastcomma - 1)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		The search is done case-sensitive.
		For pattern searches use |match()|.
		-1 is returned if the {needle} does not occur in {haystack}.
		If the {needle} is empty the length of {haystack} is returned.
		See also |stridx()|.  Examples: >
		  :echo strridx("an angry armadillo", "an")	     3
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
検索は大文字・小文字を区別する。検索パターンについては |@ref{match()}| を使う。

@{haystack@} の中に @{needle@} がないときは -1 を返す。@{needle@} が空文字列のときは @{haystack@} の長さを返す。|@ref{stridx()}| も参照。例:
@example
:echo strridx("an angry armadillo", "an")            3
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<							*strrchr()*
		When used with a single character it works similar to the C
		function strrchr().
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{strrchr()}
@findex strrchr()
@{needle@} が 1 文字の場合は C の関数 strrchr() と同じように動作する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
strtrans({expr})					*strtrans()*
		The result is a String, which is {expr} with all unprintable
		characters translated into printable characters |'isprint'|.
		Like they are shown in a window.  Example: >
			echo strtrans(@a)
<		This displays a newline in register a as "^@" instead of
		starting a new line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{strtrans()}
@findex strtrans()
@item strtrans(@{expr@})
結果は文字列で、@{expr@} 内の表示不可能な文字を |@ref{'isprint'}| で指定される、表示可能な文字に変換したもの。ウィンドウに表示することができるようになる。例:
@example
echo strtrans(@@a)
@end example
これはレジスタの中の改行を、改行として表示する代わりに "^@@" と表示する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
strwidth({expr})					*strwidth()*
		The result is a Number, which is the number of display cells
		String {expr} occupies.  A Tab character is counted as one
		cell, alternatively use |strdisplaywidth()|.
		When {expr} contains characters with East Asian Width Class
		Ambiguous, this function's return value depends on 'ambiwidth'.
		Also see |strlen()|, |strdisplaywidth()| and |strchars()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{strwidth()}
@findex strwidth()
@item strwidth(@{expr@})
結果は数値で、文字列 @{expr@} のスクリーン上での表示セル幅を返す。タブ文字の幅は 1 として数えられる (タブ文字の幅も考慮したい場合は |@ref{strdisplaywidth()}| を使うこと)。

@{expr@} に幅が曖昧 (Ambiguous) な東アジアの文字が含まれているときは、文字幅は '@option{ambiwidth}' の設定に依存する。

|@ref{strlen()}|, |@ref{strdisplaywidth()}|, |@ref{strchars()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
submatch({nr} [, {list}])			*submatch()* *E935*
		Only for an expression in a |:substitute| command or
		substitute() function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{submatch()}
@anchor{E935}
@findex submatch()
@erindex E935
@item submatch(@{nr@} [, @{list@}])
|@ref{:substitute}| コマンドや substitute() 関数の中の式でのみ使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Returns the {nr}'th submatch of the matched text.  When {nr}
		is 0 the whole matched text is returned.
		Note that a NL in the string can stand for a line break of a
		multi-line match or a NUL character in the text.
		Also see |sub-replace-expression|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

マッチしたテキストの @{nr@} 番目の部分マッチを返す。@{nr@} が 0 のときはマッチしたテキスト全体を返す。
@quotation
@strong{Note:} @*
文字列中の NL 文字は複数行マッチにおける改行文字か、NUL 文字のどちらかである。
@end quotation
|@ref{sub-replace-expression}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {list} is present and non-zero then submatch() returns
		a list of strings, similar to |getline()| with two arguments.
		NL characters in the text represent NUL characters in the
		text.
		Only returns more than one item for |:substitute|, inside
		|substitute()| this list will always contain one or zero
		items, since there are no real line breaks.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{list@} に非ゼロの値が指定されたときは submatch() は文字列のリストを返す。|@ref{getline()}| に 2 つの引数を指定したときの戻り値と同じである。テキスト中の NL 文字は NUL 文字を表す。

|@ref{:substitute}| で使われたときのみ複数要素のリストを返す。|@ref{substitute()}| では、実際の改行はそこにはないので、リストは常に 0 または 1 つの要素である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When substitute() is used recursively only the submatches in
		the current (deepest) call can be obtained.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
substitute() が再帰的に使用された場合、現在の（最も深い）サブマッチのみが取得できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Examples: >
			:s/\d\+/\=submatch(0) + 1/
			:echo substitute(text, '\d\+', '\=submatch(0) + 1', '')
<		This finds the first number in the line and adds one to it.
		A line break is included as a newline character.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:s/\d\+/\=submatch(0) + 1/
:echo substitute(text, '\d\+', '\=submatch(0) + 1', '')
@end example
この例は、行の中で最初の数値を検索し、それに 1 を加える。改行は改行文字として含まれる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
substitute({expr}, {pat}, {sub}, {flags})		*substitute()*
		The result is a String, which is a copy of {expr}, in which
		the first match of {pat} is replaced with {sub}.
		When {flags} is "g", all matches of {pat} in {expr} are
		replaced.  Otherwise {flags} should be "".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{substitute()}
@findex substitute()
@item substitute(@{expr@}, @{pat@}, @{sub@}, @{flags@})
結果は文字列で、@{expr@} 内で最初に @{pat@} にマッチした部分を @{sub@} に置換えたコピーになる。

@{flags@} が "g" なら、@{expr@} 内の @{pat@} にマッチした部分をすべて置換する。そうしたくない場合は @{flags@} は "" にすべきである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		This works like the ":substitute" command (without any flags).
		But the matching with {pat} is always done like the 'magic'
		option is set and 'cpoptions' is empty (to make scripts
		portable).  'ignorecase' is still relevant, use |/\c| or |/\C|
		if you want to ignore or match case and ignore 'ignorecase'.
		'smartcase' is not used.  See |string-match| for how {pat} is
		used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはコマンド "@command{:substitute}" (一切のフラグ無し) のように働く。しかしマッチングは常にオプション '@option{magic}' が設定され、オプション '@option{cpoptions}' は空にして実行される (スクリプトをポータブルにするため)。

'@option{ignorecase}' は適用される。'@option{ignorecase}' の設定にかかわらず大文字小文字を区別するかしないか固定するには |@ref{/\c}| か |@ref{/\C}| を使う。'@option{smartcase}' は適用されない。@{pat@} がどう扱われるかについては |@ref{string-match}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		A "~" in {sub} is not replaced with the previous {sub}.
		Note that some codes in {sub} have a special meaning
		|sub-replace-special|.  For example, to replace something with
		"\n" (two characters), use "\\\\n" or '\\n'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
また、@{sub@} 内の "~" は前回の @{sub@} に置換されない。

@{sub@} 内の幾つかのコードには |@ref{sub-replace-special}| の特殊な意味があることに注意。例えば、何かの文字列をリテラルの "\n" に置換えるためには、"\\\\n" か '\\n' を使う必要がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {pat} does not match in {expr}, {expr} is returned
		unmodified.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{pat@} が @{expr@} の何処にもマッチしなければ、@{expr@} が何の変更も受けずに返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example: >
		   :let &path = substitute(&path, ",\\=[^,]*$", "", "")
<		This removes the last component of the 'path' option. >
		   :echo substitute("testing", ".*", "\\U\\0", "")
<		results in "TESTING".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:let &path = substitute(&path, ",\\=[^,]*$", "", "")
@end example
これはオプション '@option{path}' の最後のコンポーネントを削除する。
@example
:echo substitute("testing", ".*", "\\U\\0", "")
@end example
結果は "TESTING" となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {sub} starts with "\=", the remainder is interpreted as
		an expression. See |sub-replace-expression|.  Example: >
		   :echo substitute(s, '%\(\x\x\)',
			   \ '\=nr2char("0x" . submatch(1))', 'g')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{sub@} が "\=" で開始している場合は、その後ろの文字列は式として解釈される。|@ref{sub-replace-expression}| 参照。例:
@example
:echo substitute(s, '%\(\x\x\)',
        \ '\=nr2char("0x" . submatch(1))', 'g')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		When {sub} is a Funcref that function is called, with one
		optional argument.  Example: >
		   :echo substitute(s, '%\(\x\x\)', SubNr, 'g')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{sub@} が関数リファレンスの場合、1 個のオプショナル引数と共にその関数が呼び出される。例:
@example
:echo substitute(s, '%\(\x\x\)', SubNr, 'g')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		The optional argument is a list which contains the whole
		matched string and up to nine submatches, like what
		|submatch()| returns.  Example: >
		   :echo substitute(s, '%\(\x\x\)', {m -> '0x' . m[1]}, 'g')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプショナル引数はマッチ文字列全体と9個のサブマッチが含まれる以下の |@ref{submatch()}| が返す様なリストである。例:
@example
:echo substitute(s, '%\(\x\x\)', @{m -> '0x' . m[1]@}, 'g')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
swapinfo({fname})					*swapinfo()*
		The result is a dictionary, which holds information about the
		swapfile {fname}. The available fields are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{swapinfo()}
@cindex swapinfo()
@item swapinfo(@{fname@})
結果は辞書で、スワップファイル @{fname@} に関する情報を保持している。フィールドには次のようなものがある:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			version VIM version
			user	user name
			host	host name
			fname	original file name
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item version @tab VIM のバージョン
@item user @tab ユーザー名
@item host @tab ホスト名
@item fname @tab オリジナルのファイル名
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			pid	PID of the VIM process that created the swap
				file
			mtime	last modification time in seconds
			inode	Optional: INODE number of the file
			dirty	1 if file was modified, 0 if not
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item pid @tab スワップファイルを生成した VIM プロセスの PID
@item mtime @tab 秒単位の最終修正時刻
@item inode @tab オプション: ファイルの INODE 番号
@item dirty @tab もしも変更されていたなら 1、そうでなければ 0
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that "user" and "host" are truncated to at most 39 bytes.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"user" と "host" は 多くても 39 バイトまで切り詰められることに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		In case of failure an "error" item is added with the reason:
			Cannot open file: file not found or in accessible
			Cannot read file: cannot read first block
			Not a swap file: does not contain correct block ID
			Magic number mismatch: Info in first block is invalid
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
失敗する場合、根拠に "エラー" 項目が追加される:
@multitable @columnfractions .3 .7
@item Cannot open file: @tab ファイルが見つからないかアクセスができない
@item Cannot read file: @tab 最初のブロックを読み込むことができない
@item Not a swap file: @tab 正しいブロック ID が含まれていない
@item Magic number mismatch: @tab 無効な最初のブロックの情報
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
synID({lnum}, {col}, {trans})				*synID()*
		The result is a Number, which is the syntax ID at the position
		{lnum} and {col} in the current window.
		The syntax ID can be used with |synIDattr()| and
		|synIDtrans()| to obtain syntax information about text.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{synID()}
@findex synID()
@item synID(@{lnum@}, @{col@}, @{trans@})
結果は数値で、現在のウィンドウ内での位置 @{lnum@} と @{col@} の位置の構文 ID。

構文 ID は |@ref{synIDattr()}| と |@ref{synIDtrans()}| に渡すことで、テキストについての構文情報を取得するのに使用できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{col} is 1 for the leftmost column, {lnum} is 1 for the first
		line.  'synmaxcol' applies, in a longer line zero is returned.
		Note that when the position is after the last character,
		that's where the cursor can be in Insert mode, synID() returns
		zero.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最左のカラムを指定するには @{col@} に 1 を、最初の行を指定するには @{line@} に 1 を指定する。'@option{synmaxcol}' が適用され、長すぎる行では 0 が返ってくる。
@quotation
@strong{Note:} @*
挿入モードでカーソル位置を最後の文字より後ろにした場合、synID() は 0 を返す。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {trans} is |TRUE|, transparent items are reduced to the
		item that they reveal.  This is useful when wanting to know
		the effective color.  When {trans} is |FALSE|, the transparent
		item is returned.  This is useful when wanting to know which
		syntax item is effective (e.g. inside parens).
		Warning: This function can be very slow.  Best speed is
		obtained by going through the file in forward direction.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{trans@} が |@ref{TRUE}| ならば、透過属性のアイテムは省略され、実際に表示されているアイテムが評価対象になる。これは実際に有効になっているカラーを知りたい時に役に立つ。

@{trans@} が |@ref{FALSE}| ならば、透過属性のアイテムが返される。これはどの構文アイテムが有効になっているかを知りたい時に役に立つ (例:カッコの中とか)。
@quotation
@strong{警告:} @*
この関数は非常に遅い。ファイルを順方向に走査する時にだけベストなスピードが得られる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example (echoes the name of the syntax item under the cursor): >
			:echo synIDattr(synID(line("."), col("."), 1), "name")
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例 (カーソルの下の構文アイテムの名前を表示する):
@example
:echo synIDattr(synID(line("."), col("."), 1), "name")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
synIDattr({synID}, {what} [, {mode}])			*synIDattr()*
		The result is a String, which is the {what} attribute of
		syntax ID {synID}.  This can be used to obtain information
		about a syntax item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{synIDattr()}
@findex synIDattr()
@item synIDattr(@{synID@}, @{what@} [, @{mode@}])
結果は文字列で、@{synID@} の属性 @{what@} の内容を示す。これは構文アイテムの情報を取得するのに使用できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{mode} can be "gui", "cterm" or "term", to get the attributes
		for that mode.  When {mode} is omitted, or an invalid value is
		used, the attributes for the currently active highlighting are
		used (GUI, cterm or term).
		Use synIDtrans() to follow linked highlight groups.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{mode@} には取得したいモードの属性に応じて、"gui" か "cterm" か "term" が指定できる。@{mode@} が省略されるか、無効な値が指定された場合、現在有効になっているハイライトモードが使用される (GUI、cterm、term のどれか)。

ハイライトグループにリンクされた属性を取得するには synIDtrans() を使用する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{what}		result
		"name"		the name of the syntax item
		"fg"		foreground color (GUI: color name used to set
				the color, cterm: color number as a string,
				term: empty string)
		"bg"		background color (as with "fg")
		"font"		font name (only available in the GUI)
				|highlight-font|
		"sp"		special color (as with "fg") |highlight-guisp|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@headitem @{what@} @tab 結果
@item "name" @tab 構文アイテムの名前
@item "fg" @tab 前景色 (GUI: カラー名、cterm: 文字列としてのカラー番号、term: 空文字列)
@item "bg" @tab 背景色("fg" 同様)
@item "font" @tab フォント名 (GUI でのみ利用可) |@ref{highlight-font}|
@item "sp" @tab 特殊な色 ("fg" 同様) |@ref{highlight-guisp}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		"fg#"		like "fg", but for the GUI and the GUI is
				running the name in "#RRGGBB" form
		"bg#"		like "fg#" for "bg"
		"sp#"		like "fg#" for "sp"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "fg#" @tab "fg" 同様だが、"#RRGGBB" のフォーマットで
@item "bg#" @tab "bg" 同様だが、"#RRGGBB" のフォーマットで
@item "sp#" @tab "sp" 同様だが、"#RRGGBB" のフォーマットで
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		"bold"		"1" if bold
		"italic"	"1" if italic
		"reverse"	"1" if reverse
		"inverse"	"1" if inverse (= reverse)
		"standout"	"1" if standout
		"underline"	"1" if underlined
		"undercurl"	"1" if undercurled
		"strike"	"1" if strikethrough
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "bold" @tab 太字なら "1"
@item "italic" @tab 斜体なら "1"
@item "reverse" @tab 反転なら "1"
@item "inverse" @tab 反転 (原文 inverse) なら "1" (reverse と等価)
@item "standout" @tab 強調 (standout) なら "1"
@item "underline" @tab 下線付きなら "1"
@item "undercurl" @tab 波線付きなら "1"
@item "strike" @tab 取り消し線なら "1"
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example (echoes the color of the syntax item under the
		cursor): >
	:echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例 (カーソルの下の構文アイテムのカラーを表示する):
@example
:echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
synIDtrans({synID})					*synIDtrans()*
		The result is a Number, which is the translated syntax ID of
		{synID}.  This is the syntax group ID of what is being used to
		highlight the character.  Highlight links given with
		":highlight link" are followed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{synIDtrans()}
@findex synIDtrans()
@item synIDtrans(@{synID@})
結果は数値で、@{synID@} を構文 ID に変換したもの。キャラクタをハイライト表示している構文グループの ID である。

"@command{:highlight link}" によって与えられるハイライトのリンクはこれに従っている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
synconcealed({lnum}, {col})				*synconcealed()*
		The result is a List with currently three items:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{synconcealed()}
@findex synconcealed()
@item synconcealed(@{lnum@}, @{col@})
値は 3 つの項目を持つリスト。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		1. The first item in the list is 0 if the character at the
		   position {lnum} and {col} is not part of a concealable
		   region, 1 if it is.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item リストの 1 番目のアイテムは、@{lnum@} と @{col@} の指す位置の文字が Conceal 可能リージョンの中にないなら 0、あるなら 1。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		2. The second item in the list is a string. If the first item
		   is 1, the second item contains the text which will be
		   displayed in place of the concealed text, depending on the
		   current setting of 'conceallevel' and 'listchars'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item リストの 2 番目のアイテムは文字列。最初のアイテムが 1 なら、Conceal されたテキストの場所に表示されるテキストを含む (実行時の '@option{conceallevel}' と '@option{listchars}' の設定に依存する)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		3. The third and final item in the list is a number
		   representing the specific syntax region matched in the
		   line. When the character is not concealed the value is
		   zero. This allows detection of the beginning of a new
		   concealable region if there are two consecutive regions
		   with the same replacement character.  For an example, if
		   the text is "123456" and both "23" and "45" are concealed
		   and replace by the character "X", then:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item リストの 3 番目と最後のアイテムは、行中でマッチした特有のシンタックスリージョンを表す番号。文字が Conceal されていないなら、値は 0。同じ置換文字を持つ 2 つの連続したリージョンがあるなら、新たな Conceal 可能なリージョンの始りを検出を可能にする。ひとつの例として、テキストは "123456" で、"23" と "45" が Conceal されていて、文字 "X" で置き換えるとすると:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			call			returns ~
			synconcealed(lnum, 1)   [0, '', 0]
			synconcealed(lnum, 2)   [1, 'X', 1]
			synconcealed(lnum, 3)   [1, 'X', 1]
			synconcealed(lnum, 4)   [1, 'X', 2]
			synconcealed(lnum, 5)   [1, 'X', 2]
			synconcealed(lnum, 6)   [0, '', 0]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .7 .3
@headitem 呼び出し @tab 戻り値
@item synconcealed(lnum, 1) @tab [0, '', 0]
@item synconcealed(lnum, 2) @tab [1, 'X', 1]
@item synconcealed(lnum, 3) @tab [1, 'X', 1]
@item synconcealed(lnum, 4) @tab [1, 'X', 2]
@item synconcealed(lnum, 5) @tab [1, 'X', 2]
@item synconcealed(lnum, 6) @tab [0, '', 0]
@end multitable
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
synstack({lnum}, {col})					*synstack()*
		Return a |List|, which is the stack of syntax items at the
		position {lnum} and {col} in the current window.  Each item in
		the List is an ID like what |synID()| returns.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{synstack()}
@findex synstack()
@item synstack(@{lnum@}, @{col@})
カレントウィンドウの @{lnum@}, @{col@} の位置の構文アイテムのスタックを |@ref{List}| にして返す。このリストの要素は |@ref{synID()}| が返すのと同じ種類の ID である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The first item in the List is the outer region, following are
		items contained in that one.  The last one is what |synID()|
		returns, unless not the whole item is highlighted or it is a
		transparent item.
		This function is useful for debugging a syntax file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リストの最初の要素が一番外側の領域で、続く要素がその中に内包されている。アイテム全体がハイライトされている、または最後の要素が transparent なアイテムである場合を除き、最後の要素が |@ref{synID()}| が返すものである。

この関数は構文ファイルをデバッグするのに役に立つ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example that shows the syntax stack under the cursor: >
			for id in synstack(line("."), col("."))
			   echo synIDattr(id, "name")
			endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例 (カーソル下の構文スタックを表示する):
@example
for id in synstack(line("."), col("."))
   echo synIDattr(id, "name")
endfor
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		When the position specified with {lnum} and {col} is invalid
		nothing is returned.  The position just after the last
		character in a line and the first column in an empty line are
		valid positions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{lnum@} と @{col@} が不正な場所を指しているときは戻り値なし。行の最後の文字の 1 つ後ろと空行の一番目の列は有効な位置である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
system({expr} [, {input}])				*system()* *E677*
		Get the output of the shell command {expr} as a string.  See
		|systemlist()| to get the output as a List.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{system()}
@anchor{E677}
@findex system()
@erindex E677
@item system(@{expr@} [, @{input@}])
シェルコマンド @{expr@} の実行結果を文字列として得る。リストとして受け取るには |@ref{systemlist()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {input} is given and is a string this string is written
		to a file and passed as stdin to the command.  The string is
		written as-is, you need to take care of using the correct line
		separators yourself.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{input@} に文字列が指定された場合、その文字列はファイルに書き出され、コマンドの標準入力として渡される。この文字列はそのまま (as-is) 書き出されるので、正しい改行文字を使うよう自分自身で気をつけなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If {input} is given and is a |List| it is written to the file
		in a way |writefile()| does with {binary} set to "b" (i.e.
		with a newline between each list item with newlines inside
		list items converted to NULs).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@{input@} にリスト |@ref{List}| が指定された場合は、|@ref{writefile()}| の @{binary@} に "b" を指定したのと同様にファイルに書き出される (つまり、リストの各要素は改行文字で連結され、要素内の改行文字は NUL 文字に変換される)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When {input} is given and is a number that is a valid id for
		an existing buffer then the content of the buffer is written
		to the file line by line, each line terminated by a NL and
		NULs characters where the text has a NL.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@{input@} が指定され、それが数値で既存のバッファとして有効な id であるならば、そのバッファの内容が 1 行ずつファイルに書き出される。それぞれの行は NL で終端され、テキスト中の NL は NUL 文字に置き換えられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Pipes are not used, the 'shelltemp' option is not used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
パイプは使用されず、'@option{shelltemp}' オプションは使用されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When prepended by |:silent| the terminal will not be set to
		cooked mode.  This is meant to be used for commands that do
		not need the user to type.  It avoids stray characters showing
		up on the screen which require |CTRL-L| to remove. >
			:silent let f = system('ls *.vim')
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:silent}| が前置されたときは、端末は cooked モードには設定されない。これはユーザー入力を必要としないコマンドを使用することを意味する。これは画面に不要な文字が表示されるのを防ぐ (|@ref{CTRL-L}| でそれをクリアする必要がなくなる)。
@example
:silent let f = system('ls *.vim')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note: Use |shellescape()| or |::S| with |expand()| or
		|fnamemodify()| to escape special characters in a command
		argument.  Newlines in {expr} may cause the command to fail.
		The characters in 'shellquote' and 'shellxquote' may also
		cause trouble.
		This is not to be used for interactive commands.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
コマンドの引数をエスケープするには、|@ref{shellescape()}|, |@ref{expand()}| の |@ref{::S}| または |@ref{fnamemodify()}| を使用する。@{expr@} 内に改行文字があるとコマンドは失敗するだろう。'@option{shellquote}' や '@option{shellxquote}' 内にある文字も問題を起こすかもしれない。

対話的なコマンドを使用することはできない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The result is a String.  Example: >
		    :let files = system("ls " .  shellescape(expand('%:h')))
		    :let files = system('ls ' . expand('%:h:S'))
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
戻り値は文字列。例:
@example
:let files = system("ls " .  shellescape(expand('%:h')))
:let files = system('ls ' . expand('%:h:S'))
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<		To make the result more system-independent, the shell output
		is filtered to replace <CR> with <NL> for Macintosh, and
		<CR><NL> with <NL> for DOS-like systems.
		To avoid the string being truncated at a NUL, all NUL
		characters are replaced with SOH (0x01).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
システムに依存しないような戻り値にするために、シェルの出力をフィルタリングし、マッキントッシュにおいては <CR> を <NL> に変換し、DOS 系のシステムにおいては <CR><NL> を <NL> に変換している。

文字列が NUL 文字で切れるのを防ぐため、すべての NUL 文字は SOH (0x01) に置換される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The command executed is constructed using several options:
	'shell' 'shellcmdflag' 'shellxquote' {expr} 'shellredir' {tmp} 'shellxquote'
		({tmp} is an automatically generated file name).
		For Unix and OS/2 braces are put around {expr} to allow for
		concatenated commands.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
実行されるコマンドはいくつかのオプションを適用して構成される:

'@option{shell}' '@option{shellcmdflag}' '@option{shellxquote}' @{expr@} '@option{shellredir}' @{tmp@} '@option{shellxquote}'

(@{tmp@} は自動的に生成されるファイル名)

Unix と OS/2 ではコマンドの連結ができるように @{expr@} の両側に波括弧が置かれる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The command will be executed in "cooked" mode, so that a
		CTRL-C will interrupt the command (on Unix at least).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドは「cooked」モードで実行される。そのため @kbd{CTRL-C} でコマンドを中断できる (少なくとも Unix では)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The resulting error code can be found in |v:shell_error|.
		This function will fail in |restricted-mode|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
エラーコードは |@ref{v:shell_error}| に格納される。

この関数は |@ref{restricted-mode}| では失敗する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Note that any wrong value in the options mentioned above may
		make the function fail.  It has also been reported to fail
		when using a security agent application.
		Unlike ":!cmd" there is no automatic check for changed files.
		Use |:checktime| to force a check.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
上記のオプションに不正な値が入っていると、この関数の呼び出しが失敗する可能性がある。セキュリティエージェントアプリケーションを使っていると失敗することがあるとも報告されている。

"@command{:!cmd}" とは違い、ファイルが変更されているかのチェックは行わない。

明示的にチェックさせるには |@ref{:checktime}| を使う。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
systemlist({expr} [, {input}])				*systemlist()*
		Same as |system()|, but returns a |List| with lines (parts of
		output separated by NL) with NULs transformed into NLs. Output
		is the same as |readfile()| will output with {binary} argument
		set to "b".  Note that on MS-Windows you may get trailing CR
		characters.

		Returns an empty string on error.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{systemlist()}
@findex systemlist()
@item systemlist(@{expr@} [, @{input@}])
|@ref{system()}| と同じだが行のリスト |@ref{List}| を返す。行は NL 文字で区切られ、NUL 文字は NL 文字に変換される。出力は |@ref{readfile()}| の @{binary@} 引数に "b" を指定したのと同様である。
@quotation
@strong{Note:} @*
MS-Windows では末尾の CR 文字がつくかもしれないことに注意。
@end quotation
エラー時には空文字列が返る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
tabpagebuflist([{arg}])					*tabpagebuflist()*
		The result is a |List|, where each item is the number of the
		buffer associated with each window in the current tab page.
		{arg} specifies the number of the tab page to be used. When
		omitted the current tab page is used.
		When {arg} is invalid the number zero is returned.
		To get a list of all buffers in all tabs use this: >
			let buflist = []
			for i in range(tabpagenr('$'))
			   call extend(buflist, tabpagebuflist(i + 1))
			endfor
<		Note that a buffer may appear in more than one window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tabpagebuflist()}
@findex tabpagebuflist()
@item tabpagebuflist([@{arg@}])
カレントタブページ内の各ウィンドウに表示されているバッファの番号を要素とするリスト |@ref{List}| を返す。

@{arg@} は対象とするタブページの番号を指定する。省略したときはカレントタブページを対象とする。

@{arg@} が無効なときは数値 0 を返す。

全タブページ中の全バッファのリストを得るには次のようにする:
@verbatim
let buflist = []
for i in range(tabpagenr('$'))
   call extend(buflist, tabpagebuflist(i + 1))
endfor
@end verbatim
@quotation
@strong{Note:} @*
1 つのバッファが複数のウィンドウに表示されている場合があることに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
tabpagenr([{arg}])					*tabpagenr()*
		The result is a Number, which is the number of the current
		tab page.  The first tab page has number 1.
		When the optional argument is "$", the number of the last tab
		page is returned (the tab page count).
		The number can be used with the |:tab| command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tabpagenr()}
@findex tabpagenr()
@item tabpagenr([@{arg@}])
結果は数値で、カレントタブページの番号。最初のタブページの番号は 1 となる。

省略可能な引数 @{arg@} に指定できる値は "$" のみであり、最後のタブページの番号 (つまりタブページの個数) を返す。

この番号はコマンド |@ref{:tab}| で指定できるものと同じである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
tabpagewinnr({tabarg} [, {arg}])			*tabpagewinnr()*
		Like |winnr()| but for tab page {tabarg}.
		{tabarg} specifies the number of tab page to be used.
		{arg} is used like with |winnr()|:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tabpagewinnr()}
@findex tabpagewinnr()
@item tabpagewinnr(@{tabarg@} [, @{arg@}])
|@ref{winnr()}| と同様だが、タブページ @{tabarg@} を対象とする。

@{tabarg@} は対象とするタブページの番号を指定する。

@{arg@} は |@ref{winnr()}| の場合と同じように扱われる。すなわち:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		- When omitted the current window number is returned.  This is
		  the window which will be used when going to this tab page.
		- When "$" the number of windows is returned.
		- When "#" the previous window nr is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item 省略するとカレントウィンドウの番号を返す。これは、このタブページに入るとき使われるウィンドウである。
@item "$" とするとウィンドウの個数を返す。
@item "#" とすると前のウィンドウ番号を返す。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Useful examples: >
		    tabpagewinnr(1)	    " current window of tab page 1
		    tabpagewinnr(4, '$')    " number of windows in tab page 4
<		When {tabarg} is invalid zero is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
役に立つ例:
@example
tabpagewinnr(1)         " タブページ 1 のカレントウィンドウ
tabpagewinnr(4, '$')    " タブページ 4 内のウィンドウの個数
@end example
@{tabarg@} が無効なときは 0 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*tagfiles()*
tagfiles()	Returns a |List| with the file names used to search for tags
		for the current buffer.  This is the 'tags' option expanded.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tagfiles()}
@findex tagfiles()
@item tagfiles()
カレントバッファにおいて、タグを検索するときに使うファイルの名前からなるリスト |@ref{List}| を返す。オプション '@option{tags}' を展開したものである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
taglist({expr} [, {filename}])				*taglist()*
		Returns a list of tags matching the regular expression {expr}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{taglist()}
@findex taglist()
@item taglist(@{expr@} [, @{filename@}])
正規表現 @{expr@} にマッチするタグのリストを返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {filename} is passed it is used to prioritize the results
		in the same way that |:tselect| does. See |tag-priority|.
		{filename} should be the full path of the file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もし @{filename@} が省略されると、|@ref{:tselect}| がするのと同じ方法の結果が優先される。|@ref{tag-priority}| を参照。@{filename@} はファイルへのフルパスである必要がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Each list item is a dictionary with at least the following
		entries:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
そのリストの各要素は辞書であり、少なくとも次の要素を持つ:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			name		Name of the tag.
			filename	Name of the file where the tag is
					defined.  It is either relative to the
					current directory or a full path.
			cmd		Ex command used to locate the tag in
					the file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@headitem name @tab タグの名前。
@item filename @tab タグの定義があるファイルの名前。カレントディレクトリからの相対パス、またはフルパスである。
@item cmd @tab そのファイルの中でタグの位置を特定するために使う ex コマンド。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			kind		Type of the tag.  The value for this
					entry depends on the language specific
					kind values.  Only available when
					using a tags file generated by
					Exuberant ctags or hdrtag.
			static		A file specific tag.  Refer to
					|static-tag| for more information.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item kind @tab タグの種類。種類は言語に依存する。この要素は、Exuberant ctags か hdrtag によって生成されたタグファイルを使っているときのみ使用できる。
@item static @tab ファイル固有のタグ。より詳しくは |@ref{static-tag}| を参照。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		More entries may be present, depending on the content of the
		tags file: access, implementation, inherits and signature.
		Refer to the ctags documentation for information about these
		fields.  For C code the fields "struct", "class" and "enum"
		may appear, they give the name of the entity the tag is
		contained in.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
タグファイルの内容によってはこれ以上の要素が存在することもある。例: アクセス、実装、継承、シグネチャ。これらのフィールドについての情報は ctags のドキュメントを参照。C のソースにおいては、フィールド "struct"、"class"、"enum" が現れることがある。これらは、タグを含んでいるものの名前を示す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The ex-command "cmd" can be either an ex search pattern, a
		line number or a line number followed by a byte number.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ex コマンド "cmd" は検索パターンか、行番号か、行番号とバイト番号のいずれかである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If there are no matching tags, then an empty list is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マッチするタグがない場合は空リストを返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		To get an exact tag match, the anchors '^' and '$' should be
		used in {expr}.  This also make the function work faster.
		Refer to |tag-regexp| for more information about the tag
		search regular expression pattern.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
完全一致するタグを取得するには、@{expr@} にアンカー '^' と '$' をつけること。これは関数の動作を速くすることにもなる。タグ検索の正規表現についてより詳しいことは |@ref{tag-regexp}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Refer to |'tags'| for information about how the tags file is
		located by Vim. Refer to |tags-file-format| for the format of
		the tags file generated by the different ctags tools.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim が使用するタグファイルについては |@ref{'tags'}| を参照。様々な ctags によって生成されるタグファイルのフォーマットについては |@ref{tags-file-format}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
tan({expr})						*tan()*
		Return the tangent of {expr}, measured in radians, as a |Float|
		in the range [-inf, inf].
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo tan(10)
<			0.648361 >
			:echo tan(-4.01)
<			-1.181502
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tan()}
@findex tan()
@item tan(@{expr@})
@{expr@} の正接 (タンジェント) をラジアンで返す。値は [-inf, inf] の範囲の浮動小数点数 (|@ref{Float}|)。

@{expr@} は浮動小数点数 (|@ref{Float}|) か数値 (|@ref{Number}|) でなければならない。

例:
@example
:echo tan(10)
0.648361
:echo tan(-4.01)
-1.181502
@end example
@{|@ref{+float}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
tanh({expr})						*tanh()*
		Return the hyperbolic tangent of {expr} as a |Float| in the
		range [-1, 1].
		{expr} must evaluate to a |Float| or a |Number|.
		Examples: >
			:echo tanh(0.5)
<			0.462117 >
			:echo tanh(-1)
<			-0.761594
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tanh()}
@findex tanh()
@item tanh(@{expr@})
@{expr@} の双曲線正接 (ハイパボリックタンジェント) を返す。値は [-1, 1] の範囲の浮動小数点数 (|@ref{Float}|)。

@{expr@} は浮動小数点数 (|@ref{Float}|) か数値 (|@ref{Number}|) でなければならない。

例:
@example
:echo tanh(0.5)
0.462117
:echo tanh(-1)
-0.761594
@end example
@{|@ref{+float}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
tempname()					*tempname()* *temp-file-name*
		The result is a String, which is the name of a file that
		doesn't exist.  It can be used for a temporary file.  The name
		is different for at least 26 consecutive calls.  Example: >
			:let tmpfile = tempname()
			:exe "redir > " . tmpfile
<		For Unix, the file will be in a private directory |tempfile|.
		For MS-Windows forward slashes are used when the 'shellslash'
		option is set or when 'shellcmdflag' starts with '-'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tempname()}
@anchor{temp-file-name}
@findex tempname()
@cindex temp-file-name
@item tempname()
結果は文字列で、存在しないファイルのファイル名を示す。これはテンポラリファイルの名前として使用可能である。少なくとも連続 26 回の呼出しまでは違う名前を生成することが保証される。例:
@example
:let tmpfile = tempname()
:exe "redir > " . tmpfile
@end example
Unix では、ファイルはプライベートなディレクトリに置かれる。|@ref{tempfile}|

MS-Windows では、'@option{shellslash}' がオンのときか '@option{shellcmdflag}' が '-' で始まるときはスラッシュが使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*term_dumpdiff()*
term_dumpdiff({filename}, {filename} [, {options}])
		Open a new window displaying the difference between the two
		files.  The files must have been created with
		|term_dumpwrite()|.
		Returns the buffer number or zero when the diff fails.
		Also see |terminal-diff|.
		NOTE: this does not work with double-width characters yet.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_dumpdiff()}
@findex term_dumpdiff()
@item term_dumpdiff(@{filename@}, @{filename@} [, @{options@}])
2 ファイルの差分を表示している新しいウィンドウを開く。ファイルは |@ref{term_dumpwrite()}| で作成されていなければならない。

diff に失敗した場合はバッファ番号もしくは 0 を返す。|@ref{terminal-diff}| も参照。

@quotation
@strong{Note:} @*
これは 2 バイト文字ではまだ動作しないことに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The top part of the buffer contains the contents of the first
		file, the bottom part of the buffer contains the contents of
		the second file.  The middle part shows the differences.
		The parts are separated by a line of dashes.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バッファの上部は最初のファイルの内容を含み、下部は 2 番目のファイルの内容を含む。真ん中の部分は差分を表示する。それぞれのパートはダッシュのラインで区切られる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If the {options} argument is present, it must be a Dict with
		these possible members:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もしも @{options@} に引数があるなら、次のような要素を持つ辞書になっていなければならない:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "term_name"	     name to use for the buffer name, instead
				     of the first file name.
		   "term_rows"	     vertical size to use for the terminal,
				     instead of using 'termwinsize'
		   "term_cols"	     horizontal size to use for the terminal,
				     instead of using 'termwinsize'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item "term_name" @tab 初期ファイル名の代わりのバッファ名に使うための名前
@item "term_rows" @tab '@option{termwinsize}' を使う代わりの端末が使う高さのサイズ
@item "term_cols" @tab '@option{termwinsize}' を使う代わりの端末が使う幅のサイズ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "vertical"	     split the window vertically
		   "curwin"	     use the current window, do not split the
				     window; fails if the current buffer
				     cannot be |abandon|ed
		   "norestore"	     do not add the terminal window to a
				     session file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "vertical" @tab ウィンドウを垂直に分割する
@item "curwin" @tab カレントウィンドウを使いウィンドウは分割しない; もしもカレントバッファを破棄 |@ref{abandon}| することができないならば失敗する。
@item "norestore" @tab セッションファイルに端末ウィンドウを追加しない
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Each character in the middle part indicates a difference. If
		there are multiple differences only the first in this list is
		used:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
真ん中のそれぞれの文字は差異を示している。もしも複数の差異があるのなら、このリストの最初のものだけが使われる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			X	different character
			w	different width
			f	different foreground color
			b	different background color
			a	different attribute
			+	missing position in first file
			-	missing position in second file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item X @tab 文字が異なる
@item w @tab 幅が異なる
@item f @tab 前景色が異なる
@item b @tab 背景色が異なる
@item a @tab 属性が異なる
@item + @tab 1 つ目のファイルの位置が欠損している
@item - @tab 2 つ目のファイルの位置が欠損している
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Using the "s" key the top and bottom parts are swapped.  This
		makes it easy to spot a difference.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"s" キーを使うと上と下の部分が交換される。これは差異を見つけやすくする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*term_dumpload()*
term_dumpload({filename} [, {options}])
		Open a new window displaying the contents of {filename}
		The file must have been created with |term_dumpwrite()|.
		Returns the buffer number or zero when it fails.
		Also see |terminal-diff|.

		For {options} see |term_dumpdiff()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_dumpload()}
@findex term_dumpload()
@item term_dumpload(@{filename@} [, @{options@}])
@{filename@} の内容を表示している新しいウィンドウを開く。ファイルは |@ref{term_dumpwrite()}| で作成されていなければならない。失敗した場合はバッファ番号もしくは 0 を返す。|@ref{terminal-diff}| も参照。

@{options@} の詳細は |@ref{term_dumpdiff()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*term_dumpwrite()*
term_dumpwrite({buf}, {filename} [, {options}])
		Dump the contents of the terminal screen of {buf} in the file
		{filename}.  This uses a format that can be used with
		|term_dumpload()| and |term_dumpdiff()|.
		If {filename} already exists an error is given.	*E953*
		Also see |terminal-diff|.

		{options} is a dictionary with these optional entries:
			"rows"		maximum number of rows to dump
			"columns"	maximum number of columns to dump
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_dumpwrite()}
@findex term_dumpwrite()
@item term_dumpwrite(@{buf@}, @{filename@} [, @{options@}])
ファイル @{filename@} 内の @{buf@} のターミナル画面の内容をダンプする。これは |@ref{term_dumpload()}| と |@ref{term_dumpdiff()}| で使われるフォーマットを使う。

@anchor{E953}
@erindex E953
もしも @{filename@} がすでに存在しているならエラーが与えられる。|@ref{terminal-diff}| も参照。

@{options@} は次のオプションを持つ辞書:
@multitable @columnfractions .3 .7
@item "rows" @tab ダンプする行の最大値
@item "columns" @tab ダンプする列の最大値
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getaltscreen({buf})				*term_getaltscreen()*
		Returns 1 if the terminal of {buf} is using the alternate
		screen.
		{buf} is used as with |term_getsize()|.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getaltscreen()}
@findex term_getaltscreen()
@item term_getaltscreen(@{buf@})
@{buf@} のターミナルがオルタネートスクリーンを使っているなら 1 を返す。

@{buf@} は |@ref{term_getsize()}| と同様に使われる。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getansicolors({buf})				*term_getansicolors()*
		Get the ANSI color palette in use by terminal {buf}.
		Returns a List of length 16 where each element is a String
		representing a color in hexadecimal "#rrggbb" format.
		Also see |term_setansicolors()| and |g:terminal_ansi_colors|.
		If neither was used returns the default colors.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getansicolors()}
@findex term_getansicolors()
@item term_getansicolors(@{buf@})
ターミナル @{buf@} で使われている ANSI カラーパレットを取得する。16 の長さのリストを返す。それぞれの項目は 16 進数の "#rrggbb" フォーマットで表わされているカラーです。|@ref{term_setansicolors()}| と |@ref{g:terminal_ansi_colors}| も参照。もしもどちらも使われていなければ、デフォルト色が返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{buf} is used as with |term_getsize()|.  If the buffer does not
		exist or is not a terminal window, an empty list is returned.
		{only available when compiled with the |+terminal| feature and
		with GUI enabled and/or the |+termguicolors| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{buf@} は |@ref{term_getsize()}| と同様に使われる。もしもバッファが存在しないか端末ウィンドウでなければ、空のリストが返される。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたとき、かつ GUI が有効のとき、かつ/または |@ref{+termguicolors}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getattr({attr}, {what})				*term_getattr()*
		Given {attr}, a value returned by term_scrape() in the "attr"
		item, return whether {what} is on.  {what} can be one of:
			bold
			italic
			underline
			strike
			reverse
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getattr()}
@findex term_getattr()
@item term_getattr(@{attr@}, @{what@})
与えられた @{attr@}。要素中で term_scrape() によって返された値。@{what@} がオンかどうかを返す。 @{what@} は次のうちのどれか:
@example
bold
italic
underline
strike
reverse
@end example
@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getcursor({buf})					*term_getcursor()*
		Get the cursor position of terminal {buf}. Returns a list with
		two numbers and a dictionary: [row, col, dict].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getcursor()}
@findex term_getcursor()
@item term_getcursor(@{buf@})
ターミナル @{buf@} のカーソル位置を取得する。2 つの数値と辞書のリストを返す: [row, col, dict]。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		"row" and "col" are one based, the first screen cell is row
		1, column 1.  This is the cursor position of the terminal
		itself, not of the Vim window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"row" と "col" は原点で、1 番目のスクリーンのセルは row が 1 で column が 1。これはターミナル自身のカーソルの位置で Vim ウィンドウのものではない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		"dict" can have these members:
		   "visible"	one when the cursor is visible, zero when it
				is hidden.
		   "blink"	one when the cursor is visible, zero when it
				is hidden.
		   "shape"	1 for a block cursor, 2 for underline and 3
				for a vertical bar.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"dict" は 3 つの数値を持てる:
@multitable @columnfractions .2 .8
@item "visible" @tab カーソルが可視なら 1、不可視なら 0
@item "blink" @tab カーソルが可視なら 1、不可視なら 0
@item "shape" @tab カーソルの形がブロックなら 1、アンダーラインなら 2、バーティカルなら 3。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{buf} must be the buffer number of a terminal window. If the
		buffer does not exist or is not a terminal window, an empty
		list is returned.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{buf@} はターミナルウィンドウのバッファ番号でなければならない。バッファが存在しないか、ターミナルウィンドウでなければ、空のリストが返される。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getjob({buf})					*term_getjob()*
		Get the Job associated with terminal window {buf}.
		{buf} is used as with |term_getsize()|.
		Returns |v:null| when there is no job.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getjob()}
@findex term_getjob()
@item term_getjob(@{buf@})
ターミナルウィンドウの @{buf@} と関連付けられたジョブを取得する。@{buf@} は |@ref{term_getsize()}| として使われる。ジョブがない場合は |@ref{v:null}| を返す。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getline({buf}, {row})				*term_getline()*
		Get a line of text from the terminal window of {buf}.
		{buf} is used as with |term_getsize()|.

		The first line has {row} one.  When {row} is "." the cursor
		line is used.  When {row} is invalid an empty string is
		returned.

		To get attributes of each character use |term_scrape()|.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getline()}
@findex term_getline()
@item term_getline(@{buf@}, @{row@})
ターミナルウィンドウの @{buf@} からテキストの 1 行を取得する。@{buf@} は |@ref{term_getsize()}| として使われる。

1 番目の行は @{row@} を 1 つ持っている。@{row@} が "." のとき、カーソル行が使われる。@{row@} が正しくなければ、空文字列が返される。

それぞれの文字の属性を取得するには |@ref{term_scrape()}| を使う。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getscrolled({buf})					*term_getscrolled()*
		Return the number of lines that scrolled to above the top of
		terminal {buf}.  This is the offset between the row number
		used for |term_getline()| and |getline()|, so that: >
			term_getline(buf, N)
<		is equal to: >
			`getline(N + term_getscrolled(buf))
<		(if that line exists).

		{buf} is used as with |term_getsize()|.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getscrolled()}
@findex term_getscrolled()
@item term_getscrolled(@{buf@})
ターミナル @{buf@} の上方にスクロールされた行数を返す。これは |@ref{term_getline()}| と |@ref{getline()}| で使われる行番号のオフセット。
そのため:
@example
term_getline(buf, N)
@end example
は次と同じ:
@example
`getline(N + term_getscrolled(buf))
@end example
(その行が存在するなら)。

@{buf@} は |@ref{term_getsize()}| として使われる。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getsize({buf})					*term_getsize()*
		Get the size of terminal {buf}. Returns a list with two
		numbers: [rows, cols].  This is the size of the terminal, not
		the window containing the terminal.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getsize()}
@findex term_getsize()
@item term_getsize(@{buf@})
ターミナル @{buf@} のサイズを取得する。2 つの数値を持つリストを返す: [rows, cols]。これはターミナルのサイズであって、ターミナルを持っているウィンドウのサイズではない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{buf} must be the buffer number of a terminal window.  Use an
		empty string for the current buffer.  If the buffer does not
		exist or is not a terminal window, an empty list is returned.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{buf@} はターミナルウィンドウのバッファ番号でなければならない。カレントバッファのために空文字列を使う。バッファが存在しないか、ターミナルウィンドウでなければ、空リストが返される。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getstatus({buf})					*term_getstatus()*
		Get the status of terminal {buf}. This returns a comma
		separated list of these items:
			running		job is running
			finished	job has finished
			normal		in Terminal-Normal mode
		One of "running" or "finished" is always present.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getstatus()}
@findex term_getstatus()
@item term_getstatus(@{buf@})
ターミナル @{buf@} のステータスを取得する。次の項目のコンマ区切りのリストを返す:
@multitable @columnfractions .3 .7
@item running @tab ジョブは動作中
@item finished @tab ジョブは停止
@item normal @tab Terminal-Normal モード中
@end multitable
"running" もしくは "finished" のどちらかが常に存在する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{buf} must be the buffer number of a terminal window. If the
		buffer does not exist or is not a terminal window, an empty
		string is returned.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{buf@} はターミナルウィンドウのバッファ番号でなければならない。バッファが存在しないか、ターミナルウィンドウでなければ、空文字列が返される。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_gettitle({buf})					*term_gettitle()*
		Get the title of terminal {buf}. This is the title that the
		job in the terminal has set.

		{buf} must be the buffer number of a terminal window. If the
		buffer does not exist or is not a terminal window, an empty
		string is returned.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_gettitle()}
@findex term_gettitle()
@item term_gettitle(@{buf@})
ターミナル @{buf@} のタイトルを取得する。これはターミナル内で設定されたジョブのタイトル。

@{buf@} はターミナルウィンドウのバッファ番号でなければならない。バッファが存在しないか、ターミナルウィンドウでなければ、空文字列が返される。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_gettty({buf} [, {input}])				*term_gettty()*
		Get the name of the controlling terminal associated with
		terminal window {buf}.  {buf} is used as with |term_getsize()|.

		When {input} is omitted or 0, return the name for writing
		(stdout). When {input} is 1 return the name for reading
		(stdin). On UNIX, both return same name.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_gettty()}
@findex term_gettty()
@item term_gettty(@{buf@} [, @{input@}])
ターミナルウィンドウ @{buf@} に関連付けらてた制御中のターミナルの名前を取得する。@{buf@} は |@ref{term_getsize()}| として使われる。

@{input@} が省略されるか 0 なら、書き込んでいる名前を返す (stdout)。@{input@} が 1 なら、読み込んでいる名前を返す (stdin)。UNIX ではどちらも同じ名前を返す。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_list()						*term_list()*
		Return a list with the buffer numbers of all buffers for
		terminal windows.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_list()}
@findex term_list()
@item term_list()
ターミナルウィンドウのためのすべてのバッファのバッファ番号を持つリスト

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_scrape({buf}, {row})				*term_scrape()*
		Get the contents of {row} of terminal screen of {buf}.
		For {buf} see |term_getsize()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_scrape()}
@findex term_scrape()
@item term_scrape(@{buf@}, @{row@})
@{buf@} のターミナルスクリーンの @{row@} の内容を取得する。@{buf@} のためには |@ref{term_getsize()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The first line has {row} one.  When {row} is "." the cursor
		line is used.  When {row} is invalid an empty string is
		returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
1 番目の行は @{row@} を 1 つ持っている。@{row@} が "." のとき、カーソル行が使われる。@{row@} が正しくなければ、空文字列が返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Return a List containing a Dict for each screen cell:
		    "chars"	character(s) at the cell
		    "fg"	foreground color as #rrggbb
		    "bg"	background color as #rrggbb
		    "attr"	attributes of the cell, use |term_getattr()|
				to get the individual flags
		    "width"	cell width: 1 or 2
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
それぞれのスクリーンセルのための辞書を含むリストを返す:
@multitable @columnfractions .2 .8
@item "chars" @tab セルの文字
@item "fg" @tab #rrggbb 形式の前景色
@item "bg" @tab #rrggbb 形式の背景色
@item "attr" @tab セルの属性。個々のフラグを取得するには |@ref{term_getattr()}| を使う
@item "width" @tab セルの幅: 1 もしくは 2
@end multitable
@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_sendkeys({buf}, {keys})				*term_sendkeys()*
		Send keystrokes {keys} to terminal {buf}.
		{buf} is used as with |term_getsize()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_sendkeys()}
@findex term_sendkeys()
@item term_sendkeys(@{buf@}, @{keys@})
ターミナル @{buf@} にキーストローク @{keys@} を送る。@{buf@} は |@ref{term_getsize()}| として使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{keys} are translated as key sequences. For example, "\<c-x>"
		means the character CTRL-X.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{keys@} はキーの連続として解釈される。例えば、"\<c-x>" は @kbd{CTRL-X} を意味する。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_setansicolors({buf}, {colors})			*term_setansicolors()*
		Set the ANSI color palette used by terminal {buf}.
		{colors} must be a List of 16 valid color names or hexadecimal
		color codes, like those accepted by |highlight-guifg|.
		Also see |term_getansicolors()| and |g:terminal_ansi_colors|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_setansicolors()}
@findex term_setansicolors()
@item term_setansicolors(@{buf@}, @{colors@})
ターミナル @{buf@} で使われている ANSI カラーパレットを設定する。@{colors@} は 正しい 16 ANSI カラーか、|@ref{highlight-guifg}| で認められているような 16 進数のカラーコードのリストでなければならない。|@ref{term_getansicolors()}| と |@ref{g:terminal_ansi_colors}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The colors normally are:
			0    black
			1    dark red
			2    dark green
			3    brown
			4    dark blue
			5    dark magenta
			6    dark cyan
			7    light grey
			8    dark grey
			9    red
			10   green
			11   yellow
			12   blue
			13   magenta
			14   cyan
			15   white
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カラーは通常、以下のとおり:
@multitable @columnfractions .2 .8
@item 0 @tab black
@item 1 @tab dark red
@item 2 @tab dark green
@item 3 @tab brown
@item 4 @tab dark blue
@item 5 @tab dark magenta
@item 6 @tab dark cyan
@item 7 @tab light grey
@item 8 @tab dark grey
@item 9 @tab red
@item 10 @tab green
@item 11 @tab yellow
@item 12 @tab blue
@item 13 @tab magenta
@item 14 @tab cyan
@item 15 @tab white
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		These colors are used in the GUI and in the terminal when
		'termguicolors' is set.  When not using GUI colors (GUI mode
		or 'termguicolors'), the terminal window always uses the 16
		ANSI colors of the underlying terminal.
		{only available when compiled with the |+terminal| feature and
		with GUI enabled and/or the |+termguicolors| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのカラーは '@option{termguicolors}' が設定されているときに GUI と端末で使われる。GUI カラーが使われていないとき (GUI モードもしくは '@option{termguicolors}' が設定されている)、端末ウィンドウは常に、端末の根底にある 16 ANSI カラーを使う。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたとき、かつ GUI が有効のとき、かつ/または |@ref{+termguicolors}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_setkill({buf}, {how})				*term_setkill()*
		When exiting Vim or trying to close the terminal window in
		another way, {how} defines whether the job in the terminal can
		be stopped.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_setkill()}
@findex term_setkill()
@item term_setkill(@{buf@}, @{how@})
Vim を終了もしくは他の方法で端末ウィンドウを閉じようとしているとき、@{how@} は端末のジョブを停止することができるかどうか明確にする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When {how} is empty (the default), the job will not be
		stopped, trying to exit will result in |E947|.
		Otherwise, {how} specifies what signal to send to the job.
		See |job_stop()| for the values.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@{how@} が空 (既定) のとき、ジョブは停止されず、終了しようとしたことは |@ref{E947}| の結果を生じる。さもなければ、@{how@} はジョブに送られたシグナルが何であるかを明示する。値については |@ref{job_stop()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		After sending the signal Vim will wait for up to a second to
		check that the job actually stopped.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シグナルが送られたあと、Vim はジョブが実際に停止するのを確認するまでの時間 (秒) 待機するだろう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_setrestore({buf}, {command})			*term_setrestore()*
		Set the command to write in a session file to restore the job
		in this terminal.  The line written in the session file is: >
			terminal ++curwin ++cols=%d ++rows=%d {command}
<		Make sure to escape the command properly.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_setrestore()}
@findex term_setrestore()
@item term_setrestore(@{buf@}, @{command@})
端末内のジョブを復帰するために、セッションファイル内に書き込むコマンドを設定する。セッションファイルに書き込まれる行は:
@example
terminal ++curwin ++cols=%d ++rows=%d @{command@}
@end example
コマンドが適切にエスケープされているか確認すること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Use an empty {command} to run 'shell'.
		Use "NONE" to not restore this window.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'shell' を実行するには 空 @{command@} を使う。

このウィンドウを復帰しないようにするには "NONE" を使う。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_setsize({buf}, {rows}, {cols})		*term_setsize()* *E955*
		Set the size of terminal {buf}. The size of the window
		containing the terminal will also be adjusted, if possible.
		If {rows} or {cols} is zero or negative, that dimension is not
		changed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_setsize()}
@anchor{E955}
@findex term_setsize()
@erindex E955
@item term_setsize(@{buf@}, @{rows@}, @{cols@})
ターミナル @{buf@} のサイズを設定する。もしも可能ならターミナルを含んでいるウィンドウのサイズも調整されるだろう。もしも @{rows@} や @{cols@} がゼロかマイナスならば、サイズは変更されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{buf} must be the buffer number of a terminal window.  Use an
		empty string for the current buffer.  If the buffer does not
		exist or is not a terminal window, an error is given.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{buf@} は端末ウィンドウのバッファ番号でなければならない。現在のバッファに適用するには空文字列を使う。もしもバッファが存在しないか端末ウィンドウでなければ、エラーになる。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_start({cmd}, {options})				*term_start()*
		Open a terminal window and run {cmd} in it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_start()}
@findex term_start()
@item term_start(@{cmd@}, @{options@})
ターミナルウィンドウを開きその中で @{cmd@} を起動する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{cmd} can be a string or a List, like with |job_start()|. The
		string "NONE" can be used to open a terminal window without
		starting a job, the pty of the terminal can be used by a
		command like gdb.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{cmd@} は文字列もしくは |@ref{job_start()}| のようなリストになりうる。文字列 "NONE" はジョブを開始することなくターミナルウィンドウを開くのに使われる。ターミナルの pty は gdb のようなコマンドによって使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Returns the buffer number of the terminal window.  If {cmd}
		cannot be executed the window does open and shows an error
		message.
		If opening the window fails zero is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ターミナルウィンドウのバッファ番号を返す。@{cmd@} が実行できないときは、ウィンドウを開いてエラーメッセジを表示する。

ウィンドウを開くのに失敗すると 0 が返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{options} are similar to what is used for |job_start()|, see
		|job-options|.  However, not all options can be used.  These
		are supported:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{options@} は |@ref{job_start()}| で使われるものと似ている。|@ref{job-options}| を参照。しかしながら、すべてのオプションが使われるわけではない。次のものがサポートされている:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   all timeout options
		   "stoponexit", "cwd", "env"
		   "callback", "out_cb", "err_cb", "exit_cb", "close_cb"
		   "in_io", "in_top", "in_bot", "in_name", "in_buf"
		   "out_io", "out_name", "out_buf", "out_modifiable", "out_msg"
		   "err_io", "err_name", "err_buf", "err_modifiable", "err_msg"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
すべてのタイムアウトオプション
"stoponexit", "cwd", "env"
"callback", "out_cb", "err_cb", "exit_cb", "close_cb"
"in_io", "in_top", "in_bot", "in_name", "in_buf"
"out_io", "out_name", "out_buf", "out_modifiable", "out_msg"
"err_io", "err_name", "err_buf", "err_modifiable", "err_msg"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		However, at least one of stdin, stdout or stderr must be
		connected to the terminal.  When I/O is connected to the
		terminal then the callback function for that part is not used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
少なくとも標準入力が 1 つであるが、標準出力か標準エラーはターミナルに接続されていなければならない。I/O がターミナルに接続されているときは、その部分のコールバック関数は使われない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		There are extra options:
		   "term_name"	     name to use for the buffer name, instead
				     of the command name.
		   "term_rows"	     vertical size to use for the terminal,
				     instead of using 'termwinsize'
		   "term_cols"	     horizontal size to use for the terminal,
				     instead of using 'termwinsize'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
特別なオプションがある:
@multitable @columnfractions .3 .7
@item "term_name" @tab バッファ名に使う名前。コマンド名の代わり
@item "term_rows" @tab ターミナルで使う高さ。'@option{termwinsize}' の代わり
@item "term_cols" @tab ターミナルで使う幅。'@option{termwinsize}' の代わり
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "vertical"	     split the window vertically; note that
				     other window position can be defined with
				     command modifiers, such as |:belowright|.
		   "curwin"	     use the current window, do not split the
				     window; fails if the current buffer
				     cannot be |abandon|ed
		   "hidden"	     do not open a window
		   "norestore"	     do not add the terminal window to a
				     session file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "vertical" @tab ウィンドウを垂直に分割する。
@quotation
@strong{Note:} @*
その他のウィンドウ位置は |@ref{:belowright}| のようなコマンド修飾子によって定義されうることに注意。
@end quotation
@item "curwin" @tab カレントウィンドウを使う。ウィンドウは分割しない。カレントバッファを放棄 |@ref{abandon}| できなければ失敗する
@item "hidden" @tab ウィンドウを開かない
@item "norestore" @tab セッションファイルのためにターミナルウィンドウを追加しない
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "term_kill"	     what to do when trying to close the
				     terminal window, see |term_setkill()|
		   "term_finish"     What to do when the job is finished:
					"close": close any windows
					"open": open window if needed
				     Note that "open" can be interruptive.
				     See |term++close| and |term++open|.
		   "term_opencmd"    command to use for opening the window when
				     "open" is used for "term_finish"; must
				     have "%d" where the buffer number goes,
				     e.g. "10split|buffer %d"; when not
				     specified "botright sbuf %d" is used
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "term_kill" @tab 端末ウィンドウを閉じようとしたときにすること。|@ref{term_setkill()}| を参照
@item "term_finish" @tab
ジョブが終了したときの処理:
@multitable @columnfractions .2 .8
@item "close": @tab すべてウィンドウを閉じる
@item "open": @tab 必要ならばウィンドウを開く
@end multitable
@quotation
@strong{Note:} @*
"open" は中断できることに注意。
@end quotation
|@ref{term++close}| と |@ref{term++open}| を参照。
@item "term_opencmd" @tab
"term_finish" のために "open" が使われるとき、ウィンドウを開くためのコマンド。バッファ番号の先に "%d" がなければならない。例えば "10split|buffer %d"。これが指定されていなければ、"botright sbuf %d" が使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "eof_chars"	     Text to send after all buffer lines were
				     written to the terminal.  When not set
				     CTRL-D is used on MS-Windows. For Python
				     use CTRL-Z or "exit()". For a shell use
				     "exit".  A CR is always added.
		   "ansi_colors"     A list of 16 color names or hex codes
				     defining the ANSI palette used in GUI
				     color modes.  See |g:terminal_ansi_colors|.

		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "eof_chars" @tab
ターミナルに書き込まれるすべてのバッファ行のあとに送られるテキスト。これが設定されていないとき、MS-Windows では CTRL-D が使われる。Python では CTRL-Z か "exit()" が使われる。シェルでは "exit" が使われる。CR は常に付加される。
@item "ansi_colors" @tab
16 ANSI カラーの名前か GUI カラーモードで使われている ANSI パレットで定義されている 16 進数のカラーコードのリスト。|@ref{g:terminal_ansi_colors}| を参照
@end multitable
@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_wait({buf} [, {time}])					*term_wait()*
		Wait for pending updates of {buf} to be handled.
		{buf} is used as with |term_getsize()|.
		{time} is how long to wait for updates to arrive in msec.  If
		not set then 10 msec will be used.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item term_wait(@{buf@} [, @{time@}])
@anchor{term_wait()}
@findex term_wait()
処理する @{buf@} の更新を待つ。

@{buf@} は |@ref{term_getsize()}| として使われる。

@{time@} はアップデートまでのミリ秒。設定されていなければ 10 ミリ秒が使われる。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
test_alloc_fail({id}, {countdown}, {repeat})		*test_alloc_fail()*
		This is for testing: If the memory allocation with {id} is
		called, then decrement {countdown}, and when it reaches zero
		let memory allocation fail {repeat} times.  When {repeat} is
		smaller than one it fails one time.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{test_alloc_fail()}
@findex test_alloc_fail()
@item test_alloc_fail(@{id@}, @{countdown@}, @{repeat@})
この関数はテストのために使われる: @{id@} のメモリ割り当てが行われた際に @{countdown@} はデクリメントされ、それが 0 になれば @{repeat@} 回のメモリの割り当ての失敗を発生させる。@{repeat@} が 1 未満の場合は、失敗を 1 回のみ発生させる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
test_autochdir()					*test_autochdir()*
		Set a flag to enable the effect of 'autochdir' before Vim
		startup has finished.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{test_autochdir()}
@findex test_autochdir()
@item test_autochdir()
Vim の起動が完了する前に '@option{autochdir}' の効果を有効にするためのフラグをセットする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
test_feedinput({string})				*test_feedinput()*
		Characters in {string} are queued for processing as if they
		were typed by the user. This uses a low level input buffer.
		This function works only when with |+unix| or GUI is running.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{test_feedinput()}
@findex test_feedinput()
@item test_feedinput(@{string@})
@{string@} 中の文字は、まるでユーザーによって入力されたかのようにプロセスに渡される。これは低レベルの入力バッファを使う。この関数は |@ref{+unix}| もしくは GUI の環境でのみ機能する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
test_garbagecollect_now()			 *test_garbagecollect_now()*
		Like garbagecollect(), but executed right away.  This must
		only be called directly to avoid any structure to exist
		internally, and |v:testing| must have been set before calling
		any function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{test_garbagecollect_now()}
@findex test_garbagecollect_now()
@item test_garbagecollect_now()
garbagecollect() とほぼ同じであるが、この関数はガーベッジコレクトを直ちに実行する。この関数を実行する場合は、構造体が内部に存在しないようにするために直接呼び出す必要がある。また、この関数を呼び出す前に |@ref{v:testing}| を設定する必要がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
test_ignore_error({expr})			 *test_ignore_error()*
		Ignore any error containing {expr}.  A normal message is given
		instead.
		This is only meant to be used in tests, where catching the
		error with try/catch cannot be used (because it skips over
		following code).
		{expr} is used literally, not as a pattern.
		There is currently no way to revert this.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{test_ignore_error()}
@findex test_ignore_error()
@item test_ignore_error(@{expr@})
@{expr@} を含むすべてのエラーを無視する。代わりに通常メッセージが表示される。

これは、テストにおいて、try/catch を用いてエラーを捕捉できない (以降のコードをスキップするので) 場合のみに使うことを意図している。

@{expr@} は文字通り用いられ、パターンとしてではない。

現在、これを元に戻す方法はない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
test_null_channel()					*test_null_channel()*
		Return a Channel that is null. Only useful for testing.
		{only available when compiled with the +channel feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{test_null_channel()}
@findex test_null_channel()
@item test_null_channel()
null の Channel を返す。これはテストのみに使われる。

@{|@ref{+channel}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
test_null_dict()					*test_null_dict()*
		Return a Dict that is null. Only useful for testing.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{test_null_dict()}
@findex test_null_dict()
@item test_null_dict()
null の Dict を返す。これはテストのみに使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
test_null_job()						*test_null_job()*
		Return a Job that is null. Only useful for testing.
		{only available when compiled with the +job feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{test_null_job()}
@findex test_null_job()
@item test_null_job()
null の Job を返す。これはテストのみに使われる。

@{|@ref{+job}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
test_null_list()					*test_null_list()*
		Return a List that is null. Only useful for testing.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{test_null_list()}
@findex test_null_list()
@item test_null_list()
null の List を返す。これはテストのみに使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
test_null_partial()					*test_null_partial()*
		Return a Partial that is null. Only useful for testing.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{test_null_partial()}
@findex test_null_partial()
@item test_null_partial()
null の Partial を返す。これはテストのみに使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
test_null_string()					*test_null_string()*
		Return a String that is null. Only useful for testing.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{test_null_string()}
@findex test_null_string()
@item test_null_string()
null の String を返す。これはテストのみに使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
test_override({name}, {val})				*test_override()*
		Overrides certain parts of Vims internal processing to be able
		to run tests. Only to be used for testing Vim!
		The override is enabled when {val} is non-zero and removed
		when {val} is zero.
		Current supported values for name are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{test_override()}
@findex test_override()
@item test_override(@{name@}, @{val@})
テストを実行できるようにするため、Vim の内部処理の特定の部分を置き換える。Vim をテストするためだけに使用すること！

置き換えは、@{val@} が非 0 のときに有効化され、@{val@} が 0 のときに取り除かれる。

現在、name に使える値は:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		name	     effect when {val} is non-zero ~
		redraw       disable the redrawing() function
		redraw_flag  ignore the RedrawingDisabled flag
		char_avail   disable the char_avail() function
		starting     reset the "starting" variable, see below
		nfa_fail     makes the NFA regexp engine fail to force a
			     fallback to the old engine
		ALL	     clear all overrides ({val} is not used)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@headitem name @tab @{val@} が非 0 のときの効果
@item redraw @tab redrawing() 関数を無効化する
@item redraw_flag @tab RedrawingDisabled フラグを無視する
@item char_avail @tab char_avail() 関数を無効化する
@item starting @tab "starting" の値をリセットする。以下を参照
@item nfa_fail @tab NFA 正規表現エンジンが失敗すると強制的に古いエンジンにフォールバックする
@item ALL @tab すべての置き換えをクリアする (@{val@} は使われない)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		"starting" is to be used when a test should behave like
		startup was done.  Since the tests are run by sourcing a
		script the "starting" variable is non-zero. This is usually a
		good thing (tests run faster), but sometimes changes behavior
		in a way that the test doesn't work properly.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim の起動が完了した時と同じ状況としてテストをしたい場合に "starting" は使われる。テストはスクリプトを読み込んで実行されるので、"starting" の値は非ゼロ。このことは多くの場合で良いこと (テストの実行が速い) なのだが、テストがうまく動かない場合に挙動が変化するときがある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When using: >
			call test_override('starting', 1)
<		The value of "starting" is saved.  It is restored by: >
			call test_override('starting', 0)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

使用時:
@example
call test_override('starting', 1)
@end example
"starting" の値は保存される。この値は次のようにして復元できる:
@example
call test_override('starting', 0)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
test_settime({expr})					*test_settime()*
		Set the time Vim uses internally.  Currently only used for
		timestamps in the history, as they are used in viminfo, and
		for undo.
		Using a value of 1 makes Vim not sleep after a warning or
		error message.
		{expr} must evaluate to a number.  When the value is zero the
		normal behavior is restored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{test_settime()}
@findex test_settime()
@item test_settime(@{expr@})
Vim が内部的に用いる時間を設定する。現在は history のタイムスタンプ、viminfo のタイムスタンプ、undo に使用されている。

1 を渡せば、Vim は、警告やエラーメッセージの後、スリープしなくなる。

@{expr@} は、数値として評価されなければならない。0 を渡せば、Vim の内部時間は通常動作に戻る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*timer_info()*
timer_info([{id}])
		Return a list with information about timers.
		When {id} is given only information about this timer is
		returned.  When timer {id} does not exist an empty list is
		returned.
		When {id} is omitted information about all timers is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{timer_info()}
@findex timer_info()
@item timer_info([@{id@}])
タイマーに関する情報のリストを返す。

@{id@} が指定された場合はそのタイマーに関する情報だけが返される。タイマー @{id@} が存在しない場合は空のリストが返される。

@{id@} が省略された場合は全てのタイマーに関する情報が返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For each timer the information is stored in a Dictionary with
		these items:
		    "id"	    the timer ID
		    "time"	    time the timer was started with
		    "remaining"	    time until the timer fires
		    "repeat"	    number of times the timer will still fire;
				    -1 means forever
		    "callback"	    the callback
		    "paused"	    1 if the timer is paused, 0 otherwise

		{only available when compiled with the |+timers| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
各タイマーの情報は以下の項目を含んだ辞書で格納される:
@multitable @columnfractions .2 .8
@headitem "id" @tab タイマーのID
@item "time" @tab タイマーが開始してからの時間
@item "remaining" @tab タイマーが発火するまでの時間
@item "repeat" @tab 何回タイマーを発火させるかの回数; -1 は無限を意味する
@item "callback" @tab コールバック
@item "paused" @tab タイマーが一時停止中なら 1、それ以外は 0
@end multitable
@{|@ref{+timers}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
timer_pause({timer}, {paused})				*timer_pause()*
		Pause or unpause a timer.  A paused timer does not invoke its
		callback when its time expires.  Unpausing a timer may cause
		the callback to be invoked almost immediately if enough time
		has passed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{timer_pause()}
@findex timer_pause()
@item timer_pause(@{timer@}, @{paused@})
タイマーを一時停止もしくは再開する。一時停止したタイマーは時間が経過してもコールバックを呼び出さない。タイマーの再開は十分に時間が経過しているなら、すぐさまコールバックが呼び出されるかもしれない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Pausing a timer is useful to avoid the callback to be called
		for a short time.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
タイマーの停止は少しの間、コールバックが呼び出されるのを避けるのに便利である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {paused} evaluates to a non-zero Number or a non-empty
		String, then the timer is paused, otherwise it is unpaused.
		See |non-zero-arg|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{paused@} が 0 以外の数値、もしくは空でない文字列で評価される場合にタイマーが停止し、それ以外は再開する。|@ref{non-zero-arg}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{only available when compiled with the |+timers| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{|@ref{+timers}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*timer_start()* *timer* *timers*
timer_start({time}, {callback} [, {options}])
		Create a timer and return the timer ID.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{timer_start()}
@anchor{timer}
@anchor{timers}
@findex timer_start()
@cindex timer
@cindex timers
@item timer_start(@{time@}, @{callback@} [, @{options@}])
タイマーを作成しその ID を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{time} is the waiting time in milliseconds. This is the
		minimum time before invoking the callback.  When the system is
		busy or Vim is not waiting for input the time will be longer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{time@} はミリ秒での待機時間。これはコールバックが呼び出されるまでの最短の時間である。システムがビジーもしくは Vim が入力待ちでない場合、これは長くなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{callback} is the function to call.  It can be the name of a
		function or a |Funcref|.  It is called with one argument, which
		is the timer ID.  The callback is only invoked when Vim is
		waiting for input.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{callback@} は呼び出す関数。関数の名前もしくは |@ref{Funcref}| であっても良い。引数にはタイマー ID の引数が 1 つだけ渡されて呼び出される。コールバックは Vim が入力待ちの場合だけ呼び出される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{options} is a dictionary.  Supported entries:
		   "repeat"	Number of times to repeat calling the
				callback.  -1 means forever.  When not present
				the callback will be called once.
				If the timer causes an error three times in a
				row the repeat is cancelled.  This avoids that
				Vim becomes unusable because of all the error
				messages.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{options@} は辞書。以下がサポートされている:
@multitable @columnfractions .2 .8
@item "repeat" @tab コールバックを呼び出す繰り返し回数。-1 は無限を意味する。指定されない場合はコールバックは一度だけ呼び出される。

タイマーが一行で 3 度エラーになったら、繰り返しは取り消される。すべてはエラーメッセージなので、Vim が制御不能になるのを防ぐ。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example: >
			func MyHandler(timer)
			  echo 'Handler called'
			endfunc
			let timer = timer_start(500, 'MyHandler',
				\ {'repeat': 3})
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@verbatim
func MyHandler(timer)
  echo 'Handler called'
endfunc
let timer = timer_start(500, 'MyHandler',
        \ {'repeat': 3})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		This will invoke MyHandler() three times at 500 msec
		intervals.

		{only available when compiled with the |+timers| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは MyHandler() を 500ms 間隔で 3 回呼び出す。

@{|@ref{+timers}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
timer_stop({timer})					*timer_stop()*
		Stop a timer.  The timer callback will no longer be invoked.
		{timer} is an ID returned by timer_start(), thus it must be a
		Number.  If {timer} does not exist there is no error.

		{only available when compiled with the |+timers| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{timer_stop()}
@findex timer_stop()
@item timer_stop(@{timer@})
タイマーを停止する。タイマーのコールバックは以降呼び出されない。@{timer@} は timer_start() が返した ID である。よって数値でなければならない。@{timer@} が存在しなかった場合でもエラーは発生しない。

@{|@ref{+timers}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
timer_stopall()						*timer_stopall()*
		Stop all timers.  The timer callbacks will no longer be
		invoked.  Useful if some timers is misbehaving.  If there are
		no timers there is no error.

		{only available when compiled with the |+timers| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{timer_stopall()}
@findex timer_stopall()
@item timer_stopall()
全てのタイマーを停止する。タイマーのコールバックは以降呼び出されない。タイマーが不作法に振る舞う場合に便利である。タイマーが存在しなかった場合でもエラーは発生しない。

@{|@ref{+timers}| 機能を有効にしてコンパイルしたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
tolower({expr})						*tolower()*
		The result is a copy of the String given, with all uppercase
		characters turned into lowercase (just like applying |gu| to
		the string).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tolower()}
@findex tolower()
@item tolower(@{expr@})
引数の文字列の大文字を小文字に変換してできた文字列を返す (文字列に |@ref{gu}| を適用するのとちょうど同じ)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
toupper({expr})						*toupper()*
		The result is a copy of the String given, with all lowercase
		characters turned into uppercase (just like applying |gU| to
		the string).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{toupper()}
@findex toupper()
@item toupper(@{expr@})
引数の文字列の小文字を大文字に変換してできた文字列を返す (文字列に |@ref{gU}| を適用するのとちょうど同じ)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
tr({src}, {fromstr}, {tostr})				*tr()*
		The result is a copy of the {src} string with all characters
		which appear in {fromstr} replaced by the character in that
		position in the {tostr} string.  Thus the first character in
		{fromstr} is translated into the first character in {tostr}
		and so on.  Exactly like the unix "tr" command.
		This code also deals with multibyte characters properly.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tr()}
@findex tr()
@item tr(@{src@}, @{fromstr@}, @{tostr@})
文字列 @{src@} の中で、@{fromstr@} に含まれる全ての文字を @{tostr@} の対応する文字で置き換えた文字列を返す。つまり、@{fromstr@} の最初の文字が @{tostr@} の最初の文字に置き換えられる。2 文字目以降も同様。Unix のコマンド "tr" とちょうど同じである。マルチバイト文字も正しく扱える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Examples: >
			echo tr("hello there", "ht", "HT")
<		returns "Hello THere" >
			echo tr("<blob>", "<>", "{}")
<		returns "{blob}"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
echo tr("hello there", "ht", "HT")
@end example
戻り値は "Hello THere" となる。
@example
echo tr("<blob>", "<>", "@{@}")
@end example
戻り値は "@{blob@}" となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
trim({text} [, {mask}])						*trim()*
		Return {text} as a String where any character in {mask} is
		removed from the beginning and  end of {text}.
		If {mask} is not given, {mask} is all characters up to 0x20,
		which includes Tab, space, NL and CR, plus the non-breaking
		space character 0xa0.
		This code deals with multibyte characters properly.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{trim()}
@findex trim()
@item trim(@{text@} [, @{mask@}])
@{text@} の始めと終わりから、@{mask@} 内にあるどのような文字も削除された文字列として @{text@} を返す。

もしも @{mask@} が与えられていなければ、@{mask@} は 0x20 までのすべての文字となる。これは Tab, space, NL や CR を含み、加えて ノーブレークスペースの 0xa0 も含む。

このコードはマルチバイト文字を適切に扱う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Examples: >
			echo trim("   some text ")
<		returns "some text" >
			echo trim("  \r\t\t\r RESERVE \t\n\x0B\xA0") . "_TAIL"
<		returns "RESERVE_TAIL" >
			echo trim("rm<Xrm<>X>rrm", "rm<>")
<		returns "Xrm<>X" (characters in the middle are not removed)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
echo trim("   some text ")
@end example
"some text" を返す。
@example
echo trim("  \r\t\t\r RESERVE \t\n\x0B\xA0") . "_TAIL"
@end example
"RESERVE_TAIL" を返す。
@example
echo trim("rm<Xrm<>X>rrm", "rm<>")
@end example
"Xrm<>X" (中間の文字は削除されない) を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
trunc({expr})							*trunc()*
		Return the largest integral value with magnitude less than or
		equal to {expr} as a |Float| (truncate towards zero).
		{expr} must evaluate to a |Float| or a |Number|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{trunc()}
@findex trunc()
@item trunc(@{expr@})
@{expr@} をゼロ方向に切りつめた整数を |@ref{Float}| で返す。

@{expr@} は |@ref{Float}| または |@ref{Number}| に評価されなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
			echo trunc(1.456)
<			1.0  >
			echo trunc(-5.456)
<			-5.0  >
			echo trunc(4.0)
<			4.0
		{only available when compiled with the |+float| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
echo trunc(1.456)
1.0
echo trunc(-5.456)
-5.0
echo trunc(4.0)
4.0
@end example
@{|@ref{+float}| 機能つきでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*type()*
type({expr})	The result is a Number representing the type of {expr}.
		Instead of using the number directly, it is better to use the
		v:t_ variable that has the value:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{type()}
@findex type()
@item type(@{expr@})
@{expr@} の型を示す数値を返す。マジックナンバーを使わずに、v:t_ 変数を使う方が良い。それぞれの値は以下の通り:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Number:	    0  |v:t_number|
			String:	    1  |v:t_string|
			Funcref:    2  |v:t_func|
			List:	    3  |v:t_list|
			Dictionary: 4  |v:t_dict|
			Float:	    5  |v:t_float|
			Boolean:    6  |v:t_bool| (v:false and v:true)
			None	    7  |v:t_none| (v:null and v:none)
			Job	    8  |v:t_job|
			Channel	    9  |v:t_channel|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item 数値: @tab 0  |@ref{v:t_number}|
@item 文字列: @tab 1  |@ref{v:t_string}|
@item Funcref: @tab 2  |@ref{v:t_func}|
@item リスト:@tab 3  |@ref{v:t_list}|
@item 辞書: @tab 4  |@ref{v:t_dict}|
@item 浮動小数点数: @tab 5  |@ref{v:t_float}|
@item 真偽値: @tab 6  |@ref{v:t_bool}| (v:false と v:true)
@item 特殊値: @tab 7  |@ref{v:t_none}| (v:null と v:none)
@item ジョブ: @tab 8  |@ref{v:t_job}|
@item チャネル: @tab 9  |@ref{v:t_channel}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		For backward compatibility, this method can be used: >
			:if type(myvar) == type(0)
			:if type(myvar) == type("")
			:if type(myvar) == type(function("tr"))
			:if type(myvar) == type([])
			:if type(myvar) == type({})
			:if type(myvar) == type(0.0)
			:if type(myvar) == type(v:false)
			:if type(myvar) == type(v:none)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
後方互換性のためには、次のような使い方ができる:
@example
:if type(myvar) == type(0)
:if type(myvar) == type("")
:if type(myvar) == type(function("tr"))
:if type(myvar) == type([])
:if type(myvar) == type(@{@})
:if type(myvar) == type(0.0)
:if type(myvar) == type(v:false)
:if type(myvar) == type(v:none)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		To check if the v:t_ variables exist use this: >
			:if exists('v:t_number')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
v:t_ 変数が存在するかを判定するにはこれを使う:
@example
:if exists('v:t_number')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
undofile({name})					*undofile()*
		Return the name of the undo file that would be used for a file
		with name {name} when writing.  This uses the 'undodir'
		option, finding directories that exist.  It does not check if
		the undo file exists.
		{name} is always expanded to the full path, since that is what
		is used internally.
		If {name} is empty undofile() returns an empty string, since a
		buffer without a file name will not write an undo file.
		Useful in combination with |:wundo| and |:rundo|.
		When compiled without the +persistent_undo option this always
		returns an empty string.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{undofile()}
@findex undofile()
@item undofile(@{name@})
@{name@} という名前のファイルの保存時に使用されるアンドゥファイルの名前を返す。'@option{undodir}' オプションが使用され、存在するディレクトリが検索される。アンドゥファイルが存在するかどうかはチェックされない。

@{name@} は常に絶対パスに展開される (内部では絶対パスを使っているため)。

@{name@} が空の場合 undofile() は空文字列を返す。ファイル名のないバッファはアンドゥファイルを書かないからである。|@ref{:wundo}| や |@ref{:rundo}| と組み合わせて使うと便利だろう。

+persistent_undo オプションを無効にしてコンパイルされた場合はこの関数は常に空文字列を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
undotree()						*undotree()*
		Return the current state of the undo tree in a dictionary with
		the following items:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{undotree()}
@findex undotree()
@item undotree()
アンドゥツリーの現在の状態を辞書で返す。辞書の内容は次のとおり:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		  "seq_last"	The highest undo sequence number used.
		  "seq_cur"	The sequence number of the current position in
				the undo tree.  This differs from "seq_last"
				when some changes were undone.
		  "time_cur"	Time last used for |:earlier| and related
				commands.  Use |strftime()| to convert to
				something readable.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item "seq_last" @tab 使用されたアンドゥシーケンス番号の最大値。
@item "seq_cur" @tab アンドゥツリーの現在のシーケンス番号。いくつかの変更がアンドゥされた状態だと "seq_last" と違う値になる。
@item "time_cur" @tab 最後に |@ref{:earlier}| 系のコマンドが使われた時間。読みやすい形式に変換するには |@ref{strftime()}| を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		  "save_last"	Number of the last file write.  Zero when no
				write yet.
		  "save_cur"	Number of the current position in the undo
				tree.
		  "synced"	Non-zero when the last undo block was synced.
				This happens when waiting from input from the
				user.  See |undo-blocks|.
		  "entries"	A list of dictionaries with information about
				undo blocks.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "save_last" @tab 最後にファイルが保存された番号。保存がまだならゼロになる。
@item "save_cur" @tab アンドゥツリー内の現在位置の番号。
@item "synced" @tab 最後のアンドゥブロックが同期されていれば非ゼロ。これはユーザーからの入力を待機しているときに起こる。|@ref{undo-blocks}| 参照。
@item "entries" @tab アンドゥブロックの情報を表す辞書のリスト。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The first item in the "entries" list is the oldest undo item.
		Each List item is a Dictionary with these items:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"entries" リストの 1 番目にはもっとも古いアンドゥアイテムが入っている。リストの各アイテムは次のような情報を持った辞書である:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		  "seq"		Undo sequence number.  Same as what appears in
				|:undolist|.
		  "time"	Timestamp when the change happened.  Use
				|strftime()| to convert to something readable.
		  "newhead"	Only appears in the item that is the last one
				that was added.  This marks the last change
				and where further changes will be added.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item "seq" @tab アンドゥシーケンス番号。|@ref{:undolist}| で表示されるものと同じ。
@item "time" @tab 変更が起こった時間。読みやすい形式に変換するには |@ref{strftime()}| を使う。
@item "newhead" @tab この項目は最後に追加されたアイテムにのみある。これは最後の変更を示し、次の変更を追加する場所を示す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		  "curhead"	Only appears in the item that is the last one
				that was undone.  This marks the current
				position in the undo tree, the block that will
				be used by a redo command.  When nothing was
				undone after the last change this item will
				not appear anywhere.
		  "save"	Only appears on the last block before a file
				write.  The number is the write count.  The
				first write has number 1, the last one the
				"save_last" mentioned above.
		  "alt"		Alternate entry.  This is again a List of undo
				blocks.  Each item may again have an "alt"
				item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "curhead" @tab この項目は最後にアンドゥされたアイテムにのみある。これはアンドゥツリーの現在位置を示し、次にリドゥコマンドによって使われるブロックを示す。最後に変更を加えてからアンドゥを一度も実行していないときはこの項目はどこにも現れない。
@item "save" @tab この項目はファイルが保存される前の最後のブロックにのみある。番号は保存回数を示す。最初の保存は 1 で、最後のものは "save_last" と同じ。
@item "alt" @tab 切り替えエントリ。同じアンドゥブロックのリストが入れ子にされている。それぞれのアイテムはさらに "alt" アイテムを持っていることがある。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
uniq({list} [, {func} [, {dict}]])			*uniq()* *E882*
		Remove second and succeeding copies of repeated adjacent
		{list} items in-place.  Returns {list}.  If you want a list
		to remain unmodified make a copy first: >
			:let newlist = uniq(copy(mylist))
<		The default compare function uses the string representation of
		each item.  For the use of {func} and {dict} see |sort()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{uniq()}
@anchor{E882}
@findex uniq()
@erindex E882
@item uniq(@{list@} [, @{func@} [, @{dict@}]])
@{list@} 内の隣接する同じ値の要素の 2 個目以降をその場で (in-place) 削除する。@{list@} を返す。リストを変更したくない場合は事前にコピーする:
@example
:let newlist = uniq(copy(mylist))
@end example
デフォルトの比較関数は各要素の文字列表現を使う。@{func@} と @{dict@} については |@ref{sort()}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
values({dict})						*values()*
		Return a |List| with all the values of {dict}.  The |List| is
		in arbitrary order.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{values()}
@findex values()
@item values(@{dict@})
@{dict@} の全ての値からなるリスト |@ref{List}| を返す。このリストの順序は不定である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
virtcol({expr})						*virtcol()*
		The result is a Number, which is the screen column of the file
		position given with {expr}.  That is, the last screen position
		occupied by the character at that position, when the screen
		would be of unlimited width.  When there is a <Tab> at the
		position, the returned Number will be the column at the end of
		the <Tab>.  For example, for a <Tab> in column 1, with 'ts'
		set to 8, it returns 8. |conceal| is ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{virtcol()}
@findex virtcol()
@item virtcol(@{expr@})
結果は数値で、@{expr@} で与えられるファイルの位置の、スクリーン上での桁の位置を示す。返る値は、指定された位置にある文字の末尾が、スクリーン座標 (の桁) でどこに存在するかである。<Tab> (タブ文字) が指定した位置にあった場合には、戻り値はそのタブの最後のカラム (桁) 位置になる。具体的に、'@option{ts}' が 8 に設定された状態で第 1 桁に <Tab> があった場合、戻り値は 8 になる。|@ref{conceal}| は無視される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		For the byte position use |col()|.
		For the use of {expr} see |col()|.
		When 'virtualedit' is used {expr} can be [lnum, col, off], where
		"off" is the offset in screen columns from the start of the
		character.  E.g., a position within a <Tab> or after the last
		character.  When "off" is omitted zero is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

バイト位置については |@ref{col()}| を使う。

@{expr@}の解釈の仕方については |@ref{col()}| を参照。

'@option{virtualedit}' がオンのときは [lnum, col, off] というリストを指定することもできる。"off" は文字の開始位置からのスクリーン座標でのオフセットである。例えば、<Tab>の中の位置や、行の最後の文字以降の位置を示すために使う。"off" が省略された場合はゼロが使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When Virtual editing is active in the current mode, a position
		beyond the end of the line can be returned. |'virtualedit'|
		The accepted positions are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

現在のモードに対して仮想編集がオンのときは、行末を越えた位置が返ってくることもある。|@ref{'virtualedit'}| 可能な位置指定:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		    .	    the cursor position
		    $	    the end of the cursor line (the result is the
			    number of displayed characters in the cursor line
			    plus one)
		    'x	    position of mark x (if the mark is not set, 0 is
			    returned)
		    v       In Visual mode: the start of the Visual area (the
			    cursor is the end).  When not in Visual mode
			    returns the cursor position.  Differs from |'<| in
			    that it's updated right away.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item . @tab カーソルの位置
@item $ @tab カーソル行の末尾 (カーソル行に表示されている文字数 +1 となる)
@item 'x @tab マーク x の位置 (マークが設定されていない場合、0 が返る)
@item v @tab ビジュアルモードでは: ビジュアル選択領域の開始行 (カーソルがその端)。ビジュアルモード以外ではカーソル位置を返す。すぐに更新される点が |@ref{'<}| と違う。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that only marks in the current file can be used.
		Examples: >
  virtcol(".")	   with text "foo^Lbar", with cursor on the "^L", returns 5
  virtcol("$")	   with text "foo^Lbar", returns 9
  virtcol("'t")    with text "	  there", with 't at 'h', returns 6
<		The first column is 1.  0 is returned for an error.
		A more advanced example that echoes the maximum length of
		all lines: >
		    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
現在のファイルに対して設定されているマークだけが使用可能なことに注意。

例:
@example
virtcol(".")     "foo^Lbar" の "^L" の位置にカーソル、戻り値 5
virtcol("$")     "foo^Lbar" に対し、戻り値 9
virtcol("'t")    "    there" の 'h' に 't を設定、戻り値 6
@end example
最初の桁は 1 となる。エラーの場合は 0 が返る。より高度な例 (全ての行の長さの最大値を返す):
@example
echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
visualmode([expr])						*visualmode()*
		The result is a String, which describes the last Visual mode
		used in the current buffer.  Initially it returns an empty
		string, but once Visual mode has been used, it returns "v",
		"V", or "<CTRL-V>" (a single CTRL-V character) for
		character-wise, line-wise, or block-wise Visual mode
		respectively.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{visualmode()}
@findex visualmode()
@item visualmode([expr])
結果は文字列で、カレントバッファ内で最後に使われたビジュアルモードを教えてくれる。初期状態では単に空文字列を返すだけだが、一度でもビジュアルモードが使われた場合、その種類によって "v"か "V" か "<CTRL-V>" (CTRL-V の文字が 1 文字で) 返される。これはそれぞれ文字選択、行選択、矩形選択を意味している。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Example: >
			:exe "normal " . visualmode()
<		This enters the same Visual mode as before.  It is also useful
		in scripts if you wish to act differently depending on the
		Visual mode that was used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
exe "normal " . visualmode()
@end example
これは最後に使われたのと同じビジュアルモードに入る。また、スクリプトの動作を、最後に使われたビジュアルモードに応じて変更したい場合にも便利だろう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		If Visual mode is active, use |mode()| to get the Visual mode
		(e.g., in a |:vmap|).
		If [expr] is supplied and it evaluates to a non-zero Number or
		a non-empty String, then the Visual mode will be cleared and
		the old value is returned.  See |non-zero-arg|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ビジュアルモードにいるときは |@ref{mode()}| を使ってビジュアルモードの種類を取得できる。(|@ref{:vmap}| などの中などで) @{expr@} に 0 以外の数値か空文字列以外の文字列を指定した場合は、ビジュアルモードがクリアされ、以前の値を返す。|@ref{non-zero-arg}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
wildmenumode()					*wildmenumode()*
		Returns |TRUE| when the wildmenu is active and |FALSE|
		otherwise.  See 'wildmenu' and 'wildmode'.
		This can be used in mappings to handle the 'wildcharm' option
		gracefully. (Makes only sense with |mapmode-c| mappings).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{wildmenumode()}
@findex wildmenumode()
@item wildmenumode()
wildmenu が有効な場合は |@ref{TRUE}| を返し、そうでなければ |@ref{FALSE}| を返す。'@option{wildmenu}' と '@option{wildmode}' を参照。

マッピングの中で '@option{wildcharm}' オプションを有効に扱うために使用できる。(|@ref{mapmode-c}| マッピングの場合のみ意味をなす。)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For example to make <c-j> work like <down> in wildmode, use: >
    :cnoremap <expr> <C-j> wildmenumode() ? "\<Down>\<Tab>" : "\<c-j>"
<
		(Note, this needs the 'wildcharm' option set appropriately).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば、wildmode で <c-j> が <down> と同じように動作するようにするには:
@example
:cnoremap <expr> <C-j> wildmenumode() ? "\<Down>\<Tab>" : "\<c-j>"
@end example
(
@quotation
@strong{Note:} @*
'@option{wildcharm}' オプションが適切に設定されている必要がある。
@end quotation
)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
win_findbuf({bufnr})					*win_findbuf()*
		Returns a list with |window-ID|s for windows that contain
		buffer {bufnr}.  When there is none the list is empty.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{win_findbuf()}
@findex win_findbuf()
@item win_findbuf(@{bufnr@})
バッファ @{bufnr@} が含まれているウィンドウについて |@ref{window-ID}| のリストを返す。存在しない場合は空のリストになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
win_getid([{win} [, {tab}]])				*win_getid()*
		Get the |window-ID| for the specified window.
		When {win} is missing use the current window.
		With {win} this is the window number.  The top window has
		number 1.  Use `win_getid(winnr())` for the current window.
		Without {tab} use the current tab, otherwise the tab with
		number {tab}.  The first tab has number one.
		Return zero if the window cannot be found.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{win_getid()}
@findex win_getid()
@item win_getid([@{win@} [, @{tab@}]])
特定のウィンドウに関する |@ref{window-ID}| を得る。@{win@} が未指定の時は現在のウィンドウとなる。この @{win@} はウィンドウ番号である。トップウィンドウは番号 1 を持つ。現在のウィンドウに対しては `win_getid(winnr())` を使う。

@{tab@} が未指定の場合現在のタブが使用され、@{tab@} が番号で指定された場合はそのタブとなる。最初のタブ番号は 1 である。ウィンドウが見付からない場合には 0 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
win_gotoid({expr})					*win_gotoid()*
		Go to window with ID {expr}.  This may also change the current
		tabpage.
		Return 1 if successful, 0 if the window cannot be found.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{win_gotoid()}
@findex win_gotoid()
@item win_gotoid(@{expr@})
@{expr@} の ID で示されるウィンドウへ移動する。これは現在のタブページも移動する。

成功した場合は 1 を、ウィンドウが見付からない場合は 0 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
win_id2tabwin({expr})					*win_id2tabwin()*
		Return a list with the tab number and window number of window
		with ID {expr}: [tabnr, winnr].
		Return [0, 0] if the window cannot be found.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{win_id2tabwin()}
@findex win_id2tabwin()
@item win_id2tabwin(@{expr@})
@{expr@} の ID で示されるタブ番号とウィンドウ番号のリストを返す: [tabnr, winnr]

ウィンドウが見付からなかった場合は [0, 0] を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
win_id2win({expr})					*win_id2win()*
		Return the window number of window with ID {expr}.
		Return 0 if the window cannot be found in the current tabpage.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{win_id2win()}
@findex win_id2win()
@item win_id2win(@{expr@})
@{expr@} の ID で示されるウィンドウのウィンドウ番号を返す。現在のタブページ内でそのウィンドウが見付からなかった場合は 0 を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
win_screenpos({nr})					*win_screenpos()*
		Return the screen position of window {nr} as a list with two
		numbers: [row, col].  The first window always has position
		[1, 1], unless there is a tabline, then it is [2, 1].
		{nr} can be the window number or the |window-ID|.
		Return [0, 0] if the window cannot be found in the current
		tabpage.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{win_screenpos()}
@findex win_screenpos()
@item win_screenpos(@{nr@})
2 つの数値を持つリストとしてウィンドウ @{nr@} のスクリーン位置を返す: [row, col]。最初のウィンドウの位置は常に [1, 1]。タブ行が無いのであれば [2, 1]。

@{nr@} はウィンドウ番号もしくは |@ref{window-ID}| になる。

現在のタブページでウィンドウが見つからなければ [0, 0] を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*winbufnr()*
winbufnr({nr})	The result is a Number, which is the number of the buffer
		associated with window {nr}.  {nr} can be the window number or
		the |window-ID|.
		When {nr} is zero, the number of the buffer in the current
		window is returned.
		When window {nr} doesn't exist, -1 is returned.
		Example: >
  :echo "The file in the current window is " . bufname(winbufnr(0))
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{winbufnr()}
@findex winbufnr()
@item winbufnr(@{nr@})
結果は数値で、@{nr@} 番目のウィンドウに関連付けられているバッファの番号。@{nr@} にはウィンドウ番号または |@ref{window-ID}| が使える。

@{nr@} が 0 の場合、現在のウィンドウに関連付けられているバッファの番号が返る。

@{nr@} で存在しないウィンドウを指定した場合には -1 が返る。

例:
@example
:echo "The file in the current window is " . bufname(winbufnr(0))
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*wincol()*
wincol()	The result is a Number, which is the virtual column of the
		cursor in the window.  This is counting screen cells from the
		left side of the window.  The leftmost column is one.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{wincol()}
@findex wincol()
@item wincol()
結果は数値で、ウィンドウの中でカーソルがある位置の仮想桁番号を表す。これはウィンドウの左側から数えたスクリーン上の桁である。一番左の桁は 1 となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
winheight({nr})						*winheight()*
		The result is a Number, which is the height of window {nr}.
		{nr} can be the window number or the |window-ID|.
		When {nr} is zero, the height of the current window is
		returned.  When window {nr} doesn't exist, -1 is returned.
		An existing window always has a height of zero or more.
		This excludes any window toolbar line.
		Examples: >
  :echo "The current window has " . winheight(0) . " lines."
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{winheight()}
@findex winheight()
@item winheight(@{nr@})
結果は数値で、@{nr@} で示されるウィンドウの高さ (行数) を示す。@{nr@} にはウィンドウ番号または |@ref{window-ID}| が使える。@{nr@} が 0 ならば、現在のウィンドウの高さが返る。@{nr@} というウィンドウが存在しない場合、-1 が返る。存在しているウィンドウは、絶対に 0 かそれ以上の高さを持っている。これはどのようなウィンドウツールバーも除外する。

例:
@example
:echo "The current window has " . winheight(0) . " lines."
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
winlayout([{tabnr}])					*winlayout()*
		The result is a nested List containing the layout of windows
		in a tabpage.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{winlayout()}
@findex winlayout()
@item winlayout([@{tabnr@}])
結果はタブページ内のウィンドウレイアウトを含む、ネストされたリスト。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Without {tabnr} use the current tabpage, otherwise the tabpage
		with number {tabnr}. If the tabpage {tabnr} is not found,
		returns an empty list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{tabnr@} を指定しないと現在のタブページが使われ、そうでなければ番号 @{tabnr@} のタブページが使われる。もしもタブページ @{tabnr@} が見つからなければ、空のリストが返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For a leaf window, it returns:
			['leaf', {winid}]
		For horizontally split windows, which form a column, it
		returns:
			['col', [{nested list of windows}]]
		For vertically split windows, which form a row, it returns:
			['row', [{nested list of windows}]]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
leaf ウィンドウなら、次のものが返る:
@example
['leaf', @{winid@}]
@end example
水平分割したウィンドウなら、桁の方式で次のものが返る:
@example
['col', [@{nested list of windows@}]]
@end example
垂直分割したウィンドウなら、行の方式で次のものが返る:
@example
['row', [@{nested list of windows@}]]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example: >
			" Only one window in the tab page
			:echo winlayout()
			['leaf', 1000]
			" Two horizontally split windows
			:echo winlayout()
			['col', [['leaf', 1000], ['leaf', 1001]]]
			" Three horizontally split windows, with two
			" vertically split windows in the middle window
			:echo winlayout(2)
			['col', [['leaf', 1002], ['row', ['leaf', 1003],
					     ['leaf', 1001]]], ['leaf', 1000]]
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
" タブページにウィンドウが 1 つのみ
:echo winlayout()
['leaf', 1000]
" 水平分割されたウィンドウが 2 つ
:echo winlayout()
['col', [['leaf', 1000], ['leaf', 1001]]]
" 3 つの水平分割されたウィンドウで、真ん中のウィンドウは
" 垂直分割されたウィンドウが 2 つある
:echo winlayout(2)
['col', [['leaf', 1002], ['row', ['leaf', 1003],
                     ['leaf', 1001]]], ['leaf', 1000]]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*winline()*
winline()	The result is a Number, which is the screen line of the cursor
		in the window.  This is counting screen lines from the top of
		the window.  The first line is one.
		If the cursor was moved the view on the file will be updated
		first, this may cause a scroll.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{winline()}
@findex winline()
@item winline()
結果は数値で、ウィンドウの最上行から数えた行番号を返す。ウィンドウでの最上行が1となる。

カーソルが移動するとファイルの表示が更新され、それによってスクロールが引き起こされることがある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*winnr()*
winnr([{arg}])	The result is a Number, which is the number of the current
		window.  The top window has number 1.
		When the optional argument is "$", the number of the
		last window is returned (the window count). >
			let window_count = winnr('$')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{winnr()}
@findex winnr()
@item winnr([@{arg@}])
結果は現在のウィンドウを示す数値。最上位のウィンドウは 1 である。

省略可能な引数 @{arg@} に "$" を設定すると、最後のウィンドウの番号が返る (つまりウィンドウの個数)。
@example
let window_count = winnr('$')
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		When the optional argument is "#", the number of the last
		accessed window is returned (where |CTRL-W_p| goes to).
		If there is no previous window or it is in another tab page 0
		is returned.
		The number can be used with |CTRL-W_w| and ":wincmd w"
		|:wincmd|.
		Also see |tabpagewinnr()| and |win_getid()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{arg@} に "#" を設定すると、最後にアクセスしたウィンドウの番号を返す (|@ref{CTRL-W_p}| で移動するウィンドウと同じ)。

以前のウィンドウがない場合、またはそれが他のタブページにある場合は 0 を返す。

この番号は |@ref{CTRL-W_w}| と "@command{:wincmd w}" で使える。|@ref{:wincmd}|

|@ref{tabpagewinnr()}| と |@ref{win_getid()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*winrestcmd()*
winrestcmd()	Returns a sequence of |:resize| commands that should restore
		the current window sizes.  Only works properly when no windows
		are opened or closed and the current window and tab page is
		unchanged.
		Example: >
			:let cmd = winrestcmd()
			:call MessWithWindowSizes()
			:exe cmd
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{winrestcmd()}
@findex winrestcmd()
@item winrestcmd()
現在のウィンドウサイズを復元するための一連の |@ref{:resize}| コマンドを返す。これが返すコマンドは、ウィンドウを開閉せず、カレントウィンドウとカレントタブページが変更されていないときのみ正しく動作する。

例:
@example
:let cmd = winrestcmd()
:call MessWithWindowSizes()
:exe cmd
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*winrestview()*
winrestview({dict})
		Uses the |Dictionary| returned by |winsaveview()| to restore
		the view of the current window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{winrestview()}
@findex winrestview()
@item winrestview(@{dict@})
|@ref{winsaveview()}| が返す辞書 |@ref{Dictionary}| を使ってカレントウィンドウの表示状態を復元する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note: The {dict} does not have to contain all values, that are
		returned by |winsaveview()|. If values are missing, those
		settings won't be restored. So you can use: >
		    :call winrestview({'curswant': 4})
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
@{dict@} は |@ref{winsaveview()}| の戻り値に含まれる値をすべて持っていなくても構わない。値がない場合はその設定は復元されない。次のようにできる:

@example
:call winrestview(@{'curswant': 4@})
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		This will only set the curswant value (the column the cursor
		wants to move on vertical movements) of the cursor to column 5
		(yes, that is 5), while all other settings will remain the
		same. This is useful, if you set the cursor position manually.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは curswant 値 (縦方向移動でカーソルの移動先として使われる列番号) を列番号 5 に設定する (はいそのとおり。5 です)。ほかの設定値は変更されない。これはカーソル位置を手動で設定したい場合に便利である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If you have changed the values the result is unpredictable.
		If the window size changed the result won't be the same.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この値を手動で変更した場合、結果は予測できない。ウィンドウサイズが変更されていると、結果は必ずしも元通りにならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*winsaveview()*
winsaveview()	Returns a |Dictionary| that contains information to restore
		the view of the current window.  Use |winrestview()| to
		restore the view.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{winsaveview()}
@findex winsaveview()
@item winsaveview()
カレントウィンドウの表示状態を復元するための情報を持つ辞書 |@ref{Dictionary}| を返す。この表示状態を復元するには |@ref{winrestview()}| を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		This is useful if you have a mapping that jumps around in the
		buffer and you want to go back to the original view.
		This does not save fold information.  Use the 'foldenable'
		option to temporarily switch off folding, so that folds are
		not opened when moving around. This may have side effects.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

マッピング内でジャンプして、元の表示状態を戻したいときに使われる。

折り畳み情報は保存しない。オプション '@option{foldenable}' によって一時的に折り畳みをオフにし、移動中に折り畳みが開かれないようにすること。これは副作用があるかもしれない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The return value includes:
			lnum		cursor line number
			col		cursor column (Note: the first column
					zero, as opposed to what getpos()
					returns)
			coladd		cursor column offset for 'virtualedit'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
戻り値は以下のキーを持つ:
@multitable @columnfractions .2 .8
@item lnum @tab カーソルの行番号
@item col @tab カーソルの桁番号 (
@quotation
@strong{Note:} @*
getpos() とは異なり最初の桁番号はゼロ
@end quotation
)
@item coladd @tab カーソル位置の桁オフセット。'@option{virtualedit}' がオンのとき使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			curswant	column for vertical movement
			topline		first line in the window
			topfill		filler lines, only in diff mode
			leftcol		first column displayed
			skipcol		columns skipped
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item curswant	垂直移動するときの桁
@item topline @tab ウィンドウの最上行
@item topfill @tab 削除行。差分モードでのみ
@item leftcol @tab 表示されている最初の桁
@item skipcol @tab スキップされている桁
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that no option values are saved.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
オプションの値は保存されない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
winwidth({nr})						*winwidth()*
		The result is a Number, which is the width of window {nr}.
		{nr} can be the window number or the |window-ID|.
		When {nr} is zero, the width of the current window is
		returned.  When window {nr} doesn't exist, -1 is returned.
		An existing window always has a width of zero or more.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{winwidth()}
@findex winwidth()
@item winwidth(@{nr@})
結果は数値で、ウィンドウ @{nr@} の幅。@{nr@} にはウィンドウ番号または |@ref{window-ID}| が使える。

@{nr@} が 0 のときはカレントウィンドウの幅を返す。ウィンドウ @{nr@} が存在しないときは -1 を返す。ウィンドウは必ず 0 以上の幅を持つ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Examples: >
  :echo "The current window has " . winwidth(0) . " columns."
  :if winwidth(0) <= 50
  :  50 wincmd |
  :endif
<		For getting the terminal or screen size, see the 'columns'
		option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
:echo "The current window has " . winwidth(0) . " columns."
:if winwidth(0) <= 50
:  50 wincmd |
:endif
@end example
端末または画面サイズを取得するには、'@option{columns}' オプション参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
wordcount()						*wordcount()*
		The result is a dictionary of byte/chars/word statistics for
		the current buffer.  This is the same info as provided by
		|g_CTRL-G|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{wordcount()}
@findex wordcount()
@item wordcount()
この結果は現在のバッファのバイト/文字/単語統計情報の辞書である。これは |@ref{g_CTRL-G}| が提供する情報と同じである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The return value includes:
			bytes		Number of bytes in the buffer
			chars		Number of chars in the buffer
			words		Number of words in the buffer
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この値には下記が含まれる:
@multitable @columnfractions .3 .7
@item bytes @tab バッファ内のバイト数
@item chars @tab バッファ内の文字数
@item words @tab バッファ内の単語数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			cursor_bytes    Number of bytes before cursor position
					(not in Visual mode)
			cursor_chars    Number of chars before cursor position
					(not in Visual mode)
			cursor_words    Number of words before cursor position
					(not in Visual mode)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item cursor_bytes @tab カーソル位置より前のバイト数 (ビジュアルモードでない)
@item cursor_chars @tab カーソル位置より前の文字数 (ビジュアルモードでない)
@item cursor_words @tab カーソル位置より前の単語数 (ビジュアルモードでない)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			visual_bytes    Number of bytes visually selected
					(only in Visual mode)
			visual_chars    Number of chars visually selected
					(only in Visual mode)
			visual_words    Number of words visually selected
					(only in Visual mode)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item visual_bytes @tab ビジュアル選択領域内のバイト数 (ビジュアルモードのみ)
@item visual_chars @tab ビジュアル選択領域内の文字数 (ビジュアルモードのみ)
@item visual_words @tab ビジュアル選択領域内の単語数 (ビジュアルモードのみ)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
							*writefile()*
writefile({list}, {fname} [, {flags}])
		Write |List| {list} to file {fname}.  Each list item is
		separated with a NL.  Each list item must be a String or
		Number.
		When {flags} contains "b" then binary mode is used: There will
		not be a NL after the last list item.  An empty item at the
		end does cause the last line in the file to end in a NL.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{writefile()}
@findex writefile()
@item writefile(@{list@}, @{fname@} [, @{flags@}])
|@ref{List}| @{list@} をファイル @{fname@} に書き込む。リストの各要素は改行文字 (NL) で区切られる。各要素は文字列か数値でなければならない。

@{flags@} が "b" を含むときはバイナリモードとなり、最後の要素の後に NL が追加されない。最後の要素が空であると、ファイルの最後の行が NL で終わるようになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {flags} contains "a" then append mode is used, lines are
		appended to the file: >
			:call writefile(["foo"], "event.log", "a")
			:call writefile(["bar"], "event.log", "a")
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{flags@} が "a" を含むときは追記モードとなり、ファイルに行が追記される。
@example
:call writefile(["foo"], "event.log", "a")
:call writefile(["bar"], "event.log", "a")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When {flags} contains "s" then fsync() is called after writing
		the file.  This flushes the file to disk, if possible.  This
		takes more time but avoids losing the file if the system
		crashes.
		When {flags} does not contain "S" or "s" then fsync() is
		called if the 'fsync' option is set.
		When {flags} contains "S" then fsync() is not called, even
		when 'fsync' is set.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{flags@} が "s" を含むときはファイルを書き込んだ後に fsync() が呼ばれる。もしも可能ならば、ファイルをディスクにフラッシュする。これには時間がかかるけれども、例えシステムがクラッシュしたとしても、ファイルを失うことを回避する。

@{flags@} が "S" も "s" も含まないときに 'fsync' オプションが設定されていると fsync() は呼ばれる。

@{flags@} が "S" を含むときは 'fsync' が設定されていても fsync() は呼ばれない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		All NL characters are replaced with a NUL character.
		Inserting CR characters needs to be done before passing {list}
		to writefile().
		An existing file is overwritten, if possible.
		When the write fails -1 is returned, otherwise 0.  There is an
		error message if the file can't be created or when writing
		fails.
		Also see |readfile()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
NL 文字は NUL 文字に置換される。

CR 文字を加えるには、@{list@} を writefile() に渡す前に行わねばならない。

既存のファイルは上書きされる (上書き可能ならば)。

書き込みが失敗したときは -1 を返す。そうでなければ 0 を返す。ファイルを作成できないときや、書き込みが失敗したときはエラーメッセージが表示される。

|@ref{readfile()}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		To copy a file byte for byte: >
			:let fl = readfile("foo", "b")
			:call writefile(fl, "foocopy", "b")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バイト単位でファイルをコピーするには次のようにする:
@example
:let fl = readfile("foo", "b")
:call writefile(fl, "foocopy", "b")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
xor({expr}, {expr})					*xor()*
		Bitwise XOR on the two arguments.  The arguments are converted
		to a number.  A List, Dict or Float argument causes an error.
		Example: >
			:let bits = xor(bits, 0x80)
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{xor()}
@findex xor()
@item xor(@{expr@}, @{expr@})
2 つの引数のビット排他的論理和。引数は数値に変換される。リスト、辞書、浮動小数点数を指定するとエラーになる。

例:
@example
:let bits = xor(bits, 0x80)
@end example
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
							*feature-list*
There are four types of features:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{feature-list}
@cindex feature-list
@unnumberedsubsec 機能は大別して 4 つの系統に分けられる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
1.  Features that are only supported when they have been enabled when Vim
    was compiled |+feature-list|.  Example: >
	:if has("cindent")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item コンパイル時に |@ref{+feature-list}| とした時にだけサポートされる機能。例:
@example
:if has("cindent")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
2.  Features that are only supported when certain conditions have been met.
    Example: >
	:if has("gui_running")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ある状態の時にだけサポートされる機能。例:
@example
:if has("gui_running")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<							*has-patch*
3.  Beyond a certain version or at a certain version and including a specific
    patch.  The "patch-7.4.248" feature means that the Vim version is 7.5 or
    later, or it is version 7.4 and patch 248 was included.  Example: >
	:if has("patch-7.4.248")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 特定のバージョン以降であるか、またはバージョンが同じで特定のパッチが含まれているかどうか。"patch-7.4.248" は、Vim のバージョンが 7.5 以降か、または 7.4 でパッチ 248 を含んでいるかどうかを示す。例:
@example
:if has("patch-7.4.248")
@end example
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<    Note that it's possible for patch 248 to be omitted even though 249 is
    included.  Only happens when cherry-picking patches.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
249 が適用されていても、248 が抜けていることもありうるので注意。cherry-pick パッチの時にのみ生じる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    Note that this form only works for patch 7.4.237 and later, before that
    you need to check for the patch and the  v:version.  Example (checking
    version 6.2.148 or later): >
	:if v:version > 602 || (v:version == 602 && has("patch148"))
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
これはパッチ 7.4.237 以降でのみ機能する。それ以前では上述のように v:version を確認する必要がある。例 (6.2.148 以降かどうかを確認する):
@end quotation
@example
:if v:version > 602 || (v:version == 602 && has("patch148"))
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Hint: To find out if Vim supports backslashes in a file name (MS-Windows),
use: `if exists('+shellslash')`
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{ヒント:} @*
Vim がファイル名 (MS-Windows) でバックスラッシュをサポートしているかどうかを調べるには `if exists('+shellslash')` を使用する。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
acl			Compiled with |ACL| support.
all_builtin_terms	Compiled with all builtin terminals enabled.
amiga			Amiga version of Vim.
arabic			Compiled with Arabic support |Arabic|.
arp			Compiled with ARP support (Amiga).
autocmd			Compiled with autocommand support. |autocommand|
autochdir		Compiled with support for 'autochdir'
autoservername		Automatically enable |clientserver|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item acl @tab |@ref{ACL}| をサポート
@item all_builtin_terms @tab 全ての組込みターミナルを有効にしてコンパイル
@item amiga @tab AMIGA バージョン
@item arabic @tab アラビア語をサポート |@ref{Arabic}|
@item arp @tab ARP をサポート (Amiga)
@item autocmd @tab オートコマンドをサポート |@ref{autocommand}|
@item autochdir @tab '@option{autochdir}' をサポート
@item autoservername @tab 自動的に動作する |@ref{clientserver}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
balloon_eval		Compiled with |balloon-eval| support.
balloon_multiline	GUI supports multiline balloons.
beos			BeOS version of Vim.
browse			Compiled with |:browse| support, and browse() will
			work.
browsefilter		Compiled with support for |browsefilter|.
builtin_terms		Compiled with some builtin terminals.
byte_offset		Compiled with support for 'o' in 'statusline'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item balloon_eval @tab |@ref{balloon-eval}| をサポート
@item balloon_multiline @tab 複数行バルーンをサポート
@item beos @tab BeOS バージョン
@item browse @tab |@ref{:browse}| をサポートし、browse() が動作する
@item browsefilter @tab |@ref{browsefilter}| をサポート
@item builtin_terms @tab 幾つかの組込みターミナルが有効
@item byte_offset @tab '@option{statusline}' において 'o' がサポートされる
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
cindent			Compiled with 'cindent' support.
clientserver		Compiled with remote invocation support |clientserver|.
clipboard		Compiled with 'clipboard' support.
cmdline_compl		Compiled with |cmdline-completion| support.
cmdline_hist		Compiled with |cmdline-history| support.
cmdline_info		Compiled with 'showcmd' and 'ruler' support.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item cindent @tab '@option{cindent}' をサポート
@item clientserver @tab リモート呼び出しをサポート |@ref{clientserver}|
@item clipboard @tab '@option{clipboard}' をサポート
@item cmdline_compl @tab |@ref{cmdline-completion}| コマンドライン補完をサポート
@item cmdline_hist @tab |@ref{cmdline-history}| コマンドライン履歴をサポート
@item cmdline_info @tab '@option{showcmd}' と '@option{ruler}' をサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
comments		Compiled with |'comments'| support.
compatible		Compiled to be very Vi compatible.
cryptv			Compiled with encryption support |encryption|.
cscope			Compiled with |cscope| support.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item comments @tab |@ref{'comments'}| をサポート
@item compatible @tab Vi 互換度を非常に高めてコンパイルされている
@item cryptv @tab 暗号化をサポート |@ref{encryption}|
@item cscope @tab |@ref{cscope}| をサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
debug			Compiled with "DEBUG" defined.
dialog_con		Compiled with console dialog support.
dialog_gui		Compiled with GUI dialog support.
diff			Compiled with |vimdiff| and 'diff' support.
digraphs		Compiled with support for digraphs.
directx			Compiled with support for DirectX and 'renderoptions'.
dnd			Compiled with support for the "~ register |quote_~|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item debug @tab デバッグバージョンである
@item dialog_con @tab コンソールダイアログのサポート
@item dialog_gui @tab GUI ダイアログのサポート
@item diff @tab |@ref{vimdiff}| と '@option{diff}' のサポート
@item digraphs @tab ダイグラフをサポート
@item directx @tab DirectX と '@option{renderoptions}' をサポート
@item dnd @tab レジスタ "~ をサポート |@ref{quote_~}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
ebcdic			Compiled on a machine with ebcdic character set.
emacs_tags		Compiled with support for Emacs tags.
eval			Compiled with expression evaluation support.  Always
			true, of course!
ex_extra		|+ex_extra|, always true now
extra_search		Compiled with support for |'incsearch'| and
			|'hlsearch'|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ebcdic @tab EBCDIC 文字集合のマシン用
@item emacs_tags @tab Emacs 式のタグファイルをサポート
@item eval @tab 式評価をサポート。もちろん常に真。
@item ex_extra @tab 今は常に真 |@ref{+ex_extra}|
@item extra_search @tab |@ref{'incsearch'}| と |@ref{'hlsearch'}| をサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
farsi			Compiled with Farsi support |farsi|.
file_in_path		Compiled with support for |gf| and |<cfile>|
filterpipe		When 'shelltemp' is off pipes are used for shell
			read/write/filter commands
find_in_path		Compiled with support for include file searches
			|+find_in_path|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item farsi @tab |@ref{farsi}| をサポート
@item file_in_path @tab |@ref{gf}| と |@ref{<cfile>}| をサポート
@item filterpipe @tab '@option{shelltemp}' がオフのとき、シェルの読み込み・書き込み・フィルタコマンドにパイプを使う。
@item find_in_path @tab include ファイル内の検索をサポート |@ref{+find_in_path}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
float			Compiled with support for |Float|.
fname_case		Case in file names matters (for Amiga, MS-DOS, and
			Windows this is not present).
folding			Compiled with |folding| support.
footer			Compiled with GUI footer support. |gui-footer|
fork			Compiled to use fork()/exec() instead of system().
fullscreen              Compiled with 'fullscreen' support.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item float @tab 浮動小数点数 |@ref{Float}| サポート
@item fname_case @tab ファイル名の大文字小文字が区別される (Amiga, MS-DOS, そして Windows では区別されないので偽)
@item folding @tab |@ref{folding}| 折り畳みをサポート
@item footer @tab GUI のフッターをサポート |@ref{gui-footer}|
@item fork @tab system() の代わりに fork()/exec() を用いている
@item fullscreen @tab '@option{fullscreen}' のサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
gettext			Compiled with message translation |multi-lang|
gui			Compiled with GUI enabled.
gui_athena		Compiled with Athena GUI.
gui_gnome		Compiled with Gnome support (gui_gtk is also defined).
gui_gtk			Compiled with GTK+ GUI (any version).
gui_gtk2		Compiled with GTK+ 2 GUI (gui_gtk is also defined).
gui_gtk3		Compiled with GTK+ 3 GUI (gui_gtk is also defined).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item gettext @tab 翻訳メッセージをサポート |@ref{multi-lang}|
@item gui @tab GUI が有効である
@item gui_athena @tab Athena の GUI が有効である
@item gui_gnome @tab Gnome サポート (gui_gtk も定義される)
@item gui_gtk @tab GTK+ の GUI が有効である
@item gui_gtk2 @tab GTK+ 2 の GUI が有効である (gui_gtk も定義される)
@item gui_gtk3 @tab GTK+ 3 の GUI が有効である (gui_gtk も定義される)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
gui_mac			Compiled with Macintosh GUI.
gui_macvim		Compiled with MacVim GUI.
gui_motif		Compiled with Motif GUI.
gui_photon		Compiled with Photon GUI.
gui_running		Vim is running in the GUI, or it will start soon.
gui_win32		Compiled with MS Windows Win32 GUI.
gui_win32s		idem, and Win32s system being used (Windows 3.1)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item gui_mac @tab マッキントッシュの GUI が有効である
@item gui_macvim @tab MacVim の GUI が有効である。
@item gui_motif @tab Motif の GUI が有効である
@item gui_photon @tab Photon の GUI が有効である
@item gui_running @tab Vim が GUI モードで起動している、もしくは間もなくする
@item gui_win32 @tab Win32 の GUI が有効である
@item gui_win32s @tab Win32s の GUI が有効である (Windows 3.1)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
hangul_input		Compiled with Hangul input support. |hangul|
iconv			Can use iconv() for conversion.
insert_expand		Compiled with support for CTRL-X expansion commands in
			Insert mode.
jumplist		Compiled with |jumplist| support.
keymap			Compiled with 'keymap' support.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item hangul_input @tab ハングル入力サポート |@ref{hangul}|
@item iconv @tab iconv() をサポート
@item insert_expand @tab 挿入モード時に CTRL-X の展開がサポートされる
@item jumplist @tab |@ref{jumplist}| をサポート
@item keymap @tab '@option{keymap}' をサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
lambda			Compiled with |lambda| support.
langmap			Compiled with 'langmap' support.
libcall			Compiled with |libcall()| support.
linebreak		Compiled with 'linebreak', 'breakat', 'showbreak' and
			'breakindent' support.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item lambda @tab |@ref{lambda}| をサポート
@item langmap @tab '@option{langmap}' サポート
@item libcall @tab |@ref{libcall()}| をサポート
@item linebreak @tab '@option{linebreak}', '@option{breakat}', '@option{showbreak}', '@option{breakindent}' をサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
lispindent		Compiled with support for lisp indenting.
listcmds		Compiled with commands for the buffer list |:files|
			and the argument list |arglist|.
localmap		Compiled with local mappings and abbr. |:map-local|
lua			Compiled with Lua interface |Lua|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item lispindent @tab lisp 式のインデントをサポート
@item listcmds @tab バッファリスト用のコマンド |@ref{:files}| と引数リスト用のコマンド |@ref{arglist}| をサポート
@item localmap @tab ローカルなマッピングと短縮入力をサポート |@ref{:map-local}|
@item lua @tab Lua インターフェイスをサポート |@ref{Lua}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
mac			Any Macintosh version of Vim  cf. osx
macunix			Synonym for osxdarwin
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item mac @tab すべてのマッキントッシュ版 Vim。osx を参照
@item macunix @tab osxdarwin と同義語
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
menu			Compiled with support for |:menu|.
mksession		Compiled with support for |:mksession|.
modify_fname		Compiled with file name modifiers. |filename-modifiers|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item menu @tab |@ref{:menu}| をサポート
@item mksession @tab |@ref{:mksession}| をサポート
@item modify_fname @tab ファイル名変換子をサポート |@ref{filename-modifiers}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
mouse			Compiled with support mouse.
mouse_dec		Compiled with support for Dec terminal mouse.
mouse_gpm		Compiled with support for gpm (Linux console mouse)
mouse_netterm		Compiled with support for netterm mouse.
mouse_pterm		Compiled with support for qnx pterm mouse.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item mouse @tab マウスをサポート
@item mouse_dec @tab DEC のターミナルマウスをサポート
@item mouse_gpm @tab gpm をサポート (Linux のコンソールマウス)
@item mouse_netterm @tab netterm のマウスをサポート
@item mouse_pterm @tab qnx pterm のマウスをサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
mouse_sysmouse		Compiled with support for sysmouse (*BSD console mouse)
mouse_sgr		Compiled with support for sgr mouse.
mouse_urxvt		Compiled with support for urxvt mouse.
mouse_xterm		Compiled with support for xterm mouse.
mouseshape		Compiled with support for 'mouseshape'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item mouse_sysmouse @tab sysmouse (*BSD コンソールマウス) をサポート
@item mouse_sgr @tab sgr のマウスをサポート
@item mouse_urxvt @tab urxvt のマウスをサポート
@item mouse_xterm @tab xterm のマウスをサポート
@item mouseshape @tab '@option{mouseshape}' をサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
multi_byte		Compiled with support for 'encoding'
multi_byte_encoding	'encoding' is set to a multi-byte encoding.
multi_byte_ime		Compiled with support for IME input method.
multi_lang		Compiled with support for multiple languages.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item multi_byte @tab '@option{encoding}' をサポート
@item multi_byte_encoding @tab '@option{encoding}' がマルチバイトエンコーディングになる
@item multi_byte_ime @tab IME による入力をサポート
@item multi_lang @tab 複数言語をサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
mzscheme		Compiled with MzScheme interface |mzscheme|.
netbeans_enabled	Compiled with support for |netbeans| and connected.
netbeans_intg		Compiled with support for |netbeans|.
num64			Compiled with 64-bit |Number| support.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item mzscheme @tab MzScheme インターフェイスをサポート |@ref{mzscheme}|
@item netbeans_enabled @tab |@ref{netbeans}| をサポートし、現在接続している
@item netbeans_intg @tab |@ref{netbeans}| をサポート
@item num64 @tab 64 ビット数値をサポート |@ref{Number}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
odbeditor               Compiled with |odbeditor| support.
ole			Compiled with OLE automation support for Win32.
osx			Compiled for macOS  cf. mac
osxdarwin		Compiled for macOS, with |mac-darwin-feature|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item odbeditor @tab |@ref{odbeditor}| をサポート
@item ole @tab Win32 にて OLE オートメーションをサポート
@item osx @tab macOS 向け。mac を参照
@item osxdarwin @tab macOS 向け。|@ref{mac-darwin-feature}| をサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
packages		Compiled with |packages| support.
path_extra		Compiled with up/downwards search in 'path' and 'tags'
perl			Compiled with Perl interface.
persistent_undo		Compiled with support for persistent undo history.
postscript		Compiled with PostScript file printing.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item packages @tab |@ref{packages}| をサポート
@item path_extra @tab '@option{path}' と '@option{tags}' の上方・下方検索をサポート
@item perl @tab Perl インターフェイスをサポート
@item persistent_undo @tab 永続アンドゥをサポート
@item postscript @tab PostScript ファイルの印刷をサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
printer			Compiled with |:hardcopy| support.
profile			Compiled with |:profile| support.
python			Python 2.x interface available. |has-python|
python_compiled		Compiled with Python 2.x interface. |has-python|
python_dynamic		Python 2.x interface is dynamically loaded. |has-python|
python3			Python 3.x interface available. |has-python|
python3_compiled	Compiled with Python 3.x interface. |has-python|
python3_dynamic		Python 3.x interface is dynamically loaded. |has-python|
pythonx			Compiled with |python_x| interface. |has-pythonx|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item printer @tab |@ref{:hardcopy}| をサポート
@item profile @tab |@ref{:profile}| をサポート
@item python @tab Python 2.x インターフェイスをサポート |@ref{has-python}|
@item python3 @tab Python 3.x インターフェイスをサポート |@ref{has-python}|
@item python @tab Python 2.x インターフェイスを利用できる |@ref{has-python}|
@item python_compiled @tab Python 2.x インターフェイスでコンパイルされている |@ref{has-python}|
@item python_dynamic @tab Python 2.x インターフェイスは動的にロードされる |@ref{has-python}|
@item python3 @tab Python 3.x インターフェイスを利用できる |@ref{has-python}|
@item python3_compiled @tab Python 3.x インターフェイスでコンパイルされている |@ref{has-python}|
@item python3_dynamic @tab Python 3.x インターフェイスは動的にロードされる |@ref{has-python}|
@item pythonx @tab |@ref{python_x}| インターフェイスをサポート |@ref{has-pythonx}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
qnx			QNX version of Vim.
quickfix		Compiled with |quickfix| support.
reltime			Compiled with |reltime()| support.
rightleft		Compiled with 'rightleft' support.
ruby			Compiled with Ruby interface |ruby|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item qnx @tab QNX バージョン
@item quickfix @tab |@ref{quickfix}| をサポート
@item reltime @tab |@ref{reltime()}| をサポート
@item rightleft @tab '@option{rightleft}' をサポート
@item ruby @tab Ruby インターフェイスをサポート |@ref{ruby}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
scrollbind		Compiled with 'scrollbind' support.
showcmd			Compiled with 'showcmd' support.
signs			Compiled with |:sign| support.
smartindent		Compiled with 'smartindent' support.
spell			Compiled with spell checking support |spell|.
startuptime		Compiled with |--startuptime| support.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item scrollbind @tab '@option{scrollbind}' をサポート
@item showcmd @tab '@option{showcmd}' をサポート
@item signs @tab |@ref{:sign}| をサポート
@item smartindent @tab '@option{smartindent}' をサポート
@item spell @tab スペルチェックをサポート |@ref{spell}|
@item startuptime @tab |@ref{--startuptime, , @minus{}@minus{}startuptime}| をサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
statusline		Compiled with support for 'statusline', 'rulerformat'
			and special formats of 'titlestring' and 'iconstring'.
sun_workshop		Compiled with support for Sun |workshop|.
syntax			Compiled with syntax highlighting support |syntax|.
syntax_items		There are active syntax highlighting items for the
			current buffer.
system			Compiled to use system() instead of fork()/exec().
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item statusline @tab '@option{statusline}', '@option{rulerformat}' そして '@option{titlestring}' と '@option{iconstring}' の特殊フォーマットをサポート
@item sun_workshop @tab Sun |@ref{workshop}| をサポート
@item syntax @tab 構文ハイライト |@ref{syntax}| をサポート
@item syntax_items @tab 現在のバッファに有効なシンタックスが設定されている
@item system @tab fork()/exec() の代わりに system() が使用されている
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
tag_binary		Compiled with binary searching in tags files
			|tag-binary-search|.
tag_old_static		Compiled with support for old static tags
			|tag-old-static|.
tag_any_white		Compiled with support for any white characters in tags
			files |tag-any-white|.
tcl			Compiled with Tcl interface.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item tag_binary @tab タグファイル内の二分探索 |@ref{tag-binary-search}|
@item tag_old_static @tab 旧式の静的 tags をサポート |@ref{tag-old-static}|
@item tag_any_white @tab タグファイル内の空白文字をサポート |@ref{tag-any-white}|
@item tcl @tab TCL インターフェイスをサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
termguicolors		Compiled with true color in terminal support.
terminal		Compiled with |terminal| support.
terminfo		Compiled with terminfo instead of termcap.
termresponse		Compiled with support for |t_RV| and |v:termresponse|.
textobjects		Compiled with support for |text-objects|.
tgetent			Compiled with tgetent support, able to use a termcap
			or terminfo file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item termguicolors @tab 端末での true カラーをサポート
@item terminal @tab |@ref{terminal}| をサポート
@item terminfo @tab termcap の代わりに terminfo をサポート
@item termresponse @tab |@ref{t_RV}| と |@ref{v:termresponse}| をサポート
@item textobjects @tab |@ref{text-objects}| をサポート
@item tgetent @tab tgetent をサポート。termcap か terminfo ファイルが使用可能
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
timers			Compiled with |timer_start()| support.
title			Compiled with window title support |'title'|.
toolbar			Compiled with support for |gui-toolbar|.
touchbar		Compiled with support for Touch Bar in MacVim.
transparency            Compiled with 'transparency' support.
ttyin			input is a terminal (tty)
ttyout			output is a terminal (tty)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item timers @tab |@ref{timer_start()}| をサポート
@item title @tab ウィンドウタイトルをサポート |@ref{'title'}|
@item toolbar @tab |@ref{gui-toolbar}| をサポート
@item touchbar @tab MacVim でのタッチバーをサポート
@item transparency @tab '@option{transparency}' をサポート
@item ttyin @tab 入力が端末 (tty) である
@item ttyout @tab 出力が端末 (tty) である
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
unix			Unix version of Vim. *+unix*
unnamedplus		Compiled with support for "unnamedplus" in 'clipboard'
user_commands		User-defined commands.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{+unix}
@cindex +unix
@item unix @tab UNIX バージョン
@item unnamedplus @tab '@option{clipboard}' に "unnamedplus" をサポート
@item user_commands @tab ユーザー定義コマンドをサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
vcon			Win32: Virtual console support is working, can use
			'termguicolors'. Also see |+vtp|.
vertsplit		Compiled with vertically split windows |:vsplit|.
vim_starting		True while initial source'ing takes place. |startup|
			*vim_starting*
viminfo			Compiled with viminfo support.
virtualedit		Compiled with 'virtualedit' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item vcon @tab Win32: 仮想コンソールが動作するなら '@option{termguicolors}' を使うことができる。|@ref{+vtp}| も参照。
@item vertsplit @tab ウィンドウの垂直分割をサポート |@ref{:vsplit}|
@item vim_starting @tab Vim の初期化プロセス中は真となる。|@ref{startup}|
@anchor{vim_starting}
@cindex vim_starting
@item viminfo @tab viminfo をサポート
@item virtualedit @tab オプション '@option{virtualedit}' をサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
visual			Compiled with Visual mode.
visualextra		Compiled with extra Visual mode commands.
			|blockwise-operators|.
vms			VMS version of Vim.
vreplace		Compiled with |gR| and |gr| commands.
vtp			Compiled for vcon support |+vtp| (check vcon to find
			out if it works in the current console).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item visual @tab ビジュアルモードをサポート
@item visualextra @tab 拡張ビジュアルモードをサポート |@ref{blockwise-operators}|
@item vms @tab VMS バージョン
@item vreplace @tab コマンド |@ref{gR}| と |@ref{gr}| をサポート
@item vtp @tab |@ref{+vtp}| をサポートする vcon をコンパイルする (現在のコンソールで動作するなら、見つけるために vcon をチェックする)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
wildignore		Compiled with 'wildignore' option.
wildmenu		Compiled with 'wildmenu' option.
win16			old version for MS-Windows 3.1 (always False)
win32			Win32 version of Vim (MS-Windows 95 and later, 32 or
			64 bits)
win32unix		Win32 version of Vim, using Unix files (Cygwin)
win64			Win64 version of Vim (MS-Windows 64 bit).
win95			Win32 version for MS-Windows 95/98/ME (always False)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item wildignore @tab オプション '@option{wildignore}' をサポート
@item wildmenu @tab オプション '@option{wildmenu}' を指定してコンパイル
@item win16 @tab 古い MS-Windows 3.1 バージョン (常に偽)
@item win32 @tab Win32 バージョン (MS-Windows 95 以上の 32 or 64 ビット)
@item win32unix @tab Win32 バージョン。Unix ファイルを使用 (Cygwin)
@item win64 @tab Win64 バージョン (MS-Windows 64 bit)
@item win95 @tab Win32 バージョン。MS-Windows 95/98/ME 用 (常に偽)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
winaltkeys		Compiled with 'winaltkeys' option.
windows			Compiled with support for more than one window.
writebackup		Compiled with 'writebackup' default on.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item winaltkeys @tab オプション '@option{winaltkeys}' を指定してコンパイル
@item windows @tab 複数ウィンドウをサポート
@item writebackup @tab オプション '@option{writebackup}' が起動時にonになる
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
xfontset		Compiled with X fontset support |xfontset|.
xim			Compiled with X input method support |xim|.
xpm			Compiled with pixmap support.
xpm_w32			Compiled with pixmap support for Win32. (Only for
			backward compatibility. Use "xpm" instead.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item xfontset @tab X fontset をサポート |@ref{xfontset}|
@item xim @tab XIM をサポート |@ref{xim}|
@item xpm @tab pixmap をサポート
@item xpm_w32 @tab Win32 で pixmap をサポート(後方互換性のためのみ。代わりに "xpm" を使用せよ。)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
xsmp			Compiled with X session management support.
xsmp_interact		Compiled with interactive X session management support.
xterm_clipboard		Compiled with support for xterm clipboard.
xterm_save		Compiled with support for saving and restoring the
			xterm screen.
x11			Compiled with X11 support.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item xsmp @tab X セッションマネージメントをサポート
@item xsmp_interact @tab 対話的 X セッションマネージメントをサポート
@item xterm_clipboard @tab xterm のクリップボードサポート
@item xterm_save @tab xterm のスクリーンの保存復帰をサポート
@item x11 @tab X11 をサポート
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*string-match*
Matching a pattern in a String
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{string-match}
@cindex string-match
@cindex 文字列内でのパターンマッチング
@unnumberedsubsec 文字列内でのパターンマッチング
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A regexp pattern as explained at |pattern| is normally used to find a match in
the buffer lines.  When a pattern is used to find a match in a String, almost
everything works in the same way.  The difference is that a String is handled
like it is one line.  When it contains a "\n" character, this is not seen as a
line break for the pattern.  It can be matched with a "\n" in the pattern, or
with ".".  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{pattern}| で説明されている正規表現パターンは通常、バッファ内の行に対してマッチを検索するために使われる。

文字列内でマッチを見つけるために使うときも、ほとんどは同じように動作する。違いは、文字列が 1 つの行であるかのように扱われる事である。

文字列が文字 "\n" だけを含むとき、これは改行とはみなされない。この "\n" はパターン内の "\n" や "." にマッチする。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:let a = "aaaa\nxxxx"
	:echo matchstr(a, "..\n..")
	aa
	xx
	:echo matchstr(a, "a.x")
	a
	x
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:let a = "aaaa\nxxxx"
:echo matchstr(a, "..\n..")
aa
xx
:echo matchstr(a, "a.x")
a
x
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Don't forget that "^" will only match at the first character of the String and
"$" at the last character of the string.  They don't match after or before a
"\n".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"^" は文字列の最初の文字でだけマッチし、"$" は最後の文字でだけマッチすることに注意。"\n" の前後にはマッチしない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
5. Defining functions					*user-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{user-functions}
@cindex user-functions
@cindex 関数定義
@section 5. 関数定義
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
New functions can be defined.  These can be called just like builtin
functions.  The function executes a sequence of Ex commands.  Normal mode
commands can be executed with the |:normal| command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザーは自分で新しい関数を定義することができる。その関数は組込み関数とまったく同じように呼び出せる。関数は一連の Ex コマンドを実行する。ノーマルモードコマンドはコマンド |@ref{:normal}| によって実行できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The function name must start with an uppercase letter, to avoid confusion with
builtin functions.  To prevent from using the same name in different scripts
avoid obvious, short names.  A good habit is to start the function name with
the name of the script, e.g., "HTMLcolor()".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数名は組込み関数との混同を避ける為、大文字で始まらなければならない。他のスクリプトで同じ関数名を使用してしまうことを避ける為に、露骨に短い名前は避けるべきである。関数名を例えば "HTMLcolor()" のように、スクリプトの名前から始めるというのは良い習慣である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It's also possible to use curly braces, see |curly-braces-names|.  And the
|autoload| facility is useful to define a function only when it's called.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
波括弧変数というものもある (|@ref{curly-braces-names}| を参照)。また、オートロード |@ref{autoload}| 機構を使うと、関数が呼ばれたときだけ定義することができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*local-function*
A function local to a script must start with "s:".  A local script function
can only be called from within the script and from functions, user commands
and autocommands defined in the script.  It is also possible to call the
function from a mapping defined in the script, but then |<SID>| must be used
instead of "s:" when the mapping is expanded outside of the script.
There are only script-local functions, no buffer-local or window-local
functions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{local-function}
@cindex local-function
スクリプトローカルな関数の名前は "s:" で始めなければならない。スクリプトローカルな関数は、そのスクリプトの中の関数から、またはそのスクリプト内で定義されたユーザー定義コマンド、オートコマンドからしか呼ぶことができない。そのスクリプト内で定義されたマッピングにより呼ぶこともできるが、スクリプトの外部でマッピングが展開された場合は "s:" の代わりに |@ref{<SID>}| をつけなければならない。

ローカル関数はスクリプトローカル関数だけである。バッファローカル関数やウィンドウローカル関数というものはない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*:fu* *:function* *E128* *E129* *E123*
:fu[nction]		List all functions and their arguments.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{:fu}
@anchor{:function}
@anchor{E128}
@anchor{E129}
@anchor{E123}
@pindex :fu
@pindex :function
@erindex E128
@erindex E129
@erindex E123
@item :fu[nction]
全ての関数と、その引数を表示する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:fu[nction] {name}	List function {name}.
			{name} can also be a |Dictionary| entry that is a
			|Funcref|: >
				:function dict.init
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :fu[nction] @{name@}
関数 @{name@} の定義を表示する。

@{name@} は辞書 |@ref{Dictionary}| の要素の |@ref{Funcref}| であってもよい:
@example
:function dict.init
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:fu[nction] /{pattern}	List functions with a name matching {pattern}.
			Example that lists all functions ending with "File": >
				:function /File$
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :fu[nction] /@{pattern@}
@{pattern@} にマッチする名前の関数を表示する。"File" で終わる関数を全て表示する例:
@example
:function /File$
@end example
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:function-verbose*
When 'verbose' is non-zero, listing a function will also display where it was
last defined. Example: >

    :verbose function SetFileTypeSH
	function SetFileTypeSH(name)
	    Last set from /usr/share/vim/vim-7.0/filetype.vim
<
See |:verbose-cmd| for more information.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:function-verbose}
@cindex :function-verbose
'@option{verbose}' が 0 でないとき、これらのコマンドで関数を表示すると、それがどこで定義されたかも表示する。例:
@example
:verbose function SetFileTypeSH
    function SetFileTypeSH(name)
        Last set from /usr/share/vim/vim-7.0/filetype.vim
@end example
より詳しくは |@ref{:verbose-cmd}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*E124* *E125* *E853* *E884*
:fu[nction][!] {name}([arguments]) [range] [abort] [dict] [closure]
			Define a new function by the name {name}.  The body of
			the function follows in the next lines, until the
			matching |:endfunction|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{E124}
@anchor{E125}
@anchor{E853}
@anchor{E884}
@erindex E124
@erindex E125
@erindex E853
@erindex E884
@item :fu[nction][!] @{name@}([arguments]) [range] [abort] [dict] [closure]
@{name@} という名前で新しい関数を定義する。関数の本体は、宣言の次の行から始まり、対応する |@ref{:endfunction}| までになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			The name must be made of alphanumeric characters and
			'_', and must start with a capital or "s:" (see
			above).  Note that using "b:" or "g:" is not allowed.
			(since patch 7.4.260 E884 is given if the function
			name has a colon in the name, e.g. for "foo:bar()".
			Before that patch no error was given).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数名はアルファベットと数字と '_' からなり、通常の関数はアルファベットの大文字、スクリプトローカル関数は "s:" で始まらなければならない。
@quotation
@strong{Note:} @*
"b:" や "g:" は使用できない (7.4.260 からは関数名にコロンが含まれる場合は E884 エラーが発生する。例 "foo:bar()"。このパッチ以前はエラーにはならない)。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			{name} can also be a |Dictionary| entry that is a
			|Funcref|: >
				:function dict.init(arg)
<			"dict" must be an existing dictionary.  The entry
			"init" is added if it didn't exist yet.  Otherwise [!]
			is required to overwrite an existing function.  The
			result is a |Funcref| to a numbered function.  The
			function can only be used with a |Funcref| and will be
			deleted if there are no more references to it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{name@} は辞書 |@ref{Dictionary}| の要素の |@ref{Funcref}| であってもよい:
@example
:function dict.init(arg)
@end example
"dict" は既に定義されている辞書でなければならない。その要素 "init" がまだ存在しないならば追加される。存在する場合は、既存の関数を上書きするためには [!] をつけなければならない。この値は番号つきの関数を指す |@ref{Funcref}| である。この関数は |@ref{Funcref}| を通してのみ呼ぶことができ、そこへの参照がなくなると削除される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
								*E127* *E122*
			When a function by this name already exists and [!] is
			not used an error message is given.  When [!] is used,
			an existing function is silently replaced.  Unless it
			is currently being executed, that is an error.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E127}
@anchor{E122}
@erindex E127
@erindex E122

この名前で定義される関数が既に定義済みで [!] が使用されなかった場合、エラーとなる。[!] が使用されていれば、それまで存在していた関数は、速やかに新しいものへ置換えられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			NOTE: Use ! wisely.  If used without care it can cause
			an existing function to be replaced unexpectedly,
			which is hard to debug.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
賢く使うこと！気をつけないで使うと、意図せず存在する関数が置き換えられてしまう。これはひどいバグだ。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			For the {arguments} see |function-argument|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数 @{arguments@} については |@ref{function-argument}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*:func-range* *a:firstline* *a:lastline*
			When the [range] argument is added, the function is
			expected to take care of a range itself.  The range is
			passed as "a:firstline" and "a:lastline".  If [range]
			is excluded, ":{range}call" will call the function for
			each line in the range, with the cursor on the start
			of each line.  See |function-range-example|.
			The cursor is still moved to the first line of the
			range, as is the case with all Ex commands.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:func-range}
@anchor{a:firstline}
@anchor{a:lastline}
@cindex :func-range
@vindex a:firstline
@vindex a:lastline
引数 [range] を追加した場合、関数は「範囲」を管理することができる。「範囲」は "a:firstline" と "a:lastline" によって渡される。[range] がなかった場合、":@{range@}call" が「範囲」を指定されて実行されると、1 行 1 行について、カーソルをその行の先頭に置いた状態で関数を呼び出すことになる。|@ref{function-range-example}| を参照。他の Ex コマンドと同様に、カーソルは選択範囲の最初の行に移動される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
								*:func-abort*
			When the [abort] argument is added, the function will
			abort as soon as an error is detected.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:func-abort}
@cindex :func-abort

引数 [abort] を追加すると、関数の実行中にエラーに遭遇し次第、即関数は中断される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
								*:func-dict*
			When the [dict] argument is added, the function must
			be invoked through an entry in a |Dictionary|.  The
			local variable "self" will then be set to the
			dictionary.  See |Dictionary-function|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:func-dict}
@cindex :func-dict

引数 [dict] を追加すると、この関数は辞書 |@ref{Dictionary}| の要素を通してしか呼べなくなる。そしてその辞書にローカル変数 "self" が定義される。|@ref{Dictionary-function}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*:func-closure* *E932*
			When the [closure] argument is added, the function
			can access variables and arguments from the outer
			scope.  This is usually called a closure.  In this
			example Bar() uses "x" from the scope of Foo().  It
			remains referenced even after Foo() returns: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:func-closure}
@anchor{E932}
@cindex :func-closure
@erindex E932

引数 [closure] を追加すると、関数は外側のスコープの変数と引数をアクセスできるようになる。これは一般的にクロージャと呼ばれる。以下の例では Bar() は Foo() のスコープの "x" を使用している。それは Foo() から戻っても参照され続ける:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
				:function! Foo()
				:  let x = 0
				:  function! Bar() closure
				:    let x += 1
				:    return x
				:  endfunction
				:  return funcref('Bar')
				:endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:function! Foo()
:  let x = 0
:  function! Bar() closure
:    let x += 1
:    return x
:  endfunction
:  return funcref('Bar')
:endfunction
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				:let F = Foo()
				:echo F()
<				1 >
				:echo F()
<				2 >
				:echo F()
<				3
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:let F = Foo()
:echo F()
1
:echo F()
2
:echo F()
3
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*function-search-undo*
			The last used search pattern and the redo command "."
			will not be changed by the function.  This also
			implies that the effect of |:nohlsearch| is undone
			when the function returns.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{function-search-undo}
@cindex function-search-undo
関数の実行によって、最後に使用されたサーチパターン、及び redo コマンドの "." の内容は変更されない。したがって、関数内で |@ref{:nohlsearch}| を行っても、関数から戻ると検索結果のハイライトが元に戻ることになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*:endf* *:endfunction* *E126* *E193* *W22*
:endf[unction] [argument]
			The end of a function definition.  Best is to put it
			on a line by its own, without [argument].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:endf}
@anchor{:endfunction}
@anchor{E126}
@anchor{E193}
@anchor{W22}
@pindex :endf
@pindex :endfunction
@erindex E126
@erindex E193
@erindex W22
@item :endf[unction] [argument]
関数定義の終了。[argument] を付けずに 1 行このコマンドのみを書くのがベスト。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			[argument] can be:
				| command	command to execute next
				\n command	command to execute next
				" comment	always ignored
				anything else	ignored, warning given when
						'verbose' is non-zero
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[argument] となるのは:
@multitable @columnfractions .3 .7
@item | command @tab 次を実行するコマンド
@item \n command @tab 次を実行するコマンド
@item " comment @tab 常に無効
@item anything else @tab 無効。'@option{verbose}' が非ゼロのときは警告が出る
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			The support for a following command was added in Vim
			8.0.0654, before that any argument was silently
			ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim 8.0.0654 以降で追加されたコマンドがサポートされ、それより以前のコマンドは黙って無視される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			To be able to define a function inside an `:execute`
			command, use line breaks instead of |:bar|: >
				:exe "func Foo()\necho 'foo'\nendfunc"
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
`:execute` コマンドの中で関数と定義するため、|@ref{:bar}| の代わりに改行を使う:
@example
:exe "func Foo()\necho 'foo'\nendfunc"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
				*:delf* *:delfunction* *E130* *E131* *E933*
:delf[unction][!] {name}
			Delete function {name}.
			{name} can also be a |Dictionary| entry that is a
			|Funcref|: >
				:delfunc dict.init
<			This will remove the "init" entry from "dict".  The
			function is deleted if there are no more references to
			it.
			With the ! there is no error if the function does not
			exist.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:delf}
@anchor{:delfunction}
@anchor{E130}
@anchor{E131}
@anchor{E933}
@pindex :delf
@pindex :delfunction
@erindex E130
@erindex E131
@erindex E933
@item :delf[unction][!] @{name@}
関数 @{name@} を削除する。

@{name@} は辞書 |@ref{Dictionary}| の要素の |@ref{Funcref}| であってもよい:
@example
:delfunc dict.init
@end example
この例は "dict" から要素 "init" を削除する。この関数への参照がなくなると、関数は削除される。! を一緒に使うと、関数が存在しなくてもエラーを生じない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:retu* *:return* *E133*
:retu[rn] [expr]	Return from a function.  When "[expr]" is given, it is
			evaluated and returned as the result of the function.
			If "[expr]" is not given, the number 0 is returned.
			When a function ends without an explicit ":return",
			the number 0 is returned.
			Note that there is no check for unreachable lines,
			thus there is no warning if commands follow ":return".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:retu}
@anchor{:return}
@anchor{E133}
@pindex :retu
@pindex :return
@erindex E133
@item :retu[rn] [expr]
関数から戻る。"[expr]" が与えられた場合、それは評価され関数の戻り値として呼出し側に渡される。"[expr]" が与えられない場合、数値 0 が呼出し側に渡される。
@quotation
@strong{Note:} @*
関数内に実行されない命令があるかどうかはチェックされないことに留意すること。つまり、たとえ "@command{:return}" 命令の後に何か命令があったとしても、警告も何も与えられない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			If the ":return" is used after a |:try| but before the
			matching |:finally| (if present), the commands
			following the ":finally" up to the matching |:endtry|
			are executed first.  This process applies to all
			nested ":try"s inside the function.  The function
			returns at the outermost ":endtry".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:try}| と |@ref{:finally}| の間で "@command{:return}" が実行された場合、"@command{:finally}" から対応する |@ref{:endtry}| までのコマンドがまず実行される。"@command{:try}" がネストしている場合、それらの全てに対してこのプロセスが適用される。そして最も外側の "@command{:endtry}" にて関数を抜ける。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*function-argument* *a:var*
An argument can be defined by giving its name.  In the function this can then
be used as "a:name" ("a:" for argument).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{function-argument}
@anchor{a:var}
@cindex function-argument
@vindex a:var
引数は、与えられた名前によって定義される。関数のなかでは "a:name" ("a:" を引数に接頭)のようにして参照することができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*a:0* *a:1* *a:000* *E740* *...*
Up to 20 arguments can be given, separated by commas.  After the named
arguments an argument "..." can be specified, which means that more arguments
may optionally be following.  In the function the extra arguments can be used
as "a:1", "a:2", etc.  "a:0" is set to the number of extra arguments (which
can be 0).  "a:000" is set to a |List| that contains these arguments.  Note
that "a:1" is the same as "a:000[0]".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{a:0}
@anchor{a:1}
@anchor{a:000}
@anchor{E740}
@anchor{...}
@vindex a:0
@vindex a:1
@vindex a:000
@erindex E740
@cindex ...

引数はコンマで区切ることで、最大 20 まで与えることができる。最後の引数を "..." にすることで、可変長の引数を使用できる。関数の中では "a:1" や "a:2" のようにして可変長の引数にアクセスできる。"a:0" は可変長引数が幾つあるかを示している (0 であること、つまり引数がそれ以上ないこともある)。"a:000" は全引数を持つリスト |@ref{List}| を示している。
@quotation
@strong{Note:} @*
"a:1" は "a:000[0]" と同じである。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
								*E742*
The a: scope and the variables in it cannot be changed, they are fixed.
However, if a composite type is used, such as |List| or |Dictionary| , you can
change their contents.  Thus you can pass a |List| to a function and have the
function add an item to it.  If you want to make sure the function cannot
change a |List| or |Dictionary| use |:lockvar|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E742}
@erindex E742

a: のスコープとこの変数は固定されており、変更できない。しかしリスト |@ref{List}| や辞書 |@ref{Dictionary}| のような複合型が使用された場合は、その内容を変更できる。よって関数にリスト |@ref{List}| を渡し、そこに要素を追加させることができる。関数にリスト |@ref{List}| や辞書 |@ref{Dictionary}| を変更させたくない場合は |@ref{:lockvar}| を使うこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When not using "...", the number of arguments in a function call must be equal
to the number of named arguments.  When using "...", the number of arguments
may be larger.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"..." が使われていない時は、関数呼び出しの時の引数の数は名前付きの引数の数と一致していなければならない。"..." を使った時には引数の数は大きくなるだろう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It is also possible to define a function without any arguments.  You must
still supply the () then.

It is allowed to define another function inside a function body.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数を引数無しで定義することも可能である。その時でも()は付けなければならない。関数の中で別の関数を定義することも可能である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*local-variables*
Inside a function local variables can be used.  These will disappear when the
function returns.  Global variables need to be accessed with "g:".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{local-variables}
@cindex local-variables
関数の中でローカル変数を使うこともできる。これらは関数から戻ると消滅する。グローバル変数にアクセスするためには "g:" を付ける必要がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Example: >
  :function Table(title, ...)
  :  echohl Title
  :  echo a:title
  :  echohl None
  :  echo a:0 . " items:"
  :  for s in a:000
  :    echon ' ' . s
  :  endfor
  :endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@verbatim
:function Table(title, ...)
:  echohl Title
:  echo a:title
:  echohl None
:  echo a:0 . " items:"
:  for s in a:000
:    echon ' ' . s
:  endfor
:endfunction 
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This function can then be called with: >
  call Table("Table", "line1", "line2")
  call Table("Empty Table")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この関数は次のように呼ぶことができる:
@example
let lines = Table("Table", "line1", "line2")
let lines = Table("Empty Table")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To return more than one value, return a |List|: >
  :function Compute(n1, n2)
  :  if a:n2 == 0
  :    return ["fail", 0]
  :  endif
  :  return ["ok", a:n1 / a:n2]
  :endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
1 つ以上の値を返したい場合には、リスト |@ref{List}| を返すようにする:
@verbatim
:function Compute(n1, n2)
:  if a:n2 == 0
:    return ["fail", 0]
:  endif
:  return ["ok", a:n1 / a:n2]
:endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This function can then be called with: >
  :let [success, div] = Compute(102, 6)
  :if success == "ok"
  :  echo div
  :endif
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この関数は次のように呼ぶことができる:
@verbatim
:let [success, div] = Compute(102, 6)
:if success == "ok"
:  echo div
:endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*:cal* *:call* *E107* *E117*
:[range]cal[l] {name}([arguments])
		Call a function.  The name of the function and its arguments
		are as specified with |:function|.  Up to 20 arguments can be
		used.  The returned value is discarded.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{:cal}
@anchor{:call}
@anchor{E107}
@anchor{E117}
@pindex :cal
@pindex :call
@erindex E107
@erindex E117
@item :[range]cal[l] @{name@}([arguments])
関数を呼び出す。関数の名前と引数は |@ref{:function}| によって指定されるものである。引数は最大 20 まで使用可能。戻り値は破棄される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Without a range and for functions that accept a range, the
		function is called once.  When a range is given the cursor is
		positioned at the start of the first line before executing the
		function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

「範囲」を受け付ける関数に「範囲」を指定しなかった場合、関数はカーソルの現在位置について一度だけ呼び出される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When a range is given and the function doesn't handle it
		itself, the function is executed for each line in the range,
		with the cursor in the first column of that line.  The cursor
		is left at the last line (possibly moved by the last function
		call).  The arguments are re-evaluated for each line.  Thus
		this works:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

「範囲」を受け付けない関数に「範囲」を指定した場合、その範囲の 1 行ずつについて関数が呼び出される。その時カーソルは当該行の先頭に設定される。カーソルは「範囲」の最下行の左端になる(恐らく最後の関数呼出しの結果、動いた先である)。引数は各呼出しについて繰り返し評価される。それは次の例で確かめることができる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*function-range-example*  >
	:function Mynumber(arg)
	:  echo line(".") . " " . a:arg
	:endfunction
	:1,5call Mynumber(getline("."))
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{function-range-example}
@cindex function-range-example
@verbatim
:function Mynumber(arg)
:  echo line(".") . " " . a:arg
:endfunction
:1,5call Mynumber(getline("."))
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The "a:firstline" and "a:lastline" are defined anyway, they
		can be used to do something different at the start or end of
		the range.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"a:firstline" と "a:lastline" はとにかく定義されるので、「範囲」の最初や最後で何か違った事をするのにも用いることができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example of a function that handles the range itself: >

	:function Cont() range
	:  execute (a:firstline + 1) . "," . a:lastline . 's/^/\t\\ '
	:endfunction
	:4,8call Cont()
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
「範囲」自身を扱っている関数の例:
@verbatim
:function Cont() range
:  execute (a:firstline + 1) . "," . a:lastline . 's/^/\t\\ '
:endfunction
:4,8call Cont()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		This function inserts the continuation character "\" in front
		of all the lines in the range, except the first one.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この関数は「範囲」の最初の行を除いた全ての行の先頭に、継続のための文字 "\" を挿入する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When the function returns a composite value it can be further
		dereferenced, but the range will not be used then.  Example: >
	:4,8call GetDict().method()
<		Here GetDict() gets the range but method() does not.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この関数の戻り値からさらに間接参照が行われる場合、その参照先には範囲が渡されない。例:
@example
:4,8call GetDict().method()
@end example
GetDict() には範囲が渡されるが、method() には渡されない。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
								*E132*
The recursiveness of user functions is restricted with the |'maxfuncdepth'|
option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E132}
@erindex E132
関数の再帰的な使用はオプション |@ref{'maxfuncdepth'}| によって制限することができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
AUTOMATICALLY LOADING FUNCTIONS ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex 自動的に読み込まれる関数
@unnumberedsubsec 自動的に読み込まれる関数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*autoload-functions*
When using many or large functions, it's possible to automatically define them
only when they are used.  There are two methods: with an autocommand and with
the "autoload" directory in 'runtimepath'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{autoload-functions}
@cindex autoload-functions
たくさんの関数または巨大な関数を使うときは、それらが使用されたときだけ自動的に定義されるようにすることができる。これには 2 つの方法がある: オートコマンドによる方法と、'@option{runtimepath}' 内の "autoload" ディレクトリによる方法である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Using an autocommand ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex オートコマンドを使う方法
@unnumberedsubsec オートコマンドを使う方法
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This is introduced in the user manual, section |41.14|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはユーザーマニュアルのセクション |@ref{41.14}| で説明されている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The autocommand is useful if you have a plugin that is a long Vim script file.
You can define the autocommand and quickly quit the script with |:finish|.
That makes Vim startup faster.  The autocommand should then load the same file
again, setting a variable to skip the |:finish| command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オートコマンドは、長い Vim script ファイルのプラグインに対して有用である。自動コマンドを定義し、すぐに |@ref{:finish}| でそのスクリプトを抜ける。こうすると Vim の起動が速くなる。その後オートコマンドにより |@ref{:finish}| コマンドをスキップする変数を定義し、そのファイルが再び読み込まれる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Use the FuncUndefined autocommand event with a pattern that matches the
function(s) to be defined.  Example: >

	:au FuncUndefined BufNet* source ~/vim/bufnetfuncs.vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
定義すべき関数名にマッチするパターンを指定してオートコマンドイベント FuncUndefined を使う。例:
@example
:au FuncUndefined BufNet* source ~/vim/bufnetfuncs.vim
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The file "~/vim/bufnetfuncs.vim" should then define functions that start with
"BufNet".  Also see |FuncUndefined|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイル "~/vim/bufnetfuncs.vim" は "BufNet" で始まる関数を定義しなければならない。|@ref{FuncUndefined}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Using an autoload script ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex オートロードスクリプトの使い方
@unnumberedsubsec オートロードスクリプトの使い方
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*autoload* *E746*
This is introduced in the user manual, section |41.15|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{autoload}
@anchor{E746}
@cindex autoload
@erindex E746
これはユーザーマニュアルのセクション |@ref{41.15}| で説明されている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Using a script in the "autoload" directory is simpler, but requires using
exactly the right file name.  A function that can be autoloaded has a name
like this: >

	:call filename#funcname()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"autoload" ディレクトリのスクリプトを使う方法はより簡単である。しかし完全に正しいファイル名を使う必要がある。オートロードされる関数は次のような名前を持つ:
@example
:call filename#funcname()
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When such a function is called, and it is not defined yet, Vim will search the
"autoload" directories in 'runtimepath' for a script file called
"filename.vim".  For example "~/.vim/autoload/filename.vim".  That file should
then define the function like this: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このような関数が呼ばれ、それがまだ定義されていなかった場合、Vim は '@option{runtimepath}' 内の "autoload" ディレクトリから "@file{filename.vim}" というスクリプトファイルを探す。例えば "@file{~/.vim/autoload/filename.vim}" のように。そしてこのファイルは次のような関数を定義していなければならない:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	function filename#funcname()
	   echo "Done!"
	endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
function filename#funcname()
   echo "Done!"
endfunction
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The file name and the name used before the # in the function must match
exactly, and the defined function must have the name exactly as it will be
called.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このファイル名と関数の # の前の部分は完全に一致しなければならない。そして定義された関数は呼ばれた関数と完全に同じ名前でなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It is possible to use subdirectories.  Every # in the function name works like
a path separator.  Thus when calling a function: >

	:call foo#bar#func()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
サブディレクトリを使うこともできる。関数名の中の # はパスのセパレータのように解釈される。つまり、次の関数を呼ぶと:
@example
:call foo#bar#func()
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim will look for the file "autoload/foo/bar.vim" in 'runtimepath'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は '@option{runtimepath}' からファイル "@file{autoload/foo/bar.vim}" を探す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This also works when reading a variable that has not been set yet: >

	:let l = foo#bar#lvar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはまだ定義されていない変数を参照するときにも使える:
@example
:let l = foo#bar#lvar
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
However, when the autoload script was already loaded it won't be loaded again
for an unknown variable.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
しかしこのオートロードスクリプトがすでに読み込まれている場合、未知の変数があってもこのスクリプトは再読み込みされない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When assigning a value to such a variable nothing special happens.  This can
be used to pass settings to the autoload script before it's loaded: >

	:let foo#bar#toggle = 1
	:call foo#bar#func()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この変数に値を代入するときは、何も特別なことはない。この方法は、オートロードスクリプトが読み込まれる前に設定を渡すために使うことができる:
@example
:let foo#bar#toggle = 1
:call foo#bar#func()
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that when you make a mistake and call a function that is supposed to be
defined in an autoload script, but the script doesn't actually define the
function, the script will be sourced every time you try to call the function.
And you will get an error message every time.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
オートロードスクリプト内で定義されるはずの関数を呼んだがスクリプト内で関数が定義されなかった場合、その関数を呼ぶたびにそのスクリプトが source される。そして毎回エラーメッセージが表示される。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Also note that if you have two script files, and one calls a function in the
other and vice versa, before the used function is defined, it won't work.
Avoid using the autoload functionality at the toplevel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
また、2 つのスクリプト間で、互いに自分が定義される前に相手を呼ぶような関数があると、これは動作しない。トップレベルでオートロード機能を使うのは避けること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Hint: If you distribute a bunch of scripts you can pack them together with the
|vimball| utility.  Also read the user manual |distribute-script|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Hint:} @*
たくさんのファイルからなるスクリプトを配布する場合には、|@ref{vimball}| ユーティリティを使うとそれらをまとめることができる。ユーザーマニュアルの |@ref{distribute-script}| も参照。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
6. Curly braces names					*curly-braces-names*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{curly-braces-names}
@cindex curly-braces-names
@cindex 波括弧変数
@section 6. 波括弧変数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In most places where you can use a variable, you can use a "curly braces name"
variable.  This is a regular variable name with one or more expressions
wrapped in braces {} like this: >
	my_{adjective}_variable
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数を使用可能なほとんどの文脈では「波括弧」変数を使うことができる。これは有効な変数名であり、次のように、1 個以上の式を波括弧 @{@} で囲む:
@example
my_@{adjective@}_variable
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When Vim encounters this, it evaluates the expression inside the braces, puts
that in place of the expression, and re-interprets the whole as a variable
name.  So in the above example, if the variable "adjective" was set to
"noisy", then the reference would be to "my_noisy_variable", whereas if
"adjective" was set to "quiet", then it would be to "my_quiet_variable".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim はこれを見つけると、まず波括弧の中の式を評価し、その値をもとの位置に置きかえ、全体を変数名として再解釈する。よって上の例では、変数 "adjective" に "noisy" が代入されていたとすると、この変数は "my_noisy_variable" となる。あるいは、"adjective" に "quiet" が代入されていたとすれば "my_quiet_variable" となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
One application for this is to create a set of variables governed by an option
value.  For example, the statement >
	echo my_{&background}_message
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これの応用の 1 つは、オプション値によって支配される変数の集合を作ることである。例えば次の文
@example
echo my_@{&background@}_message
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
would output the contents of "my_dark_message" or "my_light_message" depending
on the current value of 'background'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
は現在の '@option{background}' の値に応じて "my_dark_message" か "my_light_message" の中身を表示する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use multiple brace pairs: >
	echo my_{adverb}_{adjective}_message
..or even nest them: >
	echo my_{ad{end_of_word}}_message
where "end_of_word" is either "verb" or "jective".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
波括弧を複数使うこともできる:
@example
echo my_@{adverb@}_@{adjective@}_message
@end example
ネストさせることもできる:
@example
echo my_@{ad@{end_of_word@}@}_message
@end example
ここで "end_of_word" は "verb" か "jective" のどちらかである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
However, the expression inside the braces must evaluate to a valid single
variable name, e.g. this is invalid: >
	:let foo='a + b'
	:echo c{foo}d
.. since the result of expansion is "ca + bd", which is not a variable name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
しかし、波括弧の中の式を評価した結果が有効な変数名とならなければならない。つまり、次は無効である:
@example
:let foo='a + b'
:echo c@{foo@}d
@end example
というのは、展開の結果が "ca + bd" となるからで、これは有効な名前ではない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*curly-braces-function-names*
You can call and define functions by an evaluated name in a similar way.
Example: >
	:let func_end='whizz'
	:call my_func_{func_end}(parameter)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{curly-braces-function-names}
@cindex curly-braces-function-names
同様の方法で評価した名前により関数を定義したり呼び出したりできる。

例:
@example
:let func_end='whizz'
:call my_func_@{func_end@}(parameter)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This would call the function "my_func_whizz(parameter)".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この例は関数 "my_func_whizz(parameter)" を呼びだす。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This does NOT work: >
  :let i = 3
  :let @{i} = ''  " error
  :echo @{i}      " error
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらは機能しない:
@verbatim
:let i = 3
:let @{i} = ''  " error
:echo @{i}      " error
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
7. Commands						*expression-commands*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{expression-commands}
@cindex expression-commands
@cindex コマンド
@section 7. コマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:let {var-name} = {expr1}				*:let* *E18*
			Set internal variable {var-name} to the result of the
			expression {expr1}.  The variable will get the type
			from the {expr}.  If {var-name} didn't exist yet, it
			is created.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{:let}
@anchor{E18}
@pindex :let
@erindex E18
@item :let @{var-name@} = @{expr1@}
内部変数 @{var-name@} に式 @{expr1@} の結果をセットする。変数の型は @{expr1@} によって決定される。@{var-name@} という変数がまだ存在しない場合、新たに作成される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:let {var-name}[{idx}] = {expr1}			*E689*
			Set a list item to the result of the expression
			{expr1}.  {var-name} must refer to a list and {idx}
			must be a valid index in that list.  For nested list
			the index can be repeated.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E689}
@erindex E689
@item :let @{var-name@}[@{idx@}] = @{expr1@}
リストの要素に式 @{expr1@} の結果をセットする。@{var-name@} はリストを参照し、@{idx@} はそのリストの有効なインデックスでなければならない。ネストしたリストに対してはインデックスを繰り返すことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			This cannot be used to add an item to a |List|.
			This cannot be used to set a byte in a String.  You
			can do that like this: >
				:let var = var[0:2] . 'X' . var[4:]
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このコマンドはリスト |@ref{List}| に要素を追加するためには使えない。文字列の i バイト目をセットするためにも使えない。それには次のようにする:
@example
:let var = var[0:2] . 'X' . var[4:]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*E711* *E719*
:let {var-name}[{idx1}:{idx2}] = {expr1}		*E708* *E709* *E710*
			Set a sequence of items in a |List| to the result of
			the expression {expr1}, which must be a list with the
			correct number of items.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E708}
@anchor{E709}
@anchor{E710}
@anchor{E711}
@anchor{E719}
@erindex E708
@erindex E709
@erindex E710
@erindex E711
@erindex E719
@item :let @{var-name@}[@{idx1@}:@{idx2@}] = @{expr1@}
リスト |@ref{List}| の一部を式 @{expr@} の値で置き換える。@{expr@} の値は正しい個数の要素を持つリストでなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			{idx1} can be omitted, zero is used instead.
			{idx2} can be omitted, meaning the end of the list.
			When the selected range of items is partly past the
			end of the list, items will be added.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{idx1@} を省略すると 0 となる。@{idx2@} を省略するとリストの末尾となる。指定された範囲の一部がリストの末尾を越える場合、要素が追加される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*:let+=* *:let-=* *:let.=* *E734*
:let {var} += {expr1}	Like ":let {var} = {var} + {expr1}".
:let {var} -= {expr1}	Like ":let {var} = {var} - {expr1}".
:let {var} .= {expr1}	Like ":let {var} = {var} . {expr1}".
			These fail if {var} was not set yet and when the type
			of {var} and {expr1} don't fit the operator.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:let+=}
@anchor{:let-=}
@anchor{:let.=}
@anchor{E734}
@pindex :let+=
@pindex :let-=
@pindex :let.=
@erindex E734
@item :let @{var@} += @{expr1@} ":let @{var@} = @{var@} + @{expr1@}" と同様
@itemx :let @{var@} -= @{expr1@} ":let @{var@} = @{var@} - @{expr1@}" と同様
@itemx :let @{var@} .= @{expr1@} ":let @{var@} = @{var@} . @{expr1@}" と同様
@{var@} がセットされていないときや、@{var@} と @{expr1@} の型が演算子に合わないときは失敗する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
:let ${env-name} = {expr1}			*:let-environment* *:let-$*
			Set environment variable {env-name} to the result of
			the expression {expr1}.  The type is always String.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:let-environment}
@anchor{:let-$}
@cindex :let-environment
@pindex :let-$
@item :let $@{env-name@} = @{expr1@}
環境変数 @{env-name@} に式 @{expr1@} の結果をセットする。型は常に文字列。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
:let ${env-name} .= {expr1}
			Append {expr1} to the environment variable {env-name}.
			If the environment variable didn't exist yet this
			works like "=".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :let $@{env-name@} .= @{expr1@}
環境変数 @{env-name@} に @{expr1@} を付け加える。その環境変数が存在しないときは "=" と同様に働く。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:let @{reg-name} = {expr1}			*:let-register* *:let-@*
			Write the result of the expression {expr1} in register
			{reg-name}.  {reg-name} must be a single letter, and
			must be the name of a writable register (see
			|registers|).  "@@" can be used for the unnamed
			register, "@/" for the search pattern.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:let-register}
@anchor{:let-@@}
@cindex :let-register
@pindex :let-@@
@item :let @@@{reg-name@} = @{expr1@}
式 @{expr1@} の結果をレジスタ @{reg-name@} に書きこむ。@{reg-name@} は単一の文字でかつ、書きこむことのできるレジスタでなければならない (|@ref{registers}| を参照)。"@@@@" は名前無しレジスタとして使用でき、"@@/" はサーチパターンとして使用できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			If the result of {expr1} ends in a <CR> or <NL>, the
			register will be linewise, otherwise it will be set to
			characterwise.
			This can be used to clear the last search pattern: >
				:let @/ = ""
<			This is different from searching for an empty string,
			that would match everywhere.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@{expr1@} の結果が <CR> か <NL> で終了していた場合、レジスタは行単位で設定され、そうでなければ文字単位で設定される。次のコマンドにより最後に検索したパターンをクリアすることができる:
@example
:let @@/ = ""
@end example
これは空文字列を検索するのとは異なる。空文字列を検索すると、いたるところでマッチする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:let @{reg-name} .= {expr1}
			Append {expr1} to register {reg-name}.  If the
			register was empty it's like setting it to {expr1}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :let @@@{reg-name@} .= @{expr1@}
レジスタ @{reg-name@} に @{expr1@} を付け加える。このレジスタが空のときは、そこに @{expr1@} をセットする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:let &{option-name} = {expr1}			*:let-option* *:let-&*
			Set option {option-name} to the result of the
			expression {expr1}.  A String or Number value is
			always converted to the type of the option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:let-option}
@anchor{:let-&}
@cindex :let-option
@pindex :let-&
@item :let &@{option-name@} = @{expr1@}
オプション @{option-name@} に式 @{expr@} の値をセットする。文字列や数値の値はそのオプションの型に変換される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			For an option local to a window or buffer the effect
			is just like using the |:set| command: both the local
			value and the global value are changed.
			Example: >
				:let &path = &path . ',/usr/local/include'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ウィンドウやバッファについてローカルなオプションに対しては、その効果は |@ref{:set}| コマンドを使ったときと同様で、ローカルな値とグローバルな値の両方が変更される。例:
@example
:let &path = &path . ',/usr/local/include'
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			This also works for terminal codes in the form t_xx.
			But only for alphanumerical names.  Example: >
				:let &t_k1 = "\<Esc>[234;"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは、t_xx 形式の端末コードにも使える。ただし、英数字の名前に限る。例:
@example
:let &t_k1 = "\<Esc>[234;"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			When the code does not exist yet it will be created as
			a terminal key code, there is no error.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コードが存在していなかったときは端末キーコードとして作成され、エラーは発生しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:let &{option-name} .= {expr1}
			For a string option: Append {expr1} to the value.
			Does not insert a comma like |:set+=|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :let &@{option-name@} .= @{expr1@}
文字列のオプションの場合: その値に @{expr@} を付け加える。|@ref{:set+=}| とは違い、コンマを挿入しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:let &{option-name} += {expr1}
:let &{option-name} -= {expr1}
			For a number or boolean option: Add or subtract
			{expr1}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :let &@{option-name@} += @{expr1@}
@itemx :let &@{option-name@} -= @{expr1@}
数値または切替のオプションの場合: @{expr1@} を足す・引く。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:let &l:{option-name} = {expr1}
:let &l:{option-name} .= {expr1}
:let &l:{option-name} += {expr1}
:let &l:{option-name} -= {expr1}
			Like above, but only set the local value of an option
			(if there is one).  Works like |:setlocal|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :let &l:@{option-name@} = @{expr1@}
@itemx :let &l:@{option-name@} .= @{expr1@}
@itemx :let &l:@{option-name@} += @{expr1@}
@itemx :let &l:@{option-name@} -= @{expr1@}
上と同様だが、オプションのローカルな値だけをセットする (ローカルな値があるならば)。|@ref{:setlocal}| と同様に働く。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:let &g:{option-name} = {expr1}
:let &g:{option-name} .= {expr1}
:let &g:{option-name} += {expr1}
:let &g:{option-name} -= {expr1}
			Like above, but only set the global value of an option
			(if there is one).  Works like |:setglobal|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :let &g:@{option-name@} = @{expr1@}
@itemx :let &g:@{option-name@} .= @{expr1@}
@itemx :let &g:@{option-name@} += @{expr1@}
@itemx :let &g:@{option-name@} -= @{expr1@}
上と同様だが、オプションのグローバルな値だけをセットする (グローバルな値があるならば)。|@ref{:setglobal}| と同様に働く。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:let [{name1}, {name2}, ...] = {expr1}		*:let-unpack* *E687* *E688*
			{expr1} must evaluate to a |List|.  The first item in
			the list is assigned to {name1}, the second item to
			{name2}, etc.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:let-unpack}
@anchor{E687}
@anchor{E688}
@cindex :let-unpack
@erindex E687
@erindex E688
@item :let [@{name1@}, @{name2@}, ...] = @{expr1@}
@{expr1@} の値はリスト |@ref{List}| でなければならない。そのリストの最初の要素が @{name1@} に代入され、2 番目の要素が @{name2@} に代入される。以下同様。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			The number of names must match the number of items in
			the |List|.
			Each name can be one of the items of the ":let"
			command as mentioned above.
			Example: >
				:let [s, item] = GetItem(s)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
name の個数がリスト |@ref{List}| の要素の個数に一致しなければならない。

前述のように各 name は "@command{:let}" コマンドの要素の1つになることができる。例:
@example
:let [s, item] = GetItem(s)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			Detail: {expr1} is evaluated first, then the
			assignments are done in sequence.  This matters if
			{name2} depends on {name1}.  Example: >
				:let x = [0, 1]
				:let i = 0
				:let [i, x[i]] = [1, 2]
				:echo x
<			The result is [0, 2].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
詳細: 最初に @{expr1@} が評価され、それから順番に代入が行われる。@{name2@} が @{name1@} に依存するかどうかは問題になる。例:
@example
:let x = [0, 1]
:let i = 0
:let [i, x[i]] = [1, 2]
:echo x
@end example
この結果は[0, 2]となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:let [{name1}, {name2}, ...] .= {expr1}
:let [{name1}, {name2}, ...] += {expr1}
:let [{name1}, {name2}, ...] -= {expr1}
			Like above, but append/add/subtract the value for each
			|List| item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :let [@{name1@}, @{name2@}, ...] .= @{expr1@}
@itemx :let [@{name1@}, @{name2@}, ...] += @{expr1@}
@itemx :let [@{name1@}, @{name2@}, ...] -= @{expr1@}
上と同様だが、リスト |@ref{List}| の各要素に対し連結・足し算・引き算を行う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:let [{name}, ..., ; {lastname}] = {expr1}
			Like |:let-unpack| above, but the |List| may have more
			items than there are names.  A list of the remaining
			items is assigned to {lastname}.  If there are no
			remaining items {lastname} is set to an empty list.
			Example: >
				:let [a, b; rest] = ["aval", "bval", 3, 4]
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :let [@{name@}, ..., ; @{lastname@}] = @{expr1@}
|@ref{:let-unpack}| と同様だが、リスト |@ref{List}| の要素数が names の数より多くてもよい。余った要素のリストが @{lastname@} に代入される。要素の余りがないとき @{lastname@} は空リストになる。例:
@example
:let [a, b; rest] = ["aval", "bval", 3, 4]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
:let [{name}, ..., ; {lastname}] .= {expr1}
:let [{name}, ..., ; {lastname}] += {expr1}
:let [{name}, ..., ; {lastname}] -= {expr1}
			Like above, but append/add/subtract the value for each
			|List| item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :let [@{name@}, ..., ; @{lastname@}] .= @{expr1@}
@itemx :let [@{name@}, ..., ; @{lastname@}] += @{expr1@}
@itemx :let [@{name@}, ..., ; @{lastname@}] -= @{expr1@}
上と同様だが、リスト |@ref{List}| の各要素に対して連結・足し算・引き算を行う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
								*E121*
:let {var-name}	..	List the value of variable {var-name}.  Multiple
			variable names may be given.  Special names recognized
			here:				*E738*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E121}
@erindex E121
@item :let @{var-name@}	..
変数 @{var-name@} の値を一覧表示する。変数の名前を複数指定することができる。以下の特別な名前が認識される:
@anchor{E738}
@erindex E738
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			  g:	global variables
			  b:	local buffer variables
			  w:	local window variables
			  t:	local tab page variables
			  s:	script-local variables
			  l:	local function variables
			  v:	Vim variables.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item g: @tab グローバル変数
@item b: @tab バッファローカル変数
@item w: @tab ウィンドウローカル変数
@item t: @tab タブページローカル変数
@item s: @tab スクリプトローカル変数
@item l: @tab 関数ローカル変数
@item v: @tab Vim の変数
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:let			List the values of all variables.  The type of the
			variable is indicated before the value:
			    <nothing>	String
				#	Number
				*	Funcref
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :let
全変数の値を一覧表示する。値の前に変数の型が示される:
@multitable @columnfractions .5 .5
@item <nothing> @tab 文字列
@item # @tab 数値
@item * @tab Funcref
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
:unl[et][!] {name} ...				*:unlet* *:unl* *E108* *E795*
			Remove the internal variable {name}.  Several variable
			names can be given, they are all removed.  The name
			may also be a |List| or |Dictionary| item.
			With [!] no error message is given for non-existing
			variables.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:unlet}
@anchor{:unl}
@anchor{E108}
@anchor{E795}
@pindex :unlet
@pindex :unl
@erindex E108
@erindex E795
@item :unl[et][!] @{name@} ...
内部変数 @{name@} を削除する。複数の変数名を指定すると、それらが全て削除される。名前はリスト |@ref{List}| や辞書 |@ref{Dictionary}| の要素でもよい。

[!] をつけると存在しない変数に対するエラーメッセージを表示しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			One or more items from a |List| can be removed: >
				:unlet list[3]	  " remove fourth item
				:unlet list[3:]   " remove fourth item to last
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リスト |@ref{List}| から 1 個以上の要素を削除することができる:
@example
:unlet list[3]	  " 4番目の要素を削除
:unlet list[3:]   " 4番目から最後までの要素を削除
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			One item from a |Dictionary| can be removed at a time: >
				:unlet dict['two']
				:unlet dict.two
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
辞書 |@ref{Dictionary}| からは一度に 1 個の要素を削除することができる:
@example
:unlet dict['two']
:unlet dict.two
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			This is especially useful to clean up used global
			variables and script-local variables (these are not
			deleted when the script ends).  Function-local
			variables are automatically deleted when the function
			ends.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
グローバル変数とスクリプトローカル変数をクリーンアップするために特に便利である (これらはスクリプト終了時に検出されない)。関数ローカルな関数は、その関数から抜けるときに自動的に削除される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:unl[et] ${env-name} ...			*:unlet-environment* *:unlet-$*
			Remove environment variable {env-name}.
			Can mix {name} and ${env-name} in one :unlet command.
			No error message is given for a non-existing
			variable, also without !.
			If the system does not support deleting an environment
			variable, it is made emtpy.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:unlet-environment}
@anchor{:unlet-$}
@pindex :unlet-environment
@pindex :unlet-$
@item :unl[et] $@{env-name@} ...
環境変数 @{env-name@} を削除する。1 つの @command{:unlet} コマンドで @{name@} と $@{env-name@} を合わせることができる。変数が存在しない場合は ! がなくてもエラーメッセージを生じない。システムがもしも環境変数の削除をサポートしていないのなら、空にします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:lockv[ar][!] [depth] {name} ...			*:lockvar* *:lockv*
			Lock the internal variable {name}.  Locking means that
			it can no longer be changed (until it is unlocked).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:lockvar}
@anchor{:lockv}
@pindex :lockvar
@pindex :lockv
@item :lockv[ar][!] [depth] @{name@} ...
内部変数 @{name@} をロックする。ロックすると、それ以降変更ができなくなる(アンロックするまで)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			A locked variable can be deleted: >
				:lockvar v
				:let v = 'asdf'		" fails!
				:unlet v
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ロックされた変数を削除することはできる:
@example
:lockvar v
:let v = 'asdf'		" 失敗!
:unlet v
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<							*E741* *E940*
			If you try to change a locked variable you get an
			error message: "E741: Value is locked: {name}".
			If you try to lock or unlock a built-in variable you
			get an error message: "E940: Cannot lock or unlock
			variable {name}".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E741}
@anchor{E940}
@erindex E741
@erindex E940
ロックされた変数を変更しようとするとエラーメッセージ
@display
"E741: Value is locked: @{name@}"
@end display
が表示される。

もしも組み込み変数をロック・アンロックしようとすると、エラーメッセージ
@display
"E940: Cannot lock or unlock variable @{name@}"
@end display
が表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			[depth] is relevant when locking a |List| or
			|Dictionary|.  It specifies how deep the locking goes:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[depth] はリスト |@ref{List}| や辞書 |@ref{Dictionary}| をロックするときに意味がある。どれだけ深くロックするかを指定する:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
				1	Lock the |List| or |Dictionary| itself,
					cannot add or remove items, but can
					still change their values.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item リスト |@ref{List}| や辞書 |@ref{Dictionary}| それ自身をロックする。要素を追加したり削除はできないが、要素の値を変えることはできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
				2	Also lock the values, cannot change
					the items.  If an item is a |List| or
					|Dictionary|, cannot add or remove
					items, but can still change the
					values.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 要素の値もロックする。その要素がリスト |@ref{List}| や辞書 |@ref{Dictionary}| である場合、その中の要素の追加や削除はできないが、値の変更はできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
				3	Like 2 but for the |List| /
					|Dictionary| in the |List| /
					|Dictionary|, one level deeper.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 2 と同様だが、リスト |@ref{List}|・辞書内 |@ref{Dictionary}| のリスト |@ref{List}| ・辞書 |@ref{Dictionary}| に対してもあてはまる。1 レベル深い。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			The default [depth] is 2, thus when {name} is a |List|
			or |Dictionary| the values cannot be changed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[depth] の既定値は 2 であり、@{name@} がリスト |@ref{List}| または辞書 |@ref{Dictionary}| である場合、その値は変更できない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
								*E743*
			For unlimited depth use [!] and omit [depth].
			However, there is a maximum depth of 100 to catch
			loops.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E743}
@erindex E743
深さを無限にするには [!] を使い、[depth] を省略する。しかしループを捕捉するために深さの最大値は 100 に設定されている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			Note that when two variables refer to the same |List|
			and you lock one of them, the |List| will also be
			locked when used through the other variable.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
2 つの変数が同じリスト |@ref{List}| を参照している場合、片方の変数をロックすると、もう一方の変数を介してアクセスした場合もロックされている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Example: >
				:let l = [0, 1, 2, 3]
				:let cl = l
				:lockvar l
				:let cl[1] = 99		" won't work!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
:let l = [0, 1, 2, 3]
:let cl = l
:lockvar l
:let cl[1] = 99		" 代入できない!
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			You may want to make a copy of a list to avoid this.
			See |deepcopy()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これを回避するにはリストのコピーを作るとよい。|@ref{deepcopy()}| を参照。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
:unlo[ckvar][!] [depth] {name} ...			*:unlockvar* *:unlo*
			Unlock the internal variable {name}.  Does the
			opposite of |:lockvar|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:unlockvar}
@anchor{:unlo}
@pindex :unlockvar
@pindex :unlo
@item :unlo[ckvar][!] [depth] @{name@} ...
内部変数 @{name@} をアンロックする。|@ref{:lockvar}| の逆を行う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
:if {expr1}			*:if* *:endif* *:en* *E171* *E579* *E580*
:en[dif]		Execute the commands until the next matching ":else"
			or ":endif" if {expr1} evaluates to non-zero.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:if}
@anchor{:endif}
@anchor{:en}
@anchor{E171}
@anchor{E579}
@anchor{E580}
@pindex :if
@pindex :endif
@pindex :en
@erindex E171
@erindex E579
@erindex E580
@item :if @{expr1@}
@itemx :en[dif]
@{expr1@} が非ゼロと評価された場合に、対応する "@command{:else}" か "@command{:endif}" までの命令を実行する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			From Vim version 4.5 until 5.0, every Ex command in
			between the ":if" and ":endif" is ignored.  These two
			commands were just to allow for future expansions in a
			backward compatible way.  Nesting was allowed.  Note
			that any ":else" or ":elseif" was ignored, the "else"
			part was not executed either.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バージョン 4.5 から 5.0 まで間の Vim は、"@command{:if}" と "@command{:endif}" の間の全ての Ex コマンドは無視する。この 2 つのコマンドは将来の拡張性を、下位互換と同時に提供するためのものである。ネスティング (入れ子) が可能である。
@quotation
@strong{Note:} @*
"@command{:else}" や "@command{:elseif}" は無視され、"else" 部分は一切実行されないことに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			You can use this to remain compatible with older
			versions: >
				:if version >= 500
				:  version-5-specific-commands
				:endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
あなたはこれを、旧バージョンとの互換性を保ったまま使用することができる:
@example
:if version >= 500
:  version-5-specific-commands
:endif
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			The commands still need to be parsed to find the
			"endif".  Sometimes an older Vim has a problem with a
			new command.  For example, ":silent" is recognized as
			a ":substitute" command.  In that case ":execute" can
			avoid problems: >
				:if version >= 600
				:  execute "silent 1,$delete"
				:endif
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
しかしそれでも "endif" を見つけるために後続のコマンドをパースする必要がある。古い Vim で新しいコマンドを使うと問題が起こることがある。例えば "@command{:silent}" が "@command{:substitute}" コマンドと認識されるなど。その場合には、"@command{:execute}" を使うと問題を避けることができる:
@example
:if version >= 600
:  execute "silent 1,$delete"
:endif
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			NOTE: The ":append" and ":insert" commands don't work
			properly in between ":if" and ":endif".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"@command{:append}" と "@command{:insert}" コマンドは ":if" と ":endif" の間では正しく動かない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:else* *:el* *E581* *E583*
:el[se]			Execute the commands until the next matching ":else"
			or ":endif" if they previously were not being
			executed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:else}
@anchor{:el}
@anchor{E581}
@anchor{E583}
@pindex :else
@pindex :el
@erindex E581
@erindex E583
@item :el[se]
対応する ":if" ブロックが実行されなかった場合には、これに対応する ":else" か ":endif" までのコマンドが実行される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*:elseif* *:elsei* *E582* *E584*
:elsei[f] {expr1}	Short for ":else" ":if", with the addition that there
			is no extra ":endif".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:elseif}
@anchor{:elsei}
@anchor{E582}
@anchor{E584}
@pindex :elseif
@pindex :elsei
@erindex E582
@erindex E584
@item :elsei[f] @{expr1@}
":else" ":if" の省略形。":endif" を付け加える (入れ子にする) 手間を省くことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:wh[ile] {expr1}			*:while* *:endwhile* *:wh* *:endw*
						*E170* *E585* *E588* *E733*
:endw[hile]		Repeat the commands between ":while" and ":endwhile",
			as long as {expr1} evaluates to non-zero.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:while}
@anchor{:endwhile}
@anchor{:wh}
@anchor{:endw}
@anchor{E170}
@anchor{E585}
@anchor{E588}
@anchor{E733}
@pindex :while
@pindex :endwhile
@pindex :wh
@pindex :endw
@erindex E170
@erindex E585
@erindex E588
@erindex E733
@item :wh[ile] @{expr1@}
@itemx :endw[hile]
@{expr1@} が非ゼロとして評価される間、":while" と ":endwhile" の間のコマンドを繰り返し実行する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			When an error is detected from a command inside the
			loop, execution continues after the "endwhile".
			Example: >
				:let lnum = 1
				:while lnum <= line("$")
				   :call FixLine(lnum)
				   :let lnum = lnum + 1
				:endwhile
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ループの内側でエラーが生じた場合、endwhile の直後から実行が再開される。

例:
@example
:let lnum = 1
:while lnum <= line("$")
   :call FixLine(lnum)
   :let lnum = lnum + 1
:endwhile
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			NOTE: The ":append" and ":insert" commands don't work
			properly inside a ":while" and ":for" loop.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
":append" や ":insert" コマンドは ":while" ループの内側では正しく動かない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:for {var} in {list}					*:for* *E690* *E732*
:endfo[r]						*:endfo* *:endfor*
			Repeat the commands between ":for" and ":endfor" for
			each item in {list}.  Variable {var} is set to the
			value of each item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:for}
@anchor{E690}
@anchor{E732}
@anchor{:endfo}
@anchor{:endfor}
@pindex :for
@erindex E690
@erindex E732
@pindex :endfo
@pindex :endfor
@item :for @{var@} in @{list@}
@itemx :endfo[r]
@{list@} の各要素に対し、":for" と ":endfor" の間のコマンドを繰り返す。変数 @{var@} に各要素の値がセットされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			When an error is detected for a command inside the
			loop, execution continues after the "endfor".
			Changing {list} inside the loop affects what items are
			used.  Make a copy if this is unwanted: >
				:for item in copy(mylist)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ループの内側のコマンドでエラーが検出されたときは "endfor" の後から実行が継続される。

ループの内側で @{list@} を変更するとどの要素が使われるかに影響を与える。それを望まない場合はコピーを作ること:
@example
:for item in copy(mylist)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			When not making a copy, Vim stores a reference to the
			next item in the list, before executing the commands
			with the current item.  Thus the current item can be
			removed without effect.  Removing any later item means
			it will not be found.  Thus the following example
			works (an inefficient way to make a list empty): >
				for item in mylist
				   call remove(mylist, 0)
				endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コピーを作らないと、Vim は現在の要素に対してコマンドを実行する前に、リストの次の要素への参照を保存する。そのため副作用なしに現在の要素を削除することができる。それ以降の要素を変更すると、それが見つからなくなる。つまり以下の例は動作する (リストを空にする非効率な方法):
@example
for item in mylist
   call remove(mylist, 0)
endfor
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			Note that reordering the list (e.g., with sort() or
			reverse()) may have unexpected effects.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
リストを並べ替える (例えば sort() や reverse() で) と予期しない結果になることがある。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:for [{var1}, {var2}, ...] in {listlist}
:endfo[r]
			Like ":for" above, but each item in {listlist} must be
			a list, of which each item is assigned to {var1},
			{var2}, etc.  Example: >
				:for [lnum, col] in [[1, 3], [2, 5], [3, 8]]
				   :echo getline(lnum)[col]
				:endfor
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :for [@{var1@}, @{var2@}, ...] in @{listlist@}
@itemx :endfo[r]
上の ":for" と同様だが、@{listlist@} の各要素がリストでなければならない点が異なる。そのリストの各要素が @{var1@}, @{var2@} などに代入される。例:
@example
:for [lnum, col] in [[1, 3], [2, 5], [3, 8]]
   :echo getline(lnum)[col]
:endfor
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*:continue* *:con* *E586*
:con[tinue]		When used inside a ":while" or ":for" loop, jumps back
			to the start of the loop.
			If it is used after a |:try| inside the loop but
			before the matching |:finally| (if present), the
			commands following the ":finally" up to the matching
			|:endtry| are executed first.  This process applies to
			all nested ":try"s inside the loop.  The outermost
			":endtry" then jumps back to the start of the loop.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:continue}
@anchor{:con}
@anchor{E586}
@pindex :continue
@pindex :con
@erindex E586
@item :con[tinue]
":while" または ":for" ループの内側で使われたときは、そのループの開始位置まで戻る。

ループの内側の |@ref{:try}| と |@ref{:finally}| の間で使われた場合、|@ref{:finally}| から |@ref{:endtry}| までの間のコマンドがまず実行される。

ループの内側で ":try" がネストしている場合、全ての ":try" に対してこのプロセスが適用される。最も外側の ":endtry" の後ループの開始位置まで戻る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:break* *:brea* *E587*
:brea[k]		When used inside a ":while" or ":for" loop, skips to
			the command after the matching ":endwhile" or
			":endfor".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:break}
@anchor{:brea}
@anchor{E587}
@pindex :break
@pindex :brea
@erindex E587
@item :brea[k]
":while" または ":for" ループの内側で使われたときは、対応する ":endwhile" または ":endfor" の後のコマンドまでスキップする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			If it is used after a |:try| inside the loop but
			before the matching |:finally| (if present), the
			commands following the ":finally" up to the matching
			|:endtry| are executed first.  This process applies to
			all nested ":try"s inside the loop.  The outermost
			":endtry" then jumps to the command after the loop.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

ループの内側の |@ref{:try}| と |@ref{:finally}| の間で使われた場合、":finally" から |@ref{:endtry}| までの間のコマンドがまず実行される。

ループの内側で ":try" がネストしている場合、全ての ":try" に対してこのプロセスが適用される。最も外側の ":endtry" の後ループの後までジャンプする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:try				*:try* *:endt* *:endtry* *E600* *E601* *E602*
:endt[ry]		Change the error handling for the commands between
			":try" and ":endtry" including everything being
			executed across ":source" commands, function calls,
			or autocommand invocations.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:try}
@anchor{:endt}
@anchor{:endtry}
@anchor{E600}
@anchor{E601}
@anchor{E602}
@pindex :try
@pindex :endt
@pindex :endtry
@erindex E600
@erindex E601
@erindex E602
@item :try
@itemx :endt[ry]
":try" と ":endtry" の間のコマンド (":source" コマンド、関数呼び出し、オートコマンド実行を含めた全てのコマンド実行) のエラー制御を変更する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			When an error or interrupt is detected and there is
			a |:finally| command following, execution continues
			after the ":finally".  Otherwise, or when the
			":endtry" is reached thereafter, the next
			(dynamically) surrounding ":try" is checked for
			a corresponding ":finally" etc.  Then the script
			processing is terminated.  (Whether a function
			definition has an "abort" argument does not matter.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
エラーや割り込みが検出された場合、後に |@ref{:finally}| コマンドがあるならば、":finally" の後から実行が継続される。そうでなければ、または ":endtry" に達した後は次の動的に囲んでいる ":try" に対応する ":finally" などが探される。その後スクリプトは実行を停止する。(関数定義に引数 "abort" がついているかどうかは関係ない)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Example: >
		:try | edit too much | finally | echo "cleanup" | endtry
		:echo "impossible"	" not reached, script terminated above
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
:try | edit too much | finally | echo "cleanup" | endtry
:echo "impossible"      " 実行されない。上のコマンドによりスクリプトは停止する。
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Moreover, an error or interrupt (dynamically) inside
			":try" and ":endtry" is converted to an exception.  It
			can be caught as if it were thrown by a |:throw|
			command (see |:catch|).  In this case, the script
			processing is not terminated.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
さらに、(動的に) ":try" と ":endtry" の内側にあるエラーや割り込みは例外に変換される。そしてそれは |@ref{:throw}| コマンドによって投げたときと同様に捕捉できる (|@ref{:catch}| を参照)。この場合はスクリプトの実行は停止しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			The value "Vim:Interrupt" is used for an interrupt
			exception.  An error in a Vim command is converted
			to a value of the form "Vim({command}):{errmsg}",
			other errors are converted to a value of the form
			"Vim:{errmsg}".  {command} is the full command name,
			and {errmsg} is the message that is displayed if the
			error exception is not caught, always beginning with
			the error number.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
割り込み例外には "Vim:Interrupt" という値が使われる。Vim コマンドにおけるエラーは "Vim(@{command@}):@{errmsg@}"という形式の値に変換される。その他のエラーは "Vim:@{errmsg@}" という形式のエラーに変換される。ここで @{command@} はコマンドの完全な名前であり、@{errmsg@} はその例外が捕捉されなかった場合に表示されるメッセージで、常にエラー番号で始まる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Examples: >
		:try | sleep 100 | catch /^Vim:Interrupt$/ | endtry
		:try | edit | catch /^Vim(edit):E\d\+/ | echo "error" | endtry
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
:try | sleep 100 | catch /^Vim:Interrupt$/ | endtry
:try | edit | catch /^Vim(edit):E\d\+/ | echo "error" | endtry
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*:cat* *:catch* *E603* *E604* *E605*
:cat[ch] /{pattern}/	The following commands until the next |:catch|,
			|:finally|, or |:endtry| that belongs to the same
			|:try| as the ":catch" are executed when an exception
			matching {pattern} is being thrown and has not yet
			been caught by a previous ":catch".  Otherwise, these
			commands are skipped.
			When {pattern} is omitted all errors are caught.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:cat}
@anchor{:catch}
@anchor{E603}
@anchor{E604}
@anchor{E605}
@pindex :cat
@pindex :catch
@erindex E603
@erindex E604
@erindex E605
@item :cat[ch] /@{pattern@}/
@{pattern@} にマッチする例外が発生し、より前の |@ref{:catch}| で捕捉されなかった場合、このコマンドから次の |@ref{:catch}|, |@ref{:finally}|, |@ref{:endtry}| までのコマンドが実行される。そのような例外が発生しなかった場合、そのコマンドはスキップされる。

@{pattern@} が省略された場合は全てのエラーが捕捉される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			Examples: >
		:catch /^Vim:Interrupt$/	" catch interrupts (CTRL-C)
		:catch /^Vim\%((\a\+)\)\=:E/	" catch all Vim errors
		:catch /^Vim\%((\a\+)\)\=:/	" catch errors and interrupts
		:catch /^Vim(write):/		" catch all errors in :write
		:catch /^Vim\%((\a\+)\)\=:E123/	" catch error E123
		:catch /my-exception/		" catch user exception
		:catch /.*/			" catch everything
		:catch				" same as /.*/
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:catch /^Vim:Interrupt$/        " 割り込み (CTRL-C) を捕捉
:catch /^Vim\%((\a\+)\)\=:E/    " 全 Vim エラーを捕捉
:catch /^Vim\%((\a\+)\)\=:/     " 例外と割り込みを捕捉
:catch /^Vim(write):/           " :write における全エラーを捕捉
:catch /^Vim\%((\a\+)\)\=:E123/ " エラー E123 を捕捉
:catch /my-exception/           " ユーザー定義例外を捕捉
:catch /.*/                     " 全てを捕捉
:catch                          " /.*/ と同じ
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Another character can be used instead of / around the
			{pattern}, so long as it does not have a special
			meaning (e.g., '|' or '"') and doesn't occur inside
			{pattern}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{pattern@} を囲むのに/以外の文字を使うことができる。ただしその文字は特別な意味 (例: '|' や '"' など)を持っていてはならず、@{pattern@} の内側に現れてはならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Information about the exception is available in
			|v:exception|.  Also see |throw-variables|.
			NOTE: It is not reliable to ":catch" the TEXT of
			an error message because it may vary in different
			locales.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例外の情報は |@ref{v:exception}| で得られる。|@ref{throw-variables}| も参照。
@quotation
@strong{Note:} @*
エラーメッセージの本文によって ":catch" することは確実ではない。メッセージはロケールによって異なるからである。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*:fina* *:finally* *E606* *E607*
:fina[lly]		The following commands until the matching |:endtry|
			are executed whenever the part between the matching
			|:try| and the ":finally" is left:  either by falling
			through to the ":finally" or by a |:continue|,
			|:break|, |:finish|, or |:return|, or by an error or
			interrupt or exception (see |:throw|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:fina}
@anchor{:finally}
@anchor{E606}
@anchor{E607}
@pindex :fina
@pindex :finally
@erindex E606
@erindex E607
@item :fina[lly]
|@ref{:try}| と ":finally" の間を抜ける前に必ず、このコマンドから対応する |@ref{:endtry}| の間のコマンドが実行される。つまり正常に進んだ場合、|@ref{:continue}|, |@ref{:break}|, |@ref{:finish}|, |@ref{:return}| を使った場合、エラー・割り込み・例外が発生した場合 (|@ref{:throw}| を参照) のいずれの場合でも。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:th* *:throw* *E608*
:th[row] {expr1}	The {expr1} is evaluated and thrown as an exception.
			If the ":throw" is used after a |:try| but before the
			first corresponding |:catch|, commands are skipped
			until the first ":catch" matching {expr1} is reached.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:th}
@anchor{:throw}
@anchor{E608}
@pindex :th
@pindex :throw
@erindex E608
@item :th[row] @{expr1@}
@{expr1@} を評価し、例外として投げる。|@ref{:try}| と |@ref{:catch}| の間で ":throw" が使われた場合、@{expr1@} にマッチする最初の |@ref{:catch}| までのコマンドはスキップされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			If there is no such ":catch" or if the ":throw" is
			used after a ":catch" but before the |:finally|, the
			commands following the ":finally" (if present) up to
			the matching |:endtry| are executed.  If the ":throw"
			is after the ":finally", commands up to the ":endtry"
			are skipped.  At the ":endtry", this process applies
			again for the next dynamically surrounding ":try"
			(which may be found in a calling function or sourcing
			script), until a matching ":catch" has been found.
			If the exception is not caught, the command processing
			is terminated.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
そのような ":catch" がない場合、または ":catch" と |@ref{:finally}| の間で ":throw" が使われた場合、":finally" から |@ref{:endtry}| までのコマンドが実行される。":throw" が ":finally" の後で実行された場合、":endtry" までのコマンドはスキップされる。

":endtry" において、動的に囲んでいる次の ":try" (これは関数呼び出しやスクリプト source も含めて探される) から対応する ":catch" までに対しこのプロセスが再び適用される。例外が捕捉されない場合、コマンドの処理は終了する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Example: >
		:try | throw "oops" | catch /^oo/ | echo "caught" | endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
:try | throw "oops" | catch /^oo/ | echo "caught" | endtry
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			Note that "catch" may need to be on a separate line
			for when an error causes the parsing to skip the whole
			line and not see the "|" that separates the commands.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
エラーによって行のパースがスキップされ、"|" によるコマンド区切りが解釈されないような場合は "catch" は行を分けて書く必要がある。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:ec* *:echo*
:ec[ho] {expr1} ..	Echoes each {expr1}, with a space in between.  The
			first {expr1} starts on a new line.
			Also see |:comment|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:ec}
@anchor{:echo}
@pindex :ec
@pindex :echo
@item :ec[ho] @{expr1@} ..
各 @{expr1@} をスペースで区切って表示する。最初の @{expr1@} の表示は、常に新しい行から始まる。|@ref{:comment}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Use "\n" to start a new line.  Use "\r" to move the
			cursor to the first column.
			Uses the highlighting set by the |:echohl| command.
			Cannot be followed by a comment.
			Example: >
		:echo "the value of 'shell' is" &shell
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

改行が必要な場合 "\n" を使用する。カーソルを第 1 桁に持って行くには "\r" を使用する。色強調を行うにはコマンド |@ref{:echohl}| を使用する。コメント文を同じ行に続けることはできない。

例:
@example
:echo "the value of 'shell' is" &shell
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<							*:echo-redraw*
			A later redraw may make the message disappear again.
			And since Vim mostly postpones redrawing until it's
			finished with a sequence of commands this happens
			quite often.  To avoid that a command from before the
			":echo" causes a redraw afterwards (redraws are often
			postponed until you type something), force a redraw
			with the |:redraw| command.  Example: >
		:new | redraw | echo "there is a new window"
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:echo-redraw}
@cindex :echo-redraw
このコマンドの後、再描画を行うと表示したメッセージが消えてしまう。Vim は一連のコマンドが完了するまで再描画を後回しにするため、この現象は頻繁に発生する。例えば、":echo" より前に実行したコマンドが後で再描画を引き起こし、メッセージが消えてしまうということがある (再描画はしばしばユーザーが何か入力するまで後回しにされる)。この問題を避けるには、|@ref{:redraw}| を使って強制的に再描画すること。例:
@example
:new | redraw | echo "there is a new window"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:echon*
:echon {expr1} ..	Echoes each {expr1}, without anything added.  Also see
			|:comment|.
			Uses the highlighting set by the |:echohl| command.
			Cannot be followed by a comment.
			Example: >
				:echon "the value of 'shell' is " &shell
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:echon}
@pindex :echon
@item :echon @{expr1@} ..
改行を付けずに、@{expr1@} を表示する。|@ref{:comment}| も参照。色強調を行うにはコマンド |@ref{:echohl}| を使用する。コメント文を同じ行に続けることはできない。

例:
@example
:echon "the value of 'shell' is " &shell
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Note the difference between using ":echo", which is a
			Vim command, and ":!echo", which is an external shell
			command: >
		:!echo %		--> filename
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
Vim コマンドの ":echo" と、外部のシェルコマンドである ":!echo" との違いに注意:
@example
:!echo %                --> filename
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			The arguments of ":!" are expanded, see |:_%|. >
		:!echo "%"		--> filename or "filename"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
":!" の引数は展開される。|@ref{:_%}| を参照。
@example
:!echo "%"              --> filename or "filename"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			Like the previous example.  Whether you see the double
			quotes or not depends on your 'shell'. >
		:echo %			--> nothing
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
前の例のように働く。ダブルクォートが表示されるかどうかは、使用している '@option{shell}' に依存する。
@example
:echo %                 --> 何も表示されない
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			The '%' is an illegal character in an expression. >
		:echo "%"		--> %
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'%' は式として不当な文字である。
@example
:echo "%"               --> %
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			This just echoes the '%' character. >
		:echo expand("%")	--> filename
<			This calls the expand() function to expand the '%'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
単に文字 '%' を表示する。
@example
:echo expand("%")       --> filename
@end example
'%' を展開するために関数 expand() を呼び出している。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:echoh* *:echohl*
:echoh[l] {name}	Use the highlight group {name} for the following
			|:echo|, |:echon| and |:echomsg| commands.  Also used
			for the |input()| prompt.  Example: >
		:echohl WarningMsg | echo "Don't panic!" | echohl None
<			Don't forget to set the group back to "None",
			otherwise all following echo's will be highlighted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:echoh}
@anchor{:echohl}
@pindex :echoh
@pindex :echohl
@item :echoh[l] @{name@}
次の |@ref{:echo}|, |@ref{:echon}|, |@ref{:echomsg}| コマンドから、ハイライトグループ @{name@} を適用する。|@ref{input()}| のプロンプトに対しても適用される。例:
@example
:echohl WarningMsg | echo "Don't panic!" | echohl None
@end example
使用した後にはグループを "None" に戻すことを忘れないように。さもないとそれ以降の echo の表示全てがハイライトされてしまう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:echom* *:echomsg*
:echom[sg] {expr1} ..	Echo the expression(s) as a true message, saving the
			message in the |message-history|.
			Spaces are placed between the arguments as with the
			|:echo| command.  But unprintable characters are
			displayed, not interpreted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:echom}
@anchor{:echomsg}
@pindex :echom
@pindex :echomsg
@item :echom[sg] @{expr1@} ..
式を本当のメッセージとして表示し、そのメッセージをメッセージ履歴 |@ref{message-history}| に保存する。|@ref{:echo}| コマンド同様に、引数の間にスペースが挿入される。しかし印字不可能な文字は解釈されずに表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			The parsing works slightly different from |:echo|,
			more like |:execute|.  All the expressions are first
			evaluated and concatenated before echoing anything.
			The expressions must evaluate to a Number or String, a
			Dictionary or List causes an error.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:echo}| とはかなり異なり、むしろ |@ref{:execute}| に近い方法で解析がされる。なんらかを表示する前に、まず最初に全ての式が評価し、連結する。式を評価した値は数値か文字列でなければならない。辞書やリストはエラーとなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Uses the highlighting set by the |:echohl| command.
			Example: >
		:echomsg "It's a Zizzer Zazzer Zuzz, as you can plainly see."
<			See |:echo-redraw| to avoid the message disappearing
			when the screen is redrawn.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
強調を行うには |@ref{:echohl}| コマンドを使う。

例:
@example
:echomsg "It's a Zizzer Zazzer Zuzz, as you can plainly see."
@end example
画面を再描画したときメッセージが消去されてしまうのを避ける方法については |@ref{:echo-redraw}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:echoe* *:echoerr*
:echoe[rr] {expr1} ..	Echo the expression(s) as an error message, saving the
			message in the |message-history|.  When used in a
			script or function the line number will be added.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:echoe}
@anchor{:echoerr}
@pindex :echoe
@pindex :echoerr
@item :echoe[rr] @{expr1@} ..
式をエラーメッセージとして表示し、そのメッセージをメッセージ履歴 |@ref{message-history}| に保存する。スクリプトや関数の中で使用されたときは行番号が付け加えられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Spaces are placed between the arguments as with the
			:echo command.  When used inside a try conditional,
			the message is raised as an error exception instead
			(see |try-echoerr|).
			Example: >
		:echoerr "This script just failed!"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:echo}| コマンドと同様に引数の間にスペースが挿入される。try 条件文の中で使用されたときは、このメッセージがエラー例外として投げられる。(|@ref{try-echoerr}| を参照)

例:
@example
:echoerr "This script just failed!"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			If you just want a highlighted message use |:echohl|.
			And to get a beep: >
		:exe "normal \<Esc>"
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
単にメッセージを強調させたい場合には |@ref{:echohl}| を使うこと。ビープを鳴らしたいときには次のようにする:
@example
:exe "normal \<Esc>"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:exe* *:execute*
:exe[cute] {expr1} ..	Executes the string that results from the evaluation
			of {expr1} as an Ex command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:exe}
@anchor{:execute}
@pindex :exe
@pindex :execute
@item :exe[cute] @{expr1@} ..
@{expr1@} の評価結果の文字列を Ex コマンドとして実行する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Multiple arguments are concatenated, with a space in
			between.  To avoid the extra space use the "."
			operator to concatenate strings into one argument.
			{expr1} is used as the processed command, command line
			editing keys are not recognized.
			Cannot be followed by a comment.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
複数の引数は連結され、間にスペースが挿入される。余計なスペースを入れたくない場合は "." オペレータを使って文字列を連結すること。

@{expr1@} は処理されたコマンドとして扱われ、コマンドライン編集用のキーは認識されない。コメント文を同じ行に続けることはできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Examples: >
		:execute "buffer" nextbuf
		:execute "normal" count . "w"
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@example
:execute "buffer" nextbuf
:execute "normal" count . "w"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			":execute" can be used to append a command to commands
			that don't accept a '|'.  Example: >
		:execute '!ls' | echo "theend"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
":execute" は '|' を受けつけないコマンドに、次のコマンドを続けて実行させるのにも使用できる。例:
@example
:execute '!ls' | echo "theend"
@end example
@{訳注: 普通の使い方では ":!ls" の後には '|' を使って、Ex コマンドを続けることはできない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<			":execute" is also a nice way to avoid having to type
			control characters in a Vim script for a ":normal"
			command: >
		:execute "normal ixxx\<Esc>"
<			This has an <Esc> character, see |expr-string|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
また ":execute" は、Vim script 内でコマンド ":normal" の引数に制御文字を書くことを避けるために役に立つ。
@example
:execute "normal ixxx\<Esc>"
@end example
これで <Esc> 文字を表す。|@ref{expr-string}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			Be careful to correctly escape special characters in
			file names.  The |fnameescape()| function can be used
			for Vim commands, |shellescape()| for |:!| commands.
			Examples: >
		:execute "e " . fnameescape(filename)
		:execute "!ls " . shellescape(filename, 1)
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイル名の中の特殊文字を正しくエスケープするように注意すること。Vim コマンドに与えるファイル名をエスケープするには |@ref{fnameescape()}| を使う。|@ref{:!}| コマンドに与えるときは |@ref{shellescape()}| を使う。

例:
@example
:execute "e " . fnameescape(filename)
:execute "!ls " . shellescape(filename, 1)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Note: The executed string may be any command-line, but
			starting or ending "if", "while" and "for" does not
			always work, because when commands are skipped the
			":execute" is not evaluated and Vim loses track of
			where blocks start and end.  Also "break" and
			"continue" should not be inside ":execute".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
execute に渡す文字列はいかなるコマンドでも構わないが、"if" や "while"、"for" の開始や終了は常に機能するとは限らない。なぜならコマンドをスキップするときには ":execute" は解釈されないので Vim はブロックの開始や終了を認識することができない。"break" と "continue" も ":execute" で実行すべきではない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			This example does not work, because the ":execute" is
			not evaluated and Vim does not see the "while", and
			gives an error for finding an ":endwhile": >
		:if 0
		: execute 'while i > 5'
		:  echo "test"
		: endwhile
		:endif
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次の例は機能しない。":execute" は評価されず、Vim は "while" を認識しないので、":endwhile" を見つけたときにエラーが発生する:
@example
:if 0
: execute 'while i > 5'
:  echo "test"
: endwhile
:endif
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			It is allowed to have a "while" or "if" command
			completely in the executed string: >
		:execute 'while i < 5 | echo i | let i = i + 1 | endwhile'
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列の中に完全な "while" や "if" コマンドが含まれることが求められる:
@example
:execute 'while i < 5 | echo i | let i = i + 1 | endwhile'
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:exe-comment*
			":execute", ":echo" and ":echon" cannot be followed by
			a comment directly, because they see the '"' as the
			start of a string.  But, you can use '|' followed by a
			comment.  Example: >
		:echo "foo" | "this is a comment
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:exe-comment}
@cindex :exe-comment
":execute" や ":echo" そして ":echon" は、同一行に直接コメントを続けることはできない。何故ならそれらのコマンドにとって '"' は文字列の始まりに見えてしまうからである。しかし '|' の後にコメントを書くことは可能である。例:
@example
:echo "foo" | "this is a comment
@end example
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
8. Exception handling					*exception-handling*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{exception-handling}
@cindex exception-handling
@cindex 例外処理
@section 8. 例外処理
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The Vim script language comprises an exception handling feature.  This section
explains how it can be used in a Vim script.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim script 言語は例外処理機構を備えている。この節では例外処理をどのように行うかについて説明する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Exceptions may be raised by Vim on an error or on interrupt, see
|catch-errors| and |catch-interrupt|.  You can also explicitly throw an
exception by using the ":throw" command, see |throw-catch|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例外はエラー発生時や割り込み発生時に Vim によって投げられる。それについては |@ref{catch-errors}| と |@ref{catch-interrupt}| を参照。ユーザーはコマンド |@ref{:throw}| によって明示的に例外を投げることができる。|@ref{throw-catch}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
TRY CONDITIONALS					*try-conditionals*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{try-conditionals}
@cindex try-conditionals
@cindex TRY 条件文
@unnumberedsubsec TRY 条件文
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Exceptions can be caught or can cause cleanup code to be executed.  You can
use a try conditional to specify catch clauses (that catch exceptions) and/or
a finally clause (to be executed for cleanup).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例外を捕捉したり、例外を引き金として後始末のコードを実行することができる。try 条件文を使う事によって catch 節 (これが例外を捕捉する) や finally 節 (後始末のために実行される) を指定する事ができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   A try conditional begins with a |:try| command and ends at the matching
|:endtry| command.  In between, you can use a |:catch| command to start
a catch clause, or a |:finally| command to start a finally clause.  There may
be none or multiple catch clauses, but there is at most one finally clause,
which must not be followed by any catch clauses.  The lines before the catch
clauses and the finally clause is called a try block. >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

try 条件文はコマンド |@ref{:try}| によって始まり、対応するコマンド |@ref{:endtry}| によって終了する。その間でコマンド |@ref{:catch}| により catch 節を定めたり、コマンド |@ref{:finally}| によって finally 節を定めることができる。catch 節は 1 個もなかったり、複数個あってもよい。しかし finally 節は 1 個までしか持てない。finally 節の後に catch 節があってはならない。catch 節と finally 節の前の部分は try ブロックと呼ばれる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
     :try
     :	...
     :	...				TRY BLOCK
     :	...
     :catch /{pattern}/
     :	...
     :	...				CATCH CLAUSE
     :	...
     :catch /{pattern}/
     :	...
     :	...				CATCH CLAUSE
     :	...
     :finally
     :	...
     :	...				FINALLY CLAUSE
     :	...
     :endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:try
:  ...
:  ...                             try ブロック
:  ...
:catch /{pattern}/
:  ...
:  ...                             catch 節
:  ...
:catch /{pattern}/
:  ...
:  ...                             catch 節
:  ...
:finally
:  ...
:  ...                             finally 節
:  ...
:endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The try conditional allows to watch code for exceptions and to take the
appropriate actions.  Exceptions from the try block may be caught.  Exceptions
from the try block and also the catch clauses may cause cleanup actions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
try 条件文により、コードから発生する例外を監視したり、適切な対応を取ることができる。try ブロック内で発生した例外は捕捉される。try ブロックと catch 節内で発生した例外は捕捉され、後始末が行われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   When no exception is thrown during execution of the try block, the control
is transferred to the finally clause, if present.  After its execution, the
script continues with the line following the ":endtry".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

try ブロックの実行中に例外が発生しなかった場合は、制御は (もしあれば) finally 節に移動する。その実行後に、スクリプトは ":endtry" の後の行から実行を継続する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   When an exception occurs during execution of the try block, the remaining
lines in the try block are skipped.  The exception is matched against the
patterns specified as arguments to the ":catch" commands.  The catch clause
after the first matching ":catch" is taken, other catch clauses are not
executed.  The catch clause ends when the next ":catch", ":finally", or
":endtry" command is reached - whatever is first.  Then, the finally clause
(if present) is executed.  When the ":endtry" is reached, the script execution
continues in the following line as usual.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

try ブロックの実行中に例外が発生した場合は、try ブロックの残りの行はスキップされる。例外はコマンド ":catch" の引数として指定された正規表現に照合される。最初にマッチした ":catch" の後の catch 節が実行される。他の catch 節は実行されない。catch 節は次に ":catch", ":finally", ":endtry" が現れたところで終了する (どれでもよい)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   When an exception that does not match any of the patterns specified by the
":catch" commands is thrown in the try block, the exception is not caught by
that try conditional and none of the catch clauses is executed.  Only the
finally clause, if present, is taken.  The exception pends during execution of
the finally clause.  It is resumed at the ":endtry", so that commands after
the ":endtry" are not executed and the exception might be caught elsewhere,
see |try-nesting|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

":endtry" に達すると、スクリプトは次の行から通常通り実行が続けられる。発生した例外が、コマンド ":catch" で指定されたどの正規表現にもマッチしないとき、その例外はその try 条件文で捕捉されず、どの catch 節も実行されない。finally 節があるならば実行される。finally 節の実行中は例外は後回しにされ、":endtry" のときに実行される。そして ":endtry" の後のコマンドは実行されず、例外は他のどこかで捕捉される。|@ref{try-nesting}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   When during execution of a catch clause another exception is thrown, the
remaining lines in that catch clause are not executed.  The new exception is
not matched against the patterns in any of the ":catch" commands of the same
try conditional and none of its catch clauses is taken.  If there is, however,
a finally clause, it is executed, and the exception pends during its
execution.  The commands following the ":endtry" are not executed.  The new
exception might, however, be caught elsewhere, see |try-nesting|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

catch 節の実行中に新たな例外が発生した場合は、その catch 節の残りの行は実行されない。新しい例外は同じtry条件文のどの ":catch" コマンドの正規表現にも照合されず、どの catch 節も実行されない。しかし finally 節があるならばそこが実行され、その間その例外は保留される。":endtry" の後のコマンドは実行されない。新しい例外は他のどこかで捕捉される。|@ref{try-nesting}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   When during execution of the finally clause (if present) an exception is
thrown, the remaining lines in the finally clause are skipped.  If the finally
clause has been taken because of an exception from the try block or one of the
catch clauses, the original (pending) exception is discarded.  The commands
following the ":endtry" are not executed, and the exception from the finally
clause is propagated and can be caught elsewhere, see |try-nesting|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

finally 節の実行中に例外が発生した場合は、その finally 節の残りの行は実行されない。try ブロックやその catch 節のどこかで例外が発生してからその finally 節が実行されていた場合は、元の (保留されていた) 例外は破棄される。":endtry" の後のコマンドは実行されない。finally 節で発生した例外は伝播し、他のどこかで捕捉される。|@ref{try-nesting}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The finally clause is also executed, when a ":break" or ":continue" for
a ":while" loop enclosing the complete try conditional is executed from the
try block or a catch clause.  Or when a ":return" or ":finish" is executed
from the try block or a catch clause of a try conditional in a function or
sourced script, respectively.  The ":break", ":continue", ":return", or
":finish" pends during execution of the finally clause and is resumed when the
":endtry" is reached.  It is, however, discarded when an exception is thrown
from the finally clause.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
完全な try 条件文を囲む ":while" ループ内で、try ブロックや catch 節において ":break" や ":continue" が実行されたときも finally 節が実行される。また、関数の中や source されたスクリプト中で、try ブロックや try 条件文の catch 節において ":return" や ":finish" が実行されたときも finally 節が実行される。finally 節の実行中は ":break", ":continue", ":return", ":finish" は保留され、":endtry" に達したとき再開される。しかしこれらは、その finally 節内で例外が発生したときは破棄される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   When a ":break" or ":continue" for a ":while" loop enclosing the complete
try conditional or when a ":return" or ":finish" is encountered in the finally
clause, the rest of the finally clause is skipped, and the ":break",
":continue", ":return" or ":finish" is executed as usual.  If the finally
clause has been taken because of an exception or an earlier ":break",
":continue", ":return", or ":finish" from the try block or a catch clause,
this pending exception or command is discarded.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

完全な try 条件節を囲む ":while" ループ内での ":break" や ":continue"、または finally 節内で ":return" や ":finish" に出会ったときは、finally 節の残りはスキップされ、通常通り ":break", "continue", ":return", "finish" が実行される。もしその finally 節の前に、try ブロックや catch 節内で例外が発生したり、":break", ":continue", ":return", ":finally" が行われていた場合は、それらの保留されていた例外やコマンドは破棄される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For examples see |throw-catch| and |try-finally|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例として |@ref{throw-catch}| と |@ref{try-finally}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
NESTING	OF TRY CONDITIONALS				*try-nesting*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{try-nesting}
@cindex try-nesting
@cindex try 条件文のネスト
@unnumberedsubsec try 条件文のネスト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Try conditionals can be nested arbitrarily.  That is, a complete try
conditional can be put into the try block, a catch clause, or the finally
clause of another try conditional.  If the inner try conditional does not
catch an exception thrown in its try block or throws a new exception from one
of its catch clauses or its finally clause, the outer try conditional is
checked according to the rules above.  If the inner try conditional is in the
try block of the outer try conditional, its catch clauses are checked, but
otherwise only the finally clause is executed.  It does not matter for
nesting, whether the inner try conditional is directly contained in the outer
one, or whether the outer one sources a script or calls a function containing
the inner try conditional.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
try 条件文は任意にネストされられる。つまり、try 条件文の try ブロック・catch 節・finally 節のなかに別の完全な try 条件文を書くことができる。内側の try 条件文が try ブロックで発生した例外を捕捉しなかったときや、catch 節・finally 節で新たな例外が発生したときは、外側の try 条件文がそのルールにしたがって例外を捕捉する。内側の try 条件文が外側の条件文の try ブロックの中にある場合は catch 節が判定されるが、そうでない場合は finally 節のみが実行される。これはネストの仕方には関係ない。つまり、内側の try 条件文が直接外側の try 条件文に含まれていてもよいし、外側がスクリプトを source したり、内側の try 条件文を含む関数を呼び出していてもよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When none of the active try conditionals catches an exception, just their
finally clauses are executed.  Thereafter, the script processing terminates.
An error message is displayed in case of an uncaught exception explicitly
thrown by a ":throw" command.  For uncaught error and interrupt exceptions
implicitly raised by Vim, the error message(s) or interrupt message are shown
as usual.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
有効な try 条件文のどれも例外を捕捉しなかったときは、それらの finally 節が実行される。その後、スクリプトの実行は停止する。":throw" コマンドにより明示的に投げられた例外が捕捉されなかった場合は、エラーメッセージが表示される。Vim によって暗黙的に投げられたエラーや割り込み例外については、通常通りエラーメッセージや割り込みメッセージが表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For examples see |throw-catch|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例として |@ref{throw-catch}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
EXAMINING EXCEPTION HANDLING CODE			*except-examine*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{except-examine}
@cindex except-examine
@cindex 例外処理コードの検査
@unnumberedsubsec 例外処理コードの検査
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Exception handling code can get tricky.  If you are in doubt what happens, set
'verbose' to 13 or use the ":13verbose" command modifier when sourcing your
script file.  Then you see when an exception is thrown, discarded, caught, or
finished.  When using a verbosity level of at least 14, things pending in
a finally clause are also shown.  This information is also given in debug mode
(see |debug-scripts|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例外処理のコードはトリッキーになりがちである。何が起こっているか知りたいときはスクリプトファイルを source するときに '@option{verbose}' を 13 に設定するか、コマンド修飾子 ":13verbose" を使う。すると例外が発生・破棄・捕捉・完了したときには表示されるようになる。冗長度のレベルを 14 以上にすると、finally 節において保留されているものも表示されるようになる。この情報はデバッグモードでも表示される (|@ref{debug-scripts}| を参照)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
THROWING AND CATCHING EXCEPTIONS			*throw-catch*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{throw-catch}
@cindex throw-catch
@cindex 例外の生成と捕捉
@unnumberedsubsec 例外の生成と捕捉
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can throw any number or string as an exception.  Use the |:throw| command
and pass the value to be thrown as argument: >
	:throw 4711
	:throw "string"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
任意の数値や文字列を例外として投げることができる。コマンド |@ref{:throw}| を使い、投げられる値を引数に渡す:
@example
:throw 4711
:throw "string"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<							*throw-expression*
You can also specify an expression argument.  The expression is then evaluated
first, and the result is thrown: >
	:throw 4705 + strlen("string")
	:throw strpart("strings", 0, 6)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{throw-expression}
@cindex throw-expression
式を引数に指定することもできる。まずその式が評価され、その結果が投げられる:
@example
:throw 4705 + strlen("string")
:throw strpart("strings", 0, 6)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An exception might be thrown during evaluation of the argument of the ":throw"
command.  Unless it is caught there, the expression evaluation is abandoned.
The ":throw" command then does not throw a new exception.
   Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
":throw" コマンドの引数を評価している最中に例外が発生することもありうる。その例外が捕捉されない限り、その式の評価は破棄される。よって、その ":throw" コマンドは例外を投げることができない。

例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function! Foo(arg)
	:  try
	:    throw a:arg
	:  catch /foo/
	:  endtry
	:  return 1
	:endfunction
	:
	:function! Bar()
	:  echo "in Bar"
	:  return 4710
	:endfunction
	:
	:throw Foo("arrgh") + Bar()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:function! Foo(arg)
:  try
:    throw a:arg
:  catch /foo/
:  endtry
:  return 1
:endfunction
:
:function! Bar()
:  echo "in Bar"
:  return 4710
:endfunction
:
:throw Foo("arrgh") + Bar()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This throws "arrgh", and "in Bar" is not displayed since Bar() is not
executed. >
	:throw Foo("foo") + Bar()
however displays "in Bar" and throws 4711.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この例を実行すると "arrgh" が投げられ、Bar() が実行されないため "in Bar" は表示されない。しかし次のようにすると
@example
:throw Foo("foo") + Bar()
@end example
"in Bar" を表示し、4711 を投げる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Any other command that takes an expression as argument might also be
abandoned by an (uncaught) exception during the expression evaluation.  The
exception is then propagated to the caller of the command.
   Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
式を引数として受け取る他のコマンドでも、式の評価中に捕捉されない例外が発生するとコマンドが破棄される。そして例外はそのコマンドを呼び出した位置へ伝播する。

例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:if Foo("arrgh")
	:  echo "then"
	:else
	:  echo "else"
	:endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if Foo("arrgh")
:  echo "then"
:else
:  echo "else"
:endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here neither of "then" or "else" is displayed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この例で、"then" と "else" のどちらも表示されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*catch-order*
Exceptions can be caught by a try conditional with one or more |:catch|
commands, see |try-conditionals|.   The values to be caught by each ":catch"
command can be specified as a pattern argument.  The subsequent catch clause
gets executed when a matching exception is caught.
   Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{catch-order}
@cindex catch-order
例外は、1 個以上の |@ref{:catch}| コマンドを持つ try 条件文で捕捉することができる。これについては |@ref{try-conditionals}| を参照。各 ":catch" コマンドで捕捉される値は、引数にて正規表現で指定できる。マッチする例外が捕捉されると、その後に続く catch 節が実行される。

例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function! Foo(value)
	:  try
	:    throw a:value
	:  catch /^\d\+$/
	:    echo "Number thrown"
	:  catch /.*/
	:    echo "String thrown"
	:  endtry
	:endfunction
	:
	:call Foo(0x1267)
	:call Foo('string')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:function! Foo(value)
:  try
:    throw a:value
:  catch /^\d\+$/
:    echo "Number thrown"
:  catch /.*/
:    echo "String thrown"
:  endtry
:endfunction
:
:call Foo(0x1267)
:call Foo('string')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The first call to Foo() displays "Number thrown", the second "String thrown".
An exception is matched against the ":catch" commands in the order they are
specified.  Only the first match counts.  So you should place the more
specific ":catch" first.  The following order does not make sense: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最初の Foo() の呼び出しは "Number thrown" を表示し、2 番目の呼び出しは "String thrown" を表示する。例外は、順番に ":catch" コマンドに照合される。最初にマッチした catch 節だけが実行される。そのため、より限定的な ":catch" を先に書くべきである。次の順序で書くと無意味になってしまう:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:  catch /.*/
	:    echo "String thrown"
	:  catch /^\d\+$/
	:    echo "Number thrown"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:  catch /.*/
:    echo "String thrown"
:  catch /^\d\+$/
:    echo "Number thrown"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The first ":catch" here matches always, so that the second catch clause is
never taken.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最初の ":catch" は常にマッチするため、2 番目の catch 節は決して実行されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*throw-variables*
If you catch an exception by a general pattern, you may access the exact value
in the variable |v:exception|: >

	:  catch /^\d\+$/
	:    echo "Number thrown.  Value is" v:exception
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{throw-variables}
@cindex throw-variables
一般的な正規表現により例外を捕捉した場合、その正確な値には変数 |@ref{v:exception}| によりアクセスできる:
@example
:  catch /^\d\+$/
:    echo "Number thrown.  Value is" v:exception
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You may also be interested where an exception was thrown.  This is stored in
|v:throwpoint|.  Note that "v:exception" and "v:throwpoint" are valid for the
exception most recently caught as long it is not finished.
   Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
また、どこで例外が発生したかも知りたいだろう。これは |@ref{v:throwpoint}| に保持されている。
@quotation
@strong{Note:} @*
"v:exception" と "v:throwpoint" は最も直近に捕捉された例外に対し、それが終了するまで有効である。
@end quotation
例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function! Caught()
	:  if v:exception != ""
	:    echo 'Caught "' . v:exception . '" in ' . v:throwpoint
	:  else
	:    echo 'Nothing caught'
	:  endif
	:endfunction
	:
	:function! Foo()
	:  try
	:    try
	:      try
	:	 throw 4711
	:      finally
	:	 call Caught()
	:      endtry
	:    catch /.*/
	:      call Caught()
	:      throw "oops"
	:    endtry
	:  catch /.*/
	:    call Caught()
	:  finally
	:    call Caught()
	:  endtry
	:endfunction
	:
	:call Foo()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:function! Caught()
:  if v:exception != ""
:    echo 'Caught "' . v:exception . '" in ' . v:throwpoint
:  else
:    echo 'Nothing caught'
:  endif
:endfunction
:
:function! Foo()
:  try
:    try
:      try
:	 throw 4711
:      finally
:	 call Caught()
:      endtry
:    catch /.*/
:      call Caught()
:      throw "oops"
:    endtry
:  catch /.*/
:    call Caught()
:  finally
:    call Caught()
:  endtry
:endfunction
:
:call Foo()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This displays >

	Nothing caught
	Caught "4711" in function Foo, line 4
	Caught "oops" in function Foo, line 10
	Nothing caught
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上の例は次のように表示する
@verbatim
Nothing caught
Caught "4711" in function Foo, line 4
Caught "oops" in function Foo, line 10
Nothing caught
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A practical example:  The following command ":LineNumber" displays the line
number in the script or function where it has been used: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
実用的な例:  次のコマンド ":LineNumber" は、それが呼び出されたスクリプトや関数中の行番号を表示する:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function! LineNumber()
	:    return substitute(v:throwpoint, '.*\D\(\d\+\).*', '\1', "")
	:endfunction
	:command! LineNumber try | throw "" | catch | echo LineNumber() | endtry
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:function! LineNumber()
:    return substitute(v:throwpoint, '.*\D\(\d\+\).*', '\1', "")
:endfunction
:command! LineNumber try | throw "" | catch | echo LineNumber() | endtry
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*try-nested*
An exception that is not caught by a try conditional can be caught by
a surrounding try conditional: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{try-nested}
@cindex try-nested
try 条件文によって捕捉されない例外はそれを囲む try 条件文によって捕捉することができる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:try
	:  try
	:    throw "foo"
	:  catch /foobar/
	:    echo "foobar"
	:  finally
	:    echo "inner finally"
	:  endtry
	:catch /foo/
	:  echo "foo"
	:endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:try
:  try
:    throw "foo"
:  catch /foobar/
:    echo "foobar"
:  finally
:    echo "inner finally"
:  endtry
:catch /foo/
:  echo "foo"
:endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The inner try conditional does not catch the exception, just its finally
clause is executed.  The exception is then caught by the outer try
conditional.  The example displays "inner finally" and then "foo".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
内側の try 条件文はこの例外を捕捉せず、finally 節が実行されるだけである。そしてこの例外は外側の try 条件文で捕捉される。この例を実行すると "inner finally" と "foo" が表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*throw-from-catch*
You can catch an exception and throw a new one to be caught elsewhere from the
catch clause: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{throw-from-catch}
@cindex throw-from-catch
例外を捕捉した後、新しい例外を投げて他の catch 節で捕捉させることができる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function! Foo()
	:  throw "foo"
	:endfunction
	:
	:function! Bar()
	:  try
	:    call Foo()
	:  catch /foo/
	:    echo "Caught foo, throw bar"
	:    throw "bar"
	:  endtry
	:endfunction
	:
	:try
	:  call Bar()
	:catch /.*/
	:  echo "Caught" v:exception
	:endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:function! Foo()
:  throw "foo"
:endfunction
:
:function! Bar()
:  try
:    call Foo()
:  catch /foo/
:    echo "Caught foo, throw bar"
:    throw "bar"
:  endtry
:endfunction
:
:try
:  call Bar()
:catch /.*/
:  echo "Caught" v:exception
:endtry
@end verbatim

@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This displays "Caught foo, throw bar" and then "Caught bar".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これを実行すると "Caught foo, throw bar" と "Caught bar" が表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*rethrow*
There is no real rethrow in the Vim script language, but you may throw
"v:exception" instead: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{rethrow}
@cindex rethrow
Vim script 言語には本物の rethrow はないが、代わりに "v:exception" を使うことができる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function! Bar()
	:  try
	:    call Foo()
	:  catch /.*/
	:    echo "Rethrow" v:exception
	:    throw v:exception
	:  endtry
	:endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:function! Bar()
:  try
:    call Foo()
:  catch /.*/
:    echo "Rethrow" v:exception
:    throw v:exception
:  endtry
:endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<							*try-echoerr*
Note that this method cannot be used to "rethrow" Vim error or interrupt
exceptions, because it is not possible to fake Vim internal exceptions.
Trying so causes an error exception.  You should throw your own exception
denoting the situation.  If you want to cause a Vim error exception containing
the original error exception value, you can use the |:echoerr| command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{try-echoerr}
@cindex try-echoerr
@quotation
@strong{Note:} @*
この方法は Vim のエラーや割り込み例外を "rethrow" するためには使えない。Vim の内部例外を偽装することはできないからである。それを行おうとするとエラー例外が発生する。その状況を表す自分自身の例外を投げるべきである。独自のエラー例外値を含む Vim のエラー例外を発生させたい場合には、コマンド |@ref{:echoerr}| を使うことができる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:try
	:  try
	:    asdf
	:  catch /.*/
	:    echoerr v:exception
	:  endtry
	:catch /.*/
	:  echo v:exception
	:endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:try
:  try
:    asdf
:  catch /.*/
:    echoerr v:exception
:  endtry
:catch /.*/
:  echo v:exception
:endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This code displays

	Vim(echoerr):Vim:E492: Not an editor command:	asdf ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このコードを実行すると次が表示される
@display
Vim(echoerr):Vim:E492: Not an editor command:   asdf
@end display
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
CLEANUP CODE						*try-finally*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{try-finally}
@cindex try-finally
@cindex 後始末処理
@unnumberedsubsec 後始末処理
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Scripts often change global settings and restore them at their end.  If the
user however interrupts the script by pressing CTRL-C, the settings remain in
an inconsistent state.  The same may happen to you in the development phase of
a script when an error occurs or you explicitly throw an exception without
catching it.  You can solve these problems by using a try conditional with
a finally clause for restoring the settings.  Its execution is guaranteed on
normal control flow, on error, on an explicit ":throw", and on interrupt.
(Note that errors and interrupts from inside the try conditional are converted
to exceptions.  When not caught, they terminate the script after the finally
clause has been executed.)
Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
しばしばスクリプト中でグローバルな設定を変更し、最後に元の設定を復元することがある。しかしユーザーが @kbd{CTRL-C} を押してスクリプトを中断すると、設定が一貫しない状態になってしまう。スクリプトの開発段階においても、エラーが発生したり、明示的に例外を投げたが捕捉されなかった場合に、同じことが起こりうる。この問題は、try 条件文を使って finally 節で設定を復元することで解決できる。finally 節は、通常の制御フロー・エラー時・明示的な ":throw" 時・割り込み時に実行されることが保証されている。
@quotation
@strong{Note:} @*
try 条件文の内側で発生したエラーと割り込みは例外に変換される。これらが捕捉されなかったときには、finally 節の実行の後にスクリプトの実行が停止する。
@end quotation
例: >
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:try
	:  let s:saved_ts = &ts
	:  set ts=17
	:
	:  " Do the hard work here.
	:
	:finally
	:  let &ts = s:saved_ts
	:  unlet s:saved_ts
	:endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:try
:  let s:saved_ts = &ts
:  set ts=17
:
:  " Do the hard work here.
:
:finally
:  let &ts = s:saved_ts
:  unlet s:saved_ts
:endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This method should be used locally whenever a function or part of a script
changes global settings which need to be restored on failure or normal exit of
that function or script part.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数やスクリプトの一部でグローバルな設定を変更し、その関数・スクリプトの失敗時・通常終了時に設定を復元する必要があるときは、必ず局所的にこの手法を使うべきである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*break-finally*
Cleanup code works also when the try block or a catch clause is left by
a ":continue", ":break", ":return", or ":finish".
   Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{break-finally}
@cindex break-finally
":continue", ":break", ":return", ":finish" などによって try ブロックや catch 節を抜けるときも後始末処理が働く。

例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let first = 1
	:while 1
	:  try
	:    if first
	:      echo "first"
	:      let first = 0
	:      continue
	:    else
	:      throw "second"
	:    endif
	:  catch /.*/
	:    echo v:exception
	:    break
	:  finally
	:    echo "cleanup"
	:  endtry
	:  echo "still in while"
	:endwhile
	:echo "end"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let first = 1
:while 1
:  try
:    if first
:      echo "first"
:      let first = 0
:      continue
:    else
:      throw "second"
:    endif
:  catch /.*/
:    echo v:exception
:    break
:  finally
:    echo "cleanup"
:  endtry
:  echo "still in while"
:endwhile
:echo "end"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This displays "first", "cleanup", "second", "cleanup", and "end". >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上の例を実行すると "first", "cleanup", "second", "cleanup", "end" と表示される:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function! Foo()
	:  try
	:    return 4711
	:  finally
	:    echo "cleanup\n"
	:  endtry
	:  echo "Foo still active"
	:endfunction
	:
	:echo Foo() "returned by Foo"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:function! Foo()
:  try
:    return 4711
:  finally
:    echo "cleanup\n"
:  endtry
:  echo "Foo still active"
:endfunction
:
:echo Foo() "returned by Foo"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This displays "cleanup" and "4711 returned by Foo".  You don't need to add an
extra ":return" in the finally clause.  (Above all, this would override the
return value.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上の例を実行すると "cleanup" と "4711 returned by Foo" が表示される。finally 節に余計な ":return" を書く必要はない。(そうすると戻り値が上書きされてしまう)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*except-from-finally*
Using either of ":continue", ":break", ":return", ":finish", or ":throw" in
a finally clause is possible, but not recommended since it abandons the
cleanup actions for the try conditional.  But, of course, interrupt and error
exceptions might get raised from a finally clause.
   Example where an error in the finally clause stops an interrupt from
working correctly: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{except-from-finally}
@cindex except-from-finally
finally 節で ":continue", ":break", ":return", ":finish", ":throw" を使うことは可能である。しかしそうすると try 条件文の後始末を破棄してしまうことになるので推奨されていない。しかし、当然、finally 節の中で割り込みとエラー例外が発生することはありうる。

finally 節におけるエラーにより、割り込みが正しく動作しなくなる例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:try
	:  try
	:    echo "Press CTRL-C for interrupt"
	:    while 1
	:    endwhile
	:  finally
	:    unlet novar
	:  endtry
	:catch /novar/
	:endtry
	:echo "Script still running"
	:sleep 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:try
:  try
:    echo "Press CTRL-C for interrupt"
:    while 1
:    endwhile
:  finally
:    unlet novar
:  endtry
:catch /novar/
:endtry
:echo "Script still running"
:sleep 1
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you need to put commands that could fail into a finally clause, you should
think about catching or ignoring the errors in these commands, see
|catch-errors| and |ignore-errors|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
失敗する可能性のあるコマンドを finally 節に書く必要があるときは、それらのコマンドにより発生するエラーを捕捉したり無視したりすることについて考えること。|@ref{catch-errors}| と |@ref{ignore-errors}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
CATCHING ERRORS						*catch-errors*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{catch-errors}
@cindex catch-errors
@cindex エラーを変更する
@unnumberedsubsec エラーを変更する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to catch specific errors, you just have to put the code to be
watched in a try block and add a catch clause for the error message.  The
presence of the try conditional causes all errors to be converted to an
exception.  No message is displayed and |v:errmsg| is not set then.  To find
the right pattern for the ":catch" command, you have to know how the format of
the error exception is.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
特定のエラーを捕捉するには、監視したいコードを try ブロックに入れ、そのエラーメッセージに対する catch 節を加えるだけでよい。try 条件節が存在すると全てのエラーは例外に変換される。そのため、メッセージはまったく表示されず、|@ref{v:errmsg}| は設定されない。":catch" コマンドに対する正しい正規表現を作るには、エラー例外のフォーマットがどのようなものか知っていなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   Error exceptions have the following format: >

	Vim({cmdname}):{errmsg}
or >
	Vim:{errmsg}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

エラー例外は次のフォーマットを持つ:
@example
Vim(@{cmdname@}):@{errmsg@}
@end example
または
@example
Vim:@{errmsg@}
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{cmdname} is the name of the command that failed; the second form is used when
the command name is not known.  {errmsg} is the error message usually produced
when the error occurs outside try conditionals.  It always begins with
a capital "E", followed by a two or three-digit error number, a colon, and
a space.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{cmdname@} は失敗したコマンド名である。2番目の形式はコマンド名が不明のとき用いられる。@{errmsg@} は、そのエラーがtry条件文の外で発生したときに通常表示されるエラーメッセージである。エラーメッセージは必ず大文字の "E" で始まり、その後に 2, 3 桁のエラー番号、コロン、スペースが続く。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples:

The command >
	:unlet novar
normally produces the error message >
	E108: No such variable: "novar"
which is converted inside try conditionals to an exception >
	Vim(unlet):E108: No such variable: "novar"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:

次のコマンドを実行すると、
@verbatim
:unlet novar
@end verbatim
通常次のエラーメッセージが表示される
@display
E108: No such variable: "novar"
@end display
これは try 条件文の中では例外に変換される
@example
Vim(unlet):E108: No such variable: "novar"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The command >
	:dwim
normally produces the error message >
	E492: Not an editor command: dwim
which is converted inside try conditionals to an exception >
	Vim:E492: Not an editor command: dwim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のコマンドを実行すると、
@verbatim
:dwim
@end verbatim
通常次のエラーメッセージが表示される
@display
E492: Not an editor command: dwim
@end display
これは try 条件文の中では例外に変換される
@example
Vim:E492: Not an editor command: dwim
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can catch all ":unlet" errors by a >
	:catch /^Vim(unlet):/
or all errors for misspelled command names by a >
	:catch /^Vim:E492:/
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:unlet}" の全てのエラーを次によって捕捉できる
@example
:catch /^Vim(unlet):/
@end example
また、全てのミススペルされたコマンドのエラーは次で捕捉できる
@example
:catch /^Vim:E492:/
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Some error messages may be produced by different commands: >
	:function nofunc
and >
	:delfunction nofunc
both produce the error message >
	E128: Function name must start with a capital: nofunc
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
複数のコマンドによって同一のエラーメッセージが表示される場合もある:
@example
:function nofunc
@end example
と
@example
:delfunction nofunc
@end example
は両方とも次のエラーメッセージを表示する。
@display
E128: Function name must start with a capital: nofunc
@end display
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
which is converted inside try conditionals to an exception >
	Vim(function):E128: Function name must start with a capital: nofunc
or >
	Vim(delfunction):E128: Function name must start with a capital: nofunc
respectively.  You can catch the error by its number independently on the
command that caused it if you use the following pattern: >
	:catch /^Vim(\a\+):E128:/
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは try 条件節の中では例外に変換される。それぞれ
@example
Vim(function):E128: Function name must start with a capital: nofunc
@end example
または
@example
Vim(delfunction):E128: Function name must start with a capital: nofunc
@end example
となる。どのコマンドによって発生したかに関係なくこのエラーを捕捉するには、次の正規表現を使う:
@example
:catch /^Vim(\a\+):E128:/
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Some commands like >
	:let x = novar
produce multiple error messages, here: >
	E121: Undefined variable: novar
	E15: Invalid expression:  novar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
複数のエラーメッセージを表示するコマンドもある:
@example
:let x = novar
@end example
は次のエラーメッセージを表示する:
@display
E121: Undefined variable: novar
E15: Invalid expression:  novar
@end display
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Only the first is used for the exception value, since it is the most specific
one (see |except-several-errors|).  So you can catch it by >
	:catch /^Vim(\a\+):E121:/
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最初のエラーメッセージのみが例外の値として使われる。それが最も限定的なメッセージだからである (|@ref{except-several-errors}| を参照)。これは次のようにして捕捉できる
@example
:catch /^Vim(\a\+):E121:/
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can catch all errors related to the name "nofunc" by >
	:catch /\<nofunc\>/
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"nofunc" という名前に関係したエラー全てを捕捉するには
@example
:catch /\<nofunc\>/
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can catch all Vim errors in the ":write" and ":read" commands by >
	:catch /^Vim(\(write\|read\)):E\d\+:/
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンド "@command{:write}" と "@command{:read}" による全ての Vim エラーを捕捉するには
@example
:catch /^Vim(\(write\|read\)):E\d\+:/
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can catch all Vim errors by the pattern >
	:catch /^Vim\((\a\+)\)\=:E\d\+:/
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
全ての Vim エラーを捕捉するには次の正規表現を使う
@example
:catch /^Vim\((\a\+)\)\=:E\d\+:/
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*catch-text*
NOTE: You should never catch the error message text itself: >
	:catch /No such variable/
only works in the English locale, but not when the user has selected
a different language by the |:language| command.  It is however helpful to
cite the message text in a comment: >
	:catch /^Vim(\a\+):E108:/   " No such variable
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{catch-text}
@cindex catch-text
@quotation
@strong{Note:} @*
エラーメッセージの本文によって捕捉しようとしてはならない
@example
:catch /No such variable/
@end example
こうすると英語の環境では動作するが、コマンド |@ref{:language}| により他の言語を使っているユーザーの環境では動作しなくなる。しかし、コメントとしてメッセージテキストを引用することは役に立つ:
@example
:catch /^Vim(\a\+):E108:/   " No such variable
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
IGNORING ERRORS						*ignore-errors*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ignore-errors}
@cindex ignore-errors
@cindex エラーを無視する
@unnumberedsubsec エラーを無視する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can ignore errors in a specific Vim command by catching them locally: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
特定のコマンドで発生したエラーを捕捉すれば、エラーを無視することができる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:try
	:  write
	:catch
	:endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:try
:  write
:catch
:endtry
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
But you are strongly recommended NOT to use this simple form, since it could
catch more than you want.  With the ":write" command, some autocommands could
be executed and cause errors not related to writing, for instance: >

	:au BufWritePre * unlet novar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
しかしこの単純な形は使わないよう強く推奨されている。なぜなら、これはあなたが望むより多くの例外を捕捉してしまうからである。"@command{:write}" コマンドを使うと自動コマンドが実行され、書き込みとは関係ないエラーが発生する可能性がある。例えば:
@example
:au BufWritePre * unlet novar
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There could even be such errors you are not responsible for as a script
writer: a user of your script might have defined such autocommands.  You would
then hide the error from the user.
   It is much better to use >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このようなエラーの中には、スクリプトの作者が責任を負わないものもある: つまり、スクリプトのユーザーがそのようなオートコマンドを定義している場合である。その場合、上の例のようにすると、ユーザーからエラーを隠してしまうことになる。エラーを無視するには、次のようにした方がよい
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:try
	:  write
	:catch /^Vim(write):/
	:endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:try
:  write
:catch /^Vim(write):/
:endtry
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
which only catches real write errors.  So catch only what you'd like to ignore
intentionally.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは書き込みエラーだけを捕捉する。つまり、あなたが意図的に無視したいエラーだけである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For a single command that does not cause execution of autocommands, you could
even suppress the conversion of errors to exceptions by the ":silent!"
command: >
	:silent! nunmap k
This works also when a try conditional is active.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オートコマンドを発生させないような 1 つのコマンドに対しては、"@option{:silent!}" を使えばエラーを例外に変換すること自体を抑制させることができる:
@example
:silent! nunmap k
@end example
これは try 条件文が有効なときも機能する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
CATCHING INTERRUPTS					*catch-interrupt*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{catch-interrupt}
@cindex catch-interrupt
@cindex 割り込みを捕捉する
@unnumberedsubsec 割り込みを捕捉する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When there are active try conditionals, an interrupt (CTRL-C) is converted to
the exception "Vim:Interrupt".  You can catch it like every exception.  The
script is not terminated, then.
   Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
有効な try 条件文内では、割り込み (CTRL-C) は例外 "Vim:Interrupt" に変換される。これを他の例外と同様に捕捉することができる。するとそのスクリプトは停止しない。

例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function! TASK1()
	:  sleep 10
	:endfunction

	:function! TASK2()
	:  sleep 20
	:endfunction

	:while 1
	:  let command = input("Type a command: ")
	:  try
	:    if command == ""
	:      continue
	:    elseif command == "END"
	:      break
	:    elseif command == "TASK1"
	:      call TASK1()
	:    elseif command == "TASK2"
	:      call TASK2()
	:    else
	:      echo "\nIllegal command:" command
	:      continue
	:    endif
	:  catch /^Vim:Interrupt$/
	:    echo "\nCommand interrupted"
	:    " Caught the interrupt.  Continue with next prompt.
	:  endtry
	:endwhile
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:function! TASK1()
:  sleep 10
:endfunction

:function! TASK2()
:  sleep 20
:endfunction

:while 1
:  let command = input("Type a command: ")
:  try
:    if command == ""
:      continue
:    elseif command == "END"
:      break
:    elseif command == "TASK1"
:      call TASK1()
:    elseif command == "TASK2"
:      call TASK2()
:    else
:      echo "\nIllegal command:" command
:      continue
:    endif
:  catch /^Vim:Interrupt$/
:    echo "\nCommand interrupted"
:    " 例外捕捉。次のプロンプトから継続する。
:  endtry
:endwhile
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can interrupt a task here by pressing CTRL-C; the script then asks for
a new command.  If you press CTRL-C at the prompt, the script is terminated.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここで @kbd{CTRL-C} を押すとタスクに割り込むことができる。その後スクリプトは新しいコマンドを要求する。プロンプトで @kbd{CTRL-C} を押すとスクリプトが終了する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For testing what happens when CTRL-C would be pressed on a specific line in
your script, use the debug mode and execute the |>quit| or |>interrupt|
command on that line.  See |debug-scripts|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
スクリプト中の特定の行で @kbd{CTRL-C} が押されたとき何が起こるかをテストするにはデバッグモードを使い、その行の上で |@ref{>quit}| や |@ref{>interrupt}| コマンドを使う。|@ref{debug-scripts}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
CATCHING ALL						*catch-all*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{catch-all}
@cindex catch-all
@cindex 全てを捕捉する
@unnumberedsubsec 全てを捕捉する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The commands >

	:catch /.*/
	:catch //
	:catch
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のコマンド
@example
:catch /.*/
:catch //
:catch
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
catch everything, error exceptions, interrupt exceptions and exceptions
explicitly thrown by the |:throw| command.  This is useful at the top level of
a script in order to catch unexpected things.
   Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
は全てをエラー例外・割り込み例外・|@ref{:throw}| コマンドにより明示的に投げられた例外の捕捉する。これは、スクリプトのトップレベルで、予期しないことを捕捉するために役に立つ。

例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:try
	:
	:  " do the hard work here
	:
	:catch /MyException/
	:
	:  " handle known problem
	:
	:catch /^Vim:Interrupt$/
	:    echo "Script interrupted"
	:catch /.*/
	:  echo "Internal error (" . v:exception . ")"
	:  echo " - occurred at " . v:throwpoint
	:endtry
	:" end of script
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:try
:
:  " ここで難しいことをする
:
:catch /MyException/
:
:  " 既知の問題を制御する
:
:catch /^Vim:Interrupt$/
:    echo "Script interrupted"
:catch /.*/
:  echo "Internal error (" . v:exception . ")"
:  echo " - occurred at " . v:throwpoint
:endtry
:" スクリプトの終わり
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: Catching all might catch more things than you want.  Thus, you are
strongly encouraged to catch only for problems that you can really handle by
specifying a pattern argument to the ":catch".
   Example: Catching all could make it nearly impossible to interrupt a script
by pressing CTRL-C: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
全てを捕捉すると、期待していた以上のものを捕捉してしまうかもしれない。それゆえ、"@command{:catch}" コマンドの引数に正規表現を指定することにより、自分が本当に制御できる問題だけを捕捉することが強く推奨されている。

全てを捕捉してしまうと、@kbd{CTRL-C} を押してスクリプトを中断することがほぼ不可能になってしまうことがある。その例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:while 1
	:  try
	:    sleep 1
	:  catch
	:  endtry
	:endwhile
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:while 1
:  try
:    sleep 1
:  catch
:  endtry
:endwhile
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
EXCEPTIONS AND AUTOCOMMANDS				*except-autocmd*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{except-autocmd}
@cindex except-autocmd
@cindex 例外とオートコマンド
@unnumberedsubsec 例外とオートコマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Exceptions may be used during execution of autocommands.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オートコマンドの実行中に例外を使うこともできる。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:autocmd User x try
	:autocmd User x   throw "Oops!"
	:autocmd User x catch
	:autocmd User x   echo v:exception
	:autocmd User x endtry
	:autocmd User x throw "Arrgh!"
	:autocmd User x echo "Should not be displayed"
	:
	:try
	:  doautocmd User x
	:catch
	:  echo v:exception
	:endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:autocmd User x try
:autocmd User x   throw "Oops!"
:autocmd User x catch
:autocmd User x   echo v:exception
:autocmd User x endtry
:autocmd User x throw "Arrgh!"
:autocmd User x echo "Should not be displayed"
:
:try
:  doautocmd User x
:catch
:  echo v:exception
:endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This displays "Oops!" and "Arrgh!".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上の例を実行すると "Oops!" と "Arrgh!" が表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*except-autocmd-Pre*
For some commands, autocommands get executed before the main action of the
command takes place.  If an exception is thrown and not caught in the sequence
of autocommands, the sequence and the command that caused its execution are
abandoned and the exception is propagated to the caller of the command.
   Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{except-autocmd-Pre}
@cindex except-autocmd-Pre
いくつかのコマンドでは、それ自身が実行される前にオートコマンドが実行される。例外が発生し、それが一連のオートコマンドの中で捕捉されない場合、一連の自動コマンドと、その引き金となったコマンドは破棄され、例外がそのコマンドを呼んだ位置へ伝播する。

例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:autocmd BufWritePre * throw "FAIL"
	:autocmd BufWritePre * echo "Should not be displayed"
	:
	:try
	:  write
	:catch
	:  echo "Caught:" v:exception "from" v:throwpoint
	:endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:autocmd BufWritePre * throw "FAIL"
:autocmd BufWritePre * echo "Should not be displayed"
:
:try
:  write
:catch
:  echo "Caught:" v:exception "from" v:throwpoint
:endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here, the ":write" command does not write the file currently being edited (as
you can see by checking 'modified'), since the exception from the BufWritePre
autocommand abandons the ":write".  The exception is then caught and the
script displays: >

	Caught: FAIL from BufWrite Auto commands for "*"
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここで "@command{:write}" コマンドは現在編集しているファイルを書き込まない ('@option{modified}' を確認すればわかる)。BufWritePre のオートコマンドで発生した例外により、"@command{:write}" が破棄されたためである。そしてその例外は捕捉され、次を表示する:
@display
Caught: FAIL from BufWrite Auto commands for "*"
@end display
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*except-autocmd-Post*
For some commands, autocommands get executed after the main action of the
command has taken place.  If this main action fails and the command is inside
an active try conditional, the autocommands are skipped and an error exception
is thrown that can be caught by the caller of the command.
   Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{except-autocmd-Post}
@cindex except-autocmd-Post
いくつかのコマンドでは、それ自身が実行された後でオートコマンドが実行される。引き金となったコマンド自身が失敗して、それが有効な try 条件文の内側にあった場合、自動コマンドはスキップされ、エラー例外が発生する。その例外は、コマンドを呼んだ位置で捕捉することができる。

例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:autocmd BufWritePost * echo "File successfully written!"
	:
	:try
	:  write /i/m/p/o/s/s/i/b/l/e
	:catch
	:  echo v:exception
	:endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:autocmd BufWritePost * echo "File successfully written!"
:
:try
:  write /i/m/p/o/s/s/i/b/l/e
:catch
:  echo v:exception
:endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This just displays: >

	Vim(write):E212: Can't open file for writing (/i/m/p/o/s/s/i/b/l/e)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この例は次を表示する:
@display
Vim(write):E212: Can't open file for writing (/i/m/p/o/s/s/i/b/l/e)
@end display
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you really need to execute the autocommands even when the main action
fails, trigger the event from the catch clause.
   Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引き金となったコマンドが失敗したときでさえもオートコマンドを実行したいという場合は、catch 節の中でそのイベントを引き起こすことできる。

例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:autocmd BufWritePre  * set noreadonly
	:autocmd BufWritePost * set readonly
	:
	:try
	:  write /i/m/p/o/s/s/i/b/l/e
	:catch
	:  doautocmd BufWritePost /i/m/p/o/s/s/i/b/l/e
	:endtry
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:autocmd BufWritePre  * set noreadonly
:autocmd BufWritePost * set readonly
:
:try
:  write /i/m/p/o/s/s/i/b/l/e
:catch
:  doautocmd BufWritePost /i/m/p/o/s/s/i/b/l/e
:endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
You can also use ":silent!": >

	:let x = "ok"
	:let v:errmsg = ""
	:autocmd BufWritePost * if v:errmsg != ""
	:autocmd BufWritePost *   let x = "after fail"
	:autocmd BufWritePost * endif
	:try
	:  silent! write /i/m/p/o/s/s/i/b/l/e
	:catch
	:endtry
	:echo x
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:silent!}" を使うこともできる:

@verbatim
:let x = "ok"
:let v:errmsg = ""
:autocmd BufWritePost * if v:errmsg != ""
:autocmd BufWritePost *   let x = "after fail"
:autocmd BufWritePost * endif
:try
:  silent! write /i/m/p/o/s/s/i/b/l/e
:catch
:endtry
:echo x
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This displays "after fail".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上の例は "after fail" を表示する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the main action of the command does not fail, exceptions from the
autocommands will be catchable by the caller of the command:  >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引き金となったコマンドが失敗しなかった場合、オートコマンドから発生した例外は、元のコマンドを呼んだ位置から捕捉できる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:autocmd BufWritePost * throw ":-("
	:autocmd BufWritePost * echo "Should not be displayed"
	:
	:try
	:  write
	:catch
	:  echo v:exception
	:endtry
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:autocmd BufWritePost * throw ":-("
:autocmd BufWritePost * echo "Should not be displayed"
:
:try
:  write
:catch
:  echo v:exception
:endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*except-autocmd-Cmd*
For some commands, the normal action can be replaced by a sequence of
autocommands.  Exceptions from that sequence will be catchable by the caller
of the command.
   Example:  For the ":write" command, the caller cannot know whether the file
had actually been written when the exception occurred.  You need to tell it in
some way. >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{except-autocmd-Cmd}
@cindex except-autocmd-Cmd
いくつかのコマンドでは、通常の処理を一連のオートコマンドで置き換えることができる。そのコマンド列で発生した例外は元のコマンドの呼び出し位置で捕捉できる。

例: "@command{:write}" コマンドでは、例外が発生したとき、呼び出し側は実際にファイルが書き込まれたのかどうかを知ることができない。これを教える必要があるときは、なんらかの手段を使わねばならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:if !exists("cnt")
	:  let cnt = 0
	:
	:  autocmd BufWriteCmd * if &modified
	:  autocmd BufWriteCmd *   let cnt = cnt + 1
	:  autocmd BufWriteCmd *   if cnt % 3 == 2
	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"
	:  autocmd BufWriteCmd *   endif
	:  autocmd BufWriteCmd *   write | set nomodified
	:  autocmd BufWriteCmd *   if cnt % 3 == 0
	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"
	:  autocmd BufWriteCmd *   endif
	:  autocmd BufWriteCmd *   echo "File successfully written!"
	:  autocmd BufWriteCmd * endif
	:endif
	:
	:try
	:	write
	:catch /^BufWriteCmdError$/
	:  if &modified
	:    echo "Error on writing (file contents not changed)"
	:  else
	:    echo "Error after writing"
	:  endif
	:catch /^Vim(write):/
	:    echo "Error on writing"
	:endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if !exists("cnt")
:  let cnt = 0
:
:  autocmd BufWriteCmd * if &modified
:  autocmd BufWriteCmd *   let cnt = cnt + 1
:  autocmd BufWriteCmd *   if cnt % 3 == 2
:  autocmd BufWriteCmd *     throw "BufWriteCmdError"
:  autocmd BufWriteCmd *   endif
:  autocmd BufWriteCmd *   write | set nomodified
:  autocmd BufWriteCmd *   if cnt % 3 == 0
:  autocmd BufWriteCmd *     throw "BufWriteCmdError"
:  autocmd BufWriteCmd *   endif
:  autocmd BufWriteCmd *   echo "File successfully written!"
:  autocmd BufWriteCmd * endif
:endif
:
:try
:	write
:catch /^BufWriteCmdError$/
:  if &modified
:    echo "Error on writing (file contents not changed)"
:  else
:    echo "Error after writing"
:  endif
:catch /^Vim(write):/
:    echo "Error on writing"
:endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When this script is sourced several times after making changes, it displays
first >
	File successfully written!
then >
	Error on writing (file contents not changed)
then >
	Error after writing
etc.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バッファに変更を行った後でこのスクリプトを数回 source すると、1 回目は次のように表示される
@example
File successfully written!
@end example
2 回目は
@example
Error on writing (file contents not changed)
@end example
3 回目は
@example
Error after writing
@end example
以下同様。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*except-autocmd-ill*
You cannot spread a try conditional over autocommands for different events.
The following code is ill-formed: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{except-autocmd-ill}
@cindex except-autocmd-ill
異なるイベントに対するオートコマンドにわたって try 条件文を展開することはできない。以下のコードは不正である:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:autocmd BufWritePre  * try
	:
	:autocmd BufWritePost * catch
	:autocmd BufWritePost *   echo v:exception
	:autocmd BufWritePost * endtry
	:
	:write
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:autocmd BufWritePre  * try
:
:autocmd BufWritePost * catch
:autocmd BufWritePost *   echo v:exception
:autocmd BufWritePost * endtry
:
:write
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
EXCEPTION HIERARCHIES AND PARAMETERIZED EXCEPTIONS	*except-hier-param*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{except-hier-param}
@cindex except-hier-param
@cindex 例外の階層と付加情報つき例外
@unnumberedsubsec 例外の階層と付加情報つき例外
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Some programming languages allow to use hierarchies of exception classes or to
pass additional information with the object of an exception class.  You can do
similar things in Vim.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プログラミング言語の中には例外クラスを階層化したり、例外クラスのオブジェクトに付加的な情報を渡すことができるものがある。これと似たことを Vim でもできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   In order to throw an exception from a hierarchy, just throw the complete
class name with the components separated by a colon, for instance throw the
string "EXCEPT:MATHERR:OVERFLOW" for an overflow in a mathematical library.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
階層構造を持った例外を投げるには、各部分をコロンで区切った完全なクラス名を投げればよい。例えば、数学ライブラリ内でオーバーフローが発生したときに "EXCEPT:MATHERR:OVERFLOW" を投げる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   When you want to pass additional information with your exception class, add
it in parentheses, for instance throw the string "EXCEPT:IO:WRITEERR(myfile)"
for an error when writing "myfile".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例外クラスに付加的な情報を与えたいときは、それを括弧の中に書く。例えば、"myfile" の書き込み中にエラーが発生したときに文字列 "EXCEPT:IO:WRITEERR(myfile)" を投げる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   With the appropriate patterns in the ":catch" command, you can catch for
base classes or derived classes of your hierarchy.  Additional information in
parentheses can be cut out from |v:exception| with the ":substitute" command.
   Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:catch}" コマンドにおいて適切な正規表現を使えば、階層の基底クラスや派生クラスを捕捉できる。括弧の中の付加情報は、"@command{:substitute}" コマンドを使って |@ref{v:exception}| から切り出すことができる。

例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function! CheckRange(a, func)
	:  if a:a < 0
	:    throw "EXCEPT:MATHERR:RANGE(" . a:func . ")"
	:  endif
	:endfunction
	:
	:function! Add(a, b)
	:  call CheckRange(a:a, "Add")
	:  call CheckRange(a:b, "Add")
	:  let c = a:a + a:b
	:  if c < 0
	:    throw "EXCEPT:MATHERR:OVERFLOW"
	:  endif
	:  return c
	:endfunction
	:
	:function! Div(a, b)
	:  call CheckRange(a:a, "Div")
	:  call CheckRange(a:b, "Div")
	:  if (a:b == 0)
	:    throw "EXCEPT:MATHERR:ZERODIV"
	:  endif
	:  return a:a / a:b
	:endfunction
	:
	:function! Write(file)
	:  try
	:    execute "write" fnameescape(a:file)
	:  catch /^Vim(write):/
	:    throw "EXCEPT:IO(" . getcwd() . ", " . a:file . "):WRITEERR"
	:  endtry
	:endfunction
	:
	:try
	:
	:  " something with arithmetics and I/O
	:
	:catch /^EXCEPT:MATHERR:RANGE/
	:  let function = substitute(v:exception, '.*(\(\a\+\)).*', '\1', "")
	:  echo "Range error in" function
	:
	:catch /^EXCEPT:MATHERR/	" catches OVERFLOW and ZERODIV
	:  echo "Math error"
	:
	:catch /^EXCEPT:IO/
	:  let dir = substitute(v:exception, '.*(\(.\+\),\s*.\+).*', '\1', "")
	:  let file = substitute(v:exception, '.*(.\+,\s*\(.\+\)).*', '\1', "")
	:  if file !~ '^/'
	:    let file = dir . "/" . file
	:  endif
	:  echo 'I/O error for "' . file . '"'
	:
	:catch /^EXCEPT/
	:  echo "Unspecified error"
	:
	:endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:function! CheckRange(a, func)
:  if a:a < 0
:    throw "EXCEPT:MATHERR:RANGE(" . a:func . ")"
:  endif
:endfunction
:
:function! Add(a, b)
:  call CheckRange(a:a, "Add")
:  call CheckRange(a:b, "Add")
:  let c = a:a + a:b
:  if c < 0
:    throw "EXCEPT:MATHERR:OVERFLOW"
:  endif
:  return c
:endfunction
:
:function! Div(a, b)
:  call CheckRange(a:a, "Div")
:  call CheckRange(a:b, "Div")
:  if (a:b == 0)
:    throw "EXCEPT:MATHERR:ZERODIV"
:  endif
:  return a:a / a:b
:endfunction
:
:function! Write(file)
:  try
:    execute "write" fnameescape(a:file)
:  catch /^Vim(write):/
:    throw "EXCEPT:IO(" . getcwd() . ", " . a:file . "):WRITEERR"
:  endtry
:endfunction
:
:try
:
:  " 計算やI/Oを行う
:
:catch /^EXCEPT:MATHERR:RANGE/
:  let function = substitute(v:exception, '.*(\(\a\+\)).*', '\1', "")
:  echo "Range error in" function
:
:catch /^EXCEPT:MATHERR/	" catches OVERFLOW and ZERODIV
:  echo "Math error"
:
:catch /^EXCEPT:IO/
:  let dir = substitute(v:exception, '.*(\(.\+\),\s*.\+).*', '\1', "")
:  let file = substitute(v:exception, '.*(.\+,\s*\(.\+\)).*', '\1', "")
:  if file !~ '^/'
:    let file = dir . "/" . file
:  endif
:  echo 'I/O error for "' . file . '"'
:
:catch /^EXCEPT/
:  echo "Unspecified error"
:
:endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The exceptions raised by Vim itself (on error or when pressing CTRL-C) use
a flat hierarchy:  they are all in the "Vim" class.  You cannot throw yourself
exceptions with the "Vim" prefix; they are reserved for Vim.
   Vim error exceptions are parameterized with the name of the command that
failed, if known.  See |catch-errors|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
エラー時や @kbd{CTRL-C} を押したときに Vim 自身によって投げられる例外は平坦な階層になっている: つまりこれらは全て "Vim" クラスに入っている。ユーザーは接頭辞 "Vim" をつけた例外を投げることはできない。これらは Vim 用に予約されている。

Vim のエラー例外は失敗したコマンドの名前 (わかっているならば) という付加情報がついている。|@ref{catch-errors}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
PECULIARITIES
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex 変わった特性
@unnumberedsubsec 変わった特性
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*except-compat*
The exception handling concept requires that the command sequence causing the
exception is aborted immediately and control is transferred to finally clauses
and/or a catch clause.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{except-compat}
@cindex except-compat
例外制御のコンセプトは、例外を引き起こしたコマンドは即座に異常終了し、制御が finally 節または catch 節に移るという前提に基づいている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In the Vim script language there are cases where scripts and functions
continue after an error: in functions without the "abort" flag or in a command
after ":silent!", control flow goes to the following line, and outside
functions, control flow goes to the line following the outermost ":endwhile"
or ":endif".  On the other hand, errors should be catchable as exceptions
(thus, requiring the immediate abortion).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim script 言語では、エラーの後もスクリプトや関数が処理を続行する場合がある。"abort" フラグのない関数や、":silent!" をつけて実行されたコマンドでは、制御は次の行、そして関数の外へ移り、制御フローは最外側の ":endwhile" や ":endif" の次の行へ移る。一方、エラーは例外と同様に捕捉できるべきである (つまり、即座に異常終了することが要求される)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This problem has been solved by converting errors to exceptions and using
immediate abortion (if not suppressed by ":silent!") only when a try
conditional is active.  This is no restriction since an (error) exception can
be caught only from an active try conditional.  If you want an immediate
termination without catching the error, just use a try conditional without
catch clause.  (You can cause cleanup code being executed before termination
by specifying a finally clause.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この問題は、try 条件文が有効なときだけエラーを例外に変換し、(":silent!" で抑制されていない限り) 即座に異常終了することで解決される。(エラー) 例外は有効な try 条件文でのみ捕捉可能であるため、これはなんら制約とはならない。エラーを捕捉せずに即座に終了してほしいなら、単に catch 節を持たない try 条件文を使えばよい。(finally 節を指定すれば、終了の前に後始末処理を行うことができる)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When no try conditional is active, the usual abortion and continuation
behavior is used instead of immediate abortion.  This ensures compatibility of
scripts written for Vim 6.1 and earlier.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
有効な try 条件文がないとき、即座の異常終了でなく、通常の異常終了と継続が行われる。これによって Vim6.1 以前用に書かれたスクリプトの互換性を保証している。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
However, when sourcing an existing script that does not use exception handling
commands (or when calling one of its functions) from inside an active try
conditional of a new script, you might change the control flow of the existing
script on error.  You get the immediate abortion on error and can catch the
error in the new script.  If however the sourced script suppresses error
messages by using the ":silent!" command (checking for errors by testing
|v:errmsg| if appropriate), its execution path is not changed.  The error is
not converted to an exception.  (See |:silent|.)  So the only remaining cause
where this happens is for scripts that don't care about errors and produce
error messages.  You probably won't want to use such code from your new
scripts.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
しかし、有効な try 条件文の中から、例外処理コマンドを使っていない既存のスクリプトを source する (またはその関数の 1 つを呼ぶ) と、エラー発生時に既存のスクリプトの制御フローが変わるかもしれない。エラー発生時に即座に異常終了し、新しい方のスクリプト内でエラーを捕捉できる。しかし source されたスクリプトが ":silent!" コマンドでエラーメッセージを抑制していた場合 (それが適切なスクリプトなら |@ref{v:errmsg}| を見ることでエラーを確認している)、実行パスは変わらない。そのエラーは例外に変換されない (|@ref{:silent}| を参照)。これが起こる残りのただ 1 つの原因は、エラーに関心を払っていなく、エラーメッセージを表示させるスクリプトである。おそらく新しいスクリプトからそのようなコードを使いたいとは思わないだろう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*except-syntax-err*
Syntax errors in the exception handling commands are never caught by any of
the ":catch" commands of the try conditional they belong to.  Its finally
clauses, however, is executed.
   Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{except-syntax-err}
@cindex except-syntax-err
例外処理コマンドにおける構文エラーは、それが属する try 条件文のどの "@command{:catch}" コマンドでも決して捕捉されない。しかし finally 節は実行される。

例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:try
	:  try
	:    throw 4711
	:  catch /\(/
	:    echo "in catch with syntax error"
	:  catch
	:    echo "inner catch-all"
	:  finally
	:    echo "inner finally"
	:  endtry
	:catch
	:  echo 'outer catch-all caught "' . v:exception . '"'
	:  finally
	:    echo "outer finally"
	:endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:try
:  try
:    throw 4711
:  catch /\(/
:    echo "in catch with syntax error"
:  catch
:    echo "inner catch-all"
:  finally
:    echo "inner finally"
:  endtry
:catch
:  echo 'outer catch-all caught "' . v:exception . '"'
:  finally
:    echo "outer finally"
:endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This displays: >
    inner finally
    outer catch-all caught "Vim(catch):E54: Unmatched \("
    outer finally
The original exception is discarded and an error exception is raised, instead.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上の例を実行すると次が表示される:
@display
inner finally
outer catch-all caught "Vim(catch):E54: Unmatched \("
outer finally
@end display
元の例外は破棄され、代わりにエラー例外が投げられる。

@{訳注: throw 4711 により例外が発生したが、その後の catch /\(/ に構文エラーがあるためエラー例外が発生し、最初の例外は破棄された。@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*except-single-line*
The ":try", ":catch", ":finally", and ":endtry" commands can be put on
a single line, but then syntax errors may make it difficult to recognize the
"catch" line, thus you better avoid this.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{except-single-line}
@cindex except-single-line
コマンド ":try", ":catch", ":finally", ":endtry" は 1 行の中に書くことができる。しかし構文エラーがあったとき "catch" の行を認識するのが難しくなるので、避けた方がよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   Example: >
	:try | unlet! foo # | catch | endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

例:
@verbatim
:try | unlet! foo # | catch | endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
raises an error exception for the trailing characters after the ":unlet!"
argument, but does not see the ":catch" and ":endtry" commands, so that the
error exception is discarded and the "E488: Trailing characters" message gets
displayed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この例は ":unlet!" の後に余計な文字があるためエラー例外を発生させる。そして":catch" と ":endtry" が認識されないため、この例外は破棄され、"E488: Trailing characters" のメッセージが表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*except-several-errors*
When several errors appear in a single command, the first error message is
usually the most specific one and therefor converted to the error exception.
   Example: >
	echo novar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{except-several-errors}
@cindex except-several-errors
1 つのコマンドにより複数のエラーが発生した場合、普通は最初のエラーメッセージが最も限定的であるため、それがエラー例外に変換される。

例:
@example
echo novar
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
causes >
	E121: Undefined variable: novar
	E15: Invalid expression: novar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
は次を発生させる:
@display
E121: Undefined variable: novar
E15: Invalid expression: novar
@end display
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The value of the error exception inside try conditionals is: >
	Vim(echo):E121: Undefined variable: novar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
try 条件文の中のエラー例外の値は次になる:
@example
Vim(echo):E121: Undefined variable: novar
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<							*except-syntax-error*
But when a syntax error is detected after a normal error in the same command,
the syntax error is used for the exception being thrown.
   Example: >
	unlet novar #
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{except-syntax-error}
@cindex except-syntax-error
しかし、同じコマンドにおいて通常のエラーの後に構文エラーが検出されたときは、構文エラーが例外として投げられる。

例:
@verbatim
unlet novar #
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
causes >
	E108: No such variable: "novar"
	E488: Trailing characters
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは次を発生させる:
@display
E108: No such variable: "novar"
E488: Trailing characters
@end display
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The value of the error exception inside try conditionals is: >
	Vim(unlet):E488: Trailing characters
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
try 条件文の中のエラー例外の値は次になる:
@example
Vim(unlet):E488: Trailing characters
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This is done because the syntax error might change the execution path in a way
not intended by the user.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この理由は、構文エラーによってユーザーが予期していない実行パスになってしまうかもしれないためである。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	try
	    try | unlet novar # | catch | echo v:exception | endtry
	catch /.*/
	    echo "outer catch:" v:exception
	endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
try
    try | unlet novar # | catch | echo v:exception | endtry
catch /.*/
    echo "outer catch:" v:exception
endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This displays "outer catch: Vim(unlet):E488: Trailing characters", and then
a "E600: Missing :endtry" error message is given, see |except-single-line|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは "outer catch: Vim(unlet):E488: Trailing characters" を表示し、次にエラーメッセージ "E600: Missing :endtry" が表示される。|@ref{except-single-line}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
9. Examples						*eval-examples*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{eval-examples}
@cindex eval-examples
@section 9. 例
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Printing in Binary ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex 16 進数で表示する
@unnumberedsubsec 16 進数で表示する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
>
  :" The function Nr2Bin() returns the binary string representation of a number.
  :func Nr2Bin(nr)
  :  let n = a:nr
  :  let r = ""
  :  while n
  :    let r = '01'[n % 2] . r
  :    let n = n / 2
  :  endwhile
  :  return r
  :endfunc
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:" 関数 Nr2Bin() は数値の 2 進文字列表現を返す。
:func Nr2Bin(nr)
:  let n = a:nr
:  let r = ""
:  while n
:    let r = '01'[n % 2] . r
:    let n = n / 2
:  endwhile
:  return r
:endfunc
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  :" The function String2Bin() converts each character in a string to a
  :" binary string, separated with dashes.
  :func String2Bin(str)
  :  let out = ''
  :  for ix in range(strlen(a:str))
  :    let out = out . '-' . Nr2Bin(char2nr(a:str[ix]))
  :  endfor
  :  return out[1:]
  :endfunc
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:" 関数 String2Bin() は文字列中の各文字を2進文字列に変換して、ハイフン(-)で
:" 区切って返す。
:func String2Bin(str)
:  let out = ''
:  for ix in range(strlen(a:str))
:    let out = out . '-' . Nr2Bin(char2nr(a:str[ix]))
:  endfor
:  return out[1:]
:endfunc
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Example of its use: >
  :echo Nr2Bin(32)
result: "100000" >
  :echo String2Bin("32")
result: "110011-110010"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
使い方の例:
@example
:echo Nr2Bin(32)
@end example
結果: "100000"
@example
:echo String2Bin("32")
@end example
結果: "110011-110010"
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Sorting lines ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex 行をソート (並べ替え) する
@unnumberedsubsec 行をソート (並べ替え) する (by Robert Webb)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This example sorts lines with a specific compare function. >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下は、指定した比較関数を使って行をソートする例である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  :func SortBuffer()
  :  let lines = getline(1, '$')
  :  call sort(lines, function("Strcmp"))
  :  call setline(1, lines)
  :endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:func SortBuffer()
:  let lines = getline(1, '$')
:  call sort(lines, function("Strcmp"))
:  call setline(1, lines)
:endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
As a one-liner: >
  :call setline(1, sort(getline(1, '$'), function("Strcmp")))
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ワンライナーにすると次のようになる:
@example
:call setline(1, sort(getline(1, '$'), function("Strcmp")))
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
scanf() replacement ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex scanf() の代替
@unnumberedsubsec scanf() の代替
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*sscanf*
There is no sscanf() function in Vim.  If you need to extract parts from a
line, you can use matchstr() and substitute() to do it.  This example shows
how to get the file name, line number and column number out of a line like
"foobar.txt, 123, 45". >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sscanf}
@cindex sscanf
Vim には sscanf() に相当する関数が無い。行の一部を取り出す必要がある場合には、matchstr() や substitute() を使えば実現できる。以下の例は、"foobar.txt, 123, 45" というような行から、ファイル名と行番号とカラム番号を取り出す方法を示している。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   :" Set up the match bit
   :let mx='\(\f\+\),\s*\(\d\+\),\s*\(\d\+\)'
   :"get the part matching the whole expression
   :let l = matchstr(line, mx)
   :"get each item out of the match
   :let file = substitute(l, mx, '\1', '')
   :let lnum = substitute(l, mx, '\2', '')
   :let col = substitute(l, mx, '\3', '')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:" 正規表現を設定
:let mx='\(\f\+\),\s*\(\d\+\),\s*\(\d\+\)'
:" 正規表現全体にマッチする部分を取り出す
:let l = matchstr(line, mx)
:" マッチ結果から各要素を取り出す
:let file = substitute(l, mx, '\1', '')
:let lnum = substitute(l, mx, '\2', '')
:let col = substitute(l, mx, '\3', '')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The input is in the variable "line", the results in the variables "file",
"lnum" and "col". (idea from Michael Geddes)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
入力は変数 "line"、結果は "file" と "lnum" と "col" に格納される (このアイデアは Michael Geddes による)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
getting the scriptnames in a Dictionary ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex 辞書から scriptnames を取り出す
@unnumberedsubsec 辞書から scriptnames を取り出す
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*scriptnames-dictionary*
The |:scriptnames| command can be used to get a list of all script files that
have been sourced.  There is no equivalent function or variable for this
(because it's rarely needed).  In case you need to manipulate the list this
code can be used: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{scriptnames-dictionary}
@cindex scriptnames-dictionary
コマンド |@ref{:scriptnames}| により今までに source された全てのスクリプトファイルのリストを取得することができる。これと等価な関数や変数は存在しない (めったに必要にならないからである)。そのような場合には次のコードが利用できる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    " Get the output of ":scriptnames" in the scriptnames_output variable.
    let scriptnames_output = ''
    redir => scriptnames_output
    silent scriptnames
    redir END
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
" ":scriptnames" の出力を変数scriptnames_outputに入れる。
let scriptnames_output = ''
redir => scriptnames_output
silent scriptnames
redir END
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
    " Split the output into lines and parse each line.	Add an entry to the
    " "scripts" dictionary.
    let scripts = {}
    for line in split(scriptnames_output, "\n")
      " Only do non-blank lines.
      if line =~ '\S'
	" Get the first number in the line.
	let nr = matchstr(line, '\d\+')
	" Get the file name, remove the script number " 123: ".
	let name = substitute(line, '.\+:\s*', '', '')
	" Add an item to the Dictionary
	let scripts[nr] = name
      endif
    endfor
    unlet scriptnames_output
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
" 出力を行のリストに分割し、各行をパースする。辞書 "scripts" に要素を追加
" する。
let scripts = {}
for line in split(scriptnames_output, "\n")
  " 空行以外に対して実行
  if line =~ '\S'
    " 行内の最初の番号を取得
    let nr = matchstr(line, '\d\+')
    " ファイル名を取得。スクリプト番号" 123: "を削除。
    let name = substitute(line, '.\+:\s*', '', '')
    " 辞書に要素を追加
    let scripts[nr] = name
  endif
endfor
unlet scriptnames_output
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
10. No +eval feature				*no-eval-feature*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{no-eval-feature}
@cindex no-eval-feature
@cindex +eval 機能が無効
@section 10. +eval 機能が無効
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the |+eval| feature was disabled at compile time, none of the expression
evaluation commands are available.  To prevent this from causing Vim scripts
to generate all kinds of errors, the ":if" and ":endif" commands are still
recognized, though the argument of the ":if" and everything between the ":if"
and the matching ":endif" is ignored.  Nesting of ":if" blocks is allowed, but
only if the commands are at the start of the line.  The ":else" command is not
recognized.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コンパイル時に |@ref{+eval}| 機能が無効とされている場合、全ての式評価 (eval) コマンドは提供されない。その場合、Vim script が全ての種類のエラーを引き起こすことを避ける為、":if" と ":endif" は解釈される。":if" とそれに対応する ":endif" に挟まれた内容は無視される。":if" の後に続く引数も無視される。この ":if" コマンドはネスティングが可能である。しかし必ず行の先頭に書かれている必要がある。":else" コマンドは認識されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Example of how to avoid executing commands when the |+eval| feature is
missing: >

	:if 1
	:  echo "Expression evaluation is compiled in"
	:else
	:  echo "You will _never_ see this message"
	:endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{+eval}| 機能が存在しなかった場合、どのようにコマンドが実行を免れるかの例:
@verbatim
:if 1
:  echo "Expression evaluation is compiled in"
:else
:  echo "You will _never_ see this message"
:endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To execute a command only when the |+eval| feature is disabled requires a trick,
as this example shows: >

	silent! while 0
	  set history=111
	silent! endwhile
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{+eval}| 機能が無効の場合のみにコマンドを実行するためには、次の例のようなトリックが必要になる:
@example
silent! while 0
  set history=111
silent! endwhile
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the |+eval| feature is available the command is skipped because of the
"while 0".  Without the |+eval| feature the "while 0" is an error, which is
silently ignored, and the command is executed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{+eval}| 機能が利用可能な場合にコマンドは、"while 0" なのでスキップされる。|@ref{+eval}| 機能が無効の場合は、"while 0" はエラーになる。これは黙って無視され、コマンドは実行される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
11. The sandbox					*eval-sandbox* *sandbox* *E48*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{eval-sandbox}
@anchor{sandbox}
@anchor{E48}
@cindex eval-sandbox
@cindex sandbox
@erindex E48
@cindex サンドボックス
@section 11. サンドボックス
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The 'foldexpr', 'formatexpr', 'includeexpr', 'indentexpr', 'statusline' and
'foldtext' options may be evaluated in a sandbox.  This means that you are
protected from these expressions having nasty side effects.  This gives some
safety for when these options are set from a modeline.  It is also used when
the command from a tags file is executed and for CTRL-R = in the command line.
The sandbox is also used for the |:sandbox| command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{foldexpr}', '@option{formatexpr}', '@option{includeexpr}', '@option{indentexpr}', '@option{statusline}', '@option{foldtext}' はサンドボックスの中で評価される。これによって、悪質な副作用を持つ式からの保護がなされている。これによって、これらのオプションがモードラインから設定された場合にある種の安全性がもたらされている。tags ファイルからのコマンドが実行されたときとコマンドラインでの @kbd{CTRL-R =} に対してもサンドボックスが使われる。

コマンド |@ref{:sandbox}| に対してもサンドボックスが使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These items are not allowed in the sandbox:
	- changing the buffer text
	- defining or changing mapping, autocommands, user commands
	- setting certain options (see |option-summary|)
	- setting certain v: variables (see |v:var|)  *E794*
	- executing a shell command
	- reading or writing a file
	- jumping to another buffer or editing a file
	- executing Python, Perl, etc. commands
This is not guaranteed 100% secure, but it should block most attacks.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
サンドボックス内では以下の事が禁止される:
@itemize
@item バッファの変更
@item マッピング、オートコマンド、ユーザー定義コマンドの定義・変更
@item ある種のオプションの設定 (|@ref{option-summary}| を参照)
@anchor{E794}
@erindex E794
@item ある種の Vim 定義済変数 (v:) の設定 (|@ref{v:var}| を参照)
@item シェルコマンドの実行
@item ファイルの読み書き
@item 他のバッファへの移動・ファイルを開く
@item  Python, Perl 等のコマンドの実行
@end itemize
これは 100% 安全と保証するものではない。しかし、ある種の攻撃を防ぐ事はできるはずである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:san* *:sandbox*
:san[dbox] {cmd}	Execute {cmd} in the sandbox.  Useful to evaluate an
			option that may have been set from a modeline, e.g.
			'foldexpr'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{:san}
@anchor{:sandbox}
@pindex :san
@pindex :sandbox
@item :san[dbox] @{cmd@}
サンドボックス内で @{cmd@} を実行する。モードラインから設定された可能性のあるオプションを評価するために使える。

例: '@option{foldexpr}'
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*sandbox-option*
A few options contain an expression.  When this expression is evaluated it may
have to be done in the sandbox to avoid a security risk.  But the sandbox is
restrictive, thus this only happens when the option was set from an insecure
location.  Insecure in this context are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sandbox-option}
@cindex sandbox-option
いくつかのオプションは式を含んでいる。その式を評価するときはセキュリティ上の危険性を回避するためにサンドボックス内で行わねばならない。しかしサンドボックスには制限があるので、これはそのオプションが安全でない場所で設定されたときのみ行われる。ここで「安全でない」とは次の場合をいう:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- sourcing a .vimrc or .exrc in the current directory
- while executing in the sandbox
- value coming from a modeline
- executing a function that was defined in the sandbox
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item カレントディレクトリの .vimrc や .exrc を source するとき
@item サンドボックス内で実行している最中
@item モードラインから設定された値
@item サンドボックス内で定義されている関数を実行しているとき
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that when in the sandbox and saving an option value and restoring it, the
option will still be marked as it was set in the sandbox.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
サンドボックス内でオプションの値を退避し、それから復元した場合、そのオプションはやはりサンドボックス内で設定されたものとマークされる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
12. Textlock							*textlock*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{textlock}
@cindex textlock
@cindex テキストロック
@section 12. テキストロック
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In a few situations it is not allowed to change the text in the buffer, jump
to another window and some other things that might confuse or break what Vim
is currently doing.  This mostly applies to things that happen when Vim is
actually doing something else.  For example, evaluating the 'balloonexpr' may
happen any moment the mouse cursor is resting at some position.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
いくつか状況においては、バッファを変更する・他のウィンドウへジャンプするなど、Vim の現在の処理を混乱させたり破壊してしまうような動作は禁止される。これは Vim が実際に他の何かをしているときに起こることに対して当てはまる。例えば、'@option{balloonexpr}' の評価は、マウスカーソルがある位置に留まっているどんなときにでも起こりうる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This is not allowed when the textlock is active:
	- changing the buffer text
	- jumping to another buffer or window
	- editing another file
	- closing a window or quitting Vim
	- etc.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
テキストロックが有効になっているときは、以下の事が禁止される:
@itemize
@item バッファのテキスト変更
@item 他のバッファやウィンドウへの移動
@item 他のファイルを開く
@item ウィンドウを閉じたりVimを終了したり
@item その他
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
13. Testing							*testing*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{testing}
@cindex testing
@cindex テスト
@section 13. テスト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim can be tested after building it, usually with "make test".
The tests are located in the directory "src/testdir".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim はビルドした後、通常 "make test" を使ってテストできる。テストはディレクトリ "src/testdir" にある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are several types of tests added over time:
	test33.in		oldest, don't add any more
	test_something.in	old style tests
	test_something.vim	new style tests
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
時間の経過と共にいくつかのタイプのテストが追加された:
@multitable @columnfractions .99
@item test33.in               最も古い、もう追加しない
@item test_something.in       古いスタイルのテスト
@item test_something.vim      新しいスタイルのテスト
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*new-style-testing*
New tests should be added as new style tests.  These use functions such as
|assert_equal()| to keep the test commands and the expected result in one
place.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{new-style-testing}
@cindex new-style-testing
新しいテストは新しいスタイルのテストで追加すべきである。これらは |@ref{assert_equal()}| などの関数を使用して、テストコマンドと期待される結果を 1 か所に保持する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*old-style-testing*
In some cases an old style test needs to be used.  E.g. when testing Vim
without the |+eval| feature.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{old-style-testing}
@cindex old-style-testing
場合によっては、古いスタイルのテストを使用する必要がある。例えば、|@ref{+eval}| 機能なしで Vim をテストするとき。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Find more information in the file src/testdir/README.txt.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
詳細は、src/testdir/README.txt ファイルを参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
 vim:tw=78:ts=8:noet:ft=help:norl:
@end ifset
