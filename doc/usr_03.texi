@ifset JA  @c ----------- v -----------  JA  -*- tab-width: 8 -*-
@node usr_03.txt, usr_04.txt, usr_05.txt, 目次
@unnumbered カーソルの移動
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*usr_03.txt*	For Vim version 8.0.  Last change: 2017 Jul 21

		     VIM USER MANUAL - by Bram Moolenaar

			     Moving around
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex usr_03.txt
@verbatim
*usr_03.txt*	For Vim バージョン 8.0.  Last change: 2017 Jul 21

		     VIM USER MANUAL - by Bram Moolenaar

			     カーソルの移動
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Before you can insert or delete text the cursor has to be moved to the right
place.  Vim has a large number of commands to position the cursor.  This
chapter shows you how to use the most important ones.  You can find a list of
these commands below |Q_lr|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文を入力したり削除したりするには、カーソルを目的の場所に動かさなくてはなりません。Vim にはカーソル移動のためのコマンドがたくさんあります。本章では、その中でも重要なコマンドの使い方を述べます。コマンドの一覧は |@ref{Q_lr}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|03.1|	Word movement
|03.2|	Moving to the start or end of a line
|03.3|	Moving to a character
|03.4|	Matching a parenthesis
|03.5|	Moving to a specific line
|03.6|	Telling where you are
|03.7|	Scrolling around
|03.8|	Simple searches
|03.9|	Simple search patterns
|03.10|	Using marks

     Next chapter: |usr_04.txt|  Making small changes
 Previous chapter: |usr_02.txt|  The first steps in Vim
Table of contents: |usr_toc.txt|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item |@ref{03.1}| @tab 単語ごとの移動
@item |@ref{03.2}| @tab 行頭、行末への移動
@item |@ref{03.3}| @tab 文字への移動
@item |@ref{03.4}| @tab カッコの対応
@item |@ref{03.5}| @tab 特定の行への移動
@item |@ref{03.6}| @tab 現在の場所を表示
@item |@ref{03.7}| @tab スクロール
@item |@ref{03.8}| @tab 簡単な検索
@item |@ref{03.9}| @tab 簡単なパターン検索
@item |@ref{03.10}| @tab マークの使用
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*03.1*	Word movement
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{03.1}
@section 単語ごとの移動
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To move the cursor forward one word, use the "w" command.  Like most Vim
commands, you can use a numeric prefix to move past multiple words.  For
example, "3w" moves three words.  This figure shows how it works:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カーソルを 1 単語先に進めるには、"@command{w}" コマンドを使います。他の Vim コマンドもそうですが、複数の単語を一気に進めるために数値 (カウンタ) による回数指定ができます。例えば、"@command{3w}" では 3 単語進みます。図で示すと次のようになります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	This is a line with example text ~
	  --->-->->----------------->
	   w  w  w    3w
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
This is a line with example text
  --->-->->----------------->
   w  w  w    3w
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Notice that "w" moves to the start of the next word if it already is at the
start of a word.
   The "b" command moves backward to the start of the previous word:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{w}" で次の単語の先頭に移動します。既にカーソルが単語の先頭にある場合は、その次の単語の先頭に移動します。逆に "@command{b}" コマンドで直前の単語の先頭に戻ります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	This is a line with example text ~
	<----<--<-<---------<---
	   b   b b    2b      b
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
This is a line with example text
<----<--<-<---------<---
   b   b b    2b      b
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There is also the "e" command that moves to the next end of a word and "ge",
which moves to the previous end of a word:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{e}" コマンドで次の単語の末尾に移動します。"@command{ge}" で直前の単語の末尾に移動します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	This is a line with example text ~
	   <-   <--- ----->   ---->
	   ge    ge     e       e
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
This is a line with example text
   <-   <--- ----->   ---->
   ge    ge     e       e
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you are at the last word of a line, the "w" command will take you to the
first word in the next line.  Thus you can use this to move through a
paragraph, much faster than using "l".  "b" does the same in the other
direction.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カーソルが行末の単語にある場合、"@command{w}" コマンドは次の行の最初の単語に進みます。これを使うと "@command{l}" よりもずっと速く文章の中を動けます。"@command{b}" は "@command{w}" の逆方向に同じルールで動きます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A word ends at a non-word character, such as a ".", "-" or ")".  To change
what Vim considers to be a word, see the 'iskeyword' option.  If you try this
out in the help directly, 'iskeyword' needs to be reset for the examples to
work: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
単語は @samp{.} や @samp{-}、@samp{)} といったアルファベット以外の文字で区切られます。Vim が何を単語とみなすかは、'@option{iskeyword}' オプションの設定で変更できます。ヘルプで直接試したい場合は正しく動作させる為に以下の様に '@option{iskeyword}' をリセットする必要があります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:set iskeyword&
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set iskeyword&
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
It is also possible to move by white-space separated WORDs.  This is not a
word in the normal sense, that's why the uppercase is used.  The commands for
moving by WORDs are also uppercase, as this figure shows:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
空白を区切りとした単語 (WORD) を移動することもできます。これは普段意識する単語 (word) とは若干違うため、大文字を使っています。WORD 単位で動くコマンドは全部大文字です。図で示すと次の通りです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	       ge      b	  w				e
	       <-     <-	 --->			       --->
	This is-a line, with special/separated/words (and some more). ~
	   <----- <-----	 -------------------->	       ----->
	     gE      B			 W			 E
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
       ge      b          w                             e
       <-     <-         --->                          --->
This is-a line, with special/separated/words (and some more).
   <----- <-----         -------------------->         ----->
     gE      B                   W                       E
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
With this mix of lowercase and uppercase commands, you can quickly move
forward and backward through a paragraph.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
小文字と大文字のコマンドを両方使うと、文章中をより素早く動けるようになります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*03.2*	Moving to the start or end of a line
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{03.2}
@section 行頭、行末への移動
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "$" command moves the cursor to the end of a line.  If your keyboard has
an <End> key it will do the same thing.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{$}" コマンドでカーソルを行末に移動します。キーボードに @key{<End>} キーがあれば、それも同じ意味で使えます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "^" command moves to the first non-blank character of the line.  The "0"
command (zero) moves to the very first character of the line.  The <Home> key
does the same thing.  In a picture:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{^}" コマンドでカーソルを行頭から最初の非空白文字に移動します。"@command{0}" (数字のゼロ) コマンドは行頭に移動します。@key{<Home>} キーも同じです。図で示しましょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		  ^
	     <------------
	.....This is a line with example text ~
	<-----------------   --------------->
		0		   $

(the "....." indicates blanks here)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
          ^
     <------------
.....This is a line with example text
<-----------------   --------------->
        0                  $

("....." は空白文字があることを示します)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
   The "$" command takes a count, like most movement commands.  But moving to
the end of the line several times doesn't make sense.  Therefore it causes the
editor to move to the end of another line.  For example, "1$" moves you to
the end of the first line (the one you're on), "2$" to the end of the next
line, and so on.
   The "0" command doesn't take a count argument, because the "0" would be
part of the count.  Unexpectedly, using a count with "^" doesn't have any
effect.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{$}" コマンドでも他の移動コマンドのようにカウンタの指定ができます。行末への移動を何度やっても意味がありませんので、"@command{$}" コマンドでのカウンタは他の行の行末への移動の意味になります。例えば、"@command{1$}" は "@command{$}" と同じで現在行の行末への移動ですが、"@command{2$}" は次の行末への移動、"@command{3$}" は 2 行下の行末への移動、となります。

"@command{0}" コマンドは回数指定できません。これは、"@command{0}" 自身が回数指定の一部になってしまうからです。"@command{^}" に回数指定をした場合は単に無視されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*03.3*	Moving to a character
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{03.3}
@section 文字への移動
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
One of the most useful movement commands is the single-character search
command.  The command "fx" searches forward in the line for the single
character x.  Hint: "f" stands for "Find".
   For example, you are at the beginning of the following line.  Suppose you
want to go to the h of human.  Just execute the command "fh" and the cursor
will be positioned over the h:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
特に便利な移動コマンドはいくつかありますが、一文字検索コマンドもその 1 つです。コマンド "@command{fx}" はその行にある文字 @samp{x} を前方検索します。(@strong{Hint:} f は Find の意味です)。

例えば、次の文の先頭にカーソルがあり、 @samp{human} の @samp{h} に移動したいとします。"@command{fh}" コマンドを実行すると、@samp{h} の上にカーソルが進みます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	To err is human.  To really foul up you need a computer. ~
	---------->--------------->
	    fh		 fy
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
To err is human.  To really foul up you need a computer.
---------->--------------->
    fh           fy
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This also shows that the command "fy" moves to the end of the word really.
   You can specify a count; therefore, you can go to the "l" of "foul" with
"3fl":
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
続いて、"@command{fy}" コマンドで @samp{really} の @samp{y} まで移動できます。これもカウンタ指定ができます。例えば次の文の @samp{foul} の @samp{l} に進むには "@command{3fl}" です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	To err is human.  To really foul up you need a computer. ~
		  --------------------->
			   3fl
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
To err is human.  To really foul up you need a computer.
          --------------------->
                   3fl
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "F" command searches to the left:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{F}" コマンドで左向きに検索できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	To err is human.  To really foul up you need a computer. ~
		  <---------------------
			    Fh
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
To err is human.  To really foul up you need a computer.
          <---------------------
                    Fh
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "tx" command works like the "fx" command, except it stops one character
before the searched character.  Hint: "t" stands for "To".  The backward
version of this command is "Tx".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{tx}" コマンドは "@command{fx}" コマンドに似た動きをしますが、検索した文字の上ではなく、その直前で止まります。(@strong{Hint:} t は To の意味です) このコマンドの逆方向版は "@command{Tx}" です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	To err is human.  To really foul up you need a computer. ~
		   <------------  ------------->
			Th		tn
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
To err is human.  To really foul up you need a computer.
           <------------  ------------->
                Th      tn
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These four commands can be repeated with ";".  "," repeats in the other
direction.  The cursor is never moved to another line.  Not even when the
sentence continues.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この 4 つのコマンドは "@command{;}" コマンドで繰り返せます。反対方向に繰り返すには "@command{,}" コマンドです。このコマンドは、カーソルが他の行に移動することはありません。文が次行に続いていても移動しません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Sometimes you will start a search, only to realize that you have typed the
wrong command.  You type "f" to search backward, for example, only to realize
that you really meant "F".  To abort a search, press <Esc>.  So "f<Esc>" is an
aborted forward search and doesn't do anything.  Note: <Esc> cancels most
operations, not just searches.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
検索をしようとして、コマンドを打ち間違うこともあるでしょう。例えば、逆方向検索のつもりで ("@command{F}" と打つべきところを) "@command{f}" と打ってしまったとしましょう。コマンドの実行を取り止めるには @key{<Esc>} を押します。"@command{f<Esc>}" は @key{<Esc>} を探すのではなく、コマンドをキャンセルします。
@quotation
@strong{Note:} @*
@key{<Esc>} は検索に限らず、ほとんどのコマンドをキャンセルするのに使えます。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*03.4*	Matching a parenthesis
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{03.4}
@section カッコの対応
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When writing a program you often end up with nested () constructs.  Then the
"%" command is very handy: It moves to the matching paren.  If the cursor is
on a "(" it will move to the matching ")".  If it's on a ")" it will move to
the matching "(".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プログラムを書いていると、入れ子になった @samp{()} を書くことがよくあります。そのような場合には、"@command{%}" コマンドがとても便利です。このコマンドを使うと対応するカッコに移動できます。カーソルが @samp{(} の上なら対応する @samp{)} に、@samp{)} の上なら対応する @samp{(} に移動できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			    %
			 <----->
		if (a == (b * c) / d) ~
		   <---------------->
			    %
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
            %
         <----->
if (a == (b * c) / d)
   <---------------->
            %
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This also works for [] and {} pairs.  (This can be defined with the
'matchpairs' option.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このコマンドは @samp{[]} や @samp{@{@}} のペアでも機能します。(これは '@option{matchpairs}' オプションで定義できます)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the cursor is not on a useful character, "%" will search forward to find
one.  Thus if the cursor is at the start of the line of the previous example,
"%" will search forward and find the first "(".  Then it moves to its match:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カーソルがカッコの上にない場合、"@command{%}" はまず前方検索をしてカッコを探します。上記の例文で行頭にカーソルがあった場合、"@command{%}" は前方検索をして @samp{(} を見つけ、それから、対応するカッコ @samp{)} に移動します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		if (a == (b * c) / d) ~
		---+---------------->
			   %
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
if (a == (b * c) / d)
---+---------------->
            %
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*03.5*	Moving to a specific line
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{03.5}
@section 特定の行への移動
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you are a C or C++ programmer, you are familiar with error messages such as
the following:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
C や C++ のプログラマであれば、次のようなパターンのエラーメッセージはおなじみでしょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	prog.c:33: j   undeclared (first use in this function) ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@display
prog.c:33: j   undeclared (first use in this function)
@end display
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This tells you that you might want to fix something on line 33.  So how do you
find line 33?  One way is to do "9999k" to go to the top of the file and "32j"
to go down thirty-two lines.  It is not a good way, but it works.  A much
better way of doing things is to use the "G" command.  With a count, this
command positions you at the given line number.  For example, "33G" puts you
on line 33.  (For a better way of going through a compiler's error list, see
|usr_30.txt|, for information on the :make command.)
   With no argument, "G" positions you at the end of the file.  A quick way to
go to the start of a file use "gg".  "1G" will do the same, but is a tiny bit
more typing.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
何か 33 行目に修正しないといけない点がありそうです。では、どうやって 33 行目に移動しましょうか？ "@command{9999k}" などとしてファイルの先頭まで移動してから、"@command{32j}" で 32 行下に移動するやり方もあります。確かに目的は達しますが、あまりいい方法とは思えません。そこで "@command{G}" というコマンドを使います。このコマンドにカウンタを指定すると、その行にジャンプできます。例えば、"@command{33G}" とすれば、33 行目にジャンプできます。(実はコンパイラのエラーリストを使ってもっと簡単に移動する方法もあります。|@ref{usr_30.txt}| の "@command{:make}" コマンドをご覧ください。)

カウンタを指定しなかった場合はファイルの最終行にジャンプします。ファイルの先頭にジャンプするには "@command{gg}" を使います。"@command{1G}" でも同じですが、ちょっと打ちにくいですから。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	    |	first line of a file   ^
	    |	text text text text    |
	    |	text text text text    |  gg
	7G  |	text text text text    |
	    |	text text text text
	    |	text text text text
	    V	text text text text    |
		text text text text    |  G
		text text text text    |
		last line of a file    V
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
    |   first line of a file   ^
    |   text text text text    |
    |   text text text text    |  gg
7G  |   text text text text    |
    |   text text text text
    |   text text text text
    V   text text text text    |
        text text text text    |  G
        text text text text    |
        last line of a file    V
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Another way to move to a line is using the "%" command with a count.  For
example "50%" moves you to halfway the file.  "90%" goes to near the end.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
特定行に移動するもう 1 つの方法はカウンタ付きの "@command{%}" コマンドです。例えば、"@command{50%}" でファイルの真ん中に移動できます。"@command{90%}" ならファイルのほぼ最後 (90% の場所) に移動します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The previous assumes that you want to move to a line in the file, no matter if
it's currently visible or not.  What if you want to move to one of the lines
you can see?  This figure shows the three commands you can use:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以上述べたのは、画面上に見えているかどうかに関係なくファイルの特定行に移動したい場合のコマンドでした。では画面上に見えている行に移動したい場合はどうしましょうか？そういう時に使える 3 つのコマンドを下図に示します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			+---------------------------+
		H -->	| text sample text	    |
			| sample text		    |
			| text sample text	    |
			| sample text		    |
		M -->	| text sample text	    |
			| sample text		    |
			| text sample text	    |
			| sample text		    |
		L -->	| text sample text	    |
			+---------------------------+

Hints: "H" stands for Home, "M" for Middle and "L" for Last.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
        +---------------------------+
H -->   | text sample text          |
        | sample text               |
        | text sample text          |
        | sample text               |
M -->   | text sample text          |
        | sample text               |
        | text sample text          |
        | sample text               |
L -->   | text sample text          |
        +---------------------------+
@end verbatim
(@strong{Hint:} "H" は Home、"M" は Middle、"L" は Last の意味です)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*03.6*	Telling where you are
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{03.6}
@section 現在の場所を表示
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To see where you are in a file, there are three ways:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイル中の現在の場所を知るには、次の 3 つの方法があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1.  Use the CTRL-G command.  You get a message like this (assuming the 'ruler'
    option is off):

	"usr_03.txt" line 233 of 650 --35%-- col 45-52 ~

    This shows the name of the file you are editing, the line number where the
    cursor is, the total number of lines, the percentage of the way through
    the file and the column of the cursor.
       Sometimes you will see a split column number.  For example, "col 2-9".
    This indicates that the cursor is positioned on the second character, but
    because character one is a tab, occupying eight spaces worth of columns,
    the screen column is 9.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item
@command{CTRL-G} コマンド。次のようなメッセージが表示されます。('@option{ruler}' オプションがオフの場合)

@verbatim
"usr_03.txt" line 233 of 650 --35%-- col 45-52
@end verbatim

編集中のファイル名、カーソルのある行番号、全体の行数、ファイル全体を通してのパーセント、カーソル桁位置、を表示します。場合によっては、カーソル桁位置が 2 つに分けて表示されます。

例えば、@samp{col 2-9} の場合、カーソルは 2 文字目にあります。2 文字のうち、1 文字がタブ文字で、8 文字分で表示されているため、画面上では 9 桁目にある、ということです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
2.  Set the 'number' option.  This will display a line number in front of
    every line: >

	:set number
<
    To switch this off again: >

	:set nonumber
<
    Since 'number' is a boolean option, prepending "no" to its name has the
    effect of switching it off.  A boolean option has only these two values,
    it is either on or off.
       Vim has many options.  Besides the boolean ones there are options with
    a numerical value and string options.  You will see examples of this where
    they are used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
'@option{number}' オプションを設定する。行頭に行番号が表示されるようになります:

@example
:set number
@end example

オプションをオフに戻すには:

@example
:set nonumber
@end example

'@option{number}' は論理値オプションなので、オプション名の先頭に @samp{no} をつければオフにできます。論理値オプションにはオンかオフの 2 つの状態しかありません。Vim には多数のオプションがあります。論理値オプションの他に、数値オプションと文字列オプションがあります。それらのオプションの設定方法はそのうち説明します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
3.  Set the 'ruler' option.  This will display the cursor position in the
    lower right corner of the Vim window: >

	:set ruler

Using the 'ruler' option has the advantage that it doesn't take much room,
thus there is more space for your text.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
'@option{ruler}' オプションを設定する。現在のカーソル位置が、Vim ウィンドウの右下隅に表示されるようになります:

@example
:set ruler
@end example

'@option{ruler}' は表示に場所を取らないので、画面を広く使えます。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*03.7*	Scrolling around
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{03.7}
@section スクロール
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The CTRL-U command scrolls down half a screen of text.  Think of looking
through a viewing window at the text and moving this window up by half the
height of the window.  Thus the window moves up over the text, which is
backward in the file.  Don't worry if you have a little trouble remembering
which end is up.  Most users have the same problem.
   The CTRL-D command moves the viewing window down half a screen in the file,
thus scrolls the text up half a screen.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{CTRL-U}" コマンドで画面の半分だけ下にスクロールします。窓を通してテキストを見ていて、その窓を高さの半分だけ上に動かす、と考えてください。窓が上に動き、さっきより上の位置のテキストが表示されます。

どっちが上でどっちが下かわかりにくいかと思いますが、気にすることはありません。みんな同じように悩むことですから。"@command{CTRL-D}" コマンドは窓を半分だけ下げます。つまりテキストが画面の半分だけ上にスクロールすることになります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				       +----------------+
				       | some text	|
				       | some text	|
				       | some text	|
	+---------------+	       | some text	|
	| some text	|  CTRL-U  --> |		|
	|		|	       | 123456		|
	| 123456	|	       +----------------+
	| 7890		|
	|		|	       +----------------+
	| example	|  CTRL-D -->  | 7890		|
	+---------------+	       |		|
				       | example	|
				       | example	|
				       | example	|
				       | example	|
				       +----------------+
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
                               +----------------+
                               | some text      |
                               | some text      |
                               | some text      |
+---------------+              | some text      |
| some text     |  CTRL-U  --> |                |
|               |              | 123456         |
| 123456        |              +----------------+
| 7890          |
|               |              +----------------+
| example       |  CTRL-D -->  | 7890           |
+---------------+              |                |
                               | example        |
                               | example        |
                               | example        |
                               | example        |
                               +----------------+
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To scroll one line at a time use CTRL-E (scroll up) and CTRL-Y (scroll down).
Think of CTRL-E to give you one line Extra.  (If you use MS-Windows compatible
key mappings CTRL-Y will redo a change instead of scroll.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
1 行だけスクロールするには "@command{CTRL-E}" (スクロールアップ)と "@command{CTRL-Y}" (スクロールダウン) を使います。(MS-Windows 互換のキーマップをお使いの場合、"@command{CTRL-Y}" はスクロールではなく、redo コマンドとなります)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To scroll forward by a whole screen (except for two lines) use CTRL-F.  The
other way is backward, CTRL-B is the command to use.  Fortunately CTRL-F is
Forward and CTRL-B is Backward, that's easy to remember.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
1 画面分スクロールするには "@command{CTRL-F}" を使います(2 行は重複します)。逆方向へのスクロールは "@command{CTRL-B}" コマンドを使います。"@command{CTRL-F}" は Forward、"@command{CTRL-B}" は Backward、ですから覚えやすいでしょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A common issue is that after moving down many lines with "j" your cursor is at
the bottom of the screen.  You would like to see the context of the line with
the cursor.  That's done with the "zz" command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{j}" で何行も下に移動して、カーソルが画面の最下段にあるとします。カーソル前後の行を表示したい場合は "@command{zz}" コマンドを使います。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	+------------------+		 +------------------+
	| some text	   |		 | some text	    |
	| some text	   |		 | some text	    |
	| some text	   |		 | some text	    |
	| some text	   |   zz  -->	 | line with cursor |
	| some text	   |		 | some text	    |
	| some text	   |		 | some text	    |
	| line with cursor |		 | some text	    |
	+------------------+		 +------------------+
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
+------------------+             +------------------+
| some text        |             | some text        |
| some text        |             | some text        |
| some text        |             | some text        |
| some text        |   zz  -->   | line with cursor |
| some text        |             | some text        |
| some text        |             | some text        |
| line with cursor |             | some text        |
+------------------+             +------------------+
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "zt" command puts the cursor line at the top, "zb" at the bottom.  There
are a few more scrolling commands, see |Q_sc|.  To always keep a few lines of
context around the cursor, use the 'scrolloff' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{zt}" コマンドでカーソル行を画面の 1 行目として表示できます。"@command{zb}" コマンドなら画面の最下段です。これ以外にもいくつかスクロールコマンドがあります。|@ref{Q_sc}| を参照してください。カーソル近辺の数行を常に表示させたい場合は、'@option{scrolloff}' オプションを使ってください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*03.8*	Simple searches
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{03.8}
@section 簡単な検索
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To search for a string, use the "/string" command.  To find the word include,
for example, use the command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列を検索するには "@command{/string}" コマンドを使います。例えば、@samp{include} という単語を探したいのであれば、次のように使います。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	/include
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
/include
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You will notice that when you type the "/" the cursor jumps to the last line
of the Vim window, like with colon commands.  That is where you type the word.
You can press the backspace key (backarrow or <BS>) to make corrections.  Use
the <Left> and <Right> cursor keys when necessary.
   Pressing <Enter> executes the command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@key{/} を押すと、コマンドラインモードのときのように、カーソルが Vim ウィンドウの最下段に移動します。そこで検索したい単語を入力します。入力した文字を訂正するには、バックスペースキー (左矢印 または @key{<BS>}) を使います。必要に応じて @key{<Left>} や @key{<Right>} の矢印キーを使ってください。@key{<Enter>} を押すとコマンドが実行されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Note:
	The characters .*[]^%/\?~$ have special meanings.  If you want to use
	them in a search you must put a \ in front of them.  See below.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
文字のうち、@samp{.*[]^%/\?~$} には特別な意味があります。検索時にこれらを使う場合はその文字の直前に @samp{\} を置いてください。これは後 (|@ref{03.9}| の最後)で述べます。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To find the next occurrence of the same string use the "n" command.  Use this
to find the first #include after the cursor: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
同じ文字列をもう一度探したい場合には "@command{n}" コマンドを使います。今のカーソル位置の後ろにある @samp{#include} を探すには次のコマンドを使います。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	/#include
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
/#include
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
And then type "n" several times.  You will move to each #include in the text.
You can also use a count if you know which match you want.  Thus "3n" finds
the third match.  Using a count with "/" doesn't work.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次に @key{n} を数回押すと、順々に @samp{#include} にジャンプします。移動したい場所が何個目かわかっているなら、カウンタも使えます。例えば、"@command{3n}" なら 3 つ目の @samp{#include} を探します。"@command{/}" にはカウンタを指定できません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "?" command works like "/" but searches backwards: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{?}" コマンドは "@command{/}" と同じですが、逆方向に検索します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	?word
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
?word
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "N" command repeats the last search the opposite direction.  Thus using
"N" after a "/" command searches backwards, using "N" after "?" searches
forward.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{N}" コマンドは直前の検索とは反対の方向に検索を繰り返します。"@command{/}" の後で "@command{N}" を使うと後方検索になり、"@command{?}" の後で "@command{N}" を使うと前方検索になります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
IGNORING CASE
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 大文字/小文字の無視
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Normally you have to type exactly what you want to find.  If you don't care
about upper or lowercase in a word, set the 'ignorecase' option: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
普通は探したい文字列の大文字/小文字を正確に指定しなければなりません。大文字と小文字を区別したくないのであれば、'@option{ignorecase}' オプションを設定します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set ignorecase
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set ignorecase
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you now search for "word", it will also match "Word" and "WORD".  To match
case again: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これで、@samp{word} を検索すると、@samp{Word} も @samp{WORD} もヒットします。大文字/小文字を区別するように戻すのは次のコマンドです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set noignorecase
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set noignorecase
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
HISTORY
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec ヒストリ(履歴)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Suppose you do three searches: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のような 3 つの検索を行ったとします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	/one
	/two
	/three
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
/one
/two
/three
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now let's start searching by typing a simple "/" without pressing <Enter>.  If
you press <Up> (the cursor key), Vim puts "/three" on the command line.
Pressing <Enter> at this point searches for three.  If you do not press
<Enter>, but press <Up> instead, Vim changes the prompt to "/two".  Another
press of <Up> moves you to "/one".
   You can also use the <Down> cursor key to move through the history of
search commands in the other direction.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
さて、"@command{/}" だけを入力し、まだ @key{<Enter>} を押さないでください。@key{<Up>} (上矢印キー)を押すと、コマンド行に @samp{/three} と表示されます。ここで @key{<Enter>} を押すと、@samp{three} が検索されます。@key{<Enter>} を押さずに @key{<Up>} を押すとコマンド行には @samp{/two} と表示されます。さらに @key{<Up>} を押すと @samp{/one} となります。

同じように @key{<Down>} キーを使って逆方向に検索ヒストリを移動できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you know what a previously used pattern starts with, and you want to use it
again, type that character before pressing <Up>.  With the previous example,
you can type "/o<Up>" and Vim will put "/one" on the command line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以前に使ったパターンを覚えていて、それをまた使いたい場合には、そのパターンの先頭文字を入力してから @key{<Up>} を押してください。上の例で言えば、"@command{/o}@key{<Up>}" と入力すると、コマンドラインに @samp{/one} と表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The commands starting with ":" also have a history.  That allows you to recall
a previous command and execute it again.  These two histories are separate.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:}" で始まるコマンドにもヒストリがあります。以前のコマンドを呼び出して、再実行できます。検索用ヒストリと "@command{:}" コマンドヒストリは分かれています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
SEARCHING FOR A WORD IN THE TEXT
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 文章中の単語の検索
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Suppose you see the word "TheLongFunctionName" in the text and you want to
find the next occurrence of it.  You could type "/TheLongFunctionName", but
that's a lot of typing.  And when you make a mistake Vim won't find it.
   There is an easier way: Position the cursor on the word and use the "*"
command.  Vim will grab the word under the cursor and use it as the search
string.
   The "#" command does the same in the other direction.  You can prepend a
count: "3*" searches for the third occurrence of the word under the cursor.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@samp{TheLongFunctionName} という単語が文章中にあり、次に現れる場所を探したいとします。もちろん、"@command{/TheLongFunctionName}" として検索もできますが、たくさんの打鍵が必要です。それに、打ち間違えてしまうとうまく検索できません。

もっと簡単な方法があります。探したい単語の上にカーソルを置いて、"@command{*}" コマンドを使うのです。カーソル位置の単語が抜き出され、それが検索文字列として使われます。

"@command{#}" コマンドは同じことを逆方向に実行します。このコマンドもカウンタが指定できます。例えば、"@command{3*}" はカーソル位置の単語が 3 回目に現われる場所を探します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
SEARCHING FOR WHOLE WORDS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 単語全体を一致させる検索
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you type "/the" it will also match "there".  To only find words that end
in "the" use: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{/the}" と検索を行うと、@samp{there} などもヒットします。@samp{the} で終わる単語だけを探したい場合には次のようにします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	/the\>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
/the\>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "\>" item is a special marker that only matches at the end of a word.
Similarly "\<" only matches at the beginning of a word.  Thus to search for
the word "the" only: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@samp{\>} というのは特別なマーカーで、単語がここで終わっている時だけヒットします。同じように @samp{\<} は単語の始まりにだけヒットします。つまり、@samp{the} という単語だけを探したい場合は、次のようにします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	/\<the\>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
/\<the\>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This does not match "there" or "soothe".  Notice that the "*" and "#" commands
use these start-of-word and end-of-word markers to only find whole words (you
can use "g*" and "g#" to match partial words).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これだと、@samp{there} とか @samp{soothe} にはヒットしません。なお、"@command{*}" と "@command{#}" コマンドは上の「単語の先頭」と「単語の末尾」マーカーを使って、完全に一致する単語だけを探します。(単語の一部として検索したい時は "@command{g*}" と "@command{g#}" コマンドを使います)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
HIGHLIGHTING MATCHES
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 検索結果の強調表示
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
While editing a program you see a variable called "nr".  You want to check
where it's used.  You could move the cursor to "nr" and use the "*" command
and press "n" to go along all the matches.
   There is another way.  Type this command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プログラムの編集中に、@samp{nr} という変数を見つけ、その変数がどこで使われているかを知りたいとします。@samp{nr} の上にカーソルを移動して、"@command{*}" と "@command{n}" コマンドで片っ端から探すのもいいですが、他にも方法があります。次のコマンドを入力してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set hlsearch
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set hlsearch
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you now search for "nr", Vim will highlight all matches.  That is a very
good way to see where the variable is used, without the need to type commands.
   To switch this off: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@samp{nr} を検索すると、ヒットした全てのパターンが強調表示されます。これなら余計なコマンド入力が必要ないので、変数の使用箇所を確認したいときには便利です。このオプションは次のコマンドでオフにできます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set nohlsearch
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set nohlsearch
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Then you need to switch it on again if you want to use it for the next search
command.  If you only want to remove the highlighting, use this command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
さて上のやり方では、検索を行うたびに、いちいちオプションの切替えが必要になります。単に強調表示を止めるだけなら、次のコマンドを使ってください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:nohlsearch
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:nohlsearch
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This doesn't reset the option.  Instead, it disables the highlighting.  As
soon as you execute a search command, the highlighting will be used again.
Also for the "n" and "N" commands.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これならオプションはオフになりません。強調表示だけを取り消せます。次に検索コマンドを実行すると、再び強調表示されます。"@command{n}" や "@command{N}" を使ったときも同様です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
TUNING SEARCHES
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 検索のチューニング
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are a few options that change how searching works.  These are the
essential ones:
>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
検索の挙動を変更するオプションがいくつかあります。重要なのは次のものです:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:set incsearch
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set incsearch
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This makes Vim display the match for the string while you are still typing it.
Use this to check if the right match will be found.  Then press <Enter> to
really jump to that location.  Or type more to change the search string.
>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはいわゆるインクリメンタルサーチです。検索したい文字を入力している間にもヒットする文字列を探して画面に表示してくれます。これはヒットするパターンがあるかどうかのチェックに使えます。@key{<Enter>} を押すと実際にその場所にカーソルがジャンプします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:set nowrapscan
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set nowrapscan
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This stops the search at the end of the file.  Or, when you are searching
backwards, at the start of the file.  The 'wrapscan' option is on by default,
thus searching wraps around the end of the file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルの末尾まで進んだら(後方検索の場合はファイルの先頭まで戻ったら)検索を停止します。'@option{wrapscan}' オプションの初期設定はオンです。オンの場合は、ファイルの末尾まで進んだら先頭に戻って検索を続けます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
INTERMEZZO
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec ところで...
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you like one of the options mentioned before, and set it each time you use
Vim, you can put the command in your Vim startup file.
   Edit the file, as mentioned at |not-compatible|.  Or use this command to
find out where it is: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これまでに出てきたオプションを毎回設定したい場合は、スタートアップファイルにそのコマンドを書いてください。|@ref{not-compatible}| の説明のとおりにファイルを編集するか、次のコマンドを入力して、ファイルがどこにあるか確認してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:scriptnames
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:scriptnames
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Edit the file, for example with: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルを編集するには、例えば次のようにします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:edit ~/.vimrc
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:edit ~/.vimrc
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Then add a line with the command to set the option, just like you typed it in
Vim.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
そして、オプションを設定するために Vim 上で実行したのと同じコマンドを書き加えます。例えば、次のようにします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Go:set hlsearch<Esc>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
Go:set hlsearch@key{<Esc>}
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
"G" moves to the end of the file.  "o" starts a new line, where you type the
":set" command.  You end insert mode with <Esc>.  Then write the file: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{G}" でファイルの末尾まで移動し、"@command{o}" で新しい行を挿入して "@command{:set}" コマンドを書くための空行を作っています。挿入モードの終了は @key{<Esc>} です。そして、ファイルを保存しましょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	ZZ
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
ZZ
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you now start Vim again, the 'hlsearch' option will already be set.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次に Vim を起動すると、'@option{hlsearch}' オプションが最初からオンになっています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*03.9*	Simple search patterns
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{03.9}
@section 簡単なパターン検索
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The Vim editor uses regular expressions to specify what to search for.
Regular expressions are an extremely powerful and compact way to specify a
search pattern.  Unfortunately, this power comes at a price, because regular
expressions are a bit tricky to specify.
   In this section we mention only a few essential ones.  More about search
patterns and commands in chapter 27 |usr_27.txt|.  You can find the full
explanation here: |pattern|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim では、検索に正規表現 (regular expressions) を使います。正規表現というのは検索パターンを指定するための、極めてパワフルでシンプルな方法です。残念ながら、これの実力を発揮させるには少々苦労していただくことになります。

というのも、正規表現はちょっとばかりトリッキーなんです。ここでは本当に基本的なものだけを述べます。パターン検索とコマンドについては 27 章 |@ref{usr_27.txt}| でもっと詳しく説明します。完全な説明は |@ref{pattern}| にあります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
BEGINNING AND END OF A LINE
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 行頭と行末
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The ^ character matches the beginning of a line.  On an English-US keyboard
you find it above the 6.  The pattern "include" matches the word include
anywhere on the line.  But the pattern "^include" matches the word include
only if it is at the beginning of a line.
   The $ character matches the end of a line.  Therefore, "was$" matches the
word was only if it is at the end of a line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@samp{^} は行頭を示します。英語 (ASCII) キーボードでは 6 のキーに、日本語 (JIS) キーボードでは @key{0} のキーの 2 つ右側に刻印してあります。例えば、"@command{include}" というパターンは 行のどこかに @samp{include} という単語を含んでいれば、ヒットします。一方、"@command{^include}" は行頭にある @samp{include} にだけマッチします。

"@samp{$}" は同様に行末にヒットします。ですから、パターン "@command{was$}" は、行末が @samp{was} で終わっている場合だけヒットします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Let's mark the places where "/the" matches in this example line with "x"s:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
下の例では、@samp{/the} にマッチする箇所を @samp{xxx} で示しています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	the solder holding one of the chips melted and the ~
	xxx			  xxx		       xxx
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
the solder holding one of the chips melted and the
xxx                       xxx                  xxx
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Using "/the$" we find this match:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{/the$}" の場合は次のようになります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	the solder holding one of the chips melted and the ~
						       xxx
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
the solder holding one of the chips melted and the
                                               xxx
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
And with "/^the" we find this one:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{/^the}" の場合はこうです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	the solder holding one of the chips melted and the ~
	xxx
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
the solder holding one of the chips melted and the
xxx
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can try searching with "/^the$", it will only match a single line
consisting of "the".  White space does matter here, thus if a line contains a
space after the word, like "the ", the pattern will not match.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{/^the$}" という指定もできます。この指定だと、@samp{the} という単語だけの行にヒットします。なお空白文字も意味を持ちます。ですから、@samp{the } のように行末に空白文字を含んでいた場合は、"@command{/the$}" のパターンではヒットしません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MATCHING ANY SINGLE CHARACTER
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 任意の 1 文字
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The . (dot) character matches any existing character.  For example, the
pattern "c.m" matches a string whose first character is a c, whose second
character is anything, and whose third character is m.  Example:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{.}" はあらゆる文字にヒットします。例えば、"@command{c.m}" は最初が @samp{c} で始まり、2 文字目は何でも良くて、3 文字目が @samp{m} であるパターンにヒットします。例を示します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	We use a computer that became the cummin winter. ~
		 xxx		 xxx	  xxx
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
We use a computer that became the cummin winter.
         xxx             xxx      xxx
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MATCHING SPECIAL CHARACTERS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 特殊文字
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you really want to match a dot, you must avoid its special meaning by
putting a backslash before it.
   If you search for "ter.", you will find these matches:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば @samp{.} という文字自体を探す時は、上で述べたような特殊な意味を @samp{\} 文字を使って無効にします。

"@samp{ter.}" というパターンで検索をすると、次の @samp{xxx} の箇所でヒットします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	We use a computer that became the cummin winter. ~
		      xxxx			    xxxx
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
We use a computer that became the cummin winter.
              xxxx                          xxxx
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Searching for "ter\." only finds the second match.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これを @samp{ter\.} で検索すると、上図の 2 つ目だけがヒットします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*03.10*	Using marks
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{03.10}
@section マークの使用
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you make a jump to a position with the "G" command, Vim remembers the
position from before this jump.  This position is called a mark.  To go back
where you came from, use this command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{G}" コマンドでジャンプすると、その直前のカーソル位置が記録されます。これをマークと呼びます。元の場所に戻るには、次のコマンドを使います。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	``
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
``
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This ` is a backtick or open single-quote character.
   If you use the same command a second time you will jump back again.  That's
because the ` command is a jump itself, and the position from before this jump
is remembered.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この @samp{`} は backtick とか open single-quote と呼ばれる (訳注: 日本では「バッククォート」が多いでしょうか)ものです。このコマンドを 2 回実行すると、元の場所に戻ります。これは "@command{`}" コマンドもジャンプコマンドなので、実行前の場所が記録されるためです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Generally, every time you do a command that can move the cursor further than
within the same line, this is called a jump.  This includes the search
commands "/" and "n" (it doesn't matter how far away the match is).  But not
the character searches with "fx" and "tx" or the word movements "w" and "e".
   Also, "j" and "k" are not considered to be a jump.  Even when you use a
count to make them move the cursor quite a long way away.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
通常、現在行以外にカーソルが動くようなコマンドを実行した場合、それをジャンプと呼びます。"@command{/}" や "@command{n}" もジャンプの一種です(ジャンプ先がどれだけ離れているかは関係ありません)。逆に、文字検索である "@command{fx}" や "@command{tx}"、単語移動である "@command{w}" や "@command{e}" はジャンプではありません。

"@command{j}" や "@command{k}" はカウンタを指定すればカーソルをはるか彼方に移動できますが、これもジャンプ扱いではありません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The `` command jumps back and forth, between two points.  The CTRL-O command
jumps to older positions (Hint: O for older).  CTRL-I then jumps back to newer
positions (Hint: I is just next to O on the keyboard).  Consider this sequence
of commands: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{``}" コマンドは 2 個所の間を交互にジャンプします。@command{CTRL-O} コマンドはより古いマーク(@strong{Hint:} O は Older の意味です)にジャンプします。@command{CTRL-I} はより新しいマーク(@strong{Hint:} @key{I} キーは @key{O} キーのすぐ左隣りです)にジャンプします。次のコマンドを例にしましょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	33G
	/^The
	CTRL-O
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
33G
/^The
CTRL-O
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You first jump to line 33, then search for a line that starts with "The".
Then with CTRL-O you jump back to line 33.  Another CTRL-O takes you back to
where you started.  If you now use CTRL-I you jump to line 33 again.  And
to the match for "The" with another CTRL-I.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
まず 33 行目にジャンプします。次に @samp{The} で始まる行を探します。ここで @command{CTRL-O} を使うと、33 行目に戻ります。もう一度 @command{CTRL-O} を使うと、最初の場所に戻ります。そして、@command{CTRL-I} を使うと 33 行目にジャンプし、さらに @command{CTRL-I} を使うと行頭が @samp{The} で始まる行にジャンプします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
	     |	example text   ^	     |
	33G  |	example text   |  CTRL-O     | CTRL-I
	     |	example text   |	     |
	     V	line 33 text   ^	     V
	     |	example text   |	     |
       /^The |	example text   |  CTRL-O     | CTRL-I
	     V	There you are  |	     V
		example text
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
      |  example text   ^             |
 33G  |  example text   |  CTRL-O     | CTRL-I
      |  example text   |             |
      V  line 33 text   ^             V
      |  example text   |             |
/^The |  example text   |  CTRL-O     | CTRL-I
      V  There you are  |             V
         example text
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Note:
	CTRL-I is the same as <Tab>.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
@kbd{CTRL-I} は @key{<Tab>} キーと同じです。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The ":jumps" command gives a list of positions you jumped to.  The entry which
you used last is marked with a ">".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:jumps}" コマンドで今までにジャンプした場所の一覧を表示できます。最後に使ったエントリには "@samp{>}" 記号がついています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
NAMED MARKS							*bookmark*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{bookmark}
@cindex bookmark
@unnumberedsubsec 名前付きマーク
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim enables you to place your own marks in the text.  The command "ma" marks
the place under the cursor as mark a.  You can place 26 marks (a through z) in
your text.  You can't see them, it's just a position that Vim remembers.
   To go to a mark, use the command `{mark}, where {mark} is the mark letter.
Thus to move to the a mark:
>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文章中にマークを付けることができます。"@command{ma}" コマンドで現在のカーソル位置をマーク @var{a} に記録します。文章には 26 個 (aからzまで) のマークを付けられます。マークは Vim が記録している位置情報です。画面に何かが表示されるわけではありません。

マークへの移動は "@command{`@{mark@}}" コマンドを使います。@samp{@{mark@}} はマーク文字のことです。マーク @var{a} に移動するには次のようにします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	`a
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
`a
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The command 'mark (single quotation mark, or apostrophe) moves you to the
beginning of the line containing the mark.  This differs from the `mark
command, which moves you to marked column.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{'@{mark@}}" (アポストロフィ + マーク名)コマンドで @samp{@{mark@}} を設定してある行の行頭に移動できます。"@command{`@{mark@}}" の場合は @samp{@{mark@}} を設定した桁位置に移動します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The marks can be very useful when working on two related parts in a file.
Suppose you have some text near the start of the file you need to look at,
while working on some text near the end of the file.
   Move to the text at the start and place the s (start) mark there: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マーク機能はファイル中の関連している 2 箇所で作業をする場合に便利です。例えば、ファイルの最後の方を編集している時に、ファイルの最初の方の内容を確認する必要が生じた場合を考えてみましょう。

まずファイルの最初の方に移動して、マーク @var{s} (startのつもり) を付けます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	ms
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
ms
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Then move to the text you want to work on and put the e (end) mark there: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次に編集したい場所に移動して、マーク @var{e} (endのつもり) を付けます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	me
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
me
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now you can move around, and when you want to look at the start of the file,
you use this to jump there: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これで自由に行き来ができます。ファイルの先頭に移動したい時は、次のコマンドでジャンプできます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	's
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
's
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Then you can use '' to jump back to where you were, or 'e to jump to the text
you were working on at the end.
   There is nothing special about using s for start and e for end, they are
just easy to remember.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここで、"@command{''}" を使って戻ることもできますし、"@command{'e}" を使って末尾のマークまでジャンプすることもできます。

先頭にマーク @var{s} を、末尾にマーク @var{e} を使いましたが、その名前に特別な意味はありません。単に覚えやすいから使っただけです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use this command to get a list of marks: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のコマンドは設定してあるマークの一覧を表示します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:marks
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:marks
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You will notice a few special marks.  These include:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この一覧には次のような特殊なマークも表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	'	The cursor position before doing a jump
	"	The cursor position when last editing the file
	[	Start of the last change
	]	End of the last change
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item @var{'} @tab ジャンプする直前のカーソル位置
@item @var{"} @tab 直前にファイルを編集した時のカーソル位置
@item @var{[} @tab 直前の変更の開始位置
@item @var{]} @tab 直前の変更の終了位置
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================

Next chapter: |usr_04.txt|  Making small changes

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
@end ifset
