@ifset JA  @c ----------- v -----------  JA  -*- tab-width: 8 -*-
@node insert.txt, , , 目次
@unnumbered 挿入モードと置換モード
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*insert.txt*    For Vim version 8.1.  Last change: 2018 Feb 10


		  VIM REFERENCE MANUAL    by Bram Moolenaar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
*insert.txt*    For Vim バージョン 8.1.  Last change: 2018 Feb 10


		  VIMリファレンスマニュアル    by Bram Moolenaar
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
						*Insert* *Insert-mode*
Inserting and replacing text				*mode-ins-repl*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Insert}
@anchor{Insert-mode}
@anchor{mode-ins-repl}
@cindex Insert
@cindex Insert-mode
@cindex mode-ins-repl
@cindex テキストの挿入と置換
@section テキストの挿入と置換
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Most of this file is about Insert and Replace mode.  At the end are a few
commands for inserting text in other ways.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このファイルの大部分は挿入と置換モードについて記述してある。終わりのほうにテキストを挿入する別の方法を記述している。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An overview of the most often used commands can be found in chapter 24 of the
user manual |usr_24.txt|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
よく使われるコマンドの概要がユーザーマニュアルの 24 章 |@ref{usr_24.txt}| にある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. Special keys						|ins-special-keys|
2. Special special keys					|ins-special-special|
3. 'textwidth' and 'wrapmargin' options			|ins-textwidth|
4. 'expandtab', 'smarttab' and 'softtabstop'  options	|ins-expandtab|
5. Replace mode						|Replace-mode|
6. Virtual Replace mode					|Virtual-Replace-mode|
7. Insert mode completion				|ins-completion|
8. Insert mode commands					|inserting|
9. Ex insert commands					|inserting-ex|
10. Inserting a file					|inserting-file|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .6 .4
@item 1. 特別なキー @tab |@ref{ins-special-keys}|
@item 2. もっと特別なキー @tab |@ref{ins-special-special}|
@item 3. '@option{textwidth}' と '@option{wrapmargin}' オプション @tab |@ref{ins-textwidth}|
@item 4. '@option{expandtab}', '@option{smarttab}' それと '@option{softtabstop}' オプション @tab |@ref{ins-expandtab}|
@item 5. 置換モード @tab |@ref{Replace-mode}|
@item 6. 仮想置換モード @tab |@ref{Virtual-Replace-mode}|
@item 7. 挿入モードの補完 @tab |@ref{ins-completion}|
@item 8. 挿入モードのコマンド @tab |@ref{inserting}|
@item 9. Ex の挿入コマンド @tab |@ref{inserting-ex}|
@item 10. ファイルを挿入する @tab |@ref{inserting-file}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Also see 'virtualedit', for moving the cursor to positions where there is no
character.  Useful for editing a table.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字のない場所にカーソルと移動するためには '@option{virtualedit}' も参照すること。表を編集するときに便利である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
1. Special keys						*ins-special-keys*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ins-special-keys}
@cindex ins-special-keys
@cindex 特別なキー
@section 1. 特別なキー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In Insert and Replace mode, the following characters have a special meaning;
other characters are inserted directly.  To insert one of these special
characters into the buffer, precede it with CTRL-V.  To insert a <Nul>
character use "CTRL-V CTRL-@" or "CTRL-V 000".  On some systems, you have to
use "CTRL-V 003" to insert a CTRL-C.  Note: When CTRL-V is mapped you can
often use CTRL-Q instead |i_CTRL-Q|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
挿入と置換モードでは、以下の文字には特別な意味がある。その他の文字はそのまま入力される。それらの特別な文字をバッファに入力するには、@kbd{CTRL-V} に続けて入力する。<Nul> 文字を入力するには "@kbd{CTRL-V} @kbd{CTRL-@@}" か "@kbd{CTRL-V} 000" を使用する。あるシステムでは、@kbd{CTRL-C} を入力するのに "@kbd{CTRL-V} 003" を使わなければならない。
@quotation
@strong{Note:} @*
@kbd{CTRL-V} に他の動作がマップされているときは、多くの場合、代わりに @kbd{CTRL-Q} を使う |@ref{i_CTRL-Q}|。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you are working in a special language mode when inserting text, see the
'langmap' option, |'langmap'|, on how to avoid switching this mode on and off
all the time.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
テキストを入力する際に特別な言語のモードを使用している場合、いつもこのモードが ON/OFF と切り替えられてしまうのをどう避けるかを知るには '@option{langmap}' オプション (|@ref{'langmap'}|) を参照すること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you have 'insertmode' set, <Esc> and a few other keys get another meaning.
See |'insertmode'|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{insertmode}' を設定した場合には、@key{<Esc>} と他の幾つかのキーに別の意味が与えられる。|@ref{'insertmode'}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
char		action	~
-----------------------------------------------------------------------
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item 文字
アクション
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*i_CTRL-[* *i_<Esc>*
<Esc> or CTRL-[	End insert or Replace mode, go back to Normal mode.  Finish
		abbreviation.
		Note: If your <Esc> key is hard to hit on your keyboard, train
		yourself to use CTRL-[.
		If Esc doesn't work and you are using a Mac, try CTRL-Esc.
		Or disable Listening under Accessibility preferences.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-[}
@anchor{i_<Esc>}
@kindex i_CTRL-[
@kindex i_<Esc>
@item @key{<Esc>} または
@itemx @kbd{CTRL-[}
挿入/置換モードを終了し、ノーマルモードに戻る。短縮入力を終了する。
@quotation
@strong{Note:} @*
キーボードによっては @key{<Esc>} が押し難いかもしれないが、その時には @kbd{CTRL-[} を使うようにする。

Mac で Esc が効かないときは @kbd{CTRL-Esc} を試す。または、アクセシビリティ設定の音声認識を無効化する。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*i_CTRL-C*
CTRL-C		Quit insert mode, go back to Normal mode.  Do not check for
		abbreviations.  Does not trigger the |InsertLeave| autocommand
		event.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-C}
@kindex i_CTRL-C
@item @kbd{CTRL-C}
挿入モードを終了し、ノーマルモードに戻る。短縮入力はチェックしない。@kbd{CTRL-C} で挿入モードを抜けると |@ref{InsertLeave}| が発生しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*i_CTRL-@*
CTRL-@		Insert previously inserted text and stop insert.  {Vi: only
		when typed as first char, only up to 128 chars}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-@@}
@kindex i_CTRL-@@
@item @kbd{CTRL-@@}
直前に挿入されたテキストをもう一度挿入し、挿入を終了する。

@{Vi: 最初に入力された時だけ、かつ最大 128 文字まで@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*i_CTRL-A*
CTRL-A		Insert previously inserted text.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-A}
@kindex i_CTRL-A
@item @kbd{CTRL-A}
直前に挿入されたテキストをもう一度挿入する。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*i_CTRL-H* *i_<BS>* *i_BS*
<BS> or CTRL-H	Delete the character before the cursor (see |i_backspacing|
		about joining lines).
		See |:fixdel| if your <BS> key does not do what you want.
		{Vi: does not delete autoindents}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-H}
@anchor{i_<BS>}
@anchor{i_BS}
@kindex i_CTRL-H
@kindex i_<BS>
@kindex i_BS
@item @key{<BS>} または
@itemx @kbd{CTRL-H}
カーソルの前の文字を削除する (行同士の連結については |@ref{i_backspacing}| 参照)。

@key{<BS>} キーが想定するように働かない場合には |@ref{:fixdel}| を参照。

@{Vi: 自動字下げは消すことができない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*i_<Del>* *i_DEL*
<Del>		Delete the character under the cursor.  If the cursor is at
		the end of the line, and the 'backspace' option includes
		"eol", delete the <EOL>; the next line is appended after the
		current one.
		See |:fixdel| if your <Del> key does not do what you want.
		{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_<Del>}
@anchor{i_DEL}
@kindex i_<Del>
@kindex i_DEL
@item @key{<Del>}
カーソルの下の文字を削除する。カーソルが行末にあり、'@option{backspace}' オプションに "eol" が含まれている場合には、<EOL> が削除される; 現在の行の後ろに次の行が接続される。

@key{<Del>} キーが想定するように働かない場合には |@ref{:fixdel}| を参照。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*i_CTRL-W*
CTRL-W		Delete the word before the cursor (see |i_backspacing| about
		joining lines).  See the section "word motions",
		|word-motions|, for the definition of a word.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-W}
@kindex i_CTRL-W
@item @kbd{CTRL-W}
カーソルの前にある単語を削除する(行同士の連結については |@ref{i_backspacing}| 参照)。単語の定義については "word motions" の節 |@ref{word-motions}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*i_CTRL-U*
CTRL-U		Delete all entered characters before the cursor in the current
		line.  If there are no newly entered characters and
		'backspace' is not empty, delete all characters before the
		cursor in the current line.
		See |i_backspacing| about joining lines.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-U}
@kindex i_CTRL-U
@item @kbd{CTRL-U}
現在の行のカーソルの前に入力された文字を全部削除する。新しく入力した文字が無く '@option{backspace}' が空ではない時は、カーソル前の全ての文字を削除する。行同士の連結については |@ref{i_backspacing}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*i_CTRL-I* *i_<Tab>* *i_Tab*
<Tab> or CTRL-I Insert a tab.  If the 'expandtab' option is on, the
		equivalent number of spaces is inserted (use CTRL-V <Tab> to
		avoid the expansion; use CTRL-Q <Tab> if CTRL-V is mapped
		|i_CTRL-Q|).  See also the 'smarttab' option and
		|ins-expandtab|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-I}
@anchor{i_<Tab>}
@anchor{i_Tab}
@kindex i_CTRL-I
@kindex i_<Tab>
@kindex i_Tab
@item @key{<Tab>} または
@itemx @kbd{CTRL-I}
タブを挿入する。'@option{expandtab}' オプションが設定されていれば、同じ数の空白文字が挿入される (展開を避けるためには @kbd{CTRL-V} @key{<Tab>}を使う。@kbd{CTRL-V} に他の動作がマップされているときは @kbd{CTRL-Q} @key{<Tab>} を使う |@ref{i_CTRL-Q}|)。'@option{smarttab}' オプションと |@ref{ins-expandtab}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*i_CTRL-J* *i_<NL>*
<NL> or CTRL-J	Begin new line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-J}
@anchor{i_<NL>}
@kindex i_CTRL-J
@kindex i_<NL>
@item @key{<NL>} または
@itemx @kbd{CTRL-J}
新しい行を始める。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*i_CTRL-M* *i_<CR>*
<CR> or CTRL-M	Begin new line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-M}
@anchor{i_<CR>}
@kindex i_CTRL-M
@kindex i_<CR>
@item @key{<CR>} または
@itemx @kbd{CTRL-M}
新しい行を始める。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*i_CTRL-K*
CTRL-K {char1} [char2]
		Enter digraph (see |digraphs|).  When {char1} is a special
		key, the code for that key is inserted in <> form.  For
		example, the string "<S-Space>" can be entered by typing
		<C-K><S-Space> (two keys).  Neither char is considered for
		mapping.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-K}
@kindex i_CTRL-K
@item @kbd{CTRL-K} @{char1@} [char2]
ダイグラフ (|@ref{digraphs}| 参照) を入力する。@{char1@} が特別なキーだった場合、そのキーのコードが <> の形で挿入される。例えば、<C-K><S-Space> (キー 2 つ) と入力することで、文字列 "<S-Space>" が入力される。マッピングも考慮されない。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CTRL-N		Find next keyword (see |i_CTRL-N|).  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-N}
次のキーワードを探す (|@ref{i_CTRL-N}| を参照)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
CTRL-P		Find previous keyword (see |i_CTRL-P|).  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-P}
前のキーワードを探す (|@ref{i_CTRL-P}| を参照)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CTRL-R {0-9a-z"%#*+:.-=}					*i_CTRL-R*
		Insert the contents of a register.  Between typing CTRL-R and
		the second character, '"' will be displayed to indicate that
		you are expected to enter the name of a register.
		The text is inserted as if you typed it, but mappings and
		abbreviations are not used.  If you have options like
		'textwidth', 'formatoptions', or 'autoindent' set, this will
		influence what will be inserted.  This is different from what
		happens with the "p" command and pasting with the mouse.
		Special registers:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-R}
@kindex i_CTRL-R
@item @kbd{CTRL-R} @{0-9a-z"%#*+:.-=@}
レジスタの内容を挿入する。@kbd{CTRL-R} をタイプしてから 2 つ目の文字をタイプするまで、レジスタの名前の入力が期待されていることを示すため、'"' が表示される。

テキストはタイプしたかのように挿入されるが、マッピングや短縮入力の展開はされない。'@option{textwidth}' や '@option{formatoptions}' や '@option{autoindent}' のようなオプションが設定されている場合には、入力されたテキストに対して効力を持つ。これは "p" コマンドやマウスによる貼り付けとは、違う動作になる。

特別なレジスタ:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			'"'	the unnamed register, containing the text of
				the last delete or yank
			'%'	the current file name
			'#'	the alternate file name
			'*'	the clipboard contents (X11: primary selection)
			'+'	the clipboard contents
			'/'	the last search pattern
			':'	the last command-line
			'.'	the last inserted text
			'-'	the last small (less than a line) delete
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .05 .95
@item '"' @tab 最後に削除されたりヤンクされたテキストの入っている、名前なしレジスタ
@item '%' @tab 現在のファイル名
@item '#' @tab 代替バッファのファイル名
@item '*' @tab クリップボードの内容 (X11: プライマリセレクション)
@item '+' @tab クリップボードの内容
@item '/' @tab 最後に検索を行ったパターン
@item ':' @tab 最後に実行したコマンドライン
@item '.' @tab 最後に挿入したテキスト
@item '-' @tab 最後に削除した小さい (行単位以下の) 領域
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*i_CTRL-R_=*
			'='	the expression register: you are prompted to
				enter an expression (see |expression|)
				Note that 0x80 (128 decimal) is used for
				special keys.  E.g., you can use this to move
				the cursor up:
					CTRL-R ="\<Up>"
				Use CTRL-R CTRL-R to insert text literally.
				When the result is a |List| the items are used
				as lines.  They can have line breaks inside
				too.
				When the result is a Float it's automatically
				converted to a String.
				When append() or setline() is invoked the undo
				sequence will be broken.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-R_=}
@kindex i_CTRL-R_=
@item '=' @tab 式評価レジスタ: 式評価の入力を求められる (|@ref{expression}| 参照)。
0x80 (10進数で 128) は特殊なキーのために使われる。例: 次のコマンドでカーソルを上に移動できる:
@example
CTRL-R ="\<Up>"
@end example
文字をそのまま挿入するには @kbd{CTRL-R} @kbd{CTRL-R} を使うこと。

結果が |@ref{List}| のときは各要素を行として挿入する。要素の中に改行文字があってもよい。

結果が浮動小数点数のときは自動的に文字列に変換される。

append() や setline() が使われると undo シーケンスが分割される。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		See |registers| about registers.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
レジスタについては |@ref{registers}| を参照。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CTRL-R CTRL-R {0-9a-z"%#*+/:.-=}			*i_CTRL-R_CTRL-R*
		Insert the contents of a register.  Works like using a single
		CTRL-R, but the text is inserted literally, not as if typed.
		This differs when the register contains characters like <BS>.
		Example, where register a contains "ab^Hc": >
	CTRL-R a		results in "ac".
	CTRL-R CTRL-R a		results in "ab^Hc".
<		Options 'textwidth', 'formatoptions', etc. still apply.  If
		you also want to avoid these, use CTRL-R CTRL-O, see below.
		The '.' register (last inserted text) is still inserted as
		typed.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-R_CTRL-R}
@kindex i_CTRL-R_CTRL-R
@item @kbd{CTRL-R} @kbd{CTRL-R} @{0-9a-z"%#*+/:.-=@}
レジスタの内容を挿入する。@kbd{CTRL-R} が 1 つの時と同様に働くが、タイプされたようにではなく、テキストは文字通りに挿入される。これはレジスタに <BS> のような文字が含まれていた場合に違いを生じる。例えば "ab^Hc" という内容のレジスタ a があった場合:
@verbatim
CTRL-R a            結果は "ac".
CTRL-R CTRL-R a     結果は "ab^Hc".
@end verbatim
'@option{textwidth}' や '@option{formatoptions}' などのオプションは適用される。これらのオプションを無効にするには "<C-R><C-O>r" を使用する。'.' レジスタ (最後に挿入されたテキスト) だけは、@kbd{CTRL-R} と同様に、タイプされたように挿入される。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CTRL-R CTRL-O {0-9a-z"%#*+/:.-=}			*i_CTRL-R_CTRL-O*
		Insert the contents of a register literally and don't
		auto-indent.  Does the same as pasting with the mouse
		|<MiddleMouse>|. When the register is linewise this will
		insert the text above the current line, like with `P`.
		Does not replace characters!
		The '.' register (last inserted text) is still inserted as
		typed.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-R_CTRL-O}
@kindex i_CTRL-R_CTRL-O
@item @kbd{CTRL-R} @kbd{CTRL-O} @{0-9a-z"%#*+/:.-=@}
レジスタの内容が文字通り挿入され、自動字下げも行われない。マウスによる貼り付け |@ref{<MiddleMouse>}| と同様である。レジスタが linewise の時は、テキストを `P` と同様に現在行の上に挿入する。

キャラクタは置き換えられない！

'.' レジスタ (最後に挿入されたテキスト) だけは、@kbd{CTRL-R} と同様に、タイプされたように挿入される。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CTRL-R CTRL-P {0-9a-z"%#*+/:.-=}			*i_CTRL-R_CTRL-P*
		Insert the contents of a register literally and fix the
		indent, like |[<MiddleMouse>|.
		Does not replace characters!
		The '.' register (last inserted text) is still inserted as
		typed.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-R_CTRL-P}
@kindex i_CTRL-R_CTRL-P
@item @kbd{CTRL-R} @kbd{CTRL-P} @{0-9a-z"%#*+/:.-=@}
レジスタの内容が文字通りに挿入され、インデントが |@ref{[<MiddleMouse>}| 同様に修正される。

キャラクタは置き換えられない！

'.' レジスタ (最後に挿入されたテキスト) だけは、@kbd{CTRL-R} と同様に、タイプされたように挿入される。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*i_CTRL-T*
CTRL-T		Insert one shiftwidth of indent at the start of the current
		line.  The indent is always rounded to a 'shiftwidth' (this is
		vi compatible).  {Vi: only when in indent}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-T}
@kindex i_CTRL-T
@item @kbd{CTRL-T}
現在の行の先頭に shiftwidth 一単位分の字下げを挿入する。字下げ幅は '@option{shiftwidth}' に丸められる (これは vi と同じ)。

@{Vi: 字下げされている時だけ@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*i_CTRL-D*
CTRL-D		Delete one shiftwidth of indent at the start of the current
		line.  The indent is always rounded to a 'shiftwidth' (this is
		vi compatible).  {Vi: CTRL-D works only when used after
		autoindent}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-D}
@kindex i_CTRL-D
@item @kbd{CTRL-D}
現在の行の先頭の字下げを shiftwidth 一単位分削除する。字下げ幅は '@option{shiftwidth}' に丸められる (これは vi と同じ)。

@{Vi: @kbd{CTRL-D} は自動字下げの適用後にしか使えない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*i_0_CTRL-D*
0 CTRL-D	Delete all indent in the current line.  {Vi: CTRL-D works
		only when used after autoindent}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_0_CTRL-D}
@kindex i_0_CTRL-D
@item 0 @kbd{CTRL-D}
現在行の字下げを完全に削除する。

@{Vi: @kbd{CTRL-D} は自動字下げの適用後にしか使えない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*i_^_CTRL-D*
^ CTRL-D	Delete all indent in the current line.  The indent is
		restored in the next line.  This is useful when inserting a
		label.  {Vi: CTRL-D works only when used after autoindent}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_^_CTRL-D}
@kindex i_^_CTRL-D
@item ^ @kbd{CTRL-D}
現在行の字下げを完全に削除する。次の行では字下げは元に戻される。これはラベルを入力する際に役に立つ。

@{Vi: @kbd{CTRL-D} は自動字下げの適用後にしか使えない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*i_CTRL-V*
CTRL-V		Insert next non-digit literally.  For special keys, the
		terminal code is inserted.  It's also possible to enter the
		decimal, octal or hexadecimal value of a character
		|i_CTRL-V_digit|.
		The characters typed right after CTRL-V are not considered for
		mapping.  {Vi: no decimal byte entry}
		Note: When CTRL-V is mapped (e.g., to paste text) you can
		often use CTRL-Q instead |i_CTRL-Q|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-V}
@kindex i_CTRL-V
@item @kbd{CTRL-V}
続く非数字文字を文字通りに挿入する。特別なキーはターミナルコードが挿入される。10進数、8 進数、16 進数、の数字で文字コードを直接指定することもできる |@ref{i_CTRL-V_digit}|。@kbd{CTRL-V} の後の入力にはマップは適用されない。

@{Vi: 数字文字をバイトに変換できない@}
@quotation
@strong{Note:} @*
@kbd{CTRL-V} に他の動作がマップされているとき (例えばテキストをペーストするなど)、その場合には代わりに @kbd{CTRL-Q} を使用する |@ref{i_CTRL-Q}|。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*i_CTRL-Q*
CTRL-Q		Same as CTRL-V.
		Note: Some terminal connections may eat CTRL-Q, it doesn't
		work then.  It does work in the GUI.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-Q}
@kindex i_CTRL-Q
@item @kbd{CTRL-Q}
@kbd{CTRL-V} と同じ。
@quotation
@strong{Note:} @*
ある種のターミナルでは @kbd{CTRL-Q} を使用できない。GUI では使える。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CTRL-X		Enter CTRL-X mode.  This is a sub-mode where commands can
		be given to complete words or scroll the window.  See
		|i_CTRL-X| and |ins-completion|. {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-X}
@kbd{CTRL-X} モードに入る。これは単語の補完やウィンドウスクロールのコマンドを入力する、サブモードである。|@ref{i_CTRL-X}| と |@ref{ins-completion}| を参照。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*i_CTRL-E*
CTRL-E		Insert the character which is below the cursor.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-E}
@kindex i_CTRL-E
@item @kbd{CTRL-E}
カーソルの下の行の同じ位置の文字を挿入。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*i_CTRL-Y*
CTRL-Y		Insert the character which is above the cursor.  {not in Vi}
		Note that for CTRL-E and CTRL-Y 'textwidth' is not used, to be
		able to copy characters from a long line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-Y}
@kindex i_CTRL-Y
@item @kbd{CTRL-Y}
カーソルの上の行の同じ位置の文字を挿入。

@{Vi にはない@}

'@option{textwidth}' は @kbd{CTRL-E} と @kbd{CTRL-Y} には、長い行から文字をコピーすることを可能にするために、効力を発揮しないことに注意。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*i_CTRL-_*
CTRL-_		Switch between languages, as follows:
		-  When in a rightleft window, revins and nohkmap are toggled,
		   since English will likely be inserted in this case.
		-  When in a norightleft window, revins and hkmap are toggled,
		   since Hebrew will likely be inserted in this case.

		CTRL-_ moves the cursor to the end of the typed text.

		This command is only available when the 'allowrevins' option
		is set.
		Please refer to |rileft.txt| for more information about
		right-to-left mode.
		{not in Vi}
		Only if compiled with the |+rightleft| feature.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-_}
@kindex i_CTRL-_
@item @kbd{CTRL-_}
次に示すように言語を切り替える:
@itemize
@item 右→左ウィンドウでは、revins と nohkmap に切り替えられ、この場合英語を挿入できるようになる。
@item 右→左ウィンドウ以外では revins と hkmap に切り替えられ、この場合ヘブライ語を挿入できるようになる。
@end itemize
@kbd{CTRL-_} はカーソルをタイプ済みテキストの末尾に移動させる。

このコマンドは '@option{allowrevins}' オプションが設定されている時のみ有効。

右→左モードについての詳しい情報は |@ref{rileft.txt}| を参照。

@{Vi にはない@}

|@ref{+rightleft}| 機能を有効(にしてコンパイルした時にだけ使用可能。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*i_CTRL-^*
CTRL-^		Toggle the use of typing language characters.
		When language |:lmap| mappings are defined:
		- If 'iminsert' is 1 (langmap mappings used) it becomes 0 (no
		  langmap mappings used).
		- If 'iminsert' has another value it becomes 1, thus langmap
		  mappings are enabled.
		When no language mappings are defined:
		- If 'iminsert' is 2 (Input Method used) it becomes 0 (no
		  Input Method used).
		- If 'iminsert' has another value it becomes 2, thus the Input
		  Method is enabled.
		When set to 1, the value of the "b:keymap_name" variable, the
		'keymap' option or "<lang>" appears in the status line.
		The language mappings are normally used to type characters
		that are different from what the keyboard produces.  The
		'keymap' option can be used to install a whole number of them.
		{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-^}
@kindex i_CTRL-^
@item @kbd{CTRL-^}
入力言語を切替える。

言語マッピング |@ref{:lmap}| が定義されているとき:
@itemize
@item '@option{iminsert}' が 1 (言語マッピングが使われている) なら 0 (言語マッピングを使わない) になる。
@item '@option{iminsert}' が他の値なら 1 になる。したがって言語マッピングが有効になる。
@end itemize
言語マッピングが定義されていないとき:
@itemize
@item '@option{iminsert}' が 2 (インプットメソッドが使われている) なら 0 (インプットメソッドを使わない) になる。
@item '@option{iminsert}' がその他の値なら 2 になる。したがってインプットメソッドが有効になる。
@end itemize
'@option{iminsert}' を 1 にすると "b:keymap_name" の値、または '@option{keymap}' オプションか "<lang>" がステータスラインに表示される。言語マッピングは通常はキーボードにない文字を打つのに使われる。これらの値を設定するために '@option{keymap}' オプションを使える。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*i_CTRL-]*
CTRL-]		Trigger abbreviation, without inserting a character.  {not in
		Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-]}
@kindex i_CTRL-]
@item @kbd{CTRL-]}
文字を入れることなく、短縮入力をトリガーする。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*i_<Insert>*
<Insert>	Toggle between Insert and Replace mode.  {not in Vi}
-----------------------------------------------------------------------
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_<Insert>}
@kindex i_<Insert>
@item @key{<Insert>}
挿入と置換モードを交互に切り替える。

@{Vi にはない@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*i_backspacing*
The effect of the <BS>, CTRL-W, and CTRL-U depend on the 'backspace' option
(unless 'revins' is set).  This is a comma separated list of items:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_backspacing}
@kindex i_backspacing
@kbd{<BS>}, @kbd{CTRL-W} そして @kbd{CTRL-U} の効果は '@option{backspace}' オプションに依存している ('@option{revins}' が設定されていなければ)。これは下記の項目をコンマで区切ったリストになっている:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
item	    action ~
indent	    allow backspacing over autoindent
eol	    allow backspacing over end-of-line (join lines)
start	    allow backspacing over the start position of insert; CTRL-W and
	    CTRL-U stop once at the start position
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .15 .85
@item 項目 @tab アクション
@item indent @tab 字下げをバックスペースで消去可能
@item eol @tab 行末をバックスペースで消去可能 (行を連結)
@item start @tab 挿入の開始点を超えてバックスペースで消去可能; @kbd{CTRL-W} と @kbd{CTRL-U} は一度スタート地点で停止する。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When 'backspace' is empty, Vi compatible backspacing is used.  You cannot
backspace over autoindent, before column 1 or before where insert started.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{backspace}' が空の時、Vi 互換のバックスペースが使用される。自動字下げや、第 1 カラムの前、そして挿入の開始点を超えてのバックスペースはできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For backwards compatibility the values "0", "1" and "2" are also allowed, see
|'backspace'|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
下位互換性のために、値として "0", "1" そして "2" を使用することもできる。|@ref{'backspace'}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the 'backspace' option does contain "eol" and the cursor is in column 1
when one of the three keys is used, the current line is joined with the
previous line.  This effectively deletes the <EOL> in front of the cursor.
{Vi: does not cross lines, does not delete past start position of insert}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{backspace}' オプションが "eol" を含まれている時に、カーソルが第 1 カラムにあり、3 つのキーのうちどれかが押されると、現在の行が 1 行前の行に連結される。これはカーソルの前にある <EOL> を事実上消している。

@{Vi: 行をまたいだり、挿入の開始点を超えての削除はできない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*i_CTRL-V_digit*
With CTRL-V the decimal, octal or hexadecimal value of a character can be
entered directly.  This way you can enter any character, except a line break
(<NL>, value 10).  There are five ways to enter the character value:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-V_digit}
@kindex i_CTRL-V_digit
@kbd{CTRL-V} に続けて、10 進数、8 進数、16 進数のどれかで文字コードを直接入力することができる。この方法で改行 (<NL>, 数値 10) 以外のどんな文字でも入力することができる。文字コードを入力するには 5 つの方法がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
first char	mode	     max nr of chars   max value ~
(none)		decimal		   3		255
o or O		octal		   3		377	 (255)
x or X		hexadecimal	   2		ff	 (255)
u		hexadecimal	   4		ffff	 (65535)
U		hexadecimal	   8		7fffffff (2147483647)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .2 .2 .4
@item 最初の文字 @tab モード @tab 最大文字数 @tab 最大値
@item (なし) @tab 10 進数 @tab 3 @tab 255
@item o か O @tab 8 進数 @tab 3 @tab 377 (255)
@item x か X @tab 16 進数 @tab 2 @tab ff (255)
@item u @tab 16 進数 @tab 4 @tab ffff (65535)
@item U @tab 16 進数 @tab 8 @tab 7fffffff (2147483647)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Normally you would type the maximum number of characters.  Thus to enter a
space (value 32) you would type <C-V>032.  You can omit the leading zero, in
which case the character typed after the number must be a non-digit.  This
happens for the other modes as well: As soon as you type a character that is
invalid for the mode, the value before it will be used and the "invalid"
character is dealt with in the normal way.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
入力できる文字数の最大まで入力すると、例えば <C-V>032 と入力した場合にはスペース (値 32) が入る。一番上の桁のゼロは省略することができる。その場合には数値を入力した後に入力する文字は数字以外でなければならない。これは他のモードでも同じである。モード中で無効な文字を入力した場合には、それ以前に入力されたものが使われ無効な文字は通常の入力として扱われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you enter a value of 10, it will end up in the file as a 0.  The 10 is a
<NL>, which is used internally to represent the <Nul> character.  When writing
the buffer to a file, the <NL> character is translated into <Nul>.  The <NL>
character is written at the end of each line.  Thus if you want to insert a
<NL> character in a file you will have to make a line break.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
値 10 を入力すると、それは 0 になってしまう。数値 10 は <NL> であり、内部で <Nul> 文字を表すのに使われている。バッファをファイルに書き出すときに <NL> は <Nul> に変換される。<NL> は各行末に出力されるので、<NL> をファイルに書きたければ改行すること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*i_CTRL-X* *insert_expand*
CTRL-X enters a sub-mode where several commands can be used.  Most of these
commands do keyword completion; see |ins-completion|.  These are not available
when Vim was compiled without the |+insert_expand| feature.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-X}
@anchor{insert_expand}
@kindex i_CTRL-X
@kindex insert_expand
@kbd{CTRL-X} を押すと、幾つかのコマンドを使用することができる、サブモードに入る。これらのコマンドの多くはキーワードの補完である; |@ref{ins-completion}| 参照。Vim のコンパイル時に |@ref{+insert_expand}| 機能を無効にした場合には、この機能は使用できない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Two commands can be used to scroll the window up or down, without exiting
insert mode:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次の 2 つのコマンドは、挿入モードを抜けることなくウィンドウを上下にスクロールさせることができる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*i_CTRL-X_CTRL-E*
CTRL-X CTRL-E		scroll window one line up.
			When doing completion look here: |complete_CTRL-E|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-X_CTRL-E}
@kindex i_CTRL-X_CTRL-E
@table @asis
@item @kbd{CTRL-X} @kbd{CTRL-E}
ウィンドウを 1 行上にスクロール。補完途中での機能については |@ref{complete_CTRL-E}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*i_CTRL-X_CTRL-Y*
CTRL-X CTRL-Y		scroll window one line down.
			When doing completion look here: |complete_CTRL-Y|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-X_CTRL-Y}
@kindex i_CTRL-X_CTRL-Y
@item @kbd{CTRL-X} @kbd{CTRL-Y}
ウィンドウを 1 行下にスクロール。補完途中での機能については |@ref{complete_CTRL-Y}| を参照。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
After CTRL-X is pressed, each CTRL-E (CTRL-Y) scrolls the window up (down) by
one line unless that would cause the cursor to move from its current position
in the file.  As soon as another key is pressed, CTRL-X mode is exited and
that key is interpreted as in Insert mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-X} を押した後に @kbd{CTRL-E} (もしくは @kbd{CTRL-Y}) を押すと、現在のファイル内でカーソルを現在の位置から動かすことなく、ウィンドウが 1 行上 (下) にスクロールする。関係ないキーが押されると、すぐに CTRL-X モードは終了し、そのキーが挿入モードで押されたものとして解釈される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
==============================================================================
2. Special special keys				*ins-special-special*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ins-special-special}
@cindex ins-special-special
@cindex もっと特別なキー
@section 2. もっと特別なキー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The following keys are special.  They stop the current insert, do something,
and then restart insertion.  This means you can do something without getting
out of Insert mode.  This is very handy if you prefer to use the Insert mode
all the time, just like editors that don't have a separate Normal mode.  You
may also want to set the 'backspace' option to "indent,eol,start" and set the
'insertmode' option.  You can use CTRL-O if you want to map a function key to
a command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
下のキーは特別である。これらは現在の挿入を中断し、何かを行い、そして挿入を再開する。これは挿入モード出ることなく、何かをすることができることを意味している。これはモードが分かれていない普通のエディタのように、常に挿入モードを使用するのが好みの場合には、とても便利である。これには '@option{backspace}' オプションに "indent,eol,start" を設定し、'@option{insertmode}' オプションを設定すると良いだろう。コマンドにファンクションキーをマップしたいならば、@kbd{CTRL-O} を使うことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The changes (inserted or deleted characters) before and after these keys can
be undone separately.  Only the last change can be redone and always behaves
like an "i" command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのキーを使用する前後の変更 (文字の挿入や削除) は、別々に取り消すことができる。最後の変更だけがやり直すことができ、常に "i" コマンドのように振舞う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
char		action	~
-----------------------------------------------------------------------
<Up>		cursor one line up			     *i_<Up>*
<Down>		cursor one line down			     *i_<Down>*
CTRL-G <Up>	cursor one line up, insert start column	     *i_CTRL-G_<Up>*
CTRL-G k	cursor one line up, insert start column	     *i_CTRL-G_k*
CTRL-G CTRL-K	cursor one line up, insert start column	     *i_CTRL-G_CTRL-K*
CTRL-G <Down>	cursor one line down, insert start column    *i_CTRL-G_<Down>*
CTRL-G j	cursor one line down, insert start column    *i_CTRL-G_j*
CTRL-G CTRL-J	cursor one line down, insert start column    *i_CTRL-G_CTRL-J*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item char @tab action
@anchor{i_<Up>}
@kindex i_<Up>
@item @key{<Up>} @tab カーソルを 1 行上へ移動する
@anchor{i_<Down>}
@kindex i_<Down>
@item @key{<Down>} @tab カーソルを 1 行下へ移動する
@anchor{i_CTRL-G_<Up>}
@kindex i_CTRL-G_<Up>
@item @kbd{CTRL-G} @key{<Up>} @tab 1 行上の、挿入開始位置と同じ列へ移動
@anchor{i_CTRL-G_k}
@kindex i_CTRL-G_k
@item @kbd{CTRL-G} k @tab 1 行上の、挿入開始位置と同じ列へ移動
@anchor{i_CTRL-G_CTRL-K}
@kindex i_CTRL-G_CTRL-K
@item @kbd{CTRL-G} @kbd{CTRL-K} @tab 1 行上の、挿入開始位置と同じ列へ移動
@anchor{i_CTRL-G_<Down>}
@kindex i_CTRL-G_<Down>
@item @kbd{CTRL-G} @key{<Down>} @tab 1 行下の、挿入開始位置と同じ列へ移動
@anchor{i_CTRL-G_j}
@kindex i_CTRL-G_j
@item @kbd{CTRL-G} j @tab 1 行下の、挿入開始位置と同じ列へ移動
@anchor{i_CTRL-G_CTRL-J}
@kindex i_CTRL-G_CTRL-J
@item @kbd{CTRL-G} @kbd{CTRL-J} @tab 1 行下の、挿入開始位置と同じ列へ移動
@end ifset 
@c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<Left>		cursor one character left		     *i_<Left>*
<Right>		cursor one character right		     *i_<Right>*
<S-Left>	cursor one word back (like "b" command)>     *i_<S-Left>*
<C-Left>	cursor one word back (like "b" command)>     *i_<C-Left>*
<S-Right>	cursor one word forward (like "w" command)   *i_<S-Right>*
<C-Right>	cursor one word forward (like "w" command)   *i_<C-Right>*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_<Left>}
@kindex i_<Left>
@item @key{<Left>} @tab カーソルを 1 文字左へ移動する
@anchor{i_<Right>}
@kindex i_<Right>
@item @key{<Right>} @tab カーソルを 1 文字右へ移動する
@anchor{i_<S-Left>}
@kindex i_<S-Left>
@item <S-Left> @tab カーソルを 1 単語前へ ("b" コマンドのように)
@anchor{i_<C-Left>}
@kindex i_<C-Left>
@item <C-Left> @tab カーソルを 1 単語前へ ("b" コマンドのように)
@anchor{i_<S-Right>}
@kindex i_<S-Right>
@item <S-Right> @tab カーソルを 1 単語後へ ("w" コマンドのように)
@anchor{i_<C-Right>}
@kindex i_<C-Right>
@item <C-Right> @tab カーソルを 1 単語後へ ("w" コマンドのように)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<Home>		cursor to first char in the line	     *i_<Home>*
<End>		cursor to after last char in the line	     *i_<End>*
<C-Home>	cursor to first char in the file	     *i_<C-Home>*
<C-End>		cursor to after last char in the file	     *i_<C-End>*
<LeftMouse>	cursor to position of mouse click	     *i_<LeftMouse>*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_<Home>}
@kindex i_<Home>
@item @key{<Home>} @tab カーソルを行の最初の文字へ
@anchor{i_<End>}
@kindex i_<End>
@item @key{<End>} @tab カーソルを行の最後の文字の後へ
@anchor{i_<C-Home>}
@kindex i_<C-Home>
@item <C-Home> @tab カーソルをファイルの最初の文字へ
@anchor{i_<C-End>}
@kindex i_<C-End>
@item <C-End> @tab カーソルをファイルの最後の文字の後へ
@anchor{i_<LeftMouse>}
@kindex i_<LeftMouse>
@item <LeftMouse> @tab カーソルをマウスでクリックした位置へ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<S-Up>		move window one page up			     *i_<S-Up>*
<PageUp>	move window one page up			     *i_<PageUp>*
<S-Down>	move window one page down		     *i_<S-Down>*
<PageDown>	move window one page down		     *i_<PageDown>*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_<S-Up>}
@kindex i_<S-Up>
@item <S-Up> @tab 1 ページ上へ
@anchor{i_<PageUp>}
@kindex i_<PageUp>
@item @key{<PageUp>} @tab 1 ページ上へ
@anchor{i_<S-Down>}
@kindex i_<S-Down>
@item <S-Down> @tab 1 ページ下へ
@anchor{i_<PageDown>}
@kindex i_<PageDown>
@item @key{<PageDown>} @tab 1 ページ下へ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<ScrollWheelDown>    move window three lines down	*i_<ScrollWheelDown>*
<S-ScrollWheelDown>  move window one page down		*i_<S-ScrollWheelDown>*
<ScrollWheelUp>      move window three lines up		*i_<ScrollWheelUp>*
<S-ScrollWheelUp>    move window one page up		*i_<S-ScrollWheelUp>*
<ScrollWheelLeft>    move window six columns left	*i_<ScrollWheelLeft>*
<S-ScrollWheelLeft>  move window one page left		*i_<S-ScrollWheelLeft>*
<ScrollWheelRight>   move window six columns right	*i_<ScrollWheelRight>*
<S-ScrollWheelRight> move window one page right		*i_<S-ScrollWheelRight>*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_<ScrollWheelDown>}
@kindex i_<ScrollWheelDown>
@item <ScrollWheelDown> @tab ウィンドウを 3 行下へ移動
@anchor{i_<S-ScrollWheelDown>}
@kindex i_<S-ScrollWheelDown>
@item <S-ScrollWheelDown> @tab ウィンドウを 1 ページ下へ移動
@anchor{i_<ScrollWheelUp>}
@kindex i_<ScrollWheelUp>
@item <ScrollWheelUp> @tab ウィンドウを 3 行上へ移動
@anchor{i_<S-ScrollWheelUp>}
@kindex i_<S-ScrollWheelUp>
@item <S-ScrollWheelUp> @tab ウィンドウを 1 ページ上へ移動
@anchor{i_<ScrollWheelLeft>}
@kindex i_<ScrollWheelLeft>
@item <ScrollWheelLeft> @tab ウィンドウを 6 列左へ移動
@anchor{i_<S-ScrollWheelLeft>}
@kindex i_<S-ScrollWheelLeft>
@item <S-ScrollWheelLeft> @tab ウィンドウを 1 ページ左へ移動
@anchor{i_<ScrollWheelRight>}
@kindex i_<ScrollWheelRight>
@item <ScrollWheelRight> @tab ウィンドウを 6 列右へ移動
@anchor{i_<S-ScrollWheelRight>}
@kindex i_<S-ScrollWheelRight>
@item <S-ScrollWheelRight> @tab ウィンドウを 1 ページ右へ移動
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
CTRL-O		execute one command, return to Insert mode   *i_CTRL-O*
CTRL-\ CTRL-O	like CTRL-O but don't move the cursor	     *i_CTRL-\_CTRL-O*
CTRL-L		when 'insertmode' is set: go to Normal mode  *i_CTRL-L*
CTRL-G u	break undo sequence, start new change	     *i_CTRL-G_u*
CTRL-G U	don't break undo with next left/right cursor *i_CTRL-G_U*
		movement (but only if the cursor stays
		within same the line)
-----------------------------------------------------------------------
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-O}
@kindex i_CTRL-O
@item @kbd{CTRL-O} @tab 1 つコマンドを実行して、挿入モードに戻る
@anchor{i_CTRL-\_CTRL-O}
@kindex i_CTRL-\_CTRL-O
@item @kbd{CTRL-\} @kbd{CTRL-O} @tab @kbd{CTRL-O} と同様だがカーソルを移動させない
@anchor{i_CTRL-L}
@kindex i_CTRL-L
@item @kbd{CTRL-L} @tab '@option{insertmode}' がオンのとき: ノーマルモードへ
@anchor{i_CTRL-G_u}
@kindex i_CTRL-G_u
@item @kbd{CTRL-G} u @tab undo で元に戻す地点を新たに設定
@anchor{i_CTRL-G_U}
@kindex i_CTRL-G_U
@item @kbd{CTRL-G} U @tab 次の左右へのカーソル移動で undo を分割しない。(ただし、カーソルが同じ行の中にとどまった時のみ)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: If the cursor keys take you out of Insert mode, check the 'noesckeys'
option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
カーソルキーを押した時に挿入モードから抜けてしまったら、'@option{noesckeys}' オプションをチェックする。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The CTRL-O command sometimes has a side effect: If the cursor was beyond the
end of the line, it will be put on the last character in the line.  In
mappings it's often better to use <Esc> (first put an "x" in the text, <Esc>
will then always put the cursor on it).  Or use CTRL-\ CTRL-O, but then
beware of the cursor possibly being beyond the end of the line.  Note that the
command following CTRL-\ CTRL-O can still move the cursor, it is not restored
to its original position.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-O} コマンドは時々副作用を生じる: カーソルが行末を越えている場合に、行の最後の文字の上へ移動してしまうかもしれない。マッピングでは <Esc> を使うのが無難である (まず "x" を入力し、@key{<Esc>} を押すとカーソルは常にその文字の上に置かれる)。または @kbd{CTRL-\} @kbd{CTRL-O} を使う。しかしその場合はカーソルが行末を越えてしまう可能性があることに注意。
@quotation
@strong{Note:} @*
@kbd{CTRL-\} @kbd{CTRL-O} で実行するコマンドではカーソルを移動することができる。カーソル位置は復元されない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The CTRL-O command takes you to Normal mode.  If you then use a command enter
Insert mode again it normally doesn't nest.  Thus when typing "a<C-O>a" and
then <Esc> takes you back to Normal mode, you do not need to type <Esc> twice.
An exception is when not typing the command, e.g. when executing a mapping or
sourcing a script.  This makes mappings work that briefly switch to Insert
mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-O} コマンドではノーマルモードに移動できる。その最中にノーマルモードに再突入するコマンドを使ってもそれはモードが入れ子になるわけではない。例えば "a<C-O>a" と入力してから @key{<Esc>} を押した場合にはノーマルモードに戻る。@key{<Esc>} を 2 度タイプする必要はない。タイピングではない方法、例えばマッピングや source したスクリプトから実行した時は例外で、モードは入れ子になる。そのため上記の「"a<C-O>a" と入力してから <Esc>」をマッピングにより入力した場合には、ノーマルモードではなく挿入モードになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The shifted cursor keys are not available on all terminals.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@key{Shift} キーを押しながらのカーソルキー操作は、全ての端末で可能なわけではない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Another side effect is that a count specified before the "i" or "a" command is
ignored.  That is because repeating the effect of the command after CTRL-O is
too complicated.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
更に副作用として、"i" や "a" コマンドでの回数指定は無視される。そうしないと @kbd{CTRL-O} でのコマンドの繰り返しが複雑になってしまう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An example for using CTRL-G u: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-G u} を使う例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:inoremap <C-H> <C-G>u<C-H>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:inoremap <C-H> <C-G>u<C-H>
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This redefines the backspace key to start a new undo sequence.  You can now
undo the effect of the backspace key, without changing what you typed before
that, with CTRL-O u.  Another example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは undo できるバックスペースキーを再定義している。これで以前の入力を変更することなく @kbd{CTRL-O u} を使ってバックスペースの結果を元に戻せる。もう 1 つの例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:inoremap <CR> <C-]><C-G>u<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:inoremap <CR> <C-]><C-G>u<CR>
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This breaks undo at each line break.  It also expands abbreviations before
this.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは改行ごとに undo を分割する。また、それを行う前に短縮入力の展開も行う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An example for using CTRL-G U: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-G U} の使用例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	inoremap <Left>  <C-G>U<Left>
	inoremap <Right> <C-G>U<Right>
	inoremap <expr> <Home> col('.') == match(getline('.'), '\S') + 1 ?
	 \ repeat('<C-G>U<Left>', col('.') - 1) :
	 \ (col('.') < match(getline('.'), '\S') ?
	 \     repeat('<C-G>U<Right>', match(getline('.'), '\S') + 0) :
	 \     repeat('<C-G>U<Left>', col('.') - 1 - match(getline('.'), '\S')))
	inoremap <expr> <End> repeat('<C-G>U<Right>', col('$') - col('.'))
	inoremap ( ()<C-G>U<Left>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
inoremap <Left>  <C-G>U<Left>
inoremap <Right> <C-G>U<Right>
inoremap <expr> <Home> col('.') == match(getline('.'), '\S') + 1 ?
\ repeat('<C-G>U<Left>', col('.') - 1) :
\ (col('.') < match(getline('.'), '\S') ?
\     repeat('<C-G>U<Right>', match(getline('.'), '\S') + 0) :
\     repeat('<C-G>U<Left>', col('.') - 1 - match(getline('.'), '\S')))
inoremap <expr> <End> repeat('<C-G>U<Right>', col('$') - col('.'))
inoremap ( ()<C-G>U<Left>
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This makes it possible to use the cursor keys in Insert mode, without breaking
the undo sequence and therefore using |.| (redo) will work as expected.
Also entering a text like (with the "(" mapping from above):
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これにより undo を分割することなくカーソルキーを挿入モード内で使うことができ、|@ref{.}| (および redo) は期待通りに動作するようになる。また次のような (上記の "(" マッピングをともなう) テキスト入力:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
   Lorem ipsum (dolor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
Lorem ipsum (dolor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
will be repeatable by using |.| to the expected
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
は |@ref{.}| によって期待通り繰り返すことができるようになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
   Lorem ipsum (dolor)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
Lorem ipsum (dolor)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Using CTRL-O splits undo: the text typed before and after it is undone
separately.  If you want to avoid this (e.g., in a mapping) you might be able
to use CTRL-R = |i_CTRL-R|.  E.g., to call a function: >
	:imap <F2> <C-R>=MyFunc()<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-O} は undo 位置を分割する。つまり、その前後に入力したテキストが別々に undo されるようになる。これを避けたい場合 (マッピングの中などで) は CTRL-R = |@ref{i_CTRL-R}| が使えるだろう。例: 関数を呼ぶ:
@verbatim
:imap <F2> <C-R>=MyFunc()<CR>
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the 'whichwrap' option is set appropriately, the <Left> and <Right>
keys on the first/last character in the line make the cursor wrap to the
previous/next line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{whichwrap}' オプションが適切に設定されているならば、行の先頭/末尾での @key{<Left>} と @key{<Right>} キーは、カーソルを上の行や下の行へ移動させる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The CTRL-G j and CTRL-G k commands can be used to insert text in front of a
column.  Example: >
   int i;
   int j;
Position the cursor on the first "int", type "istatic <C-G>j       ".  The
result is: >
   static int i;
	  int j;
When inserting the same text in front of the column in every line, use the
Visual blockwise command "I" |v_b_I|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-G j} と @kbd{CTRL-G k} コマンドはカラムの前にテキストを挿入するのに使える。例:
@verbatim
int i;
int j;
@end verbatim
カーソルが最初の "int" にあるとき、"istatic <C-G>j       " と入力するとこうなる:
@verbatim
static int i;
int j;
@end verbatim
全ての行のカラムに同じテキストを挿入するには矩形ビジュアルコマンド "I" |@ref{v_b_I}| を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
3. 'textwidth' and 'wrapmargin' options			*ins-textwidth*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ins-textwidth}
@cindex ins-textwidth
@cindex 'textwidth' と 'wrapmargin' オプション
@section 3. 'textwidth' と 'wrapmargin' オプション
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The 'textwidth' option can be used to automatically break a line before it
gets too long.  Set the 'textwidth' option to the desired maximum line
length.  If you then type more characters (not spaces or tabs), the
last word will be put on a new line (unless it is the only word on the
line).  If you set 'textwidth' to 0, this feature is disabled.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{textwidth}' オプションは入力中の行が長くなりすぎる前に、自動的に改行を行うために使うことができる。'@option{textwidth}' オプションには望む最大行長を設定する。それを超えて文字 (空白とタブを除く) を入力すると最後の単語が (それがその行の唯一の単語で無いならば) 次の行に置かれる。'@option{textwidth}' に 0 を設定すれば、この機能を無効にすることができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The 'wrapmargin' option does almost the same.  The difference is that
'textwidth' has a fixed width while 'wrapmargin' depends on the width of the
screen.  When using 'wrapmargin' this is equal to using 'textwidth' with a
value equal to (columns - 'wrapmargin'), where columns is the width of the
screen.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{wrapmargin}' オプションはこれとほとんど同じことをする。違いは '@option{textwidth}' は固定幅なのに対して、'@option{wrapmargin}' はスクリーンの幅に依存する。'@option{wrapmargin}' を使用することは、'@option{textwidth}' に (スクリーンのカラム数 - '@option{wrapmargin}' に与えた値) を設定することに等しい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When 'textwidth' and 'wrapmargin' are both set, 'textwidth' is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{textwidth}' と '@option{wrapmargin}' が両方とも設定されていた場合には、'@option{textwidth}' が使用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you don't really want to break the line, but view the line wrapped at a
convenient place, see the 'linebreak' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もしも本当には改行をしたくないけれども、見かけ上は具合の良い場所で折り返されてほしい場合には、'@option{linebreak}' オプションを参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The line is only broken automatically when using Insert mode, or when
appending to a line.  When in replace mode and the line length is not
changed, the line will not be broken.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
自動的に改行されるのは、挿入モードを使用している時か、行に追加している時だけである。置換モードで行の長さが代わらない時には、改行は行われない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Long lines are broken if you enter a non-white character after the margin.
The situations where a line will be broken can be restricted by adding
characters to the 'formatoptions' option:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
長い行は、マージンを超えて非空白文字を入力すると、改行される。この改行がなされる位置は、'@option{formatoptions}' オプションに与える文字で制御することが可能である:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"l"  Only break a line if it was not longer than 'textwidth' when the insert
     started.
"v"  Only break at a white character that has been entered during the
     current insert command.  This is mostly Vi-compatible.
"lv" Only break if the line was not longer than 'textwidth' when the insert
     started and only at a white character that has been entered during the
     current insert command.  Only differs from "l" when entering non-white
     characters while crossing the 'textwidth' boundary.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item "l"
挿入を始めた時に '@option{textwidth}' よりも既に長くない時にだけ、改行を行う。
@item "v"
現在の挿入コマンドの間に挿入された空白文字の位置でのみ、改行を行う。これはほぼ Vi 互換。
@item "lv"
挿入を始めた時に '@option{textwidth}' よりも長くない行にだけ、かつその挿入コマンドの間に挿入された空白文字の位置でのみ、改行を行う。'@option{textwidth}' の境界を越えて非空白文字を入力した時に、"l" と違う。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Normally an internal function will be used to decide where to break the line.
If you want to do it in a different way set the 'formatexpr' option to an
expression that will take care of the line break.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
通常は、どこで改行するかを内部関数を使って決定する。この挙動を変えたい場合は、'@option{formatexpr}' に改行を処理する式を設定すること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to format a block of text, you can use the "gq" operator.  Type
"gq" and a movement command to move the cursor to the end of the block.  In
many cases, the command "gq}" will do what you want (format until the end of
paragraph).  Alternatively, you can use "gqap", which will format the whole
paragraph, no matter where the cursor currently is.  Or you can use Visual
mode: hit "v", move to the end of the block, and type "gq".  See also |gq|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
テキストのブロックを整形 (format) したいならば、"gq" オペレータを使うことができる。"gq" に続けて、ブロックの末尾までカーソルを動かす移動コマンドをタイプする。多くの場合、コマンド "gq@}" が、望むこと(段落の最後までを整形)をしてくるだろう。代わりに、現在カーソルがどこにあるかに関わらず、パラグラフ全体をフォーマットしてくれるコマンド、"gqap" を使うこともできる。またはビジュアル選択モードを使うこともできる: "v" を押し、ブロックの最後まで移動し、"gq" とタイプする。|@ref{gq}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
4. 'expandtab', 'smarttab' and 'softtabstop' options	*ins-expandtab*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ins-expandtab}
@cindex ins-expandtab
@cindex 'expandtab', 'smarttab' それと 'softtabstop' オプション
@section 4. 'expandtab', 'smarttab' それと 'softtabstop' オプション
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the 'expandtab' option is on, spaces will be used to fill the amount of
whitespace of the tab.  If you want to enter a real <Tab>, type CTRL-V first
(use CTRL-Q when CTRL-V is mapped |i_CTRL-Q|).
The 'expandtab' option is off by default.  Note that in Replace mode, a single
character is replaced with several spaces.  The result of this is that the
number of characters in the line increases.  Backspacing will delete one
space at a time.  The original character will be put back for only one space
that you backspace over (the last one).  {Vi does not have the 'expandtab'
option}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{expandtab}' オプションがオンになっていると、タブ文字は空白文字 (スペース) に展開され、その空白文字が挿入される。もし本当の <Tab> 文字を挿入したいのならば、@kbd{CTRL-V} を押してから入力する (@kbd{CTRL-V} に他の動作がマップされているときは @kbd{CTRL-Q} を使う |@ref{i_CTRL-Q}|)。

'@option{expandtab}' は初期状態でオフになっている。置換モードでは、1 文字が複数のスペースで置換されることに注意。この結果、行の中の文字数は増える。バックスペースをすると、1 度に 1 つの空白が削除される。元々そこにあった文字は、1 つのスペース (最後の 1 つ) を削除しただけで元に戻される。

@{Vi には '@option{expandtab}' オプションはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*ins-smarttab*
When the 'smarttab' option is on, a <Tab> inserts 'shiftwidth' positions at
the beginning of a line and 'tabstop' positions in other places.  This means
that often spaces instead of a <Tab> character are inserted.  When 'smarttab'
is off, a <Tab> always inserts 'tabstop' positions, and 'shiftwidth' is only
used for ">>" and the like.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ins-smarttab}
@cindex ins-smarttab
'@option{smarttab}' オプションがオンの時には、1 度の <Tab> で、行の先頭で @key{<Tab>} を 1 度押すと '@option{shiftwidth}' の位置まで、その他の場所では '@option{tabstop}' の位置まで空白が挿入される。これは <Tab> 文字の代わりに、度々スペースが挿入されることを意味している。'@option{smarttab}' がオフの時には、<Tab> では常に '@option{tabstop}' の位置まで空白が挿入され、'@option{shiftwidth}' は ">>" などの時にだけ使用される。

@{Vi には無い機能@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*ins-softtabstop*
When the 'softtabstop' option is non-zero, a <Tab> inserts 'softtabstop'
positions, and a <BS> used to delete white space, will delete 'softtabstop'
positions.  This feels like 'tabstop' was set to 'softtabstop', but a real
<Tab> character still takes 'tabstop' positions, so your file will still look
correct when used by other applications.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ins-softtabstop}
@cindex ins-softtabstop
'@option{softtabstop}' オプションが零ではない時、@key{<Tab>} は '@option{softtabstop}' で指定されるタブ位置まで空白を挿入し、@key{<BS>} は '@option{softtabstop}' で指定されるタブ位置までの空白を削除する。これは '@option{softtabstop}' に指定した値を '@option{tabstop}' に設定したのと同様に働くが、しかし本当の <Tab> 文字は依然 '@option{tabstop}' の幅に展開されるので、他のアプリケーションでそのファイルを使う時にも正しく表示されるだろう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If 'softtabstop' is non-zero, a <BS> will try to delete as much white space to
move to the previous 'softtabstop' position, except when the previously
inserted character is a space, then it will only delete the character before
the cursor.  Otherwise you cannot always delete a single character before the
cursor.  You will have to delete 'softtabstop' characters first, and then type
extra spaces to get where you want to be.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もしも '@option{softtabstop}' がゼロでないならば、直前に挿入された文字が 1 つの空白文字 (スペース) で、そのカーソルの直前の (空白) 文字だけを削除する時を除き、@key{<BS>} は空白文字を 1 つ前の '@option{softtabstop}' の位置まで削除しようと試みる。そうでないとカーソルの直前の単一の文字を消すということができなくなってしまう。まず '@option{softtabstop}' のキャラクタを消してから、それから望む場所にカーソルを持っていくために、余分な空白文字を置く必要がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
5. Replace mode				*Replace* *Replace-mode* *mode-replace*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Replace}
@anchor{Replace-mode}
@anchor{mode-replace}
@cindex Replace
@cindex Replace-mode
@cindex mode-replace
@cindex 置換モード
@section 5. 置換モード
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Enter Replace mode with the "R" command in normal mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ノーマルモードで "R" コマンドを使うと置換モードに入る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In Replace mode, one character in the line is deleted for every character you
type.  If there is no character to delete (at the end of the line), the
typed character is appended (as in Insert mode).  Thus the number of
characters in a line stays the same until you get to the end of the line.
If a <NL> is typed, a line break is inserted and no character is deleted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
置換モードでは、タイプされた全て文字のために行の文字が削除される。消す文字が無い場合 (行末)、タイプされた文字は (挿入モードのように) 追加される。このように行末に至るまで、行内のまとまった数の文字が同じままとどまる。<NL> がタイプされると、文字は消されずに改行が挿入される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Be careful with <Tab> characters.  If you type a normal printing character in
its place, the number of characters is still the same, but the number of
columns will become smaller.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
<Tab> 文字には注意。<Tab> のある場所に通常の印刷可能文字をタイプすると、文字数は同じだけど、見た目上のカラム数はより短くなってしまう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you delete characters in Replace mode (with <BS>, CTRL-W, or CTRL-U), what
happens is that you delete the changes.  The characters that were replaced
are restored.  If you had typed past the existing text, the characters you
added are deleted.  This is effectively a character-at-a-time undo.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
置換モードで文字を消す (@key{<BS>}, @kbd{CTRL-W} もしくは @kbd{CTRL-U}) 場合、変更を取り消すことになる。置き換えられてしまった文字が復帰する。存在していたテキストよりも多くタイプしていた場合には、その追加した分は削除される。これは効果的に 1 度に 1 文字ずつの UNDO になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the 'expandtab' option is on, a <Tab> will replace one character with
several spaces.  The result of this is that the number of characters in the
line increases.  Backspacing will delete one space at a time.  The original
character will be put back for only one space that you backspace over (the
last one).  {Vi does not have the 'expandtab' option}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{expandtab}' オプションがオンの場合、<Tab> は幾つかのスペースで置き換えられる。結果として行中の文字数は増えることになる。バックスペースは 1 度に 1 つの文字を消す。もともとの文字は 1 つのスペース (最後の 1 つ) をバックスペースするだけで戻される。

@{Vi には '@option{expandtab}' オプションはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
6. Virtual Replace mode		*vreplace-mode* *Virtual-Replace-mode*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{vreplace-mode}
@anchor{Virtual-Replace-mode}
@cindex vreplace-mode
@cindex Virtual-Replace-mode
@cindex 仮想置換モード
@section 6. 仮想置換モード
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Enter Virtual Replace mode with the "gR" command in normal mode.
{not available when compiled without the |+vreplace| feature}
{Vi does not have Virtual Replace mode}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ノーマルモードで "gR" コマンドを使うと仮想置換モードに入る。

@{|@ref{+vreplace}| 機能を付けずにコンパイルした場合は利用できない@}

@{Vi には仮想置換モードはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Virtual Replace mode is similar to Replace mode, but instead of replacing
actual characters in the file, you are replacing screen real estate, so that
characters further on in the file never appear to move.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
仮想置換モードは置換モードに良く似ているが、ファイルの実際の文字ごとにではなく、スクリーン上の文字幅単位で置換することができ、そのためファイル内の他の文字の見た目の位置が移動することはない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
So if you type a <Tab> it may replace several normal characters, and if you
type a letter on top of a <Tab> it may not replace anything at all, since the
<Tab> will still line up to the same place as before.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@key{<Tab>} をタイプすると通常のキャラクタを幾つか置換し、<Tab> の先頭で文字をタイプしたならば、<Tab> は以前と同じ場所に存在することになるから、何も置換されないことになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Typing a <NL> still doesn't cause characters later in the file to appear to
move.  The rest of the current line will be replaced by the <NL> (that is,
they are deleted), and replacing continues on the next line.  A new line is
NOT inserted unless you go past the end of the file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
<NL> をタイプしても、ファイル内の後の文字がその (見かけ上の) 位置を変えることはない。現在行の残りの部分は <NL> によって置き換えられ (それはつまり、消されるということ)、次の行で置換が続行される。ファイルの終端に達するまで、新しい行は挿入されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Interesting effects are seen when using CTRL-T and CTRL-D.  The characters
before the cursor are shifted sideways as normal, but characters later in the
line still remain still.  CTRL-T will hide some of the old line under the
shifted characters, but CTRL-D will reveal them again.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-T} と @kbd{CTRL-D} を使用したときには面白い効果がある。カーソルの前のキャラクタは普通に横にシフトされるが、しかしカーソルの後のキャラクタはそのままそこに残ろうとする。@kbd{CTRL-T} はシフトされた文字の下にある古い行を隠していくが、@kbd{CTRL-D} はそれらを再び表示してくれる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
As with Replace mode, using <BS> etc will bring back the characters that were
replaced.  This still works in conjunction with 'smartindent', CTRL-T and
CTRL-D, 'expandtab', 'smarttab', 'softtabstop', etc.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
置換モード同様に、@key{<BS>} 他を使用すると置換されてしまった文字を戻すことができる。この機能は '@option{smartindent}', @kbd{CTRL-T} それに @kbd{CTRL-D}, '@option{expandtab}', '@option{smarttab}', '@option{softtabstop}', その他などが考慮される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In 'list' mode, Virtual Replace mode acts as if it was not in 'list' mode,
unless "L" is in 'cpoptions'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'list' モードで '@option{cpoptions}' に "@var{L}" が含まれない時には、仮想置換モードはまるで 'list' モードでないかのように振舞う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that the only situations for which characters beyond the cursor should
appear to move are in List mode |'list'|, and occasionally when 'wrap' is set
(and the line changes length to become shorter or wider than the width of the
screen).  In other cases spaces may be inserted to avoid following characters
to move.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
カーソルより後ろの文字が移動して見えることがあるが、それは List モード |@ref{'list'}| がオンのとき、そしてまれに '@option{wrap}' がオンのとき (そして変更によって行の長さがスクリーンの幅より短くなるか長くなるとき) だけである。それ以外では、後ろの文字が動かないようにスペースが挿入される。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This mode is very useful for editing <Tab> separated columns in tables, for
entering new data while keeping all the columns aligned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このモードは <Tab> でカラムが区切られた表へ、新しいデータをカラムを揃えて入力するような編集作業に便利である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
7. Insert mode completion				*ins-completion*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ins-completion}
@cindex ins-completion
@cindex 挿入モードの補完
@section 7. 挿入モードの補完
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In Insert and Replace mode, there are several commands to complete part of a
keyword or line that has been typed.  This is useful if you are using
complicated keywords (e.g., function names with capitals and underscores).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
挿入・置換モードでは、既にタイプしたキーワードや行の一部を補完するコマンドを使用できる。これは複雑なキーワード (例えば大文字やアンダースコアを含む関数名など) を使用しているときに便利である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These commands are not available when the |+insert_expand| feature was
disabled at compile time.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この機能はコンパイル時に |@ref{+insert_expand}| 機能を有効にしておかないと使用できない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Completion can be done for:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
補完には次のような種類がある:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. Whole lines						|i_CTRL-X_CTRL-L|
2. keywords in the current file				|i_CTRL-X_CTRL-N|
3. keywords in 'dictionary'				|i_CTRL-X_CTRL-K|
4. keywords in 'thesaurus', thesaurus-style		|i_CTRL-X_CTRL-T|
5. keywords in the current and included files		|i_CTRL-X_CTRL-I|
6. tags							|i_CTRL-X_CTRL-]|
7. file names						|i_CTRL-X_CTRL-F|
8. definitions or macros				|i_CTRL-X_CTRL-D|
9. Vim command-line					|i_CTRL-X_CTRL-V|
10. User defined completion				|i_CTRL-X_CTRL-U|
11. omni completion					|i_CTRL-X_CTRL-O|
12. Spelling suggestions				|i_CTRL-X_s|
13. keywords in 'complete'				|i_CTRL-N| |i_CTRL-P|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .6 .4
@item 7.1. 行全体 @tab |@ref{i_CTRL-X_CTRL-L}|
@item 7.2. 現在のファイルのキーワード @tab |@ref{i_CTRL-X_CTRL-N}|
@item 7.3. '@option{dictionary}' のキーワード @tab |@ref{i_CTRL-X_CTRL-K}|
@item 7.4. '@option{thesaurus}' のキーワード, thesaurus-style @tab |@ref{i_CTRL-X_CTRL-T}|
@item 7.5. 編集中と外部参照しているファイルのキーワード @tab |@ref{i_CTRL-X_CTRL-I}|
@item 7.6. タグ @tab |@ref{i_CTRL-X_CTRL-]}|
@item 7.7. ファイル名 @tab |@ref{i_CTRL-X_CTRL-F}|
@item 7.8. 定義もしくはマクロ @tab |@ref{i_CTRL-X_CTRL-D}|
@item 7.9. Vim のコマンドライン @tab |@ref{i_CTRL-X_CTRL-V}|
@item 7.10. ユーザー定義補完 @tab |@ref{i_CTRL-X_CTRL-U}|
@item 7.11. オムニ補完 @tab |@ref{i_CTRL-X_CTRL-O}|
@item 7.12. スペリング補完 @tab |@ref{i_CTRL-X_s}|
@item 7.13. '@option{complete}' のキーワード @tab |@ref{i_CTRL-N}| |@ref{i_CTRL-P}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
All these, except CTRL-N and CTRL-P, are done in CTRL-X mode.  This is a
sub-mode of Insert and Replace modes.  You enter CTRL-X mode by typing CTRL-X
and one of the CTRL-X commands.  You exit CTRL-X mode by typing a key that is
not a valid CTRL-X mode command.  Valid keys are the CTRL-X command itself,
CTRL-N (next), and CTRL-P (previous).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-N} と @kbd{CTRL-P} を除くこれらの全ては、CTRL-X モードで動作する。CTRL-X モードとは挿入・置換モードのサブモードである。@kbd{CTRL-X} と @kbd{CTRL-X} コマンドのどれか 1 つをタイプすることで CTRL-X モードに移行する。CTRL-X モードから抜けるには、CTRL-X コマンドとして有効ではないキーをタイプする。有効なキーとは @kbd{CTRL-X} コマンドそれ自身、@kbd{CTRL-N} (次の候補)、そして @kbd{CTRL-P} (前の候補)である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Also see the 'infercase' option if you want to adjust the case of the match.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マッチの大文字/小文字を調節したいのならばオプション '@option{infercase}' を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*complete_CTRL-E*
When completion is active you can use CTRL-E to stop it and go back to the
originally typed text.  The CTRL-E will not be inserted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{complete_CTRL-E}
@kindex complete_CTRL-E
補完が動作中のとき、@kbd{CTRL-E} で補完を中止し、もともと入力したテキストに戻すことができる。CTRL-E は挿入されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*complete_CTRL-Y*
When the popup menu is displayed you can use CTRL-Y to stop completion and
accept the currently selected entry.  The CTRL-Y is not inserted.  Typing a
space, Enter, or some other unprintable character will leave completion mode
and insert that typed character.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{complete_CTRL-Y}
@kindex complete_CTRL-Y
ポップアップメニューが表示されているとき、@kbd{CTRL-Y} で補完を中止し、現在選択されている候補を挿入できる。CTRL-Y は挿入されない。スペース、エンターなど unprintable な文字を入力すると、その文字を挿入して補完モードを終了する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the popup menu is displayed there are a few more special keys, see
|popupmenu-keys|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ポップアップメニューが表示されているときに使える特殊なキーがもういくつかある。|@ref{popupmenu-keys}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: The keys that are valid in CTRL-X mode are not mapped.  This allows for
":map ^F ^X^F" to work (where ^F is CTRL-F and ^X is CTRL-X).  The key that
ends CTRL-X mode (any key that is not a valid CTRL-X mode command) is mapped.
Also, when doing completion with 'complete' mappings apply as usual.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
CTRL-X モードでの有効なキーはマップされない。これは ":map ^F ^X^F" な指定を可能にする (^F と ^X はそれぞれ CTRL-F と CTRL-X の意味)。これに対して、CTRL-X モードを終了させるキー (つまり CTRL-X モードのコマンドとして有効ではないキー) はマップされる。'@option{complete}' を使って補完をするとき、マップは通常通りに適用される。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: While completion is active Insert mode can't be used recursively.
Mappings that somehow invoke ":normal i.." will generate an E523 error.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
補完が動作中は、再帰的に挿入モードに入ることはできない。":normal i.." のようなマッピングを使うとエラー E523 が発生する。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The following mappings are suggested to make typing the completion commands
a bit easier (although they will hide other commands): >
    :inoremap ^] ^X^]
    :inoremap ^F ^X^F
    :inoremap ^D ^X^D
    :inoremap ^L ^X^L
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のマッピングは補完コマンドのタイピングをちょっとだけ楽にしようと提案された (これらは他のコマンドを覆い隠してしまうけれど):
@verbatim
:inoremap ^] ^X^]
:inoremap ^F ^X^F
:inoremap ^D ^X^D
:inoremap ^L ^X^L
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
As a special case, typing CTRL-R to perform register insertion (see
|i_CTRL-R|) will not exit CTRL-X mode.  This is primarily to allow the use of
the '=' register to call some function to determine the next operation.  If
the contents of the register (or result of the '=' register evaluation) are
not valid CTRL-X mode keys, then CTRL-X mode will be exited as if those keys
had been typed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例外として、レジスタの値を挿入する @kbd{CTRL-R} は CTRL-X モードを終了しない。これは主に '=' レジスタを使って関数などを呼び次の操作を決定することを可能にする。レジスタの内容 (や '=' レジスタの評価結果) が CTRL-X モードで無効なキーだった場合、それが入力されたものとして CTRL-X モードは終了する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For example, the following will map <Tab> to either actually insert a <Tab> if
the current line is currently only whitespace, or start/continue a CTRL-N
completion operation: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下のものは現在の行がスペースだけなら <Tab> を入力し、違うなら CTRL-N の補完をする <Tab> をマッピングする例である:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	function! CleverTab()
	   if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
	      return "\<Tab>"
	   else
	      return "\<C-N>"
	   endif
	endfunction
	inoremap <Tab> <C-R>=CleverTab()<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
function! CleverTab()
   if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
      return "\<Tab>"
   else
      return "\<C-N>"
   endif
endfunction
inoremap <Tab> <C-R>=CleverTab()<CR>
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------



@ifset EN
Completing whole lines					*compl-whole-line*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{compl-whole-line}
@cindex compl-whole-line
@cindex 行全体を補完する
@unnumberedsubsec 7.1. 行全体を補完する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*i_CTRL-X_CTRL-L*
CTRL-X CTRL-L		Search backwards for a line that starts with the
			same characters as those in the current line before
			the cursor.  Indent is ignored.  The matching line is
			inserted in front of the cursor.
			The 'complete' option is used to decide which buffers
			are searched for a match.  Both loaded and unloaded
			buffers are used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-X_CTRL-L}
@kindex i_CTRL-X_CTRL-L
@table @asis
@item @kbd{CTRL-X} @kbd{CTRL-L}
現在行のカーソルの前にあるのと同じ文字で始まる行を、後方 (上方向) に探す。インデントは無視される。見つかった行がカーソルの前に挿入される。

どのバッファから探すのかを決める際に '@option{complete}' オプションが参照される。読み込まれたバッファ (loaded buffer) と読み込まれていないバッファ (unloaded buffer) の両方が対象となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	CTRL-L	or
	CTRL-P		Search backwards for next matching line.  This line
			replaces the previous matching line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @kbd{CTRL-L} または
@itemx @kbd{CTRL-P}
後方に、次にマッチする行を探す。これによりみつかった行で、以前のマッチした行を置き換える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-N		Search forward for next matching line.  This line
			replaces the previous matching line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-N}
前方に、次のマッチする行を探す。これによりみつかった行で以前のマッチした行を置き換える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-X CTRL-L	After expanding a line you can additionally get the
			line next to it by typing CTRL-X CTRL-L again, unless
			a double CTRL-X is used.  Only works for loaded
			buffers.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-X} @kbd{CTRL-L}
行を展開した後で再び @kbd{CTRL-X} @kbd{CTRL-L} をタイプすれば、それに続けて付加的に行を取得でき、@kbd{CTRL-X} を 2 回押すことで終了する。読み込まれているバッファのみ検索対象となる。
@end table
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Completing keywords in current file			*compl-current*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{compl-current}
@cindex compl-current
@cindex 現在のファイルのキーワードで補完する
@unnumberedsubsec 7.2. 現在のファイルのキーワードで補完する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*i_CTRL-X_CTRL-P*
							*i_CTRL-X_CTRL-N*
CTRL-X CTRL-N		Search forwards for words that start with the keyword
			in front of the cursor.  The found keyword is inserted
			in front of the cursor.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-X_CTRL-P}
@anchor{i_CTRL-X_CTRL-N}
@kindex i_CTRL-X_CTRL-P
@kindex i_CTRL-X_CTRL-N
@table @asis
@item @kbd{CTRL-X} @kbd{CTRL-N}
カーソルの前にあるキーワードで始まる単語を、前方に検索する。みつかったキーワードはカーソルの前に挿入される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CTRL-X CTRL-P		Search backwards for words that start with the keyword
			in front of the cursor.  The found keyword is inserted
			in front of the cursor.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-X} @kbd{CTRL-P}
カーソルの前にあるキーワードで始まる単語を、後方に検索する。みつかったキーワードはカーソルの前に挿入される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @kbd{CTRL-N}
次にマッチするキーワードを前方に検索する。このキーワードは前回マッチしたキーワードを置き換える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-P}
次にマッチするキーワードを後方に検索する。このキーワードは前回マッチしたキーワードを置き換える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-X CTRL-N or
	CTRL-X CTRL-P	Further use of CTRL-X CTRL-N or CTRL-X CTRL-P will
			copy the words following the previous expansion in
			other contexts unless a double CTRL-X is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-X} @kbd{CTRL-N} または
@itemx @kbd{CTRL-X} @kbd{CTRL-P}
続けて @kbd{CTRL-X} @kbd{CTRL-N} や @kbd{CTRL-X} @kbd{CTRL-P} を使用することで、最後の展開に続けて違うコンテキストで単語を補完することができる。これは @kbd{CTRL-X} を 2 度押すことで終了できる。
@end table
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If there is a keyword in front of the cursor (a name made out of alphabetic
characters and characters in 'iskeyword'), it is used as the search pattern,
with "\<" prepended (meaning: start of a word).  Otherwise "\<\k\k" is used
as search pattern (start of any keyword of at least two characters).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カーソルの直前にあるキーワード (アルファベットと '@option{iskeyword}' の文字で構成される名前)が、直前に "\<" (単語の開始の意味)が補われて検索パターンとして使用される。キーワードがない場合には "\<\k\k" (少なくとも2文字以上のキーワードの開始位置) が検索パターンに用いられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In Replace mode, the number of characters that are replaced depends on the
length of the matched string.  This works like typing the characters of the
matched string in Replace mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
置換モードでは、置換される文字数はマッチした文字列の長さに依存する。これはマッチした文字列を置換モードでタイピングしたのと同じように振舞う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If there is not a valid keyword character before the cursor, any keyword of
at least two characters is matched.
	e.g., to get:
	    printf("(%g, %g, %g)", vector[0], vector[1], vector[2]);
	just type:
	    printf("(%g, %g, %g)", vector[0], ^P[1], ^P[2]);
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カーソルの直前に有効なキーワードの文字がなかった場合、少なくとも 2 文字以上のあらゆるキーワードがマッチする。

例えば、次の結果を得るには:
@verbatim
printf("(%g, %g, %g)", vector[0], vector[1], vector[2]);
@end verbatim
このようにタイプする:
@example
printf("(%g, %g, %g)", vector[0], ^P[1], ^P[2]);
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The search wraps around the end of the file, the value of 'wrapscan' is not
used here.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
検索はファイルの最後から最初へ循環する。ここでは '@option{wrapscan}' の値は使われない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Multiple repeats of the same completion are skipped; thus a different match
will be inserted at each CTRL-N and CTRL-P (unless there is only one
matching keyword).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
同じ補完結果が繰り返される場合にはそれがスキップされる; そのため @kbd{CTRL-N} や @kbd{CTRL-P} を押すたびに違うマッチ文字列が挿入されることになる (1 つしかマッチするキーワードがない場合は除く)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Single character matches are never included, as they usually just get in
the way of what you were really after.
	e.g., to get:
		printf("name = %s\n", name);
	just type:
		printf("name = %s\n", n^P);
	or even:
		printf("name = %s\n", ^P);
The 'n' in '\n' is skipped.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マッチ結果が 1 文字となる補完候補文字列は、通常の使用で実際に補完して欲しいものではないことがほとんどなので、補完候補に含まない。

例えば、次の結果を得るには:
@verbatim
printf("name = %s\n", name);
@end verbatim
このようにタイプする:
@example
printf("name = %s\n", n^P);
@end example
こうでも良い:
@example
printf("name = %s\n", ^P);
@end example
'\n' の中の文字 'n' はスキップされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
After expanding a word, you can use CTRL-X CTRL-P or CTRL-X CTRL-N to get the
word following the expansion in other contexts.  These sequences search for
the text just expanded and further expand by getting an extra word.  This is
useful if you need to repeat a sequence of complicated words.  Although CTRL-P
and CTRL-N look just for strings of at least two characters, CTRL-X CTRL-P and
CTRL-X CTRL-N can be used to expand words of just one character.
	e.g., to get:
		M&eacute;xico
	you can type:
		M^N^P^X^P^X^P
CTRL-N starts the expansion and then CTRL-P takes back the single character
"M", the next two CTRL-X CTRL-P's get the words "&eacute" and ";xico".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
単語補完を開始した後で、補完済み単語に続く単語を検索するのに、@kbd{CTRL-X} @kbd{CTRL-P} もしくは @kbd{CTRL-X} @kbd{CTRL-N} を使うことができる。これらのシーケンスはテキストから探され、単語を拡張補完し、さらに拡張補完していくことができる。これは複雑な単語のシーケンスを繰り返す必要があるときに役に立つ。@kbd{CTRL-P} と @kbd{CTRL-N} は少なくとも 2 文字以上の文字列を探すけれども、@kbd{CTRL-X} @kbd{CTRL-P} と @kbd{CTRL-X} @kbd{CTRL-N} は 1 文字の文字列も探し出す。

例えば、次の結果を得るには:
@verbatim
M&eacute;xico
@end verbatim
このようにタイプする:
@example
M^N^P^X^P^X^P
@end example
@kbd{CTRL-N} は補完を開始し、@kbd{CTRL-P} で最初の 1 文字 "M" に戻し、次の 2 つの @kbd{CTRL-X} @kbd{CTRL-P} が "&eacute" と ";xico" を得る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the previous expansion was split, because it got longer than 'textwidth',
then just the text in the current line will be used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
直前の補完が '@option{textwidth}' よりも長いために分裂している場合、現在の行のテキストだけが使用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the match found is at the end of a line, then the first word in the next
line will be inserted and the message "word from next line" displayed, if
this word is accepted the next CTRL-X CTRL-P or CTRL-X CTRL-N will search
for those lines starting with this word.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マッチ文字列が行末で見つかった場合には、次の行の最初の単語が挿入され "word from next line" というメッセージが表示される。さらに続けて @kbd{CTRL-X} @kbd{CTRL-P} もしくは @kbd{CTRL-X} @kbd{CTRL-N} で検索を行うと、その単語のある行で続く文字が検索される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Completing keywords in 'dictionary'			*compl-dictionary*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{compl-dictionary}
@cindex compl-dictionary
@cindex 'dictionary' のキーワードで補完する
@unnumberedsubsec 7.3. 'dictionary' のキーワードで補完する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*i_CTRL-X_CTRL-K*
CTRL-X CTRL-K		Search the files given with the 'dictionary' option
			for words that start with the keyword in front of the
			cursor.  This is like CTRL-N, but only the dictionary
			files are searched, not the current file.  The found
			keyword is inserted in front of the cursor.  This
			could potentially be pretty slow, since all matches
			are found before the first match is used.  By default,
			the 'dictionary' option is empty.
			For suggestions where to find a list of words, see the
			'dictionary' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-X_CTRL-K}
@kindex i_CTRL-X_CTRL-K
@table @asis
@item @kbd{CTRL-X} @kbd{CTRL-K}
カーソルの直前のキーワードで始まる単語をオプション '@option{dictionary}' で与えられたファイルから検索する。これは @kbd{CTRL-N} に似ているが、現在のファイル内は検索せずに辞書ファイル内だけを検索する。見つけたキーワードはカーソルの直前に挿入される。最初のマッチが使用される前に全てのマッチが検索されるので、かなり遅くなる可能性がある。オプション '@option{dictionary}' の初期値は空である。どこから単語リストを見つけ出すかについては、オプション '@option{dictionary}' を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-K	or
	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @kbd{CTRL-K} または
@itemx @kbd{CTRL-N}
マッチするキーワードの前方検索。直前にマッチしたキーワードは新しいもので置き換えられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-P}
マッチするキーワードの後方検索。直前にマッチしたキーワードは新しいもので置き換えられる。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*i_CTRL-X_CTRL-T*
CTRL-X CTRL-T		Works as CTRL-X CTRL-K, but in a special way.  It uses
			the 'thesaurus' option instead of 'dictionary'.  If a
			match is found in the thesaurus file, all the
			remaining words on the same line are included as
			matches, even though they don't complete the word.
			Thus a word can be completely replaced.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-X_CTRL-T}
@kindex i_CTRL-X_CTRL-T
@item @kbd{CTRL-X} @kbd{CTRL-T}
@kbd{CTRL-X} @kbd{CTRL-K} と同じだが、'@option{dictionary}' ではなく '@option{thesaurus}' オプションを使う。たとえ単語が完全でなくても、類語ファイルの中に単語が見つかると、その行の他の単語も一致とみなされる。したがって単語は完全に置き換えられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			For an example, imagine the 'thesaurus' file has a
			line like this: >
				angry furious mad enraged
<			Placing the cursor after the letters "ang" and typing
			CTRL-X CTRL-T would complete the word "angry";
			subsequent presses would change the word to "furious",
			"mad" etc.
			Other uses include translation between two languages,
			or grouping API functions by keyword.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば、'thesaurus' ファイルにこのような行があるとして:
@verbatim
angry furious mad enraged
@end verbatim
カーソルが "ang" の後にあり、@kbd{CTRL-X} @kbd{CTRL-T} を押すと "angry" が補完される。続けて補完すると "furious", "mad", ...、と置き換えられる。

他にも 2 つの言語間の単語の置き換えや、API 関数をキーワードによってグループ分けするのに使える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-T	or
	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @kbd{CTRL-T} または
@itemx @kbd{CTRL-N}
次のキーワードを前方に探す。見つかったキーワードはその前のキーワードを置き換える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-P}
次のキーワードを後方に探す。見つかったキーワードはその前のキーワードを置き換える。
@end table
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Completing keywords in the current and included files	*compl-keyword*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{compl-keyword}
@cindex compl-keyword
@cindex 編集中と外部参照しているファイルのキーワードで補完する
@unnumberedsubsec 7.5. 編集中と外部参照しているファイルのキーワードで補完する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The 'include' option is used to specify a line that contains an include file
name.  The 'path' option is used to search for include files.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{include}' オプションは外部参照 (インクルード) ファイルを含む行を指定するのに使う。'@option{path}' オプションはインクルードファイルを探す場所を指定するのに使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*i_CTRL-X_CTRL-I*
CTRL-X CTRL-I		Search for the first keyword in the current and
			included files that starts with the same characters
			as those before the cursor.  The matched keyword is
			inserted in front of the cursor.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-X_CTRL-I}
@kindex i_CTRL-X_CTRL-I
@table @asis
@item @kbd{CTRL-X} @kbd{CTRL-I}
カーソルの直前と同じ文字で始まる最初のキーワードを、現在のファイルとインクルードファイルから探し出す。マッチしたキーワードはカーソルの直前に挿入される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-N		Search forwards for next matching keyword.  This
			keyword replaces the previous matching keyword.
			Note: CTRL-I is the same as <Tab>, which is likely to
			be typed after a successful completion, therefore
			CTRL-I is not used for searching for the next match.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @kbd{CTRL-N}
次にマッチするキーワードを前方検索する。直前にマッチしたキーワードは新しいもので置き換えられる。
@quotation
@strong{Note:} @*
@kbd{CTRL-I} は補完が成功した時に入力する <Tab> と同じである。従って @kbd{CTRL-I} を次のマッチを探すために使用することはできない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-P		Search backward for previous matching keyword.  This
			keyword replaces the previous matching keyword.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-P}
次にマッチするキーワードを後方検索する。直前にマッチしたキーワードは新しいもので置き換えられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-X CTRL-I	Further use of CTRL-X CTRL-I will copy the words
			following the previous expansion in other contexts
			unless a double CTRL-X is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-X} @kbd{CTRL-I}
直前の補完の文脈で続けて @kbd{CTRL-X} @kbd{CTRL-I} による単語補完を行う。2 連 @kbd{CTRL-X} が使用されるまで続く。
@end table
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Completing tags						*compl-tag*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{compl-tag}
@cindex compl-tag
@cindex タグで補完する
@unnumberedsubsec 7.6. タグで補完する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*i_CTRL-X_CTRL-]*
CTRL-X CTRL-]		Search for the first tag that starts with the same
			characters as before the cursor.  The matching tag is
			inserted in front of the cursor.  Alphabetic
			characters and characters in 'iskeyword' are used
			to decide which characters are included in the tag
			name (same as for a keyword).  See also |CTRL-]|.
			The 'showfulltag' option can be used to add context
			from around the tag definition.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-X_CTRL-]}
@kindex i_CTRL-X_CTRL-]
@table @asis
@item @kbd{CTRL-X} @kbd{CTRL-]}
カーソルの直前と同じ文字で始まる最初のタグを探し出す。マッチしたタグはカーソルの直前に挿入される。アルファベットと '@option{iskeyword'} で指定される文字が、タグ名にどの文字が含まれるかを決定する (これはキーワードと同じルール)。|@ref{CTRL-]}| も参照。'@option{showfulltag}' オプションはタグ定義の周辺からコンテキストに含めるために使用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	CTRL-]	or
	CTRL-N		Search forwards for next matching tag.  This tag
			replaces the previous matching tag.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @kbd{CTRL-]} または
@itemx @kbd{CTRL-N}
次にマッチするタグを前方検索する。直前にマッチしたタグは新しいもので置き換えられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-P		Search backward for previous matching tag.  This tag
			replaces the previous matching tag.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-P}
次にマッチするタグを後方検索する。直前にマッチしたタグは新しいもので置き換えられる。
@end table
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Completing file names					*compl-filename*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{compl-filename}
@cindex compl-filename
@cindex ファイル名で補完する
@unnumberedsubsec 7.7. ファイル名で補完する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*i_CTRL-X_CTRL-F*
CTRL-X CTRL-F		Search for the first file name that starts with the
			same characters as before the cursor.  The matching
			file name is inserted in front of the cursor.
			Alphabetic characters and characters in 'isfname'
			are used to decide which characters are included in
			the file name.  Note: the 'path' option is not used
			here (yet).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-X_CTRL-F}
@kindex i_CTRL-X_CTRL-F
@table @asis
@item @kbd{CTRL-X} @kbd{CTRL-F}
カーソルの直前と同じ文字で始まる最初のファイル名を探し出す。マッチしたファイル名はカーソルの直前に挿入される。アルファベットと '@option{isfname}' で指定される文字が、ファイル名にどの文字が名前に含まれるかを決定する。
@quotation
@strong{Note:} @*
この段階では (まだ) '@option{path}' オプションは使用されない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	CTRL-F	or
	CTRL-N		Search forwards for next matching file name.  This
			file name replaces the previous matching file name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @kbd{CTRL-F} または
@itemx @kbd{CTRL-N}
次にマッチするファイル名を前方検索する。直前にマッチしたファイル名は新しいもので置き換えられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-P		Search backward for previous matching file name.
			This file name replaces the previous matching file
			name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-P}
次にマッチするファイル名を後方検索する。直前にマッチしたファイル名は新しいもので置き換えられる。
@end table
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Completing definitions or macros			*compl-define*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{compl-define}
@cindex compl-define
@cindex 定義もしくはマクロで補完する
@unnumberedsubsec 7.8. 定義もしくはマクロで補完する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The 'define' option is used to specify a line that contains a definition.
The 'include' option is used to specify a line that contains an include file
name.  The 'path' option is used to search for include files.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
定義を含んだ行を特定するのに '@option{define}' オプションが使用される。インクルードファイルを含んだ行を特定するのに '@option{include}' オプションが使用される。インクルードファイルを探すのに '@option{path}' オプションが使用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*i_CTRL-X_CTRL-D*
CTRL-X CTRL-D		Search in the current and included files for the
			first definition (or macro) name that starts with
			the same characters as before the cursor.  The found
			definition name is inserted in front of the cursor.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-X_CTRL-D}
@kindex i_CTRL-X_CTRL-D
@table @asis
@item @kbd{CTRL-X} @kbd{CTRL-D}
カーソルの直前と同じ文字で始まる最初の定義 (もしくはマクロ) 名を、現在のファイルとインクルードファイルから探し出す。マッチした定義名はカーソルの直前に挿入される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	CTRL-D	or
	CTRL-N		Search forwards for next matching macro name.  This
			macro name replaces the previous matching macro
			name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @kbd{CTRL-D} または
@itemx @kbd{CTRL-N}
次にマッチするマクロ名を前方検索する。直前にマッチしたマクロ名は新しいもので置き換えられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-P		Search backward for previous matching macro name.
			This macro name replaces the previous matching macro
			name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-P}
次にマッチするマクロ名を後方検索する。直前にマッチしたマクロ名は新しいもので置き換えられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-X CTRL-D	Further use of CTRL-X CTRL-D will copy the words
			following the previous expansion in other contexts
			unless a double CTRL-X is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-X} @kbd{CTRL-D}
直前の補完の文脈で続けて @option{CTRL-X} @option{CTRL-D} による単語補完を行う。2 連 @option{CTRL-X} が使用されるまで続く。
@end table
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Completing Vim commands					*compl-vim*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{compl-vim}
@cindex compl-vim
@cindex Vim コマンドの補完
@unnumberedsubsec 7.9. Vim コマンドの補完
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Completion is context-sensitive.  It works like on the Command-line.  It
completes an Ex command as well as its arguments.  This is useful when writing
a Vim script.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
補完は文脈に左右される。コマンドラインでの入力時のように機能する。Ex コマンドとその引数も補完する。これは Vim script を書いているときに便利である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*i_CTRL-X_CTRL-V*
CTRL-X CTRL-V		Guess what kind of item is in front of the cursor and
			find the first match for it.
			Note: When CTRL-V is mapped you can often use CTRL-Q
			instead of |i_CTRL-Q|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-X_CTRL-V}
@kindex i_CTRL-X_CTRL-V
@table @asis
@item @kbd{CTRL-X} @kbd{CTRL-V}
カーソルの前に何があるかを推測し、最初に一致するものを探す。
@quotation
@strong{Note:} @*
@kbd{CTRL-V} がマッピングに使われていれば、たいていは @kbd{CTRL-Q} が代わりに使える |@ref{i_CTRL-Q}|。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	CTRL-V	or
	CTRL-N		Search forwards for next match.  This match replaces
			the previous one.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @kbd{CTRL-V} または
@itemx @kbd{CTRL-N}
次の一致を前方に探す。そしてその前のものを置き換える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-P		Search backwards for previous match.  This match
			replaces the previous one.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-P}
次の一致を後方に探す。そしてその前のものを置き換える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-X CTRL-V	Further use of CTRL-X CTRL-V will do the same as
			CTRL-V.  This allows mapping a key to do Vim command
			completion, for example: >
				:imap <Tab> <C-X><C-V>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-X} @kbd{CTRL-V}
加えて言うと @kbd{CTRL-X} @kbd{CTRL-V} は @kbd{CTRL-V} と同じように働く。これは Vim コマンドの補完をマッピングをするのに使える。例えば:
@verbatim
:imap <Tab> <C-X><C-V>
@end verbatim
@end table
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
User defined completion					*compl-function*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{compl-function}
@cindex compl-function
@cindex ユーザー定義補完
@unnumberedsubsec 7.10. ユーザー定義補完
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Completion is done by a function that can be defined by the user with the
'completefunc' option.  See below for how the function is called and an
example |complete-functions|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザー定義補完は、オプション '@option{completefunc}' で設定した関数 (ユーザー定義関数でもよい) によって補完する方法である。この関数がどう呼び出されるかについては後述。また |@ref{complete-functions}| の例を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*i_CTRL-X_CTRL-U*
CTRL-X CTRL-U		Guess what kind of item is in front of the cursor and
			find the first match for it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-X_CTRL-U}
@kindex i_CTRL-X_CTRL-U
@table @asis
@item @kbd{CTRL-X} @kbd{CTRL-U}
カーソルの前にどの種類の項目があるか推測し、最初の候補を探す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	CTRL-U	or
	CTRL-N		Use the next match.  This match replaces the previous
			one.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @kbd{CTRL-U} または
@itemx @kbd{CTRL-N}
次の候補を選択し、現在の候補と置き換える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-P		Use the previous match.  This match replaces the
			previous one.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-P}
前の候補を選択し、現在の候補と置き換える。
@end table
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Omni completion						*compl-omni*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{compl-omni}
@cindex compl-omni
@cindex オムニ補完
@unnumberedsubsec 7.11. オムニ補完
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Completion is done by a function that can be defined by the user with the
'omnifunc' option.  This is to be used for filetype-specific completion.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オムニ補完は、オプション '@option{omnifunc}' で設定した関数 (ユーザー定義関数でもよい) によって補完する方法である。ファイル形式に特化した補完をするために使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
See below for how the function is called and an example |complete-functions|.
For remarks about specific filetypes see |compl-omni-filetypes|.
More completion scripts will appear, check www.vim.org.  Currently there is a
first version for C++.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この関数がどう呼び出されるかについては後述。また |@ref{complete-functions}| も参照。特定のファイル形式についての説明は |@ref{compl-omni-filetypes}| を参照。

今後、@url{www.vim.org} でより多くの補完スクリプトが公開されるだろう。現在のところ、C++ 用の最初のバージョンが存在する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*i_CTRL-X_CTRL-O*
CTRL-X CTRL-O		Guess what kind of item is in front of the cursor and
			find the first match for it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-X_CTRL-O}
@kindex i_CTRL-X_CTRL-O
@table @asis
@item @kbd{CTRL-X} @kbd{CTRL-O}
カーソルの前にどの種類の要素があるか推測し、最初の候補を探す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	CTRL-O	or
	CTRL-N		Use the next match.  This match replaces the previous
			one.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @kbd{CTRL-O} または
@itemx @kbd{CTRL-N}
次の候補を選択し、現在の候補と置き換える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-P		Use the previous match.  This match replaces the
			previous one.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-P}
前の候補を選択し、現在の候補と置き換える。
@end table
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Spelling suggestions					*compl-spelling*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{compl-spelling}
@cindex compl-spelling
@cindex スペリング補完
@unnumberedsubsec 7.12. スペリング補完
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A word before or at the cursor is located and correctly spelled words are
suggested to replace it.  If there is a badly spelled word in the line, before
or under the cursor, the cursor is moved to after it.  Otherwise the word just
before the cursor is used for suggestions, even though it isn't badly spelled.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カーソル前、またはカーソル位置の単語を探しだし、正しい単語の候補に置換する。カレント行のカーソル位置以前にスペルの間違った単語が存在する場合、カーソルがその単語の直後に移動する。間違った単語が存在しない場合はカーソルの直前の単語 (その単語が間違っていなくても) の訂正候補が表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
NOTE: CTRL-S suspends display in many Unix terminals.  Use 's' instead.  Type
CTRL-Q to resume displaying.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
Unix 端末の多くでは @kbd{CTRL-S} は画面をサスペンドさせるため、代わりに 's' を使うこと。サスペンドした画面を元に戻すには @kbd{CTRL-Q} を押す。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*i_CTRL-X_CTRL-S* *i_CTRL-X_s*
CTRL-X CTRL-S   or
CTRL-X s		Locate the word in front of the cursor and find the
			first spell suggestion for it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-X_CTRL-S}
@anchor{i_CTRL-X_s}
@kindex i_CTRL-X_CTRL-S
@kindex i_CTRL-X_s
@table @asis
@item @kbd{CTRL-X} @kbd{CTRL-S} または
@itemx @kbd{CTRL-X} s
カーソル前の単語を探し、その単語の正しい綴りの候補を探す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	CTRL-S	or
	CTRL-N		Use the next suggestion.  This replaces the previous
			one.  Note that you can't use 's' here.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @kbd{CTRL-S} または
@itemx @kbd{CTRL-N}
次の候補を選択する。これによって以前の候補は置換される。
@quotation
@strong{Note:} @*
ここでは代わりに 's' は使えないことに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-P		Use the previous suggestion.  This replaces the
			previous one.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-P}
前の候補を選択する。これによって以前の候補は置換される。
@end table
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Completing keywords from different sources		*compl-generic*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{compl-generic}
@cindex compl-generic
@cindex キーワードを別のソースから補完する
@unnumberedsubsec 7.13. キーワードを別のソースから補完する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*i_CTRL-N*
CTRL-N			Find next match for words that start with the
			keyword in front of the cursor, looking in places
			specified with the 'complete' option.  The found
			keyword is inserted in front of the cursor.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-N}
@kindex i_CTRL-N
@table @asis
@item @kbd{CTRL-N}
カーソルの直前と同じキーワードで始まる単語を、'@option{complete}' オプションで指定された場所から前方検索する。マッチしたキーワードはカーソルの直前に挿入される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*i_CTRL-P*
CTRL-P			Find previous match for words that start with the
			keyword in front of the cursor, looking in places
			specified with the 'complete' option.  The found
			keyword is inserted in front of the cursor.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i_CTRL-P}
@kindex i_CTRL-P
@item @kbd{CTRL-P}
カーソルの直前と同じキーワードで始まる単語を、'@option{complete}' オプションで指定された場所から後方検索する。マッチしたキーワードはカーソルの直前に挿入される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @kbd{CTRL-N}
次にマッチするキーワードを前方検索する。直前にマッチしたキーワードは新しいもので置き換えられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-P}
次にマッチするキーワードを後方検索する。直前にマッチしたキーワードは新しいもので置き換えられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-X CTRL-N or
	CTRL-X CTRL-P	Further use of CTRL-X CTRL-N or CTRL-X CTRL-P will
			copy the words following the previous expansion in
			other contexts unless a double CTRL-X is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-X} @kbd{CTRL-N} または
@itemx @kbd{CTRL-X} @kbd{CTRL-P}
直前の補完の文脈で続けて @kbd{CTRL-X} @kbd{CTRL-N} もしくは @kbd{CTRL-X} @kbd{CTRL-P} による単語補完を行う。2 連 @kbd{CTRL-X} が使用されるまで続く。
@end table
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
FUNCTIONS FOR FINDING COMPLETIONS			*complete-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{complete-functions}
@cindex complete-functions
@cindex 補完候補を検索する関数
@unnumberedsubsubsec 補完候補を検索する関数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This applies to 'completefunc' and 'omnifunc'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここでは '@option{completefunc}' と '@option{omnifunc}' について説明する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The function is called in two different ways:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらの関数は次の 2 通りの形で呼ばれる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- First the function is called to find the start of the text to be completed.
- Later the function is called to actually find the matches.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item 最初に、補完するテキストの始点を見つけるために呼ばれる。
@item 次に実際に候補を検索するために呼ばれる。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
On the first invocation the arguments are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最初の形での呼び出しでは、次の引数が与えられる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   a:findstart  1
   a:base	empty
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
a:findstart  1
a:base	empty
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The function must return the column where the completion starts.  It must be a
number between zero and the cursor column "col('.')".  This involves looking
at the characters just before the cursor and including those characters that
could be part of the completed item.  The text between this column and the
cursor column will be replaced with the matches.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらの関数は補完するテキストの始点の桁番号を返す責任を負う。桁番号は 0 以上 "col('.')" 未満でなければならない。カーソル直前の文字列を見て、補完候補の一部となりうる文字を含める処理が必要となる。この桁とカーソル位置の間のテキストが補完され、候補で置き換わることになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Special return values:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
特別な戻り値:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   -1 If no completion can be done, the completion will be cancelled with an
      error message.
   -2 To cancel silently and stay in completion mode.
   -3 To cancel silently and leave completion mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item -1 @tab 補完を行えない場合。補完はキャンセルされ、エラーメッセージが表示される。
@item -2 @tab メッセージなしでキャンセルし、補完モードに留まりたい場合。
@item -3 @tab メッセージなしでキャンセルし、補完モードから抜けたい場合。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
On the second invocation the arguments are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2 番目の形での呼び出しでは、次の引数が与えられる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   a:findstart  0
   a:base	the text with which matches should match; the text that was
		located in the first call (can be empty)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item a:findstart @tab 0
@item a:base @tab 補完対象のテキスト。つまり最初の呼び出しで指定したテキスト (空文字列の場合もありうる)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The function must return a List with the matching words.  These matches
usually include the "a:base" text.  When there are no matches return an empty
List.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらの関数は見つかった候補のリストを返す責任を負う。通常、候補の中には "a:base" そのものも含まれている。候補が存在しない場合は空リストを返すこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In order to return more information than the matching words, return a Dict
that contains the List.  The Dict can have these items:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
補完候補以外の情報を返したいときはそのリストを持った辞書を返す。辞書には以下のアイテムを含めることができる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	words		The List of matching words (mandatory).
	refresh		A string to control re-invocation of the function
			(optional).
			The only value currently recognized is "always", the
			effect is that the function is called whenever the
			leading text is changed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .15 .85
@item words @tab 補完候補のリスト (必須)
@item refresh @tab 関数の再呼び出しを制御する文字列 (オプション)

現在有効な値は "always" だけである。"always" を指定すると、補完対象のテキストが変更されるたびに補完関数が呼ばれるようになる。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Other items are ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
その他のアイテムは無視される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For acting upon end of completion, see the |CompleteDone| autocommand event.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
補完後に何かを実行したい場合はオートコマンドの |@ref{CompleteDone}| イベントを使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For example, the function can contain this: >
	let matches = ... list of words ...
	return {'words': matches, 'refresh': 'always'}
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば、次のようにして使う:
@verbatim
let matches = ... list of words ...
return {'words': matches, 'refresh': 'always'}
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*complete-items*
Each list item can either be a string or a Dictionary.  When it is a string it
is used as the completion.  When it is a Dictionary it can contain these
items:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{complete-items}
@cindex complete-items
リストの各要素は文字列か辞書のどちらかであること。文字列の場合はそれが候補となる。辞書の場合は以下の要素を含んでいること:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	word		the text that will be inserted, mandatory
	abbr		abbreviation of "word"; when not empty it is used in
			the menu instead of "word"
	menu		extra text for the popup menu, displayed after "word"
			or "abbr"
	info		more information about the item, can be displayed in a
			preview window
	kind		single letter indicating the type of completion
	icase		when non-zero case is to be ignored when comparing
			items to be equal; when omitted zero is used, thus
			items that only differ in case are added
	dup		when non-zero this match will be added even when an
			item with the same word is already present.
	empty		when non-zero this match will be added even when it is
			an empty string
	user_data 	custom data which is associated with the item and
			available in |v:completed_item|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .15 .85
@item word @tab 挿入されるテキスト。必須
@item abbr @tab "word" の略。これが空でなければ、メニューで "word" の代わりに表示される。
@item menu @tab ポップアップメニューにおける追加情報。"word" または "abbr" の後に表示される。
@item info @tab この要素についての追加情報。プレビューウィンドウに表示することができる。
@item kind @tab 候補の種類を表す1文字
@item icase @tab 0 でないならば、候補同士を比較するとき大文字小文字は無視される。省略された場合は 0 となり、大文字小文字の違いしかない候補も追加される。
@item dup @tab 0 でないならば、すでに同じ候補があってもこの候補を追加する。
@item empty @tab 0 でないならば、空文字であってもこの候補を追加する。
@item user_data @tab 候補に関連づけられ |@ref{v:completed_item}| で利用できるカスタムデータ。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
All of these except "icase", "dup" and "empty" must be a string.  If an item
does not meet these requirements then an error message is given and further
items in the list are not used.  You can mix string and Dictionary items in
the returned list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのうち "@var{icase}", "@var{dup}", "@var{empty}" 以外は文字列でなければならない。これらの要件が満たされない場合はエラーメッセージが表示され、リスト中のそれ以降の要素は無視される。リストの中で文字列と辞書が混在していてもよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "menu" item is used in the popup menu and may be truncated, thus it should
be relatively short.  The "info" item can be longer, it will  be displayed in
the preview window when "preview" appears in 'completeopt'.  The "info" item
will also remain displayed after the popup menu has been removed.  This is
useful for function arguments.  Use a single space for "info" to remove
existing text in the preview window.  The size of the preview window is three
lines, but 'previewheight' is used when it has a value of 1 or 2.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@var{menu}" はポップアップメニューに表示される。長すぎる場合は切り詰められるので、短くするとよい。"@var{info}" は '@option{completeopt}' に "@var{preview}" が含まれている場合にプレビューウィンドウに表示される。これはもっと長くてもよい。"@var{info}" はまた、ポップアップメニューが消えた後にもそのまま表示される。これは関数の引数を表示する場合などに便利である。"@var{info}" にスペース 1 個を指定すると、プレビューウィンドウに表示されているテキストが消去される。プレビューウィンドウの大きさは 3 行だが、'@option{previewheight}' が 1 か 2 のときはその高さで表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "kind" item uses a single letter to indicate the kind of completion.  This
may be used to show the completion differently (different color or icon).
Currently these types can be used:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@var{kind}" は候補の種類を示す 1 文字である。候補の表示方法 (色やアイコンなど) を区別するために使われる。現在のところ、指定可能な種類は次の通りである:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	v	variable
	f	function or method
	m	member of a struct or class
	t	typedef
	d	#define or macro
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .15 .85
@item v @tab 変数
@item f @tab 関数やメソッド
@item m @tab 構造体やクラスのメンバ
@item t @tab typedef
@item d @tab #define やマクロ
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When searching for matches takes some time call |complete_add()| to add each
match to the total list.  These matches should then not appear in the returned
list!  Call |complete_check()| now and then to allow the user to press a key
while still searching for matches.  Stop searching when it returns non-zero.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
候補の検索に時間がかかるときは |@ref{complete_add()}| を使って候補を 1 つずつリストに加えるとよい。その場合、それらの候補は戻り値のリストに現れるべきではない。ときどき |@ref{complete_check()}| を呼んで、候補の検索中にユーザーがキーを押して検索を中断できるようにすること。complete_check() が非 0 を返すと中断する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*E839* *E840*
The function is allowed to move the cursor, it is restored afterwards.
The function is not allowed to move to another window or delete text.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E839}
@anchor{E840}
@erindex E839
@erindex E840
関数の中でカーソルを移動させてもよい。カーソルは実行後に復元される。関数の中で他のウィンドウに移動したりテキストを削除することはできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An example that completes the names of the months: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
月の名前を補完する例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	fun! CompleteMonths(findstart, base)
	  if a:findstart
	    " locate the start of the word
	    let line = getline('.')
	    let start = col('.') - 1
	    while start > 0 && line[start - 1] =~ '\a'
	      let start -= 1
	    endwhile
	    return start
	  else
	    " find months matching with "a:base"
	    let res = []
	    for m in split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec")
	      if m =~ '^' . a:base
		call add(res, m)
	      endif
	    endfor
	    return res
	  endif
	endfun
	set completefunc=CompleteMonths
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
fun! CompleteMonths(findstart, base)
  if a:findstart
    " 単語の始点を検索する
    let line = getline('.')
    let start = col('.') - 1
    while start > 0 && line[start - 1] =~ '\a'
      let start -= 1
    endwhile
    return start
  else
    " "a:base" にマッチする月を探す
    let res = []
    for m in split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec")
      if m =~ '^' . a:base
    call add(res, m)
      endif
    endfor
    return res
  endif
endfun
set completefunc=CompleteMonths
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The same, but now pretending searching for matches is slow: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
検索が遅い場合のシミュレーション:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	fun! CompleteMonths(findstart, base)
	  if a:findstart
	    " locate the start of the word
	    let line = getline('.')
	    let start = col('.') - 1
	    while start > 0 && line[start - 1] =~ '\a'
	      let start -= 1
	    endwhile
	    return start
	  else
	    " find months matching with "a:base"
	    for m in split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec")
	      if m =~ '^' . a:base
		call complete_add(m)
	      endif
	      sleep 300m	" simulate searching for next match
	      if complete_check()
		break
	      endif
	    endfor
	    return []
	  endif
	endfun
	set completefunc=CompleteMonths
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
fun! CompleteMonths(findstart, base)
  if a:findstart
    " 単語の始点を検索する
    let line = getline('.')
    let start = col('.') - 1
    while start > 0 && line[start - 1] =~ '\a'
      let start -= 1
    endwhile
    return start
  else
    " "a:base" にマッチする月を探す
    for m in split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec")
      if m =~ '^' . a:base
    call complete_add(m)
      endif
      sleep 300m    " 次の候補の検索をシミュレートする
      if complete_check()
    break
      endif
    endfor
    return []
  endif
endfun
set completefunc=CompleteMonths
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
INSERT COMPLETION POPUP MENU				*ins-completion-menu*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ins-completion-menu}
@cindex ins-completion-menu
@cindex 補完ポップアップメニュー
@unnumberedsubsubsec 補完ポップアップメニュー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*popupmenu-completion*
Vim can display the matches in a simplistic popup menu.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{popupmenu-completion}
@cindex popupmenu-completion
候補を簡単なポップアップメニューで表示することができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The menu is used when:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ポップアップメニューは次のとき表示される:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The 'completeopt' option contains "menu" or "menuone".
- The terminal supports at least 8 colors.
- There are at least two matches.  One if "menuone" is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item '@option{completeopt}' が "@var{menu}" か "@var{menuone}" を含んでいる。
@item 端末が 8 色以上の表示をサポートしている。
@item 候補が 2 個以上ある。"@var{menuone}" を設定している場合は 1 個以上。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The 'pumheight' option can be used to set a maximum height.  The default is to
use all space available.
The 'pumwidth' option can be used to set a minimum width.  The default is 15
characters.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ポップアップメニューの高さの最大値はオプション '@option{pumheight}' で設定できる。既定値は利用可能なスペースをすべて使うようになっている。

'@option{pumwidth}' オプションは最小幅を設定できる。既定は 15 文字。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are three states:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ポップアップメニューには 3 つの状態がある:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
1. A complete match has been inserted, e.g., after using CTRL-N or CTRL-P.
2. A cursor key has been used to select another match.  The match was not
   inserted then, only the entry in the popup menu is highlighted.
3. Only part of a match has been inserted and characters were typed or the
   backspace key was used.  The list of matches was then adjusted for what is
   in front of the cursor.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item
候補が挿入された状態。例えば @kbd{CTRL-N} や @kbd{CTRL-P} の後。
@item
カーソルキーを使って他の候補を選択した後。候補はまだ挿入されていなく、1 つの候補が強調表示されている状態。
@item
候補の一部だけが挿入されており、文字の入力やバックスペースキーを使用できる状態。カーソルの前にある文字列によって候補のリストが増減する。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You normally start in the first state, with the first match being inserted.
When "longest" is in 'completeopt' and there is more than one match you start
in the third state.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
普通、最初は 1 番目の候補が挿入された状態 (状態 1) から始まる。'@option{completeopt}' に "@var{longest}" が含まれており、2 個以上の候補があるときは状態 3 から始まる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you select another match, e.g., with CTRL-N or CTRL-P, you go to the first
state.  This doesn't change the list of matches.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-N} や @kbd{CTRL-P} を押すことなどによって他の候補を選択すると状態 1 へ遷移する。このとき候補のリストは変化しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you are back at the original text then you are in the third state.  To
get there right away you can use a mapping that uses CTRL-P right after
starting the completion: >
	:imap <F7> <C-N><C-P>
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
元のテキストへ戻ると状態3になる。すぐに状態 3 へしたい場合は、次のように補完の直後に @kbd{CTRL-P} を行うマッピングを使えばよい:
@verbatim
:imap <F7> <C-N><C-P>
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*popupmenu-keys*
In the first state these keys have a special meaning:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{popupmenu-keys}
@cindex popupmenu-keys
状態 1 では以下のキーは特別な意味を持つ:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<BS> and CTRL-H   Delete one character, find the matches for the word before
		  the cursor.  This reduces the list of matches, often to one
		  entry, and switches to the second state.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @key{<BS>} と @kbd{CTRL-H}
1 文字削除し、カーソル前の単語の候補を検索する。これによって候補の数は少なくなり、しばしば 1 個だけになって状態 2 へ遷移する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Any non-special character:
		  Stop completion without changing the match and insert the
		  typed character.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 特殊文字でない任意の文字:
候補を変更せずに補完を停止し、入力された文字を挿入する。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In the second and third state these keys have a special meaning:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
状態2と状態3では以下のキーは特別な意味を持つ:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<BS> and CTRL-H   Delete one character, find the matches for the shorter word
		  before the cursor.  This may find more matches.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @key{<BS>} と @kbd{CTRL-H}
1 文字削除し、カーソル前の (短くなった) 単語の候補を検索する。候補の数は増える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
CTRL-L		  Add one character from the current match, may reduce the
		  number of matches.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-L}
現在の候補から 1 文字を挿入する。候補の数は少なくなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
any printable, non-white character:
		  Add this character and reduce the number of matches.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 印字可能で空白文字でない任意の文字:
その文字を挿入する。候補の数は少なくなる。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In all three states these can be used:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以上すべての状態で以下のキーが使える:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
CTRL-Y		  Yes: Accept the currently selected match and stop completion.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @kbd{CTRL-Y}
Yes: 現在選択されている候補に決定し、補完を終了する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
CTRL-E		  End completion, go back to what was there before selecting a
		  match (what was typed or longest common string).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-E}
補完を終了し、候補を選択する前の状態 (タイプした状態または最長共通文字列) へ戻る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<PageUp>	  Select a match several entries back, but don't insert it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @key{<PageUp>}
数個上の候補を選択するが、挿入はしない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<PageDown>	  Select a match several entries further, but don't insert it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @key{<PageDown>}
数個下の候補を選択するが、挿入はしない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<Up>		  Select the previous match, as if CTRL-P was used, but don't
		  insert it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @key{<Up>}
@kbd{CTRL-P} と同様に上の候補を選択するが、挿入はしない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<Down>		  Select the next match, as if CTRL-N was used, but don't
		  insert it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @key{<Down>}
@kbd{CTRL-N} と同様に下の候補を選択するが、挿入はしない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<Space> or <Tab>  Stop completion without changing the match and insert the
		  typed character.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @key{<Space>} または
@itemx @key{<Tab>}
候補を変更せずに補完を終了し、タイプされた文字を挿入する。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The behavior of the <Enter> key depends on the state you are in:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@key{<Enter>} キーの挙動は状態に依存する:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
first state:	  Use the text as it is and insert a line break.
second state:	  Insert the currently selected match.
third state:	  Use the text as it is and insert a line break.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .15 .85
@item 状態1: @tab テキストはそのままにし、改行を挿入する。
@item 状態2: @tab 選択されている候補を挿入する。
@item 状態3: @tab テキストはそのままにし、改行を挿入する。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In other words: If you used the cursor keys to select another entry in the
list of matches then the <Enter> key inserts that match.  If you typed
something else then <Enter> inserts a line break.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
言い換えると: カーソルキーでリストから他の候補を選択した後 @kbd{<Enter>} を押すとその候補を挿入する。それ以外をタイプした後で @kbd{<Enter>} を押すと改行が挿入される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
The colors of the menu can be changed with these highlight groups:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
メニューの色は以下のハイライトグループで設定できる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Pmenu		normal item  |hl-Pmenu|
PmenuSel	selected item  |hl-PmenuSel|
PmenuSbar	scrollbar  |hl-PmenuSbar|
PmenuThumb	thumb of the scrollbar  |hl-PmenuThumb|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item Pmenu @tab 通常の要素  |@ref{hl-Pmenu}|
@item PmenuSel @tab 選択されている要素  |@ref{hl-PmenuSel}|
@item PmenuSbar @tab スクロールバー  |@ref{hl-PmenuSbar}|
@item PmenuThumb @tab スクロールバーのつまみ |@ref{hl-PmenuThumb}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are no special mappings for when the popup menu is visible.  However,
you can use an Insert mode mapping that checks the |pumvisible()| function to
do something different.  Example: >
	:inoremap <Down> <C-R>=pumvisible() ? "\<lt>C-N>" : "\<lt>Down>"<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ポップアップメニューが表示されているとき用の特別なマッピングというものは存在しない。しかし挿入モードマッピングで関数 |@ref{pumvisible()}| を使えばポップアップメニューが表示されているときだけ用にマッピングを作ることができる。例:
@verbatim
:inoremap <Down> <C-R>=pumvisible() ? "\<lt>C-N>" : "\<lt>Down>"<CR>
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use of <expr> in mapping to have the popup menu used when typing a
character and some condition is met.  For example, for typing a dot: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マッピングで <expr> を使うと、入力中ある条件が満たされたとき自動的にポップアップメニューを表示させることができる。例えば、ドットを入力したとき補完を行う、またはドットそのものを入力するようにするには:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	inoremap <expr> . MayComplete()
	func MayComplete()
	    if (can complete)
	      return ".\<C-X>\<C-O>"
	    endif
	    return '.'
	endfunc
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
inoremap <expr> . MayComplete()
func MayComplete()
    if (can complete)
      return ".\<C-X>\<C-O>"
    endif
    return '.'
endfunc
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
See |:map-<expr>| for more info.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
より詳しくは |@ref{:map-<expr>}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
FILETYPE-SPECIFIC REMARKS FOR OMNI COMPLETION	    *compl-omni-filetypes*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{compl-omni-filetypes}
@cindex compl-omni-filetypes
@cindex オムニ補完についてファイル形式ごとの注意点
@unnumberedsubsubsec オムニ補完についてファイル形式ごとの注意点
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The file used for {filetype} should be autoload/{filetype}complete.vim
in 'runtimepath'.  Thus for "java" it is autoload/javacomplete.vim.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイル形式 @{filetype@} に対して使われるファイルは '@option{runtimepath}' 中の autoload/@{filetype@}complete.vim とする。つまり、"java" に対するファイルは @file{autoload/javacomplete.vim} となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
C							*ft-c-omni*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ft-c-omni}
@cindex ft-c-omni
@cindex C のオムニ補完
@unnumberedsubsubsec C
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Completion of C code requires a tags file.  You should use Exuberant ctags,
because it adds extra information that is needed for completion.  You can find
it here: http://ctags.sourceforge.net/  Version 5.6 or later is recommended.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
C のソースでオムニ補完を行うには tags ファイルが必要である。Exuberant ctags は補完に必要な付加情報を出力するため、Exuberant ctags を使うとよい。Exuberant ctags はこのサイトからダウンロードできる: @url{http://ctags.sourceforge.net/} バージョン 5.6 以降が推奨されている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For version 5.5.4 you should add a patch that adds the "typename:" field:
	ftp://ftp.vim.org/pub/vim/unstable/patches/ctags-5.5.4.patch
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バージョン 5.5.4 を使うときは "typename:" フィールドを追加するこのパッチをあてること:

@url{ftp://ftp.vim.org/pub/vim/unstable/patches/ctags-5.5.4.patch}

@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
A compiled .exe for MS-Windows can be found at:
	http://ctags.sourceforge.net/
	https://github.com/universal-ctags/ctags-win32
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
MS-Windows 用の exe ファイルは次のサイトからダウンロードできる:

@url{http://ctags.sourceforge.net/} @*
@url{https://github.com/universal-ctags/ctags-win32}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to complete system functions you can do something like this.  Use
ctags to generate a tags file for all the system header files: >
	% ctags -R -f ~/.vim/systags /usr/include /usr/local/include
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
システム関数を補完するには、次のような方法がある。ctags を使って全システムヘッダーファイルの tags ファイルを作る:
@example
% ctags -R -f ~/.vim/systags /usr/include /usr/local/include
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
In your vimrc file add this tags file to the 'tags' option: >
	set tags+=~/.vim/systags
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
そして .vimrc で '@option{tags}' オプションにこの tags ファイルを追加する:
@example
set tags+=~/.vim/systags
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When using CTRL-X CTRL-O after a name without any "." or "->" it is completed
from the tags file directly.  This works for any identifier, also function
names.  If you want to complete a local variable name, which does not appear
in the tags file, use CTRL-P instead.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カーソル前の単語が "." や "->" を含まないとき、@kbd{CTRL-X} @kbd{CTRL-O} を押すと tags ファイルから直接補完される。これはすべての識別子、関数名に対して有効である。tags ファイルに含まれないローカル変数名を補完するには @kbd{CTRL-P} を使うしかない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When using CTRL-X CTRL-O after something that has "." or "->" Vim will attempt
to recognize the type of the variable and figure out what members it has.
This means only members valid for the variable will be listed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カーソル前の単語が "." または "->" を含むとき、@kbd{CTRL-X} @kbd{CTRL-O} を押すと、変数の型が推測され、その型のメンバが推測される。よって、その変数に対して有効なメンバだけが補完候補に現れる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When a member name already was complete, CTRL-X CTRL-O will add a "." or
"->" for composite types.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
メンバ名がすでに補完されたとき @kbd{CTRL-X} @kbd{CTRL-O} を押すと、複合型に対する "." または "->" が挿入される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim doesn't include a C compiler, only the most obviously formatted
declarations are recognized.  Preprocessor stuff may cause confusion.
When the same structure name appears in multiple places all possible members
are included.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は C コンパイラを内蔵しているわけではないので、きれいに整形された宣言しか認識できない。プリプロセッサーが関係すると混乱してしまう可能性がある。同じ構造体名が複数の場所に現れる場合、それらのすべてのメンバが補完候補に含まれる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
CSS							*ft-css-omni*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ft-css-omni}
@cindex ft-css-omni
@cindex CSS のオムニ補完
@unnumberedsubsubsec CSS
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Complete properties and their appropriate values according to CSS 2.1
specification.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
CSS 2.1 仕様に従って、プロパティとその適切な値を補完できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
HTML							*ft-html-omni*
XHTML							*ft-xhtml-omni*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ft-html-omni}
@anchor{ft-xhtml-omni}
@cindex ft-html-omni
@cindex ft-xhtml-omni
@cindex HTML や XHTML のオムニ補完
@unnumberedsubsubsec HTML or XHTML
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CTRL-X CTRL-O provides completion of various elements of (X)HTML files.  It is
designed to support writing of XHTML 1.0 Strict files but will also work for
other versions of HTML. Features:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
HTML, XHTML ファイルにおいて、@kbd{CTRL-X} @kbd{CTRL-O} で (X)HTML の色々な要素を補完できる。補完スクリプトは XHTML 1.0 Strict なファイルを書くために設計されているが、他の HTML のバージョンに対しても動作するようになっている。以下の機能がある:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- after "<" complete tag name depending on context (no div suggestion inside
  of an a tag); '/>' indicates empty tags
- inside of tag complete proper attributes (no width attribute for an a tag);
  show also type of attribute; '*' indicates required attributes
- when attribute has limited number of possible values help to complete them
- complete names of entities
- complete values of "class" and "id" attributes with data obtained from
  <style> tag and included CSS files
- when completing value of "style" attribute or working inside of "style" tag
  switch to |ft-css-omni| completion
- when completing values of events attributes or working inside of "script"
  tag switch to |ft-javascript-omni| completion
- when used after "</" CTRL-X CTRL-O will close the last opened tag
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item
"<" の後では文脈に依存してタグ名を補完する (a タグの内側では div は候補に現れない)。'/>' は空タグを示す。
@item
タグの内側では適切な属性の補完が行われる (a タグに対しては width 属性は候補に現れない)。属性の型も表示される。'*' は必須な属性を意味する。
@item
属性のとりうる値が有限個しかない場合は、それらの補完を支援する。
@item
エンティティの名前を補完する。
@item
<style> タグとインクルードされた CSS ファイルから得られたデータにより、"class" と "id" の値を補完する。
@item
"style" 属性の値を補完するときや、"style" タグの内側にいるときは |@ref{ft-css-omni}| モードへ移行する。
@item
イベント属性の値を補完するときや、"script" タグの内側にいるときは |@ref{ft-javascript-omni}| モードへ移行する。
@item
"</" の後で @kbd{CTRL-X} @kbd{CTRL-O} を押すと、最後に開いたタグを閉じる。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: When used first time completion menu will be shown with little delay
- this is time needed for loading of data file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
初回実行時は補完メニューが表示されるまでに少し時間がかかる。
@itemize
@item これはデータファイルを読み込むのに時間がかかっている。
@end itemize
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Note: Completion may fail in badly formatted documents. In such case try to
run |:make| command to detect formatting problems.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
整形されていないファイルでは補完が失敗する場合がある。その場合は |@ref{:make}| を実行して整形上の問題を検出してみるとよい。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
HTML flavor						*html-flavor*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{html-flavor}
@cindex html-flavor
@cindex HTML っぽい補完
@unnumberedsubsubsec HTML flavor
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The default HTML completion depends on the filetype.  For HTML files it is
HTML 4.01 Transitional ('filetype' is "html"), for XHTML it is XHTML 1.0
Strict ('filetype' is "xhtml").
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
既定の HTML 補完はファイルタイプに依存して動作が変わる。HTML ファイル ('@option{filetype}' が "@var{html}" の場合) に対しては HTML 4.01 Transitional となり、XHTML ファイル ('@option{filetype}' が "@var{xhtml}" の場合) に対しては XHTML 1.0 Strict となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When doing completion outside of any other tag you will have possibility to
choose DOCTYPE and the appropriate data file will be loaded and used for all
next completions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
タグの外側で補完を行うと DOCTYPE を選択することができ、適切なデータファイルが読み込まれ、それ以降の補完に利用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
More about format of data file in |xml-omni-datafile|. Some of the data files
may be found on the Vim website (|www|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
データファイルのフォーマットについてより詳しくは |@ref{xml-omni-datafile}| を参照。Vim のウェブサイト (|@ref{www}|) でもいくつかのデータファイルをダウンロードできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that b:html_omni_flavor may point to a file with any XML data.  This
makes possible to mix PHP (|ft-php-omni|) completion with any XML dialect
(assuming you have data file for it).  Without setting that variable XHTML 1.0
Strict will be used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
変数 b:html_omni_flavor に任意の XML データのファイル名を設定できる。これによって PHP オムニ補完 (|@ref{ft-php-omni}|) と任意の XML ダイアレクトを組み合わせることができる (その XML ダイアレクト用のデータファイルが必要)。この変数を設定しない場合は XHTML 1.0 Strict が使用される。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
JAVASCRIPT					       *ft-javascript-omni*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ft-javascript-omni}
@cindex ft-javascript-omni
@cindex JavaScript のオムニ補完
@unnumberedsubsubsec JAVASCRIPT
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Completion of most elements of JavaScript language and DOM elements.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
JavaScript のほとんどの要素と DOM 要素を補完できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Complete:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
補完:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- variables
- function name; show function arguments
- function arguments
- properties of variables trying to detect type of variable
- complete DOM objects and properties depending on context
- keywords of language
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item 変数
@item 関数名。関数の引数も表示できる
@item 関数の引数
@item 変数の型を識別し、変数のプロパティを補完する
@item DOM オブジェクトと文脈に依存したプロパティを補完する
@item 言語のキーワード
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Completion works in separate JavaScript files (&ft==javascript), inside of
<script> tag of (X)HTML and in values of event attributes (including scanning
of external files).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
JavaScript オムニ補完は、単独の JavaScript ファイル (&ft==javascript)、(X)HTML の <script> タグの中、イベント属性の値の中で動作する (外部ファイルの読み込みも含む)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
DOM compatibility
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
DOM 互換性
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
At the moment (beginning of 2006) there are two main browsers - MS Internet
Explorer and Mozilla Firefox. These two applications are covering over 90% of
market. Theoretically standards are created by W3C organisation
(http://www.w3c.org) but they are not always followed/implemented.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
現時点 (2006 年初頭) では主流のブラウザーが 2 つある。MS Internet Explorer と Mozilla Firefox である。これら 2 つのアプリケーションは市場の 90% 以上を占めている。理論的には標準は W3C (@url{http://www.w3c.org}) によって決められるが、これらのブラウザーは必ずしもそれに従っていない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		IE	FF	W3C  Omni completion ~
		+/-	+/-	+    +		     ~
		+	+	-    +		     ~
		+	-	-    -		     ~
		-	+	-    -		     ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .2 .2 .4
@item IE @tab FF @tab W3C @tab オムニ補完
@item +/- @tab +/- @tab + @tab +
@item + @tab + @tab - @tab +
@item + @tab - @tab - @tab -
@item - @tab + @tab - @tab -
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Regardless from state of implementation in browsers but if element is defined
in standards, completion plugin will place element in suggestion list. When
both major engines implemented element, even if this is not in standards it
will be suggested. All other elements are not placed in suggestion list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ブラウザーの実装状態に関わらず、ある要素が標準で定められていれば、オムニ補完プラグインはその要素を候補リストに加える。主流のエンジンが両方ともある要素を実装していれば、たとえそれが標準で定められていなくても候補リストに加える。それ以外の要素は候補リストに加えない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
PHP							*ft-php-omni*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ft-php-omni}
@cindex ft-php-omni
@cindex PHP のオムニ補完
@unnumberedsubsubsec PHP
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Completion of PHP code requires a tags file for completion of data from
external files and for class aware completion. You should use Exuberant ctags
version 5.5.4 or newer. You can find it here: http://ctags.sourceforge.net/
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
PHP コードの補完を行うには tags ファイルが必要である。外部ファイルに書かれた情報の補完と、クラスを意識した補完のためである。Exuberant ctags 5.5.4 以降を使うこと。Exuberant ctags は次のサイトで入手できる: @url{http://ctags.sourceforge.net/}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Script completes:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オムニ補完で以下のものが補完できる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- after $ variables name
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item
$ の後の変数名
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
  - if variable was declared as object add "->", if tags file is available show
    name of class
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item
変数がオブジェクトとして宣言されており、"->" がつく場合、tags ファイルがあればクラス名が表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
  - after "->" complete only function and variable names specific for given
    class. To find class location and contents tags file is required. Because
    PHP isn't strongly typed language user can use @var tag to declare class: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
"->" の後ではそのクラスの関数名と変数名だけが候補に現れる。クラスの位置と内容を特定するためには tags ファイルが必要になる。PHP は強い型付けの言語ではないため、クラス宣言に @@var タグをつけるとよい:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	/* @var $myVar myClass */
	$myVar->
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
/* @var $myVar myClass */
$myVar->
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    Still, to find myClass contents tags file is required.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
しかし @@var タグをつけても、myClass の内容を認識するには tags ファイルが必要になる。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- function names with additional info:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
追加情報つきの関数名
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
  - in case of built-in functions list of possible arguments and after | type
    data returned by function
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item
組み込み関数の場合には、とりうる引数のリストと、| の後に関数の戻り値の型情報が表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
  - in case of user function arguments and name of file where function was
    defined (if it is not current file)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
ユーザー定義関数の場合には、引数と、その関数の定義を含むファイル名が表示される (それがカレントファイルでない場合)
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- constants names
- class names after "new" declaration
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
定数名
@item
"new" 宣言の後にクラス名
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Note: when doing completion first time Vim will load all necessary data into
memory. It may take several seconds. After next use of completion delay
should not be noticeable.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
最初に補完を行うとき、必要なデータがすべてメモリにロードされる。これに数秒かかる場合があるが、次回からの補完は気になるほどではなくなるだろう。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Script detects if cursor is inside <?php ?> tags. If it is outside it will
automatically switch to HTML/CSS/JavaScript completion. Note: contrary to
original HTML files completion of tags (and only tags) isn't context aware.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
補完スクリプトは、カーソルが <?php ?> の中にあるかどうかを検出する。もしカーソルがこのタグの外側にあれば、自動的に HMTL/CSS/JavaScript 補完に切り替わる。
@quotation
@strong{Note:} @*
元の HTML とは異なり、タグの補完が文脈依存ではなくなる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
RUBY							*ft-ruby-omni*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ft-ruby-omni}
@cindex ft-ruby-omni
@cindex Ruby のオムニ補完
@unnumberedsubsubsec RUBY
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Completion of Ruby code requires that vim be built with |+ruby|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Ruby コードの補完を行うには、vim が |@ref{+ruby}| 付きでコンパイルされている必要がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Ruby completion will parse your buffer on demand in order to provide a list of
completions.  These completions will be drawn from modules loaded by 'require'
and modules defined in the current buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Ruby のオムニ補完は、補完候補を提供するために必要に応じてバッファをパースする。補完候補は '@option{require}' で読み込まれたモジュールと、カレントバッファ内で定義されたモジュールから引き出される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The completions provided by CTRL-X CTRL-O are sensitive to the context:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-X} @kbd{CTRL-O} による補完は、次のように文脈に依存する:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	  CONTEXT			   COMPLETIONS PROVIDED ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item 文脈 @tab 提供される補完
@item
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 1. Not inside a class definition    Classes, constants and globals
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 1. クラス定義の外側 @tab クラス、定数、グローバル変数
@item
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 2. Inside a class definition	     Methods or constants defined in the class
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 2. クラス定義の内側 @tab そのクラスで定義されたメソッド、定数
@item
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 3. After '.', '::' or ':'	     Methods applicable to the object being
				       dereferenced
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 3. '.', '::', ':' の後 @tab 参照されているオブジェクトに適用可能なメソッド
@item
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 4. After ':' or ':foo'		     Symbol name (beginning with 'foo')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 4. ':', ':foo' の後 @tab シンボル名 (:foo の場合は 'foo' で始まるもの)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Notes:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Notes:}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
 - Vim will load/evaluate code in order to provide completions.  This may
   cause some code execution, which may be a concern. This is no longer
   enabled by default, to enable this feature add >
     let g:rubycomplete_buffer_loading = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item
補完を行うためにコードをロードする (評価する) 機能がある。これはつまり、コードが実行されることになり、問題となるかもしれない。現在、この機能はデフォルトで無効になっており、有効にするには次を .vimrc に加える:
@verbatim
let g:rubycomplete_buffer_loading = 1
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<- In context 1 above, Vim can parse the entire buffer to add a list of
   classes to the completion results. This feature is turned off by default,
   to enable it add >
     let g:rubycomplete_classes_in_global = 1
<  to your vimrc
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
上記の文脈 1 において、クラスのリストを補完結果に加えるためにバッファ全体をパースすることがありうる。デフォルトではこの機能は無効になっており、有効にするには次を .vimrc に加える:
@verbatim
let g:rubycomplete_classes_in_global = 1
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
 - In context 2 above, anonymous classes are not supported.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
上記の文脈 2 において、無名クラスには対応していない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
 - In context 3 above, Vim will attempt to determine the methods supported by
   the object.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
上記の文脈 3 において、Vim はオブジェクトが対応しているメソッドを決定しようと試みる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
 - Vim can detect and load the Rails environment for files within a rails
   project. The feature is disabled by default, to enable it add >
     let g:rubycomplete_rails = 1
<  to your vimrc
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
Rails プロジェクトのファイルでは Rails 環境を検出し、読み込む機能がある。デフォルトではこの機能は無効になっており、有効にするには次を .vimrc に加える:
@verbatim
let g:rubycomplete_rails = 1
@end verbatim
@end itemize
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
SYNTAX							*ft-syntax-omni*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ft-syntax-omni}
@cindex ft-syntax-omni
@cindex Syntax のオムニ補完
@unnumberedsubsubsec SYNTAX
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim has the ability to color syntax highlight nearly 500 languages.  Part of
this highlighting includes knowing what keywords are part of a language.  Many
filetypes already have custom completion scripts written for them, the
syntaxcomplete plugin provides basic completion for all other filetypes.  It
does this by populating the omni completion list with the text Vim already
knows how to color highlight.  It can be used for any filetype and provides a
minimal language-sensitive completion.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim には 500 近くの言語を強調表示する機能がある。この強調表示機能の一部として、言語で定められたキーワードを認識する機能がある。多くのファイルタイプには既に専用の補完スクリプトが存在するが、そうでないファイルタイプのために構文強調機能を利用して基本的な補完機能を提供する syntaxcomplete というプラグインがある。このプラグインは、Vim がテキストを色付けするために持っている情報を利用して補完リストを作成する。syntaxcomplete はどんなファイルタイプに対しても利用可能で、言語に応じた最小限の補完を提供する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To enable syntax code completion you can run: >
    setlocal omnifunc=syntaxcomplete#Complete
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
syntaxcomplete を有効にするにはこのコマンドを実行する:
@example
setlocal omnifunc=syntaxcomplete#Complete
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can automate this by placing the following in your |.vimrc| (after any
":filetype" command): >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これを自動的に行うようにするには、以下を |@ref{.vimrc}| に書く (":filetype" コマンドの後で):
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    if has("autocmd") && exists("+omnifunc")
	autocmd Filetype *
		    \	if &omnifunc == "" |
		    \		setlocal omnifunc=syntaxcomplete#Complete |
		    \	endif
    endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
if has("autocmd") && exists("+omnifunc")
autocmd Filetype *
        \   if &omnifunc == "" |
        \       setlocal omnifunc=syntaxcomplete#Complete |
        \   endif
endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The above will set completion to this script only if a specific plugin does
not already exist for that filetype.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これによって、ファイルタイプ専用のプラグインが存在しないときだけ syntaxcomplete プラグインで補完するようになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Each filetype can have a wide range of syntax items.  The plugin allows you to
customize which syntax groups to include or exclude from the list.  Let's have
a look at the PHP filetype to see how this works.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルタイプの中には幅広い範囲の構文アイテムを持つものもある。syntaxcomplete プラグインでは、構文グループのうちどれを補完に含めるかをカスタマイズできる。ファイルタイプ PHP を例として見てみよう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you edit a file called, index.php, run the following command: >
    syntax list
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
index.php という名前のファイルを開き、次のコマンドを実行してみる:
@example
syntax list
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The first thing you will notice is that there are many different syntax groups.
The PHP language can include elements from different languages like HTML,
JavaScript and many more.  The syntax plugin will only include syntax groups
that begin with the filetype, "php", in this case.  For example these syntax
groups are included by default with the PHP: phpEnvVar, phpIntVar,
phpFunctions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
まず最初にたくさんの異なる構文グループがあることに気づくだろう。PHP 言語は HTML, JavaScript など他の言語の要素を含むことがある。この場合、syntaxcomplete プラグインはファイルタイプ名 "php" で始まる構文グループだけを含める。例えば、次の構文グループはデフォルトで含まれる: phpEnvVar, phpIntVar, phpFunctions。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you wish non-filetype syntax items to also be included, you can use a
regular expression syntax (added in version 13.0 of
autoload\syntaxcomplete.vim) to add items.  Looking at the output from
":syntax list" while editing a PHP file I can see some of these entries: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
非ファイルタイプの構文アイテムも追加したい場合は、正規表現構文が使える (autoload#syntaxcomplete.vim のバージョン 13.0 で追加された)。PHP ファイルを編集中に ":syntax list" の出力を見ると、次のような項目が見えるだろう:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    htmlArg,htmlTag,htmlTagName,javaScriptStatement,javaScriptGlobalObjects
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
htmlArg,htmlTag,htmlTagName,javaScriptStatement,javaScriptGlobalObjects
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To pick up any JavaScript and HTML keyword syntax groups while editing a PHP
file, you can use 3 different regexs, one for each language.  Or you can
simply restrict the include groups to a particular value, without using
a regex string: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
PHP ファイルの編集に JavaScript と HTML のキーワード構文グループを追加するには各言語ごとに正規表現で設定する。あるいは、正規表現を使わず、単に含めるグループを限定して指定できる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    let g:omni_syntax_group_include_php = 'php\w\+,javaScript\w\+,html\w\+'
    let g:omni_syntax_group_include_php = 'phpFunctions,phpMethods'
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
let g:omni_syntax_group_include_php = 'php\w\+,javaScript\w\+,html\w\+'
let g:omni_syntax_group_include_php = 'phpFunctions,phpMethods'
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The basic form of this variable is: >
    let g:omni_syntax_group_include_{filetype} = 'regex,comma,separated'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この変数の設定は次のような構文になっている:
@verbatim
let g:omni_syntax_group_exclude_{filetype} = 'regex,comma,separated'
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The PHP language has an enormous number of items which it knows how to syntax
highlight.  These items will be available within the omni completion list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
PHP 言語は構文強調で色付けできる要素がとてもたくさんある。それらの要素はオムニ補完リストに現れる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Some people may find this list unwieldy or are only interested in certain
items.  There are two ways to prune this list (if necessary).  If you find
certain syntax groups you do not wish displayed you can use two different
methods to identify these groups.  The first specifically lists the syntax
groups by name.  The second uses a regular expression to identify both
syntax groups.  Simply add one the following to your vimrc: >
    let g:omni_syntax_group_exclude_php = 'phpCoreConstant,phpConstant'
    let g:omni_syntax_group_exclude_php = 'php\w*Constant'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
人によってはこれがわずらわしいと感じたり、その一部だけが欲しい場合がある。リストから余分なものを除くには 2 つの方法がある (必要なら)。特定の構文グループを表示したくない場合はそれを指定するのに 2 つの方法が使える。1 つは構文グループの名前のリストを指定する方法。もう 1 つは正規表現で構文グループを指定する方法。次のような設定を vimrc に追加する:
@verbatim
let g:omni_syntax_group_exclude_php = 'phpCoreConstant,phpConstant'
let g:omni_syntax_group_exclude_php = 'php\w*Constant'
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Add as many syntax groups to this list by comma separating them.  The basic
form of this variable is: >
    let g:omni_syntax_group_exclude_{filetype} = 'regex,comma,separated'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コンマ区切りで任意個数の構文グループを指定できる。この変数の基本的な形式は次のとおり:
@verbatim
let g:omni_syntax_group_exclude_{filetype} = 'regex,comma,separated'
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can create as many of these variables as you need, varying only the
filetype at the end of the variable name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この変数名の末尾のファイルタイプを変えればいくらでもこの変数を定義できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The plugin uses the isKeyword option to determine where word boundaries are
for the syntax items.  For example, in the Scheme language completion should
include the "-", call-with-output-file.  Depending on your filetype, this may
not provide the words you are expecting.  Setting the
g:omni_syntax_use_iskeyword option to 0 will force the syntax plugin to break
on word characters.   This can be controlled adding the following to your
vimrc: >
    let g:omni_syntax_use_iskeyword = 0
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
syntaxcomplete プラグインは、構文アイテムの単語境界の認識にオプション '@option{iskeyword}' を使用する。例として、Scheme 言語の補完では "-" が単語に含まれる (call-with-output-file など)。ファイルタイプによってはこれでは期待する補完ができないかもしれない。g:omni_syntax_use_iskeyword に 0 を代入すれば syntaxcomplete プラグインは単語文字の区切りを使わなくなる:
@verbatim
let g:omni_syntax_use_iskeyword = 0
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For plugin developers, the plugin exposes a public function OmniSyntaxList.
This function can be used to request a List of syntax items.  When editing a
SQL file (:e syntax.sql) you can use the ":syntax list" command to see the
various groups and syntax items.  For example: >
    syntax list
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プラグイン開発者のために OmniSyntaxList 関数が公開されている。この関数は構文アイテムのリストを得るために使うことができる。例えば SQL ファイルを開いているときに (:e syntax.sql) "@command{:syntax list}" コマンドを実行してグループと構文アイテムを確認してみる。例:
@verbatim
syntax list
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Yields data similar to this:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のような出力が表示される:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    sqlOperator    xxx some prior all like and any escape exists in is not ~
                       or intersect minus between distinct ~
                       links to Operator ~
    sqlType        xxx varbit varchar nvarchar bigint int uniqueidentifier ~
                       date money long tinyint unsigned xml text smalldate ~
                       double datetime nchar smallint numeric time bit char ~
                       varbinary binary smallmoney ~
                       image float integer timestamp real decimal ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
sqlOperator    xxx some prior all like and any escape exists in is not 
                   or intersect minus between distinct
                   links to Operator
sqlType        xxx varbit varchar nvarchar bigint int uniqueidentifier 
                   date money long tinyint unsigned xml text smalldate 
                   double datetime nchar smallint numeric time bit char 
                   varbinary binary smallmoney
                   image float integer timestamp real decimal
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are two syntax groups listed here: sqlOperator and sqlType.  To retrieve
a List of syntax items you can call OmniSyntaxList a number of different
ways.  To retrieve all syntax items regardless of syntax group:  >
    echo OmniSyntaxList( [] )
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2 つの構文グループ sqlOperator と sqlType がある。構文アイテムのリストを得るために OmniSyntaxList をいくつかの方法で呼び出すことができる。構文グループを限定せずにすべての構文アイテムを得るには次のようにする:
@verbatim
echo OmniSyntaxList( [] )
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To retrieve only the syntax items for the sqlOperator syntax group: >
    echo OmniSyntaxList( ['sqlOperator'] )
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
sqlOperator 構文グループの構文アイテムの得るには次のようにする:
@verbatim
echo OmniSyntaxList( ['sqlOperator'] )
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To retrieve all syntax items for both the sqlOperator and sqlType groups: >
    echo OmniSyntaxList( ['sqlOperator', 'sqlType'] )
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
sqlOperator 構文グループと sqlType 構文グループの両方の構文アイテムをすべて得るには次のようにする:
@verbatim
echo OmniSyntaxList( ['sqlOperator', 'sqlType'] )
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A regular expression can also be used: >
    echo OmniSyntaxList( ['sql\w\+'] )
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
正規表現も使える:
@verbatim
echo OmniSyntaxList( ['sql\w\+'] )
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
From within a plugin, you would typically assign the output to a List: >
    let myKeywords = []
    let myKeywords = OmniSyntaxList( ['sqlKeyword'] )
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プラグインから呼び出すときは、結果を List に代入して使うのが一般的だろう:
@verbatim
let myKeywords = []
let myKeywords = OmniSyntaxList( ['sqlKeyword'] )
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
SQL							*ft-sql-omni*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ft-sql-omni}
@cindex ft-sql-omni
@cindex SQL のオムニ補完
@unnumberedsubsubsec SQL
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Completion for the SQL language includes statements, functions, keywords.
It will also dynamically complete tables, procedures, views and column lists
with data pulled directly from within a database.  For detailed instructions
and a tutorial see |omni-sql-completion|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
SQL の補完にはステートメント、関数、キーワードが含まれる。また、データベースから直接情報を取得し、テーブル、プロシージャ、ビュー、カラムリストを動的に補完することができる。より詳しい説明とチュートリアルについては |@ref{omni-sql-completion}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The SQL completion plugin can be used in conjunction with other completion
plugins.  For example, the PHP filetype has its own completion plugin.
Since PHP is often used to generate dynamic website by accessing a database,
the SQL completion plugin can also be enabled.  This allows you to complete
PHP code and SQL code at the same time.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
SQL 補完プラグインは他の補完プラグインと組み合わせて使うことができる。例えば、PHP には PHP 用の補完スクリプトがあるが、PHP はよくデータベースにアクセスする動的なウェブサイトを生成するのに使われるため、SQL 補完プラグインも有効にするとよいかもしれない。そうすれば PHP のコードと SQL のコードを両方補完できるようになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
XML							*ft-xml-omni*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ft-xml-omni}
@cindex ft-xml-omni
@cindex XML のオムニ補完
@unnumberedsubsubsec XML
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim 7 provides a mechanism for context aware completion of XML files.  It
depends on a special |xml-omni-datafile| and two commands: |:XMLns| and
|:XMLent|.  Features are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim 7 には XML ファイルにおける文脈に応じた補完メカニズムがある。この補完メカニズムは特別なファイル |@ref{xml-omni-datafile}| に依存し、|@ref{:XMLns}| と |@ref{:XMLent}| という 2 つのコマンドがある。この補完の機能は以下の通り:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- after "<" complete the tag name, depending on context
- inside of a tag complete proper attributes
- when an attribute has a limited number of possible values help to complete
  them
- complete names of entities (defined in |xml-omni-datafile| and in the
  current file with "<!ENTITY" declarations)
- when used after "</" CTRL-X CTRL-O will close the last opened tag
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item
"<" の後ろでは文脈に応じ、タグ名を補完する。
@item
タグの内側では適切な属性を補完する。
@item
属性の取りうる値が有限個である場合はそれらの補完を支援する。
@item
実体名を補完する (|@ref{xml-omni-datafile}| 内で定義されたものとカレントファイルの "<!ENTITY" 宣言にあるもの)
@item
"</" の後ろで @kbd{CTRL-X} @kbd{CTRL-O} とすると最後に開いたタグを閉じる。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Format of XML data file					*xml-omni-datafile*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{xml-omni-datafile}
@cindex xml-omni-datafile
@cindex XML データファイルのフォーマット
@unnumberedsubsubsec XML データファイルのフォーマット
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
XML data files are stored in the "autoload/xml" directory in 'runtimepath'.
Vim distribution provides examples of data files in the
"$VIMRUNTIME/autoload/xml" directory.  They have a meaningful name which will
be used in commands.  It should be a unique name which will not create
conflicts.  For example, the name xhtml10s.vim means it is the data file for
XHTML 1.0 Strict.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
XML データファイルは '@option{runtimepath}' の中のディレクトリ "autoload/xml" に保存される。標準でディレクトリ "$VIMRUNTIME/autoload/xml" にデータファイルのサンプルが入っている。これらのファイルにはコマンドで指定できる意味のある名前がついている。XML データファイルは衝突が起きないように一意な名前をつけるべきである。例えば、xhtml10s.vim という名前は XHTML 1.0 Strict 用のデータファイルであることを意味している。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Each file contains a variable with a name like g:xmldata_xhtml10s . It is
a compound from two parts:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
各サンプルファイルには g:xmldata_xhtml10s のような名前の変数が含まれている。この変数の値は 2 つの部分からなる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. "g:xmldata_"  general prefix, constant for all data files
2. "xhtml10s"    the name of the file and the name of the described XML
		 dialect; it will be used as an argument for the |:XMLns|
		 command
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .25 .75
@item 1. "g:xmldata_" @tab 一般的なプリフィックス。全データファイルで共通。
@item 2. "xhtml10s" @tab ファイル名であり、記述された XML ダイアレクトの名前。この名前がコマンド |@ref{:XMLns}| の引数として使われる。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Part two must be exactly the same as name of file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2. は正確にファイル名と同じでなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The variable is a |Dictionary|.  Keys are tag names and each value is a two
element |List|.  The first element of the List is also a List with the names
of possible children.  The second element is a |Dictionary| with the names of
attributes as keys and the possible values of attributes as values.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この変数は辞書 |@ref{Dictionary}| である。キーはタグ名で、値は 2 個の要素を持つリスト |@ref{List}| である。リストの最初の要素はまたリストであり、有効な子ノードの名前を持つ。2 番目の要素は辞書 |@ref{Dictionary}| であり、属性名がキーで、その属性の取りうる値が値である。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
    let g:xmldata_crippled = {
    \ "vimxmlentities": ["amp", "lt", "gt", "apos", "quot"],
    \ 'vimxmlroot': ['tag1'],
    \ 'tag1':
    \ [ ['childoftag1a', 'childoftag1b'], {'attroftag1a': [],
    \ 'attroftag1b': ['valueofattr1', 'valueofattr2']}],
    \ 'childoftag1a':
    \ [ [], {'attrofchild': ['attrofchild']}],
    \ 'childoftag1b':
    \ [ ['childoftag1a'], {'attrofchild': []}],
    \ "vimxmltaginfo": {
    \ 'tag1': ['Menu info', 'Long information visible in preview window']},
    \ 'vimxmlattrinfo': {
    \ 'attrofchild': ['Menu info', 'Long information visible in preview window']}}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
let g:xmldata_crippled = {
\ "vimxmlentities": ["amp", "lt", "gt", "apos", "quot"],
\ 'vimxmlroot': ['tag1'],
\ 'tag1':
\ [ ['childoftag1a', 'childoftag1b'], {'attroftag1a': [],
\ 'attroftag1b': ['valueofattr1', 'valueofattr2']}],
\ 'childoftag1a':
\ [ [], {'attrofchild': ['attrofchild']}],
\ 'childoftag1b':
\ [ ['childoftag1a'], {'attrofchild': []}],
\ "vimxmltaginfo": {
\ 'tag1': ['Menu info', 'Long information visible in preview window']},
\ 'vimxmlattrinfo': {
\ 'attrofchild': ['Menu info', 'Long information visible in preview window']}}
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This example would be put in the "autoload/xml/crippled.vim" file and could
help to write this file: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この例を保存するファイルは "autoload/xml/crippled.vim" となり、以下のようなファイルを書くために使われる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
    <tag1 attroftag1b="valueofattr1">
        <childoftag1a attrofchild>
                &amp; &lt;
        </childoftag1a>
        <childoftag1b attrofchild="5">
            <childoftag1a>
                &gt; &apos; &quot;
            </childoftag1a>
        </childoftag1b>
    </tag1>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
<tag1 attroftag1b="valueofattr1">
    <childoftag1a attrofchild>
            &amp; &lt;
    </childoftag1a>
    <childoftag1b attrofchild="5">
        <childoftag1a>
            &gt; &apos; &quot;
        </childoftag1a>
    </childoftag1b>
</tag1>
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In the example four special elements are visible:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この例には 4 個の特別な要素が含まれている:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. "vimxmlentities" - a special key with List containing entities of this XML
   dialect.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item
"vimxmlentities" - 特別なキー。対応する値は、この XML ダイアレクトの実体を要素に持つリスト。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
2. If the list containing possible values of attributes has one element and
   this element is equal to the name of the attribute this attribute will be
   treated as boolean and inserted as 'attrname' and not as 'attrname="'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
属性の取りうる値を定めるリストの長さが 1 であり、その要素が属性名と等しい場合、この要素は boolean とみなされ、'attrname="' でなく 'attrname' が補完される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
3. "vimxmltaginfo" - a special key with a Dictionary containing tag
   names as keys and two element List as values, for additional menu info and
   the long description.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
"vimxmltaginfo" - 特別なキー。対応する値は、タグ名をキー、長さ 2 のリストを値として持つ辞書。追加のメニュー情報と長い説明を保持する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
4. "vimxmlattrinfo" - special key with Dictionary containing attribute names
   as keys and two element List as values, for additional menu info and long
   description.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
"vimxmlattrinfo" - 特別なキー。対応する値は、属性名をキー、長さ 2 のリストを値として持つ辞書。追加のメニュー情報と長い説明を保持する。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: Tag names in the data file MUST not contain a namespace description.
Check xsl.vim for an example.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
XML データファイル中のタグ名は名前空間を含んではならない。例として xsl.vim を参照。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Note: All data and functions are publicly available as global
variables/functions and can be used for personal editing functions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
全データと関数はグローバル変数/関数として公開されており、個人的な編集関数用にも使える。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DTD -> Vim							*dtd2vim*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{dtd2vim}
@cindex dtd2vim
@cindex DTD から XML オムニ補完用のデータを作成
@unnumberedsubsubsec DTD -> Vim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
On |www| is the script |dtd2vim| which parses DTD and creates an XML data file
for Vim XML omni completion.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
DTD をパースし、XML オムニ補完用の XML データファイルを作成するスクリプト |@ref{dtd2vim}| が |@ref{www}| 上にある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
    dtd2vim: http://www.vim.org/scripts/script.php?script_id=1462
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
dtd2vim: @url{http://www.vim.org/scripts/script.php?script_id=1462}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Check the beginning of that file for usage details.
The script requires perl and:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
詳しい使い方はスクリプトの先頭を参照。このスクリプトを使うには perl と
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
    perlSGML: http://savannah.nongnu.org/projects/perlsgml
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
perlSGML: @url{http://savannah.nongnu.org/projects/perlsgml}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Commands
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:XMLns {name} [{namespace}]					*:XMLns*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:XMLns}
@cindex :XMLns
@unnumberedsubsubsec :XMLns @{name@} [@{namespace@}]
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim has to know which data file should be used and with which namespace.  For
loading of the data file and connecting data with the proper namespace use
|:XMLns| command.  The first (obligatory) argument is the name of the data
(xhtml10s, xsl).  The second argument is the code of namespace (h, xsl).  When
used without a second argument the dialect will be used as default - without
namespace declaration.  For example to use XML completion in .xsl files: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
XML オムニ補完を行うには、使うデータファイルと名前空間を指定しなければならない。データファイルを読み込み、データを適切な名前空間に結びつけるにはコマンド |@ref{:XMLns}| を使う。第 1 引数 (必須) でデータの名前を指定する (xhtml10s, xsl)。

第 2 引数で名前空間コードを指定する (h, xsl)。第 2 引数を省略して実行した場合は名前空間宣言なしでダイアレクトが使われる。例として .xsl ファイルで XML 補完をするには次のようにする:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:XMLns xhtml10s
	:XMLns xsl xsl
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:XMLns xhtml10s
:XMLns xsl xsl
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
:XMLent {name}							*:XMLent*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:XMLent}
@cindex :XMLent
@unnumberedsubsubsec :XMLent @{name@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
By default entities will be completed from the data file of the default
namespace.  The XMLent command should be used in case when there is no default
namespace: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
既定ではデフォルト名前空間のデータファイルからエンティティが補完される。コマンド XMLent はデフォルト名前空間が存在しない場合に使う:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:XMLent xhtml10s
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:XMLent xhtml10s
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Usage
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
使用例
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
While used in this situation (after declarations from previous part, | is
cursor position): >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この状態で (上記のコマンドを実行した後。カーソルが | の位置にあるとする):
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	<|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
<|
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Will complete to an appropriate XHTML tag, and in this situation: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
XML オムニ補完すると適切な XHTML タグが補完される。また、次の状態:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	<xsl:|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
<xsl:|
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Will complete to an appropriate XSL tag.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
で補完すると適切な XSL タグが補完される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
The script xmlcomplete.vim, provided through the |autoload| mechanism,
has the xmlcomplete#GetLastOpenTag() function which can be used in XML files
to get the name of the last open tag (b:unaryTagsStack has to be defined): >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{autoload}| によりロードされるスクリプト xmlcomplete.vim の中で xmlcomplete#GetLastOpenTag() が定義されており、この関数を使うと XML ファイル内で最後に開いたタグの名前が得られる (b:unaryTagsStack が定義されていなければならない)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:echo xmlcomplete#GetLastOpenTag("b:unaryTagsStack")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:echo xmlcomplete#GetLastOpenTag("b:unaryTagsStack")
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------



@ifset EN
==============================================================================
8. Insert mode commands					*inserting*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{inserting}
@cindex inserting
@cindex 挿入モードのコマンド
@section 8. 挿入モードのコマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The following commands can be used to insert new text into the buffer.  They
can all be undone and repeated with the "." command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
下のコマンドはバッファに新しいテキストを挿入するのに使うことができる。それらは全て取り消すことができるし、"." コマンドで繰り返すことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*a*
a			Append text after the cursor [count] times.  If the
			cursor is in the first column of an empty line Insert
			starts there.  But not when 'virtualedit' is set!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{a}
@kindex a
@table @asis
@item a
カーソルの後ろにテキストを [count] 回追加する。'@option{virtualedit}' がセットされていないなら、カーソルが空行の最初のカラムにあるときはそこに挿入する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*A*
A			Append text at the end of the line [count] times.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{A}
@kindex A
@item A
行末にテキストを [count] 回追加する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<insert>	or				*i* *insert* *<Insert>*
i			Insert text before the cursor [count] times.
			When using CTRL-O in Insert mode |i_CTRL-O| the count
			is not supported.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{i}
@anchor{insert}
@anchor{<Insert>}
@kindex i
@cindex insert
@kindex <Insert>
@item @key{<insert>} または
@itemx i
カーソルの前にテキストを [count] 回挿入する。挿入モード中の @kbd{CTRL-O} |@ref{i_CTRL-O}| で使うときはカウントはサポートされていない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*I*
I			Insert text before the first non-blank in the line
			[count] times.
			When the 'H' flag is present in 'cpoptions' and the
			line only contains blanks, insert start just before
			the last blank.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{I}
@kindex I
@item I
行の先頭の非空白文字の前にテキストを [count] 回挿入する。

'@option{cpoptions}' にフラグ '@var{H}' が入っている場合、空白のみを含む行では最後の空白文字の 1 文字前から挿入を開始する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*gI*
gI			Insert text in column 1 [count] times.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gI}
@kindex gI
@item gI
カラム 1 からテキストを [count] 回挿入する。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*gi*
gi			Insert text in the same position as where Insert mode
			was stopped last time in the current buffer.
			This uses the |'^| mark.  It's different from "`^i"
			when the mark is past the end of the line.
			The position is corrected for inserted/deleted lines,
			but NOT for inserted/deleted characters.
			When the |:keepjumps| command modifier is used the |'^|
			mark won't be changed.
			{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gi}
@kindex gi
@item gi
カレントバッファの最後に入力がされた場所にテキストを入力する。これは |@ref{'^}| マークを使う。マークが行末を越えているときに "'^i" と動作が異なる。行が挿入、削除されていると入力位置は調整されるが、文字単位の変更は考慮されない。|@ref{:keepjumps}| コマンドが使われると |@ref{'^}| マークは変更されない。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*o*
o			Begin a new line below the cursor and insert text,
			repeat [count] times.  {Vi: blank [count] screen
			lines}
			When the '#' flag is in 'cpoptions' the count is
			ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{o}
@kindex o
@item o
カーソルのある行の下に新しい行を作り、そこにテキストを [count] 回繰り返し挿入する。@{Vi:空行を [count] 行挿入する@}

'@option{cpoptions}' にフラグ '#' が入っている場合、カウント指定は無視される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*O*
O			Begin a new line above the cursor and insert text,
			repeat [count] times.  {Vi: blank [count] screen
			lines}
			When the '#' flag is in 'cpoptions' the count is
			ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{O}
@kindex O
@item O
カーソルのある行の上に新しい行を作り、そこにテキストを [count] 回繰り返し挿入する。@{Vi:空行を [count] 行挿入する@}

'@option{cpoptions}' にフラグ '@var{#}' が入っている場合、カウント指定は無視される。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These commands are used to start inserting text.  You can end insert mode with
<Esc>.  See |mode-ins-repl| for the other special characters in Insert mode.
The effect of [count] takes place after Insert mode is exited.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのコマンドはテキストの挿入を開始するのに使われる。挿入モードは @key{<Esc>} で止めることができる。挿入モードでのその他の特殊な文字は |@ref{mode-ins-repl}| を参照。[count] の効果は挿入モードから抜けた時に現れる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When 'autoindent' is on, the indent for a new line is obtained from the
previous line.  When 'smartindent' or 'cindent' is on, the indent for a line
is automatically adjusted for C programs.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{autoindent}' が設定されている時には、新しい行のインデントに、前の行と同じものが使用される。'@option{smartindent}' か '@option{cindent}' が設定されている時には、行のインデントは C プログラム (ソースコード) のスタイルに、自動的に調整される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
'textwidth' can be set to the maximum width for a line.  When a line becomes
too long when appending characters a line break is automatically inserted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{textwidth}' は、行の最大幅(文字数)を設定することができる。文字を追加している時に行が長くなりすぎると、自動的に改行が挿入される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
==============================================================================
9. Ex insert commands					*inserting-ex*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{inserting-ex}
@cindex inserting-ex
@cindex Ex の挿入コマンド
@section 9. Ex の挿入コマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:a* *:append*
:{range}a[ppend][!]	Insert several lines of text below the specified
			line.  If the {range} is missing, the text will be
			inserted after the current line.
			Adding [!] toggles 'autoindent' for the time this
			command is executed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:a}
@anchor{:append}
@pindex :a
@pindex :append
@table @asis
@item :@{range@}a[ppend][!]
指定された行の下に何行分かのテキストを挿入する。@{range@} が省略された場合、テキストは現在行の後から挿入される。

[!] をつけるとその実行中のみ '@option{autoindent}' をトグルする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:i* *:in* *:insert*
:{range}i[nsert][!]	Insert several lines of text above the specified
			line.  If the {range} is missing, the text will be
			inserted before the current line.
			Adding [!] toggles 'autoindent' for the time this
			command is executed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:i}
@anchor{:in}
@anchor{:insert}
@pindex :i
@pindex :in
@pindex :insert
@item :@{range@}i[nsert][!]
指定された行の上に何行分かのテキストを挿入する。@{range@} が省略された場合、テキストは現在行の前から挿入される。

[!] をつけるとその実行中のみ '@option{autoindent}' をトグルする。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These two commands will keep on asking for lines, until you type a line
containing only a ".".  Watch out for lines starting with a backslash, see
|line-continuation|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これら 2 つのコマンドは、"." だけを含んだ行を入力するまで、挿入すべきテキストを待ちつづける。バックスラッシュで始まる行には警戒すべし。|@ref{line-continuation}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When in Ex mode (see |-e|) a backslash at the end of the line can be used to
insert a NUL character.  To be able to have a line ending in a backslash use
two backslashes.  This means that the number of backslashes is halved, but
only at the end of the line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Ex モード (|@ref{-e}| 参照) では行末にバックスラッシュを置くことで NUL 文字を挿入できる。行末にバックスラッシュを挿入したいときはバックスラッシュを二重にすること。バックスラッシュが行末にある場合は実際に挿入される数は半分になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
NOTE: These commands cannot be used with |:global| or |:vglobal|.
":append" and ":insert" don't work properly in between ":if" and
":endif", ":for" and ":endfor", ":while" and ":endwhile".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
これらのコマンドは |@ref{:global}| または |@ref{:vglobal}| と組み合わせて使うことはできない。":append" と ":insert" は ":if" と ":endif", ":for" と ":endfor", ":while" と ":endwhile" の間では機能しない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:start* *:startinsert*
:star[tinsert][!]	Start Insert mode just after executing this command.
			Works like typing "i" in Normal mode.  When the ! is
			included it works like "A", append to the line.
			Otherwise insertion starts at the cursor position.
			Note that when using this command in a function or
			script, the insertion only starts after the function
			or script is finished.
			This command does not work from |:normal|.
			{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:start}
@anchor{:startinsert}
@pindex :start
@pindex :startinsert
@table @asis
@item :star[tinsert][!]
このコマンドの実行直後に挿入モードを開始する。ノーマルモードで "i" をタイプしたように働く。! が含まれていた時には、行に追加する "A" のように働く。そうでなければ現在の位置から挿入が始まる。関数やスクリプトの中でこのコマンドを使用したときには、関数やスクリプトが終了してから挿入が始まることに注意。

|@ref{:normal}| からこのコマンドを呼び出すと機能しない。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:stopi* *:stopinsert*
:stopi[nsert]		Stop Insert mode as soon as possible.  Works like
			typing <Esc> in Insert mode.
			Can be used in an autocommand, example: >
				:au BufEnter scratch stopinsert
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:stopi}
@anchor{:stopinsert}
@pindex :stopi
@pindex :stopinsert
@item :stopi[nsert]
できるだけ早く挿入モードを中止する。挿入モードで @key{<Esc>} を押したように機能する。オートコマンドで使うことができる。例:
@example
:au BufEnter scratch stopinsert
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*replacing-ex* *:startreplace*
:startr[eplace][!]	Start Replace mode just after executing this command.
			Works just like typing "R" in Normal mode.  When the
			! is included it acts just like "$R" had been typed
			(ie. begin replace mode at the end-of-line).  Other-
			wise replacement begins at the cursor position.
			Note that when using this command in a function or
			script that the replacement will only start after
			the function or script is finished.
			{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{replacing-ex}
@anchor{:startreplace}
@cindex replacing-ex
@pindex :startreplace
@item :startr[eplace][!]
このコマンドを実行した直後に置換モードに入る。ノーマルモードにおける "R" とちょうど同じ。"!" をつけると "$R" とタイプしたのと同じになる (つまり行末から置換モードを開始する)。"!" をつけないとカーソル位置から置換モードを開始する。
@quotation
@strong{Note:} @*
関数やスクリプトの中からこのコマンドを実行すると、その関数・スクリプトが終了した後ではじめて置換モードになることに注意。
@end quotation
@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:startgreplace*
:startg[replace][!]	Just like |:startreplace|, but use Virtual Replace
			mode, like with |gR|.
			{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:startgreplace}
@pindex :startgreplace
@item :startg[replace][!]
|@ref{:startreplace}| と同様だが、|@ref{gR}| のような仮想置換モードになる。

@{Vi にはない@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
10. Inserting a file					*inserting-file*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{inserting-file}
@cindex inserting-file
@cindex ファイルを挿入する
@section 10. ファイルを挿入する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:r* *:re* *:read*
:r[ead] [++opt] [name]
			Insert the file [name] (default: current file) below
			the cursor.
			See |++opt| for the possible values of [++opt].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:r}
@anchor{:re}
@anchor{:read}
@pindex :r
@pindex :re
@pindex :read
@table @asis
@item :r[ead] [++opt] [name]
カーソルの後ろに、ファイル [name] (省略した場合: 現在のファイル) を挿入する。

[++opt] として指定できる値については |@ref{++opt}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:{range}r[ead] [++opt] [name]
			Insert the file [name] (default: current file) below
			the specified line.
			See |++opt| for the possible values of [++opt].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :@{range@}r[ead] [++opt] [name]
指定した行の下に、ファイル [name] (省略した場合: 現在のファイル) を挿入。

[++opt] として指定できる値については |@ref{++opt}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:r!* *:read!*
:[range]r[ead] [++opt] !{cmd}
			Execute {cmd} and insert its standard output below
			the cursor or the specified line.  A temporary file is
			used to store the output of the command which is then
			read into the buffer.  'shellredir' is used to save
			the output of the command, which can be set to include
			stderr or not.  {cmd} is executed like with ":!{cmd}",
			any '!' is replaced with the previous command |:!|.
			See |++opt| for the possible values of [++opt].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:r!}
@anchor{:read!}
@pindex :r!
@pindex :read!
@item :[range]r[ead] [++opt] !@{cmd@}
カーソルまたは指定行の後ろに、@{cmd@} を実行したその標準出力の内容を挿入。コマンドの出力を蓄え、バッファに読み	込むために、テンポラリファイルが使用される。コマンドの出力を保存するために '@option{shellredir}' が使用されるので、標準エラー出力も含めるか含めないか指定することができる。

@{cmd@} は ":!@{cmd@}" と同じように実行されるので、'!' だけを指定した場合には、以前に実行された |@ref{:!}| コマンドに置き換えられる。

[++opt] として指定できる値については |@ref{++opt}| を参照。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These commands insert the contents of a file, or the output of a command,
into the buffer.  They can be undone.  They cannot be repeated with the "."
command.  They work on a line basis, insertion starts below the line in which
the cursor is, or below the specified line.  To insert text above the first
line use the command ":0r {name}".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのコマンドは、ファイルの内容、もしくはコマンドの出力をバッファへ挿入する。これらは取り消す (UNDO) ことができる。これらは "." コマンドで繰り返すことはできない。これらは行単位で行われる操作で、挿入はカーソルの直後のラインからか、指定したラインの直後から行われる。一番最初のラインより上 (ファイルの先頭) に挿入するには ":0r @{name@}" というコマンドを使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
After the ":read" command, the cursor is left on the first non-blank in the
first new line.  Unless in Ex mode, then the cursor is left on the last new
line (sorry, this is Vi compatible).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:read}" コマンドの後には、新しいラインの左で、最初の空白でない文字にカーソルが移動する。もし Ex モードでなければ、カーソルは新しい行の最後の左側に移動する (残念だが Vi との互換性のため)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If a file name is given with ":r", it becomes the alternate file.  This can be
used, for example, when you want to edit that file instead: ":e! #".  This can
be switched off by removing the 'a' flag from the 'cpoptions' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:r}" にファイル名が与えられた場合、それが代替バッファのファイルになる。これは例えば代わりにそのファイルを編集したい時に使うことができる: "e! #"。

'@option{cpoptions}' オプションから '@var{a}' フラグを削除することで、オフに切り替えることができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Of the [++opt] arguments one is specifically for ":read", the ++edit argument.
This is useful when the ":read" command is actually used to read a file into
the buffer as if editing that file.  Use this command in an empty buffer: >
	:read ++edit filename
The effect is that the 'fileformat', 'fileencoding', 'bomb', etc. options are
set to what has been detected for "filename".  Note that a single empty line
remains, you may want to delete it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:read}" には特別な [++opt] 引数が 1 つある。++edit である。これは実際にファイルを開いたときと同じようにファイルを挿入したい場合に便利である。空のバッファで次のコマンドを実行してみよ:
@example
:read ++edit filename
@end example
こうすると '@option{fileformat}', '@option{fileencoding}', '@option{bomb}' などのオプションがそのファイルに対して検出された値になる。ただし、(:e filename とした場合と異なり) バッファの先頭に余計な空行が1行入ってしまう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*file-read*
The 'fileformat' option sets the <EOL> style for a file:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{file-read}
@cindex file-read
'@option{fileformat}' オプションがファイルの <EOL> の流儀を決定する:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
'fileformat'    characters	   name				~
  "dos"		<CR><NL> or <NL>   DOS format
  "unix"	<NL>		   Unix format
  "mac"		<CR>		   Mac format
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .30 .45 .25
@item '@option{fileformat}' @tab 文字 @tab 名前
@item "@var{dos}" @tab <CR><NL> or <NL> @tab DOS format
@item "@var{unix}" @tab <NL> @tab Unix format
@item "@var{mac}" @tab <CR> @tab Mac format
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Previously 'textmode' was used.  It is obsolete now.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以前には '@option{textmode}' が使用された。それは現在では廃れている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If 'fileformat' is "dos", a <CR> in front of an <NL> is ignored and a CTRL-Z
at the end of the file is ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{fileformat}' が "@var{dos}" の時には、<NL> の前の <CR> は無視され、ファイルの終端にある @kbd{CTRL-Z} もまた無視される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If 'fileformat' is "mac", a <NL> in the file is internally represented by a
<CR>.  This is to avoid confusion with a <NL> which is used to represent a
<NUL>.  See |CR-used-for-NL|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{fileformat}' が "@var{mac}" の時には、ファイル内の <NL> は内部的に <CR> によって表現される。これは <NL> を表現するために使用される <NUL> との混同を避けるためである。|@ref{CR-used-for-NL}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the 'fileformats' option is not empty Vim tries to recognize the type of
<EOL> (see |file-formats|).  However, the 'fileformat' option will not be
changed, the detected format is only used while reading the file.
A similar thing happens with 'fileencodings'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{fileformats}' オプションが空でなかったら、Vim は <EOL> のタイプを識別しようと試みる (|@ref{file-formats}| 参照)。しかしながら、'@option{fileformat}' オプションは変更されない。検出されたフォーマットはファイルの読み込みの際にだけ使用される。'@option{fileencodings}' についても同様。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
On non-MS-DOS, Win32, and OS/2 systems the message "[dos format]" is shown if
a file is read in DOS format, to remind you that something unusual is done.
On Macintosh, MS-DOS, Win32, and OS/2 the message "[unix format]" is shown if
a file is read in Unix format.
On non-Macintosh systems, the message "[Mac format]" is shown if a file is
read in Mac format.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
MS-DOS、Win32 そして OS/2 以外のシステムでは、DOS フォーマットのファイルを読み込んだときにはそれを知らせるために、"[dos format]" というメッセージが表示される。

マッキントッシュ、MS-DOS、Win32 そして OS/2 においては、ファイルが Unix フォーマットであった場合に、"[unix format]" というメッセージが表示される。

マッキントッシュ以外のシステムでは、ファイルがマックフォーマットであった場合に、"[Mac format]" というメッセージが表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An example on how to use ":r !": >
	:r !uuencode binfile binfile
This command reads "binfile", uuencodes it and reads it into the current
buffer.  Useful when you are editing e-mail and want to include a binary
file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
":r !" をどう使うかの例:
@example
:r !uuencode binfile binfile
@end example
このコマンドは "binfile" を読み込み uuencode 化して、それを現在のバッファに読み込む。e-mail を編集していて、バイナリファイルを含めたい時に便利である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*read-messages*
When reading a file Vim will display a message with information about the read
file.  In the table is an explanation for some of the items.  The others are
self explanatory.  Using the long or the short version depends on the
'shortmess' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{read-messages}
@cindex read-messages
ファイルを読み込むとき Vim はその情報を表示する。いくつかのものについての説明をあげる。他のものは見ればわかる。ロングとショートのどちらを使うかは '@option{shortmess}' オプションに依存する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	long		short		meaning ~
	[readonly]	{RO}		the file is write protected
	[fifo/socket]			using a stream
	[fifo]				using a fifo stream
	[socket]			using a socket stream
	[CR missing]			reading with "dos" 'fileformat' and a
					NL without a preceding CR was found.
	[NL found]			reading with "mac" 'fileformat' and a
					NL was found (could be "unix" format)
	[long lines split]		at least one line was split in two
	[NOT converted]			conversion from 'fileencoding' to
					'encoding' was desired but not
					possible
	[converted]			conversion from 'fileencoding' to
					'encoding' done
	[crypted]			file was decrypted
	[READ ERRORS]			not all of the file could be read
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .2 .5
@item ロング @tab ショート @tab 意味
@item [readonly] @tab @{RO@} @tab ファイルは書き込み制限されている
@item [fifo/socket] @tab @tab ストリームを使っている
@item [fifo] @tab @tab FIFO ストリームを使っている
@item [socket] @tab @tab ソケットストリームを使っている
@item [CR missing] @tab @tab "dos" ファイルフォーマットで読み込んでいて CR のないNLを見つけた
@item [NL found] @tab @tab "mac" ファイルフォーマットで読み込んでいて NL を見つけた (unix フォーマットなのだろう)
@item [long lines split] @tab @tab 少なくとも 1 つの行が 2 つに分割された
@item [NOT converted] @tab @tab '@option{fileencoding}' から '@option{encoding}' の変換が失敗した
@item [converted] @tab @tab '@option{fileencoding}' から '@option{encoding}' の変換を実施した。
@item [crypted] @tab @tab 暗号が解除された
@item [READ ERRORS] @tab @tab ファイルを全て読み込めなかった
@end multitable
@{訳注: 以下日本語メッセージの場合:
@multitable @columnfractions .3 .2 .5
@item ロング @tab ショート @tab 意味
@item [読込専用] @tab [読専] @tab ファイルは書き込み制限されている
@item [FIFO/ソケット] @tab @tab ストリームを使っている
@item [FIFO] @tab @tab FIFO ストリームを使っている
@item [ソケット] @tab @tab ソケットストリームを使っている
@item [CR無] @tab @tab "dos" ファイルフォーマットで読み込んでいて CR のない NL を見つけた
@item [NL有] @tab @tab "mac" ファイルフォーマットで読み込んでいて NL を見つけた (unix フォーマットなのだろう)
@item [長行分割] @tab @tab 少なくとも 1 つの行が 2 つに分割された
@item [未変換] @tab @tab '@option{fileencoding}' から '@option{encoding}' の変換が失敗した
@item [変換済] @tab @tab '@option{fileencoding}' から '@option{encoding}' の変換を実施した。
@item [暗号化] @tab @tab 暗号が解除された
@item [読込エラー] @tab @tab ファイルを全ては読み込めなかった
@end multitable
@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
 vim:tw=78:ts=8:ft=help:norl:
@end ifset
