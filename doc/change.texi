@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@node change.txt, , , 目次
@unnumbered テキストの削除と変更
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*change.txt*    For Vim version 8.0.  Last change: 2017 Feb 12


		  VIM REFERENCE MANUAL    by Bram Moolenaar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
*change.txt*    For Vim バージョン 8.0.  Last change: 2017 Feb 12


		  VIMリファレンスマニュアル    by Bram Moolenaar
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
This file describes commands that delete or change text.  In this context,
changing text means deleting the text and replacing it with other text using
one command.  You can undo all of these commands.  You can repeat the non-Ex
commands with the "." command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このファイルでは、テキストを削除したり変更するコマンドの説明をする。この文章の中では、「テキストを変更する」とは、1 つのコマンドでテキストを削除し、別のテキストに置き換えることを意味する。これらのコマンドは全てアンドゥできる。非 Ex コマンドはコマンド "." で繰り返すことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. Deleting text		|deleting|
2. Delete and insert		|delete-insert|
3. Simple changes		|simple-change|		*changing*
4. Complex changes		|complex-change|
   4.1 Filter commands		   |filter|
   4.2 Substitute		   |:substitute|
   4.3 Search and replace	   |search-replace|
   4.4 Changing tabs		   |change-tabs|
5. Copying and moving text	|copy-move|
6. Formatting text		|formatting|
7. Sorting text			|sorting|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .5 .5
@item 1. テキストの削除 @tab |@ref{deleting, , deleting}|
@item 2. 削除と挿入 @tab |@ref{delete-insert, , delete-insert}|
@anchor{changing}
@cindex changing
@item 3. 単純な変更 @tab |@ref{simple-change, , simple-change}|
@item 4. 複雑な変更 @tab |@ref{complex-change, , complex-change}|
@item @ @ @ @ 4.1 フィルタコマンド @tab |@ref{filter, , filter}|
@item @ @ @ @ 4.2 置換 @tab |@ref{:substitute, , :substitute}|
@item @ @ @ @ 4.3 検索と置換 @tab |@ref{search-replace, , search-replace}|
@item @ @ @ @ 4.4 タブの変換 @tab |@ref{change-tabs, , change-tabs}|
@item 5. テキストのコピーと移動 @tab |@ref{copy-move, , copy-move}|
@item 6. テキストの整形 @tab |@ref{formatting, , formatting}|
@item 7. テキストのソート @tab |@ref{sorting, , sorting}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For inserting text see |insert.txt|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
テキストの挿入に関しては |@ref{insert.txt, , insert.txt}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
1. Deleting text					*deleting* *E470*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{deleting}
@anchor{E470}
@cindex deleting
@cindex E470
@section 1. テキストの削除
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
["x]<Del>	or					*<Del>* *x* *dl*
["x]x			Delete [count] characters under and after the cursor
			[into register x] (not |linewise|).  Does the same as
			"dl".
			The <Del> key does not take a [count].  Instead, it
			deletes the last character of the count.
			See |:fixdel| if the <Del> key does not do what you
			want.  See |'whichwrap'| for deleting a line break
			(join lines).  {Vi does not support <Del>}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{<Del>}
@anchor{x}
@anchor{dl}
@cindex <Del>
@cindex x
@cindex dl
@table @asis
@item ["x]<Del> or ["x]x
カーソル下から後の [count] 文字を [レジスタ x に入れ] 削除する (行単位ではない |linewise|)。"dl" と同じである。

@key{<Del>} キーには [count] が使えない。代わりに、[count] の最後の文字を削除する。@{訳注: 123<Del> と押すと 3 が消え 12 になる@}

@key{<Del>} キーが思ったように動作しないときは、|:fixdel| を参照。<EOL> の削除 (行の連結) については、'@option{whichwrap}' を参照。

@{Vi では <Del> が使えない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*X* *dh*
["x]X			Delete [count] characters before the cursor [into
			register x] (not |linewise|).  Does the same as "dh".
			Also see |'whichwrap'|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{X}
@anchor{dh}
@cindex X
@cindex dh
@item ["x]X
カーソルから前の [count] 文字を [レジスタ x に入れ] 削除する (行単位ではない |linewise|)。"dh" と同じである。'@option{whichwrap}' も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*d*
["x]d{motion}		Delete text that {motion} moves over [into register
			x].  See below for exceptions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{d}
@cindex d
@item ["x]d@{motion@}
@{motion@} でカーソルが動く範囲のテキストを [レジスタ x に入れ] 削除する。例外については以下を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*dd*
["x]dd			Delete [count] lines [into register x] |linewise|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{dd}
@cindex dd
@item ["x]dd
[count] 行を [レジスタ x に入れ] 削除する (行単位 |linewise|)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*D*
["x]D			Delete the characters under the cursor until the end
			of the line and [count]-1 more lines [into register
			x]; synonym for "d$".
			(not |linewise|)
			When the '#' flag is in 'cpoptions' the count is
			ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{D}
@cindex D
@item ["x]D
カーソル下から行の最後までの文字と、[count]-1 行を、[レジスタ x に入れ] 削除する。"d$" と同義 (行単位ではない |linewise|)。

'@option{cpoptions}' にフラグ '@var{#}' が入っているとカウントは無視される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{Visual}["x]x	or					*v_x* *v_d* *v_<Del>*
{Visual}["x]d   or
{Visual}["x]<Del>	Delete the highlighted text [into register x] (for
			{Visual} see |Visual-mode|).  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_x}
@anchor{v_d}
@anchor{v_<Del>}
@cindex v_x
@cindex v_d
@cindex v_<Del>
@item @{Visual@}["x]x or @{Visual@}["x]d or @{Visual@}["x]<Del>
ビジュアル選択されたテキストを [レジスタ x に入れ] 削除する (@{Visual@} については |Visual-mode| を参照)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{Visual}["x]CTRL-H   or					*v_CTRL-H* *v_<BS>*
{Visual}["x]<BS>	When in Select mode: Delete the highlighted text [into
			register x].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_CTRL-H}
@anchor{v_<BS>}
@cindex v_CTRL-H
@cindex v_<BS>
@item @{Visual@}["x]CTRL-H or @{Visual@}["x]<BS>
選択モード内で: ビジュアル選択されたテキストを [レジスタ x に入れ] 削除する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{Visual}["x]X	or					*v_X* *v_D* *v_b_D*
{Visual}["x]D		Delete the highlighted lines [into register x] (for
			{Visual} see |Visual-mode|).  In Visual block mode,
			"D" deletes the highlighted text plus all text until
			the end of the line.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_X}
@anchor{v_D}
@anchor{v_b_D}
@cindex v_X
@cindex v_D
@cindex v_b_D
@item @{Visual@}["x]X or @{Visual@}["x]D
ビジュアル選択された行を [レジスタ x に入れ] 削除する (@{Visual@} については |Visual-mode| を参照)。矩形ビジュアルモードでは、"D" はビジュアル選択されたテキストと行末までの全てのテキストを削除する。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*:d* *:de* *:del* *:delete* *:dl* *:dp*
:[range]d[elete] [x]	Delete [range] lines (default: current line) [into
			register x].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:d}
@anchor{:de}
@anchor{:del}
@anchor{:delete}
@anchor{:dl}
@anchor{:dp}
@cindex :d
@cindex :de
@cindex :del
@cindex :delete
@cindex :dl
@cindex :dp
@item :[range]d[elete] [x]
[range] 行 (既定値: 現在行) を [レジスタ x に入れ] 削除する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Note these weird abbreviations:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
これらの変な短縮入力:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			   :dl		delete and list
			   :dell	idem
			   :delel	idem
			   :deletl	idem
			   :deletel	idem
			   :dp		delete and print
			   :dep		idem
			   :delp	idem
			   :delep	idem
			   :deletp	idem
			   :deletep	idem
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .5 .5
@item :dl @tab delete と list
@item :dell @tab 同上
@item :delel @tab 同上
@item :deletl @tab 同上
@item :deletel @tab 同上
@item :dp @tab delete と print
@item :dep @tab 同上
@item :delp @tab 同上
@item :delep @tab 同上
@item :deletp @tab 同上
@item :deletep @tab 同上
@end multitable
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]d[elete] [x] {count}
			Delete {count} lines, starting with [range]
			(default: current line |cmdline-ranges|) [into
			register x].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[range]d[elete] [x] @{count@}
[range] 行目 (既定: 現在行 |cmdline-ranges|) から @{count@} 行を [レジスタ x に入れ] 削除する。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These commands delete text.  You can repeat them with the `.` command
(except `:d`) and undo them.  Use Visual mode to delete blocks of text.  See
|registers| for an explanation of registers.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのコマンドはテキストを削除する。これらは (`:d` を除いて) コマンド `.` で繰り返したり、アンドゥできる。テキストのブロックを削除するには、ビジュアルモードを使う。レジスタの説明については、|registers| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An exception for the d{motion} command: If the motion is not linewise, the
start and end of the motion are not in the same line, and there are only
blanks before the start and there are no non-blanks after the end of the
motion, the delete becomes linewise.  This means that the delete also removes
the line of blanks that you might expect to remain. Use the |o_v| operator to
force the motion to be characterwise.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンド "@command{d@{motion@}}" に関する例外: 移動が行単位でなく、移動の開始点と終了点が同じ行になく、移動の開始点の前に空白しかなく終了点の後に空行以外がない場合には、削除は行単位となる。このときユーザーは空白のみの行が残ると期待するかもしれないが、共に削除される。削除を文字単位に強制したい場合は |o_v| を使うこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Trying to delete an empty region of text (e.g., "d0" in the first column)
is an error when 'cpoptions' includes the 'E' flag.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{cpoptions}' がフラグ '@var{E}' を含んでいるときは、テキストの空の範囲を削除しようとすると (例えば、1 列目での "d0")、エラーになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*J*
J			Join [count] lines, with a minimum of two lines.
			Remove the indent and insert up to two spaces (see
			below).  Fails when on the last line of the buffer.
			If [count] is too big it is reduce to the number of
			lines available.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{J}
@cindex J
@table @asis
@item J
[count] 行を連結する (最低は 2 行)。インデントを削除し、空白を最大 2 個まで挿入する (以下を参照)。バッファの最終行では失敗する。大きすぎる [count] は、有効な行数まで減少される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_J*
{Visual}J		Join the highlighted lines, with a minimum of two
			lines.  Remove the indent and insert up to two spaces
			(see below).  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_J}
@cindex v_J
@item @{Visual@}J
ビジュアル選択された行を連結する (最低は 2 行)。インデントを削除し、空白を最大 2 個まで挿入する (以下を参照)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*gJ*
gJ			Join [count] lines, with a minimum of two lines.
			Don't insert or remove any spaces.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gJ}
@cindex gJ
@item gJ
[count] 行を連結する (最低は 2 行)。空白の挿入や削除を行わない。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_gJ*
{Visual}gJ		Join the highlighted lines, with a minimum of two
			lines.  Don't insert or remove any spaces.  {not in
			Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_gJ}
@cindex v_gJ
@item @{Visual@}gJ
ビジュアル選択された行を連結する (最低は 2 行)。空白の挿入や削除を行わない。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:j* *:join*
:[range]j[oin][!] [flags]
			Join [range] lines.  Same as "J", except with [!]
			the join does not insert or delete any spaces.
			If a [range] has equal start and end values, this
			command does nothing.  The default behavior is to
			join the current line with the line below it.
			{not in Vi: !}
			See |ex-flags| for [flags].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:j}
@anchor{:join}
@cindex :j
@cindex :join
@item :[range]j[oin][!] [flags]
[range] 行を連結する。"J" と同様だが、[!] と共に使うと空白の挿入や削除を行わない。[range] の開始点と終了点が同じときは、このコマンドは何もしない。既定の動作では、現在行を次行と連結する。

@{Vi にはない@}

[flags] については |ex-flags| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]j[oin][!] {count} [flags]
			Join {count} lines, starting with [range] (default:
			current line |cmdline-ranges|).  Same as "J", except
			with [!] the join does not insert or delete any
			spaces.
			{not in Vi: !}
			See |ex-flags| for [flags].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[range]j[oin][!] @{count@} [flags]
[range] 行目 (既定では現在行 |cmdline-ranges|) からの @{count@} 行を連結する。"J" と同様だが、[!] と共に使うと空白の挿入や削除を行わない。

@{Vi にはない@}

[flags] については |ex-flags| を参照。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These commands delete the <EOL> between lines.  This has the effect of joining
multiple lines into one line.  You can repeat these commands (except `:j`) and
undo them.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのコマンドは、行の間の <EOL> を削除する。この結果、複数行が 1 行に連結される。これらのコマンド (`@command{:j}` 以外) は、繰り返しやアンドゥができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These commands, except "gJ", insert one space in place of the <EOL> unless
there is trailing white space or the next line starts with a ')'.  These
commands, except "gJ", delete any leading white space on the next line.  If
the 'joinspaces' option is on, these commands insert two spaces after a '.',
'!' or '?' (but if 'cpoptions' includes the 'j' flag, they insert two spaces
only after a '.').
The 'B' and 'M' flags in 'formatoptions' change the behavior for inserting
spaces before and after a multi-byte character |fo-table|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのコマンド ("@command{gJ}" 以外) は <EOL> の場所に空白を 1 個挿入する。ただし行末に空白が付いていたり、次の行が ')' で始まるときは挿入しない。これらのコマンド ("@command{gJ}" 以外) は次行の先頭あたりにある空白を全て削除する。オプション '@option{joinspaces}' がオンのときは、これらのコマンドは '.', '!', '?' の後に 2 個の空白を挿入する (しかし '@option{cpoptions}' がフラグ '@var{j}' を含んでいるときは、2 個の空白は '.' の後にしか挿入しない)。

'@option{formatoptions}' のフラグ '@var{M}' と '@var{B}' は、マルチバイト文字の前後に空白を挿入するときの動作を変更する |fo-table|。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The '[ mark is set at the end of the first line that was joined, '] at the end
of the resulting line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'[ マークは連結前の最初の行の末尾に設定される。'] マークは連結後の行の末尾に設定される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
==============================================================================
2. Delete and insert				*delete-insert* *replacing*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{delete-insert}
@anchor{replacing}
@cindex delete-insert
@cindex replacing
@section 2. 削除と挿入
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*R*
R			Enter Replace mode: Each character you type replaces
			an existing character, starting with the character
			under the cursor.  Repeat the entered text [count]-1
			times.  See |Replace-mode| for more details.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{R}
@cindex R
@table @asis
@item R
置換モードに入る。打ち込んだ文字がカーソル下の既存の文字をどんどん置き換えていく。入力されたテキストを [count]-1 回繰り返す。詳細は |Replace-mode| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*gR*
gR			Enter Virtual Replace mode: Each character you type
			replaces existing characters in screen space.  So a
			<Tab> may replace several characters at once.
			Repeat the entered text [count]-1 times.  See
			|Virtual-Replace-mode| for more details.
			{not available when compiled without the |+vreplace|
			feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gR}
@cindex gR
@item gR
仮想置換モードに入る。打ち込んだ文字が画面上の既存の文字をどんどん置き換えていく。そのため <Tab> は数文字を 1 回で置き換えることができる。入力されたテキストを [count]-1 回繰り返す。詳細は |Virtual-Replace-mode| を参照。

@{Vim が |+vreplace| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*c*
["x]c{motion}		Delete {motion} text [into register x] and start
			insert.  When  'cpoptions' includes the 'E' flag and
			there is no text to delete (e.g., with "cTx" when the
			cursor is just after an 'x'), an error occurs and
			insert mode does not start (this is Vi compatible).
			When  'cpoptions' does not include the 'E' flag, the
			"c" command always starts insert mode, even if there
			is no text to delete.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c}
@cindex c
@item ["x]c@{motion@}
@{motion@} のテキストを [レジスタ x にいれ] 削除し、挿入を始める。'@option{cpoptions}' がフラグ '@var{E}' を含むときは、削除すべきテキストがないと (例えば、"cTx" でカーソルが 'x' の直後にあるとき)、エラーが発生し挿入モードは始まらない (これは Vi 互換である)。

'@option{cpoptions}' がフラグ '@var{E}' を含まないときは、コマンド "@command{c}" は削除すべきテキストがなくても、必ず挿入モードを始める。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*cc*
["x]cc			Delete [count] lines [into register x] and start
			insert |linewise|.  If 'autoindent' is on, preserve
			the indent of the first line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cc}
@cindex cc
@item ["x]cc
[count] 行を [レジスタ x に入れ] 削除し、挿入を始める (行単位 |linewise|)。'@option{autoindent}' がオンのとき、最初の行のインデントを保持する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*C*
["x]C			Delete from the cursor position to the end of the
			line and [count]-1 more lines [into register x], and
			start insert.  Synonym for c$ (not |linewise|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{C}
@cindex C
@item ["x]C
カーソル位置から行の終わりまでと、[count]-1 行を [レジスタ x に入れ] 削除し、挿入を始める。"c$" と同義である (行単位でない|linewise|)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*s*
["x]s			Delete [count] characters [into register x] and start
			insert (s stands for Substitute).  Synonym for "cl"
			(not |linewise|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{s}
@cindex s
@item ["x]s
[count] 文字を [レジスタ x に入れ] 削除し、挿入を始める (s は Substitute --置換 を意味する)。"cl" と同義である (行単位でない |linewise|)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*S*
["x]S			Delete [count] lines [into register x] and start
			insert.  Synonym for "cc" |linewise|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{S}
@cindex S
@item ["x]S
[count] 行を [レジスタ x に入れ] 削除し、挿入を始める。"cc" と同義である (行単位 |linewise|)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{Visual}["x]c	or					*v_c* *v_s*
{Visual}["x]s		Delete the highlighted text [into register x] and
			start insert (for {Visual} see |Visual-mode|).  {not
			in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_c}
@anchor{v_s}
@cindex v_c
@cindex v_s
@item @{Visual@}["x]c or @{Visual@}["x]s
ビジュアル選択されたテキストを [レジスタ x に入れ] 削除し、挿入を始める (@{Visual@} については |Visual-mode| を参照)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_r*
{Visual}["x]r{char}	Replace all selected characters by {char}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_r}
@cindex v_r
@item @{Visual@}["x]r@{char@}
ビジュアル選択されたテキストを全て @{char@} に置き換える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_C*
{Visual}["x]C		Delete the highlighted lines [into register x] and
			start insert.  In Visual block mode it works
			differently |v_b_C|.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_C}
@cindex v_C
@item @{Visual@}["x]C
ビジュアル選択された行を [レジスタ x に入れ] 削除し、挿入を始める。矩形ビジュアルモードでは少し動作が違う |v_b_C|。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*v_S*
{Visual}["x]S		Delete the highlighted lines [into register x] and
			start insert (for {Visual} see |Visual-mode|).  {not
			in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_S}
@cindex v_S
@item @{Visual@}["x]S
ビジュアル選択された行を [レジスタ x に入れ] 削除し、挿入を始める (@{Visual@} については |Visual-mode| を参照)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*v_R*
{Visual}["x]R		Currently just like {Visual}["x]S.  In a next version
			it might work differently. {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_R}
@cindex v_R
@item @{Visual@}["x]R
現在のところ @{Visual@}["x]S と同じである。次のバージョンでは動作が変わるかもしれない。

@{Vi にはない@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Notes:
- You can end Insert and Replace mode with <Esc>.
- See the section "Insert and Replace mode" |mode-ins-repl| for the other
  special characters in these modes.
- The effect of [count] takes place after Vim exits Insert or Replace mode.
- When the 'cpoptions' option contains '$' and the change is within one line,
  Vim continues to show the text to be deleted and puts a '$' at the last
  deleted character.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Notes:}
@itemize @minus
@item 挿入モード、置換モードは <Esc> で終了できる。
@item これらのモードでの他の特殊文字については、「テキストの挿入と置換」の章 |mode-ins-repl| を参照。
@item [count] の効果は、Vim が挿入モードや置換モードを抜けた後で発生する。
@item '@option{cpoptions}' がフラグ '@var{$}' を含んでいて、変更が 1 行以内である場合、Vim は削除されるテキストを表示しつづけ、最後に削除された文字の位置に '$' を置く。
@end itemize
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
See |registers| for an explanation of registers.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
レジスタに関する説明は |registers| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Replace mode is just like Insert mode, except that every character you enter
deletes one character.  If you reach the end of a line, Vim appends any
further characters (just like Insert mode).  In Replace mode, the backspace
key restores the original text (if there was any).  (See section "Insert and
Replace mode" |mode-ins-repl|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
置換モードは挿入モードと似ているが、文字を打ち込むたびに 1 文字ずつ削除される点が違う。行の最後に達すると、Vim はそれ以降は (挿入モードと同様に) 文字を追加する。置換モードでは、バックスペースキーは (もしあれば) 以前のテキストを復元する (「テキストの挿入と置換」の章 |mode-ins-repl| を参照すること)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*cw* *cW*
Special case: When the cursor is in a word, "cw" and "cW" do not include the
white space after a word, they only change up to the end of the word.  This is
because Vim interprets "cw" as change-word, and a word does not include the
following white space.
{Vi: "cw" when on a blank followed by other blanks changes only the first
blank; this is probably a bug, because "dw" deletes all the blanks; use the
'w' flag in 'cpoptions' to make it work like Vi anyway}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cw}
@anchor{cW}
@cindex cw
@cindex cW
特別な場合: "cw" と "cW" は、カーソルが単語の上にあるとき、単語のあとにつづく空白を含めず、単語の末尾までを変更する ("ce" と "cE" と同じ働きをする)。これは Vim が "cw" を単語の変更 (change-word) として解釈し、また「単語」にはあとに続く空白は含まれないからである。

@{Vi: あとに空白が続く空白上での "cw" は、最初の空白のみを変更する。これは多分バグである。"dw" は全ての空白を削除するからだ。とにかく、Vi 風に動作させるときには '@option{cpoptions}' にフラグ '@var{w}' を含めること@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you prefer "cw" to include the space after a word, use this mapping: >
	:map cw dwi
Or use "caw" (see |aw|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"cw" の変更範囲に単語の後の空白も含めたいときは、次のマップを使うこと。
@example
:map cw dwi
@end example
または "caw" を使う (|aw| を参照)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:c* *:ch* *:change*
:{range}c[hange][!]	Replace lines of text with some different text.
			Type a line containing only "." to stop replacing.
			Without {range}, this command changes only the current
			line.
			Adding [!] toggles 'autoindent' for the time this
			command is executed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:c}
@anchor{:ch}
@anchor{:change}
@cindex :c
@cindex :ch
@cindex :change
@table @asis
@item :@{range@}c[hange][!]
テキストを行単位で別のテキストと置き換える。"." のみを含む行を打ち込むことで置換を終了する。@{range@} なしの場合、現在行のみを変更する。

[!] をつけると、このコマンドを実行するときだけ '@option{autoindent}' をトグルする。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
3. Simple changes					*simple-change*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{simple-change}
@cindex simple-change
@section 3. 単純な変更
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*r*
r{char}			Replace the character under the cursor with {char}.
			If {char} is a <CR> or <NL>, a line break replaces the
			character.  To replace with a real <CR>, use CTRL-V
			<CR>.  CTRL-V <NL> replaces with a <Nul>.
			{Vi: CTRL-V <CR> still replaces with a line break,
			cannot replace something with a <CR>}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{r}
@cindex r
@table @asis
@item r@{char@}
カーソル下の文字を @{char@} に置き換える。@{char@} が <CR> か <NL> のとき、文字は改行に置き換わる。文字を本当の <CR> に置き換えるには、@kbd{CTRL-V} <CR> を使う。@kbd{CTRL-V} <NL> は文字を <Nul> に置き換える。
@{Vi: @kbd{CTRL-V} <CR> は改行に置き換わり、何かの文字を <CR> に置き換えることはできない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			If {char} is CTRL-E or CTRL-Y the character from the
			line below or above is used, just like with |i_CTRL-E|
			and |i_CTRL-Y|.  This also works with a count, thus
			`10r<C-E>` copies 10 characters from the line below.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{char@} が @kbd{CTRL-E} または @kbd{CTRL-Y} のとき、ちょうど |i_CTRL-E| と |i_CTRL-Y| と同じように、下の行または上の行の文字が使われる。回数も指定することができるため、`10r<C-E>` は下の行から 10 文字をコピーすることになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			If you give a [count], Vim replaces [count] characters
			with [count] {char}s.  When {char} is a <CR> or <NL>,
			however, Vim inserts only one <CR>: "5r<CR>" replaces
			five characters with a single line break.
			When {char} is a <CR> or <NL>, Vim performs
			autoindenting.  This works just like deleting the
			characters that are replaced and then doing
			"i<CR><Esc>".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[count] を指定すると、[count] 文字が [count] 個の @{char@} に置き換わる。しかし @{char@} が <CR> か <NL> の場合、挿入される <CR> はただ1個である。"5r<CR>" は 5 文字を 1 個の改行に置き換える。

@{char@} が <CR> か <NL> のとき、Vim は自動インデントを行う。これは置き換えるべき文字を削除した後 "i<CR><Esc>" を実行したような動作になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			{char} can be entered as a digraph |digraph-arg|.
			|:lmap| mappings apply to {char}.  The CTRL-^ command
			in Insert mode can be used to switch this on/off
			|i_CTRL-^|.  See |utf-8-char-arg| about using
			composing characters when 'encoding' is Unicode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{char@} はダイグラフでもよい |digraph-arg|。|:lmap| のマッピングは @{char@} に適用される。挿入モードでは、コマンド @kbd{CTRL-^} を使ってマッピングを切り替えられる |i_CTRL-^|。オプション '@option{encoding}' が Unicode の一種のときに composing character を使うことについては |utf-8-char-arg| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*gr*
gr{char}		Replace the virtual characters under the cursor with
			{char}.  This replaces in screen space, not file
			space.  See |gR| and |Virtual-Replace-mode| for more
			details.  As with |r| a count may be given.
			{char} can be entered like with |r|.
			{not available when compiled without the |+vreplace|
			feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gr}
@cindex gr
@item gr@{char@}
カーソル下の仮想文字を @{char@} に置き換える。このコマンドはファイル上の文字単位ではなく、画面上の文字幅単位で置き換える。詳細は |gR| と |Virtual-Replace-mode| を参照。|r| と同様、回数を指定できる。@{char@} の入力方法は |r| と同様である。

@{ Vimが |+vreplace| 機能付きでコンパイルされたときのみ有効@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*digraph-arg*
The argument for Normal mode commands like |r| and |t| is a single character.
When 'cpo' doesn't contain the 'D' flag, this character can also be entered
like |digraphs|.  First type CTRL-K and then the two digraph characters.
{not available when compiled without the |+digraphs| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{digraph-arg}
@cindex digraph-arg
|r| や |t| 等のノーマルモードコマンドの引数は、1 個の文字である。オプション '@option{cpoptions}' がフラグ '@var{D}' を含まないとき、この文字はダイグラフ |digraphs| と同様に入力できる。まず @kbd{CTRL-K} を打ち込み、次にダイグラフの2文字を入力する。

@{Vim が |+digraphs| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*case*
The following commands change the case of letters.  The currently active
|locale| is used.  See |:language|.  The LC_CTYPE value matters here.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{case}
@cindex case
以下のコマンドは、アルファベットの大文字／小文字を切り替える。現在有効なロケール |locale| が使われる。|:language| を参照。環境変数 LC_CTYPE の値に影響される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*~*
~			'notildeop' option: Switch case of the character
			under the cursor and move the cursor to the right.
			If a [count] is given, do that many characters. {Vi:
			no count}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{~}
@cindex ~
@table @asis
@item ~
オプション '@option{tildeop}' がオフのとき: カーソル下の文字の大文字／小文字を切り替え、カーソルを右に移動させる。[count] が指定されたときは、[count] 文字に作用する。

@{Vi: カウントが使えない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
~{motion}		'tildeop' option: switch case of {motion} text. {Vi:
			tilde cannot be used as an operator}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ~@{motion@}
オプション '@option{tildeop}' がオンのとき: @{motion@} のテキストの大文字／小文字を切り替える。

@{Vi: チルダは operator として使用できない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*g~*
g~{motion}		Switch case of {motion} text. {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g~}
@cindex g~
@item g~@{motion@}
@{motion@} のテキストの大文字／小文字を切り替える。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
g~g~							*g~g~* *g~~*
g~~			Switch case of current line. {not in Vi}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g~g~}
@anchor{g~~}
@cindex g~g~
@cindex g~~
@item g~g~ or g~~
現在行の大文字／小文字を切り替える。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_~*
{Visual}~		Switch case of highlighted text (for {Visual} see
			|Visual-mode|). {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_~}
@cindex v_~
@item @{Visual@}~
ビジュアル選択されたテキストの大文字／小文字を切り替える (@{Visual@} については |Visual-mode| を参照)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_U*
{Visual}U		Make highlighted text uppercase (for {Visual} see
			|Visual-mode|). {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_U}
@cindex v_U
@item @{Visual@}U
ビジュアル選択されたテキストを大文字にする (@{Visual@} については |Visual-mode| を参照)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*gU* *uppercase*
gU{motion}		Make {motion} text uppercase. {not in Vi}
			Example: >
				:map! <C-F> <Esc>gUiw`]a
<			This works in Insert mode: press CTRL-F to make the
			word before the cursor uppercase.  Handy to type
			words in lowercase and then make them uppercase.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gU}
@anchor{uppercase}
@cindex gU
@cindex uppercase
@item gU@{motion@}
@{motion@} のテキストを大文字にする。

@{Vi にはない@}

例:
@example
:map! <C-F> <Esc>gUcw`]a
@end example
これは挿入モードで機能する。カーソルの前の単語を大文字にするときに CTRL-F を打ち込めばよい。単語は小文字で入力し、後から大文字にする方が楽だ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
gUgU							*gUgU* *gUU*
gUU			Make current line uppercase. {not in Vi}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gUgU}
@anchor{gUU}
@cindex gUgU
@cindex gUU
@item gUgU or gUU
現在行を大文字にする。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_u*
{Visual}u		Make highlighted text lowercase (for {Visual} see
			|Visual-mode|).  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_u}
@cindex v_u
@item @{Visual@}u
ビジュアル選択されたテキストを小文字にする (@{Visual@} については |Visual-mode| を参照)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*gu* *lowercase*
gu{motion}		Make {motion} text lowercase. {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gu}
@anchor{lowercase}
@cindex gu
@cindex lowercase
@item gu@{motion@}
@{motion@} のテキストを小文字にする。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
gugu							*gugu* *guu*
guu			Make current line lowercase. {not in Vi}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gugu}
@anchor{guu}
@cindex gugu
@cindex guu
@item gugu or guu
現在行を小文字にする。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*g?* *rot13*
g?{motion}		Rot13 encode {motion} text. {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g?}
@anchor{rot13}
@cindex g?
@cindex rot13
@item g?@{motion@}
@{motion@} のテキストを Rot13 エンコードする。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_g?*
{Visual}g?		Rot13 encode the highlighted text (for {Visual} see
			|Visual-mode|).  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_g?}
@cindex v_g?
@item @{Visual@}g?
ビジュアル選択されたテキストをRot13エンコードする (@{Visual@} については |Visual-mode| を参照)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
g?g?							*g?g?* *g??*
g??			Rot13 encode current line. {not in Vi}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g?g?}
@anchor{g??}
@cindex g?g?
@cindex g??
@item g?g? or g??
現在行を Rot13 エンコードする。

@{Vi にはない@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To turn one line into title caps, make every first letter of a word
uppercase: >
	:s/\v<(.)(\w*)/\u\1\L\2/g
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
各単語の最初の文字を大文字にする:
@example
:s/\v<(.)(\w*)/\u\1\L\2/g
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Adding and subtracting ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 加算と減算
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*CTRL-A*
CTRL-A			Add [count] to the number or alphabetic character at
			or after the cursor.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{CTRL-A}
@cindex CTRL-A
@table @asis
@item CTRL-A
カーソルの下または後の数字またはアルファベットに [count] を加える。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_CTRL-A*
{Visual}CTRL-A		Add [count] to the number or alphabetic character in
			the highlighted text.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_CTRL-A}
@cindex v_CTRL-A
@item @{Visual@}CTRL-A
ビジュアル選択されたテキスト中の数字またはアルファベットに [count] を加える。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_g_CTRL-A*
{Visual}g CTRL-A	Add [count] to the number or alphabetic character in
			the highlighted text. If several lines are
		        highlighted, each one will be incremented by an
			additional [count] (so effectively creating a
			[count] incrementing sequence).  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_g_CTRL-A}
@cindex v_g_CTRL-A
@item @{Visual@}g CTRL-A
ビジュアル選択されたテキスト中の数字またはアルファベットに [count] を加える。複数行がビジュアル選択されている場合、各行は付加された [count] ごとに増やされる (そのため効果的に [count] ごとに増加する配列を作ることができる)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			For Example, if you have this list of numbers:
				1. ~
				1. ~
				1. ~
				1. ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば、このような数字のリストがあるとする:
@verbatim
1.
1.
1.
1.
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Move to the second "1." and Visually select three
			lines, pressing g CTRL-A results in:
				1. ~
				2. ~
				3. ~
				4. ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2 番目の "1." に移動し 3 行をビジュアル選択してから g @kbd{CTRL-A} を押すと、このようになる:
@verbatim
1.
2.
3.
4.
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*CTRL-X*
CTRL-X			Subtract [count] from the number or alphabetic
			character at or after the cursor.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{CTRL-X}
@cindex CTRL-X
@item CTRL-X
カーソルの下または後の数字またはアルファベットから [count] を減じる。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_CTRL-X*
{Visual}CTRL-X		Subtract [count] from the number or alphabetic
			character in the highlighted text.  {not in Vi}

			On MS-Windows, this is mapped to cut Visual text
			|dos-standard-mappings|.  If you want to disable the
			mapping, use this: >
				silent! vunmap <C-X>
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_CTRL-X}
@cindex v_CTRL-X
@item @{Visual@}CTRL-X
ビジュアル選択されたテキスト中の数字またはアルファベットから [count] を減じる。

@{Vi にはない@}


MS-Windows では、ビジュアルモードでのテキストの切り取りにマップされる |dos-standard-mappings|。このマッピングを無効にしたいなら、次のようにする:
@verbatim
silent! vunmap <C-X>
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*v_g_CTRL-X*
{Visual}g CTRL-X	Subtract [count] from the number or alphabetic
			character in the highlighted text. If several lines
			are highlighted, each value will be decremented by an
			additional [count] (so effectively creating a [count]
			decrementing sequence).  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_g_CTRL-X}
@cindex v_g_CTRL-X
@item @{Visual@}g CTRL-X
ビジュアル選択されたテキスト中の数字またはアルファベットから [count] を減じる。複数行がビジュアル選択されている場合、各値は付加された [count] ごとに減らされる (そのため効果的に [count] ごとに減少する配列を作ることができる)。

@{Vi にはない@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The CTRL-A and CTRL-X commands can work for:
- signed and unsigned decimal numbers
- unsigned binary, octal and hexadecimal numbers
- alphabetic characters
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
CTRL-A と CTRL-X が適用できるのは:
@itemize @minus
@item 符号付き及び符号なし 10 進数
@item 符号なし 2 進数、8 進数および 16 進数
@item アルファベット文字
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This depends on the 'nrformats' option:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{nrformats}' オプションに依存している:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- When 'nrformats' includes "bin", Vim assumes numbers starting with '0b' or
  '0B' are binary.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize @minus
@item
'@option{nrformats}' に "@var{bin}" が含まれる時、Vim は '0b' または '0B' で始まる数値を 2 進数として扱う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- When 'nrformats' includes "octal", Vim considers numbers starting with a '0'
  to be octal, unless the number includes a '8' or '9'.  Other numbers are
  decimal and may have a preceding minus sign.
  If the cursor is on a number, the commands apply to that number; otherwise
  Vim uses the number to the right of the cursor.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
'@option{nrformats}' が "@var{octal}" を含むときは、Vim は '0' で始まり、'8' や '9' を含まない数字を 8 進数として取り扱う。他の数は 10 進数とみなされ、マイナス符号が付いてもよい。カーソルが数の上にあれば、コマンドはその数に適用される。そうでなければ、カーソルの右の数に適用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- When 'nrformats' includes "hex", Vim assumes numbers starting with '0x' or
  '0X' are hexadecimal.  The case of the rightmost letter in the number
  determines the case of the resulting hexadecimal number.  If there is no
  letter in the current number, Vim uses the previously detected case.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
'@option{nrformats}' が "@var{hex}" を含むときは、Vim は '0x' か '0X' で始まる数を 16 進数として取り扱う。その数の最も右の文字が大文字であるか小文字であるかによって、変更結果の 16 進数が大文字か小文字かが決定する。対象となった数にアルファベットが含まれない場合、Vim は前回の決定を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- When 'nrformats' includes "alpha", Vim will change the alphabetic character
  under or after the cursor.  This is useful to make lists with an alphabetic
  index.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
'@option{nrformats}' が "@var{alpha}" を含むときは、Vim はカーソル下または後のアルファベットを変更する。これはアルファベットのインデックスつきのリストを作るときに便利である。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For decimals a leading negative sign is considered for incrementing/
decrementing, for binary, octal and hex values, it won't be considered.  To
ignore the sign Visually select the number before using CTRL-A or CTRL-X. 
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
10 進数では先頭の負の符号は増加/減少に対して考慮される。しかし 2 進数、8 進数および 16 進数では考慮されない。符号を無視するには @kbd{CTRL-A} または @kbd{CTRL-X} を使う前に数字をビジュアル選択する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For numbers with leading zeros (including all octal and hexadecimal numbers),
Vim preserves the number of characters in the number when possible.  CTRL-A on
"0077" results in "0100", CTRL-X on "0x100" results in "0x0ff".
There is one exception: When a number that starts with a zero is found not to
be octal (it contains a '8' or '9'), but 'nrformats' does include "octal",
leading zeros are removed to avoid that the result may be recognized as an
octal number.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ゼロから始まる数 (全ての 8 進数、16 進数を含む) に対して、Vim はできる限りその数の文字数を保とうとする。"0077" 上で @kbd{CTRL-A} を使うと "0100" となり、"0x100" 上で @kbd{CTRL-X} を使うと "0x0ff" となる。

1 つだけ例外がある: ゼロで始まるが 8 進数でないとき ('8' や '9' を含んでいるとき)、'@option{nrformats}' が "@var{octal}" を含んでいるならば、結果が 8 進数とみなされないように、前方のゼロは削除される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that when 'nrformats' includes "octal", decimal numbers with leading
zeros cause mistakes, because they can be confused with octal numbers.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
'@option{nrformats}' が "@var{octal}" を含んでいるとき、0 で始まる 10 進数は、8 進数と区別しづらいため、意図しない結果になる可能性がある。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note similarly, when 'nrformats' includes "bin", binary numbers with a leading
'0x' or '0X' can be interpreted as hexadecimal rather than binary since '0b'
are valid hexadecimal digits.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
'@option{nrformats}' が "@var{bin}" を含んでいるとき、'0x' または '0X' で始まる 2 進数は 16 進数として解釈される。これは '0b' が 16 進数の桁として有効だからである。

@{訳注: 0x0b0011 のような値のこと。@}
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The CTRL-A command is very useful in a macro.  Example: Use the following
steps to make a numbered list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンド @kbd{CTRL-A} はマクロ内でたいへん便利である。例: 番号付きリストを作るには、次の方法を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. Create the first list entry, make sure it starts with a number.
2. qa	     - start recording into register 'a'
3. Y	     - yank the entry
4. p	     - put a copy of the entry below the first one
5. CTRL-A    - increment the number
6. q	     - stop recording
7. <count>@a - repeat the yank, put and increment <count> times
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item 1. @tab リストの最初の項目を作る。番号から始まるようにすること。
@item 2. qa @tab - レジスタ 'a' への記録を始める
@item 3. Y @tab - 項目をコピーする
@item 4. p @tab - 項目のコピーを最初の項目の後に貼り付ける
@item 5. CTRL-A @tab - 番号を増やす
@item 6. q @tab - 記録をストップする
@item 7. <count>@@a @tab - コピー、貼り付け、番号増加を <count> 回繰り返す
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
SHIFTING LINES LEFT OR RIGHT				*shift-left-right*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{shift-left-right}
@cindex shift-left-right
@unnumberedsubsec 行を左右にずらす
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*<*
<{motion}		Shift {motion} lines one 'shiftwidth' leftwards.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{<}
@cindex <
@table @asis
@item <@{motion@}
@{motion@} の行を '@option{shiftwidth}' 1 個分左にずらす。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*<<*
<<			Shift [count] lines one 'shiftwidth' leftwards.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{<<}
@cindex <<
@item <<
[count] 行を '@option{shiftwidth}' 1 個分左にずらす。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_<*
{Visual}[count]<	Shift the highlighted lines [count] 'shiftwidth'
			leftwards (for {Visual} see |Visual-mode|).  {not in
			Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_<}
@cindex v_<
@item @{Visual@}[count]<
ビジュアル選択された行を、'@option{shiftwidth}' の [count] 個分左にずらす (@{Visual@} については |Visual-mode| を参照)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*>*
 >{motion}		Shift {motion} lines one 'shiftwidth' rightwards.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{>}
@cindex >
@item >@{motion@}
@{motion@} の行を '@option{shiftwidth}' 1 個分右にずらす。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*>>*
 >>			Shift [count] lines one 'shiftwidth' rightwards.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{>>}
@cindex >>
@item >>
[count] 行を '@option{shiftwidth}' 1 個分右にずらす。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_>*
{Visual}[count]>	Shift the highlighted lines [count] 'shiftwidth'
			rightwards (for {Visual} see |Visual-mode|).  {not in
			Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_>}
@cindex v_>
@item @{Visual@}[count]>
ビジュアル選択された行を、'@option{shiftwidth}' の [count] 個分右にずらす (@{Visual@} については |Visual-mode| を参照)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:<*
:[range]<		Shift [range] lines one 'shiftwidth' left.  Repeat '<'
			for shifting multiple 'shiftwidth's.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:<}
@cindex :<
@item :[range]<
[range] の行を、'@option{shiftwidth}' 1 個分左にずらす。'@option{shiftwidth}' の複数個分ずらすには、'<' を繰り返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]< {count}	Shift {count} lines one 'shiftwidth' left, starting
			with [range] (default current line |cmdline-ranges|).
			Repeat '<' for shifting multiple 'shiftwidth's.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[range]< @{count@}
[range] (既定は現在行 |cmdline-ranges|) から始まる @{count@} 行を '@option{shiftwidth}' 1 個分左にずらす。'@option{shiftwidth}' の複数個分ずらすには、'<' を繰り返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]le[ft] [indent]	left align lines in [range].  Sets the indent in the
			lines to [indent] (default 0).  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[range]le[ft] [indent]
[range] の行を左揃えする。行のインデントは [indent] (既定値は 0) に設定される。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:>*
:[range]> [flags]	Shift {count} [range] lines one 'shiftwidth' right.
			Repeat '>' for shifting multiple 'shiftwidth's.
			See |ex-flags| for [flags].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:>}
@cindex :>
@item :[range]> [flags]
[range] の行を、'@option{shiftwidth}' 1 個分右にずらす。'@option{shiftwidth}' の複数個分ずらすには、'>' を繰り返す。[flags] については |ex-flags| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]> {count} [flags]
			Shift {count} lines one 'shiftwidth' right, starting
			with [range] (default current line |cmdline-ranges|).
			Repeat '>' for shifting multiple 'shiftwidth's.
			See |ex-flags| for [flags].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[range]> @{count@} [flags]
[range] (既定は現在の行 |cmdline-ranges|) から始まる @{count@} 行を、'@option{shiftwidth}' 1 個分右にずらす。'@option{shiftwidth}' の複数個分ずらすには、'>' を繰り返す。[flags] については |ex-flags| を参照。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The ">" and "<" commands are handy for changing the indentation within
programs.  Use the 'shiftwidth' option to set the size of the white space
which these commands insert or delete.  Normally the 'shiftwidth' option is 8,
but you can set it to, say, 3 to make smaller indents.  The shift leftwards
stops when there is no indent.  The shift right does not affect empty lines.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンド ">" と "<" は、プログラムに含まれるインデントを変更するのに便利である。オプション '@option{shiftwidth}' には、これらのコマンドが挿入、削除する空白の幅を設定する。'@option{shiftwidth}' は既定では 8 だが、例えば 3 に設定して、インデントをもっと少なくすることもできる。左方向へのシフトは、インデントがなくなったときに終了する。右方向へのシフトは、空行には適用されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the 'shiftround' option is on, the indent is rounded to a multiple of
'shiftwidth'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{shiftround}' がオンのとき、インデントは '@option{shiftwidth}' の倍数に丸められる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the 'smartindent' option is on, or 'cindent' is on and 'cinkeys' contains
'#' with a zero value, shift right does not affect lines starting with '#'
(these are supposed to be C preprocessor lines that must stay in column 1).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{shiftwidth}' がオンのとき、あるいは '@option{cindent}' がオンで '@option{cinkeys}' が値 0 の '@var{#}' を含むとき、右方向へのシフトは '#' で始まる行に適用されない (これらの行は、行の最初に位置すべき C プリプロセッサー指令であると考えられる)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the 'expandtab' option is off (this is the default) Vim uses <Tab>s as
much as possible to make the indent.  You can use ">><<" to replace an indent
made out of spaces with the same indent made out of <Tab>s (and a few spaces
if necessary).  If the 'expandtab' option is on, Vim uses only spaces.  Then
you can use ">><<" to replace <Tab>s in the indent by spaces (or use
`:retab!`).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{expandtab}' がオフ (既定値) のとき、Vim はインデントにできる限り多くの <Tab> を使う。">><<" によって、空白のみで構成されたインデントを、<Tab> (と必要ならばいくつかの空白) で構成されたインデントに置換できる。'@option{expandtab}' がオンのときは、Vim は空白のみを使う。">><<" によって、インデント内の <Tab> を空白に置換できる (あるいは `@command{:retab!}` を使う)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To move a line several 'shiftwidth's, use Visual mode or the `:` commands.
For example: >
	Vjj4>		move three lines 4 indents to the right
	:<<<		move current line 3 indents to the left
	:>> 5		move 5 lines 2 indents to the right
	:5>>		move line 5 2 indents to the right
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
行を '@option{shiftwidth}' の複数個分ずらすには、ビジュアルモードかコマンド `@command{:}` を使う。

例:
@verbatim
Vjj4>       3 行をインデント 4 個分右に移動
:<<<        現在の行をインデント 3 個分左に移動
:>> 5       5 行をインデント 2 個分右へ移動
:5>>        5 行目をインデント 2 個分右に移動
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
4. Complex changes					*complex-change*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{complex-change}
@cindex complex-change
@section 4. 複雑な変更
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
4.1 Filter commands					*filter*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{filter}
@cindex filter
@unnumberedsubsec 4.1 フィルタコマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A filter is a program that accepts text at standard input, changes it in some
way, and sends it to standard output.  You can use the commands below to send
some text through a filter, so that it is replaced by the filter output.
Examples of filters are "sort", which sorts lines alphabetically, and
"indent", which formats C program files (you need a version of indent that
works like a filter; not all versions do).  The 'shell' option specifies the
shell Vim uses to execute the filter command (See also the 'shelltype'
option).  You can repeat filter commands with ".".  Vim does not recognize a
comment (starting with '"') after the `:!` command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
フィルタとは、テキストを標準入力から受け取り、何らかの変更を加え、標準出力に送るプログラムのことである。以下のコマンドにより、テキストの一部をフィルタにかけることができる。フィルタの例としては、行をアルファベット順にソートする "sort"、C のプログラムを整形する "indent" (ただし、フィルタ機能を持ったバージョンが必要。全てのバージョンでできるわけではない) などがある。

オプション '@option{shell}' は、Vim がフィルタコマンドを実行するときに使うシェルを指定する ('@option{shelltype}' も参照)。フィルタコマンドはコマンド "@command{.}" で繰り返せる。Vim は `:!` の後の ('"' で始まる) コメントを認識しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*!*
!{motion}{filter}	Filter {motion} text lines through the external
			program {filter}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{!}
@cindex !
@table @asis
@item !@{motion@}@{filter@}
@{motion@} のテキストを外部プログラム @{filter@} でフィルタ処理する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*!!*
!!{filter}		Filter [count] lines through the external program
			{filter}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{!!}
@cindex !!
@item !!@{filter@}
[count] 行を外部プログラム @{filter@} でフィルタ処理する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_!*
{Visual}!{filter}	Filter the highlighted lines through the external
			program {filter} (for {Visual} see |Visual-mode|).
			{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_!}
@cindex v_!
@item @{Visual@}!@{filter@}
ビジュアル選択された行を外部プログラム @{filter@} でフィルタ処理する。(@{Visual@} については |Visual-mode| を参照)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:{range}![!]{filter} [!][arg]				*:range!*
			Filter {range} lines through the external program
			{filter}.  Vim replaces the optional bangs with the
			latest given command and appends the optional [arg].
			Vim saves the output of the filter command in a
			temporary file and then reads the file into the buffer
			|tempfile|.  Vim uses the 'shellredir' option to
			redirect the filter output to the temporary file.
			However, if the 'shelltemp' option is off then pipes
			are used when possible (on Unix).
			When the 'R' flag is included in 'cpoptions' marks in
			the filtered lines are deleted, unless the
			|:keepmarks| command is used.  Example: >
				:keepmarks '<,'>!sort
<			When the number of lines after filtering is less than
			before, marks in the missing lines are deleted anyway.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:range!}
@cindex :range!
@item :@{range@}![!]@{filter@} [!][arg]
@{range@} 行を外部プログラム @{filter@} でフィルタ処理する。@{filter@} の後ろには '!' を付けてもよい。これは最後に実行されたコマンドに置き換えられる。さらに [arg] を付けると、それがコマンドに付け加えられる。Vim はフィルタコマンドの出力を一時ファイルに保存し、そのファイルをバッファに読み込む |tempfile|。フィルタの出力を一時ファイルにリダイレクトするときはオプション '@option{shellredir}' が使われる。Unix では '@option{shellredir}' がオフのとき、可能ならばパイプが使われる。

'@option{cpoptions}' に '@var{R}' フラグが含まれるとき、フィルタ処理された行のマークは削除される。|:keepmarks| コマンドを使うと削除されない。例:
@example
:keepmarks '<,'>!sort
@end example
フィルタ処理のあと行数が少なくなっていた場合、すでにな
い行を指しているマークは削除される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*=*
={motion}		Filter {motion} lines through the external program
			given with the 'equalprg' option.  When the 'equalprg'
			option is empty (this is the default), use the
			internal formatting function |C-indenting| and
			|'lisp'|.  But when 'indentexpr' is not empty, it will
			be used instead |indent-expression|.  When Vim was
			compiled without internal formatting then the "indent"
			program is used as a last resort.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{=}
@cindex =
@item =@{motion@}
@{motion@} の行を、オプション '@option{equalprg}' で指定された外部プログラムでフィルタ処理する。'@option{equalprg}' が空のとき (これが既定) は、組み込みの整形機能の |C-indenting| と |'lisp'| を使う。しかし '@option{indentexpr}' が空でないときは、それが使われる |indent-expression|。Vim が内部フォーマット機能なしでコンパイルされているときは、最後の手段として "indent" プログラムが使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*==*
==			Filter [count] lines like with ={motion}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{==}
@cindex ==
@item ==
[count] 行を =@{motion@} と同様にフィルタ処理する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_=*
{Visual}=		Filter the highlighted lines like with ={motion}.
			{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_=}
@cindex v_=
@item @{Visual@}=
ビジュアル選択されたテキストを =@{motion@} と同様にフィルタ処理する。

@{Vi にはない@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
						*tempfile* *setuid*
Vim uses temporary files for filtering, generating diffs and also for
tempname().  For Unix, the file will be in a private directory (only
accessible by the current user) to avoid security problems (e.g., a symlink
attack or other people reading your file).  When Vim exits the directory and
all files in it are deleted.  When Vim has the setuid bit set this may cause
problems, the temp file is owned by the setuid user but the filter command
probably runs as the original user.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tempfile}
@anchor{setuid}
@cindex tempfile
@cindex setuid
フィルタリング、diff の生成、tempname() などを行うときには、一時ファイルが作成される。Unix ではこのファイルはプライベートな (自分だけがアクセスできる) ディレクトリに置かれる。セキュリティ上の問題 (symlink attack や他の人があなたのファイルを読むなど) を避けるためである。

Vim が終了するとき、そのディレクトリと中にあるファイルは自動的に削除される。Vim に setuid ビットが立っているとこれが問題を引き起こすことがある。一時ファイルは setuid されたユーザーが所有するのに対し、フィルタコマンドは元のユーザーとして動作するためである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
On MS-DOS and OS/2 the first of these directories that works is used: $TMP,
$TEMP, c:\TMP, c:\TEMP.
For Unix the list of directories is: $TMPDIR, /tmp, current-dir, $HOME.
For MS-Windows the GetTempFileName() system function is used.
For other systems the tmpnam() library function is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
MS-DOS と OS/2 では、以下のディレクトリのうち最初に利用可能なものが使われる: $TMP, $TEMP, c:\TMP, c:\TEMP。

Unix におけるディレクトリのリストは: $TMPDIR, /tmp, current-dir, $HOME。

MS-Windows ではシステム関数 GetTempFileName() が使われる。

他のシステムではライブラリ関数 tmpnam() が使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------



@ifset EN
4.2 Substitute						*:substitute*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:substitute}
@cindex :substitute
@unnumberedsubsec 4.2 置換
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:s* *:su*
:[range]s[ubstitute]/{pattern}/{string}/[flags] [count]
			For each line in [range] replace a match of {pattern}
			with {string}.
			For the {pattern} see |pattern|.
			{string} can be a literal string, or something
			special; see |sub-replace-special|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:s}
@anchor{:su}
@cindex :s
@cindex :su
@table @asis
@item :[range]s[ubstitute]/@{pattern@}/@{string@}/[flags] [count]
[range] の各行で @{pattern@} のマッチを @{string@} に置き換える。@{pattern@} については |pattern| を参照すること。@{string@} は普通の文字列でもよいし、特別な指定方法を使ってもよい。|sub-replace-special| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*E939*
			When [range] and [count] are omitted, replace in the
			current line only.  When [count] is given, replace in
			[count] lines, starting with the last line in [range].
			When [range] is omitted start in the current line.
			[count] must be a positive number.  Also see
			|cmdline-ranges|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E939}
@cindex E939
[range] と [count] が指定されないと、現在行内でのみ置換を行う。[count] が指定されると、[range] の最終行から数えて[count] 行で置換を行う。[range] が指定されないと、現在行から開始する。[count] は正の数でなければならない。|cmdline-ranges| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			See |:s_flags| for [flags].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
フラグについては |:s_flags| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]s[ubstitute] [flags] [count]
:[range]&[&][flags] [count]					*:&*
			Repeat last :substitute with same search pattern and
			substitute string, but without the same flags.  You
			may add [flags], see |:s_flags|.
			Note that after `:substitute` the '&' flag can't be
			used, it's recognized as a pattern separator.
			The space between `:substitute` and the 'c', 'g',
			'i', 'I' and 'r' flags isn't required, but in scripts
			it's a good idea to keep it to avoid confusion.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:&}
@cindex :&
@item :[range]s[ubstitute] [flags] [count] or :[range]&[&][flags] [count]
最後の置換を同じパターンかつ同じ置換文字列で、フラグをつけずに繰り返す。フラグを追加することもできる (|:s_flags| を参照)。
@quotation
@strong{Note:} @*
`@command{:substitute}` の後ではフラグ '&' は使えないことに注意。パターンの区切り文字だと認識されてしまう。`@command{:substitute}` とフラグ 'c', 'g', 'i', 'I', 'r' の間の空白は必要不可欠ではない。しかしスクリプト内では、混乱しないように空白を入れておくのはよい考えである。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]~[&][flags] [count]					*:~*
			Repeat last substitute with same substitute string
			but with last used search pattern.  This is like
			`:&r`.  See |:s_flags| for [flags].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:~}
@cindex :~
@item :[range]~[&][flags] [count]
最後の置換を同じ置換文字列で、最後の検索パターン @{訳注: "/" で使ったもの@} に対して繰り返す。`@command{:&r}` に似ている。フラグについては |:s_flags| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
								*&*
&			Synonym for `:s` (repeat last substitute).  Note
			that the flags are not remembered, thus it might
			actually work differently.  You can use `:&&` to keep
			the flags.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{&}
@cindex &
@item &
`@command{:s}` と同義 (最後の置換を繰り返す)。
@quotation
@strong{Note:} @*
同じフラグが使われるわけではないので注意。実際の動作は違うかもしれない。フラグも同じにするには `@command{:&&}` を使うこと。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
								*g&*
g&			Synonym for `:%s//~/&` (repeat last substitute with
			last search pattern on all lines with the same flags).
			For example, when you first do a substitution with
			`:s/pattern/repl/flags` and then `/search` for
			something else, `g&` will do `:%s/search/repl/flags`.
			Mnemonic: global substitute. {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g&}
@cindex g&
@item g&
`@command{:%s//~/&}` と同義 (全ての行に対し、最後の検索パターンで、同じフラグで最後の置換を繰り返す)。例えば、`@command{:s/pattern/repl/flags}` と置換を実行し、次に `@command{/search}` と検索を実行すると、`@command{g&}` は `@command{:%s/search/repl/flags}` を実行する。

覚え方: 「グローバル (global --全体的な) 置換」

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:snomagic* *:sno*
:[range]sno[magic] ...	Same as `:substitute`, but always use 'nomagic'.
			{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:snomagic}
@anchor{:sno}
@cindex :snomagic
@cindex :sno
@item :[range]sno[magic] ...
`@command{:substitute}` と同じだが、常に '@option{nomagic}' を使う。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:smagic* *:sm*
:[range]sm[agic] ...	Same as `:substitute`, but always use 'magic'.
			{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:smagic}
@anchor{:sm}
@cindex :smagic
@cindex :sm
@item :[range]sm[agic] ...
`@command{:substitute}` と同じだが、常に '@option{magic}' を使う。

@{Vi にはない@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:s_flags*
The flags that you can use for the substitute commands:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:s_flags}
@cindex :s_flags
@unnumberedsubsubsec 置換コマンドで使えるフラグ:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:&&*
[&]	Must be the first one: Keep the flags from the previous substitute
	command.  Examples: >
		:&&
		:s/this/that/&
<	Note that `:s` and `:&` don't keep the flags.
	{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:&&}
@cindex :&&
@table @asis
@item [&]
先頭に指定しなければならない。前回の置換コマンドと同じフラグを使う。例:
@example
:&&
:s/this/that/&
@end example
@quotation
@strong{Note:} @*
コマンド `:s` と `:&` では、前回と同じフラグは使われない。
@end quotation
@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
[c]	Confirm each substitution.  Vim highlights the matching string (with
	|hl-IncSearch|).  You can type:				*:s_c*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:s_c}
@cindex :s_c
@item [c]
置換前に毎回確認する。マッチしている文字列を (強調表示グループ |hl-IncSearch| で) 強調表示する。確認を求められたら、ユーザーは以下のように応答する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	    'y'	    to substitute this match
	    'l'	    to substitute this match and then quit ("last")
	    'n'	    to skip this match
	    <Esc>   to quit substituting
	    'a'	    to substitute this and all remaining matches {not in Vi}
	    'q'	    to quit substituting {not in Vi}
	    CTRL-E  to scroll the screen up {not in Vi, not available when
			compiled without the |+insert_expand| feature}
	    CTRL-Y  to scroll the screen down {not in Vi, not available when
			compiled without the |+insert_expand| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item 'y' @tab そのマッチを置換する ("yes")
@item 'l' @tab そのマッチを置換し、置換を終了する ("last")
@item 'n' @tab そのマッチを置換せず、次に移る ("no")
@item <Esc> @tab 置換を終了する
@item 'a' @tab そのマッチと、以降の全てのマッチを置換する @{Vi にはない@}
@item 'q' @tab 置換を終了する @{Vi にはない@}
@item CTRL-E @tab 画面を上にスクロールする @{Vi にはない。Vim が |+insert_expand| 機能付きでコンパイルされたときのみ有効@}
@item CTRL-Y @tab 画面を下にスクロールする @{Vi にはない。Vim が |+insert_expand| 機能付きでコンパイルされたときのみ有効@}
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	If the 'edcompatible' option is on, Vim remembers the [c] flag and
	toggles it each time you use it, but resets it when you give a new
	search pattern.
	{not in Vi: highlighting of the match, other responses than 'y' or 'n'}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{edcompatible}' がオンのとき、Vim はフラグ [c] を記憶し、それが指定される度にオン／オフを切り替えるが、新しい検索パターンが使われるとリセットする。

@{Vi にはないもの: マッチの強調表示、'y' と 'n' 以外の応答@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
[e]     When the search pattern fails, do not issue an error message and, in
	particular, continue in maps as if no error occurred.  This is most
	useful to prevent the "No match" error from breaking a mapping.  Vim
	does not suppress the following error messages, however:
		Regular expressions can't be delimited by letters
		\ should be followed by /, ? or &
		No previous substitute regular expression
		Trailing characters
		Interrupted
	{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item [e]
検索パターンが何もマッチしなかったとき、エラーメッセージを表示しない。特にマッピング内ではエラーが発生しなかったかのように続行される。これは「パターンは見つかりませんでした」のエラーによるマッピングの中断を防ぐのに使える。しかし以下のエラーの発生は抑制されない。
@display
「正規表現は文字で区切ることができません」
「\\ の後は / か ? か & でなければなりません」
「正規表現置換がまだ実行されていません」
「余分な文字が後ろにあります」
「(割込まれました)」
@end display
@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
[g]	Replace all occurrences in the line.  Without this argument,
	replacement occurs only for the first occurrence in each line.  If
	the 'edcompatible' option is on, Vim remembers this flag and toggles
	it each time you use it, but resets it when you give a new search
	pattern.  If the 'gdefault' option is on, this flag is on by default
	and the [g] argument switches it off.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item [g]
行中の全てのマッチを置換する。このフラグなしだと、各行の 1 個目のマッチのみが置換される。オプション '@option{edcompatible}' がオンのとき、Vim はこのフラグを記憶し、指定される度にオン／オフを切り替えるが、新しい検索パターンが使われるとリセットする。'@option{gdefault}' がオンのときは、このフラグはオンが既定値になり、フラグ [g] を指定したときにはオフになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
[i]	Ignore case for the pattern.  The 'ignorecase' and 'smartcase' options
	are not used.
	{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item [i]
パターンの大文字／小文字の区別をしない。オプション '@option{ignorecase}' と '@option{smartcase}' は使われない。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
[I]	Don't ignore case for the pattern.  The 'ignorecase' and 'smartcase'
	options are not used.
	{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item [I]
パターンの大文字／小文字を区別する。オプション '@option{ignorecase}' と '@option{smartcase}' は使われない。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
[n]	Report the number of matches, do not actually substitute.  The [c]
	flag is ignored.  The matches are reported as if 'report' is zero.
	Useful to |count-items|.
	If \= |sub-replace-expression| is used, the expression will be
	evaluated in the |sandbox| at every match.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item [n]
マッチの個数を表示し、実際には置換を行わない。フラグ [c] は無視される。'@option{report}' が 0 のときと同じようにマッチが表示される。何個あるか調べるときに便利。|count-items|

\= |sub-replace-expression| が使われたときは、式はそれぞれのマッチに対してサンドボックス (|sandbox|) で実行される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
[p]	Print the line containing the last substitute.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item [p]
最後に置換を行った行を表示する。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
[#]	Like [p] and prepend the line number.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item [#]
[p] と同様。行番号をつける。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
[l]	Like [p] but print the text like |:list|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item [l]
[p] と同様だが、|:list| のように表示する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
[r]	Only useful in combination with `:&` or `:s` without arguments.  `:&r`
	works the same way as `:~`:  When the search pattern is empty, use the
	previously used search pattern instead of the search pattern from the
	last substitute or `:global`.  If the last command that did a search
	was a substitute or `:global`, there is no effect.  If the last
	command was a search command such as "/", use the pattern from that
	command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item [r]
引数のない `:&` か `:s` との連携でのみ有効。`:&r` は `:~` と同様に動作する。検索パターンが空のとき、最後の置換コマンドや `:global` でのパターンではなく、最後の検索パターンを使用する。最後に検索パターンを使用したコマンドが置換や `:global` だったときは、何もしない。最後のコマンドが "/" のような検索コマンドだったときは、そのコマンドの検索パターンを使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	For `:s` with an argument this already happens: >
		:s/blue/red/
		/green
		:s//red/   or  :~   or  :&r
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数付きの `:s` では、すでにそう動作するようになっていた。
@verbatim
:s/blue/red/
/green
:s//red/  または  :~  または  :&r
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	The last commands will replace "green" with "red". >
		:s/blue/red/
		/green
		:&
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最後のコマンドは "green" を "red" に置き換える。
@verbatim
:s/blue/red/
/green
:&
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	The last command will replace "blue" with "red".
	{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最後のコマンドは "blue" を "red" に置き換える。

@{Vi にはない@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that there is no flag to change the "magicness" of the pattern.  A
different command is used instead, or you can use |/\v| and friends.  The
reason is that the flags can only be found by skipping the pattern, and in
order to skip the pattern the "magicness" must be known.  Catch 22!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
パターンに '@option{magic}' が適用されるかどうかを変更するフラグはないことに注意。代わりに違うコマンド @{訳注: |:snomagic|@} または |/\v| などを使う。これは、パターン解釈を飛ばすことでのみフラグを認識できるが、その一方でパターン解釈を飛ばすには '@option{magic}' の適用状態が知られている必要があるためである。Catch 22! @{訳注: どうにもならないという意味@}
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the {pattern} for the substitute command is empty, the command uses the
pattern from the last substitute or `:global` command.  If there is none, but
there is a previous search pattern, that one is used.  With the [r] flag, the
command uses the pattern from the last substitute, `:global`, or search
command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
置換コマンドで @{pattern@} が空のときは、最後に使われた置換コマンドまたはコマンド `:global` のパターンが使われる。それが無い場合は、直前の検索パターンがあればそれが使われる。フラグ [r] を指定すると、最後の置換、`:global`、または検索コマンドのパターンが使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the {string} is omitted the substitute is done as if it's empty.  Thus the
matched pattern is deleted.  The separator after {pattern} can also be left
out then.  Example: >
	:%s/TESTING
This deletes "TESTING" from all lines, but only one per line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{string@} を省略した場合は、空文字列を指定したのと同じ結果になる。すなわち、マッチしたパターンが削除される。@{pattern@} の後のセパレータも省略することができる。例:
@example
:%s/TESTING
@end example
これは、全行から "TESTING" を削除する例である。ただし、1 つの行に 2 個以上あっても 1 個しか削除されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For compatibility with Vi these two exceptions are allowed:
"\/{string}/" and "\?{string}?" do the same as "//{string}/r".
"\&{string}&" does the same as "//{string}/".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vi との互換性のため、これら 2 つの例外が許される。
@itemize @bullet
@item "\/@{string@}/" と "\?@{string@}?" は "//@{string@}/r" と同様の効果。
@item "\&@{string@}&" は "//@{string@}/" と同様の効果。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*E146*
Instead of the '/' which surrounds the pattern and replacement string, you
can use any other single-byte character, but not an alphanumeric character,
'\', '"' or '|'.  This is useful if you want to include a '/' in the search
pattern or replacement string.  Example: >
	:s+/+//+
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E146}
@cindex E146
'/' でパターンと置換文字列を囲む代わりに、英数字や '\', '"', '|' 以外であれば、他の 1 バイト文字を使うことができる。これは検索パターンや置換文字列に '/' を含む場合に有益である。例
@example
:s+/+//+
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For the definition of a pattern, see |pattern|.  In Visual block mode, use
|/\%V| in the pattern to have the substitute work in the block only.
Otherwise it works on whole lines anyway.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
パターンの定義については |pattern| を参照。矩形ビジュアルモードで、置換をその領域内だけで行いたい場合は、パターンに |/\%V| を含める。これを使わない場合は、置換は常に行全体に対して行われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*sub-replace-special* *:s\=*
When the {string} starts with "\=" it is evaluated as an expression, see
|sub-replace-expression|.  You can use that for complex replacement or special
characters.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sub-replace-special}
@anchor{:s\=}
@cindex sub-replace-special
@cindex :s\=
@{string@} が "\=" で始まるときは、それは式として評価される。|sub-replace-expression| を参照のこと。複雑な置換や特殊な文字を使うことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Otherwise these characters in {string} have a special meaning:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
そうでなければ、@{string@} の中のこれらの文字は特別な意味を持つ:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
								*:s%*
When {string} is equal to "%" and '/' is included with the 'cpoptions' option,
then the {string} of the previous substitute command is used, see |cpo-/|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:s%}
@cindex :s%
'@option{cpoptions}' に '@var{/}' が含まれている場合、@{string@} が "%" に等しいならば前の置換コマンドの @{string@} が使われる。|cpo-/| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
magic	nomagic	  action    ~
  &	  \&	  replaced with the whole matched pattern	     *s/\&*
 \&	   &	  replaced with &
      \0	  replaced with the whole matched pattern	   *\0* *s/\0*
      \1	  replaced with the matched pattern in the first
		  pair of ()					     *s/\1*
      \2	  replaced with the matched pattern in the second
		  pair of ()					     *s/\2*
      ..	  ..						     *s/\3*
      \9	  replaced with the matched pattern in the ninth
		  pair of ()					     *s/\9*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .10 .08 .12 .70
@item magic @tab @tab nomagic @tab 作用
@anchor{s/\&}
@cindex s/\&
@item & @tab @tab \& @tab マッチしたパターン全体に置き換わる
@item \& @tab @tab & @tab '&' に置き換わる
@anchor{\0}
@anchor{s/\0}
@cindex \0
@cindex s/\0
@item @tab \0 @tab @tab マッチしたパターン全体に置き換わる
@anchor{s/\1}
@cindex s/\1
@item @tab \1 @tab @tab 1 番目の () 内のマッチしたパターンに置き換わる
@anchor{s/\2}
@cindex s/\2
@item @tab \2 @tab @tab 2 番目の () 内のマッチしたパターンに置き換わる
@anchor{s/\3}
@cindex s/\3
@item @tab .. @tab @tab ..
@anchor{s/\9}
@cindex s/\9
@item @tab \9 @tab @tab 9 番目の () 内のマッチしたパターンに置き換わる
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
  ~	  \~	  replaced with the {string} of the previous
		  substitute					     *s~*
 \~	   ~	  replaced with ~				     *s/\~*
      \u	  next character made uppercase			     *s/\u*
      \U	  following characters made uppercase, until \E      *s/\U*
      \l	  next character made lowercase			     *s/\l*
      \L	  following characters made lowercase, until \E      *s/\L*
      \e	  end of \u, \U, \l and \L (NOTE: not <Esc>!)	     *s/\e*
      \E	  end of \u, \U, \l and \L			     *s/\E*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{s~}
@cindex s~
@item ~ @tab @tab \~ @tab 前回の置換の @{string@} に置き換わる
@anchor{s/\~}
@cindex s/\~
@item \~ @tab @tab ~ @tab '~' に置き換わる
@anchor{s/\u}
@cindex s/\u
@item @tab \u @tab @tab 次の文字が大文字になる
@anchor{s/\U}
@cindex s/\U
@item @tab \U @tab @tab 後に続く文字が (\E まで) 大文字になる
@anchor{s/\l}
@cindex s/\l
@item @tab \l @tab @tab 次の文字が小文字になる
@anchor{s/\L}
@cindex s/\L
@item @tab \L @tab @tab 後に続く文字が (\E まで) 小文字になる
@anchor{s/\e}
@cindex s/\e
@item @tab \e @tab @tab \u, \U, \l, \L の終わり (NOTE: <Esc> の意味ではない！)
@anchor{s/\E}
@cindex s/\E
@item @tab \E @tab @tab \u, \U, \l, \L の終わり
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
      <CR>	  split line in two at this point
		  (Type the <CR> as CTRL-V <Enter>)		     *s<CR>*
      \r	  idem						     *s/\r*
      \<CR>	  insert a carriage-return (CTRL-M)
		  (Type the <CR> as CTRL-V <Enter>)		     *s/\<CR>*
      \n	  insert a <NL> (<NUL> in the file)
		  (does NOT break the line)			     *s/\n*
      \b	  insert a <BS>					     *s/\b*
      \t	  insert a <Tab>				     *s/\t*
      \\	  insert a single backslash			     *s/\\*
      \x	  where x is any character not mentioned above:
		  Reserved for future expansion
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{s<CR>}
@cindex s<CR>
@item @tab <CR> @tab @tab ここで行を2つに分ける (<CR> は CTRL-V <Enter> と入力する)
@anchor{s/\r}
@cindex s/\r
@item @tab \r @tab @tab 同上
@anchor{s/\<CR>}
@cindex s/\<CR>
@item @tab \<CR> @tab @tab キャリッジリターン (CTRL-M) の挿入 (<CR> は CTRL-V <Enter> と入力する)
@anchor{s/\n}
@cindex s/\n
@item @tab \n @tab @tab <NL> (ファイル内では <NUL>) の挿入 (改行を「起こさない」)
@anchor{s/\b}
@cindex s/\b
@item @tab \b @tab @tab <BS> の挿入
@anchor{s/\t}
@cindex s/\t
@item @tab \t @tab @tab <Tab> の挿入
@anchor{s/\\}
@cindex s/\\
@item @tab \\ @tab @tab '\' の挿入
@item @tab \x @tab @tab ('x' は上で説明されていない文字) 将来の拡張用に予約済み
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The special meaning is also used inside the third argument {sub} of
the |substitute()| function with the following exceptions:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
特別な意味は |substitute()| の 第 3 引数 @{sub@} でも使えるがいくつか例外がある:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
  - A % inserts a percent literally without regard to 'cpoptions'.
  - magic is always set without regard to 'magic'.
  - A ~ inserts a tilde literally.
  - <CR> and \r inserts a carriage-return (CTRL-M).
  - \<CR> does not have a special meaning. it's just one of \x.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize @minus
@item % は '@option{cpoptions}' に関係なくパーセント文字を挿入する。
@item '@option{magic}' に関係なく magic は常にオンである。
@item ~ はチルダをそのまま挿入する。
@item <CR> と \r はキャリッジリターン (CTRL-M) を挿入する。
@item \<CR> は特別な意味を持たない。単に \x の一種として扱われる。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples: >
  :s/a\|b/xxx\0xxx/g		 modifies "a b"	     to "xxxaxxx xxxbxxx"
  :s/\([abc]\)\([efg]\)/\2\1/g	 modifies "af fa bg" to "fa fa gb"
  :s/abcde/abc^Mde/		 modifies "abcde"    to "abc", "de" (two lines)
  :s/$/\^M/			 modifies "abcde"    to "abcde^M"
  :s/\w\+/\u\0/g		 modifies "bla bla"  to "Bla Bla"
  :s/\w\+/\L\u\0/g		 modifies "BLA bla"  to "Bla Bla"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@verbatim
:s/a\|b/xxx\0xxx/g             "a b"      を "xxxaxxx xxxbxxx" に置換
:s/\([abc]\)\([efg]\)/\2\1/g   "af fa bg" を "fa fa gb"        に置換
:s/abcde/abc^Mde/              "abcde"    を "abc", "de" (2行) に置換
:s/$/^V^M/                     "abcde"    を "abcde^M"         に置換
:s/\w\+/\u\0/g                 "bla bla"  を "Bla Bla"         に置換
:s/\w\+/\L\u\0/g               "BLA bla"  を "Bla Bla"         に置換
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: "\L\u" can be used to capitalize the first letter of a word.  This is
not compatible with Vi and older versions of Vim, where the "\u" would cancel
out the "\L". Same for "\U\l".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"\L\u" を使うと単語の最初の文字をキャピタライズできる。これは Vi や古い Vim とは互換性がない。それらの古い環境では "\u" は "\L" をキャンセルする。"\U\l" も同様。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: In previous versions CTRL-V was handled in a special way.  Since this is
not Vi compatible, this was removed.  Use a backslash instead.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
以前のバージョンでは @kbd{CTRL-V} が特別に扱われていた。これは Vi 互換ではないので変更された。代わりに '\' を使うこと。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
command		text	result ~
:s/aa/a^Ma/	aa	a<line-break>a
:s/aa/a\^Ma/	aa	a^Ma
:s/aa/a\\^Ma/	aa	a\<line-break>a
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .33 .33 .33
@item コマンド @tab テキスト @tab 置換結果
@item :s/aa/a^Ma/ @tab aa @tab a<line-break>a
@item :s/aa/a\^Ma/ @tab aa @tab a^Ma
@item :s/aa/a\\^Ma/ @tab aa @tab a\<line-break>a
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
(you need to type CTRL-V <CR> to get a ^M here)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
(ここで ^M を使うには CTRL-V <CR> と打ち込むこと)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The numbering of "\1", "\2" etc. is done based on which "\(" comes first in
the pattern (going left to right).  When a parentheses group matches several
times, the last one will be used for "\1", "\2", etc.  Example: >
  :s/\(\(a[a-d] \)*\)/\2/      modifies "aa ab x" to "ab x"
The "\2" is for "\(a[a-d] \)".  At first it matches "aa ", secondly "ab ".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"\1", "\2" などの番号付けは、パターン内でどの "\(" が最初に来るかによって決まる (左から右の順)。括弧でくくられたグループが複数回マッチするときは、最後のものが "\1", "\2" 等に使われる。例:
@verbatim
:s/\(\(a[a-d] \)*\)/\2/      "aa ab x" を "ab x" に置換
@end verbatim
"\2" は、"\(a[a-d] \)" を参照する。このパターンはまず "aa " にマッチし、次に "ab " にマッチする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When using parentheses in combination with '|', like in \([ab]\)\|\([cd]\),
either the first or second pattern in parentheses did not match, so either
\1 or \2 is empty.  Example: >
  :s/\([ab]\)\|\([cd]\)/\1x/g   modifies "a b c d"  to "ax bx x x"
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
\([ab]\)\|\([cd]\) のように括弧を '|' と連携して使っているとき、1 番目か 2 番目のどちらかの括弧内のパターンにはマッチしない、すなわち、\1 か \2 のどちらかは空になる。例:
@verbatim
:s/\([ab]\)\|\([cd]\)/\1x/g   "a b c d" を "ax bx x x" に置換
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		*:sc* *:sce* *:scg* *:sci* *:scI* *:scl* *:scp* *:sg* *:sgc*
		*:sge* *:sgi* *:sgI* *:sgl* *:sgn* *:sgp* *:sgr* *:sI* *:si*
		*:sic* *:sIc* *:sie* *:sIe* *:sIg* *:sIl* *:sin* *:sIn* *:sIp*
		*:sip* *:sIr* *:sir* *:sr* *:src* *:srg* *:sri* *:srI* *:srl*
		*:srn* *:srp*
2-letter and 3-letter :substitute commands ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:sc}
@anchor{:sce}
@anchor{:scg}
@anchor{:sci}
@anchor{:scI}
@anchor{:scl}
@anchor{:scp}
@anchor{:sg}
@anchor{:sgc}
@anchor{:sge}
@anchor{:sgi}
@anchor{:sgI}
@anchor{:sgl}
@anchor{:sgn}
@anchor{:sgp}
@anchor{:sgr}
@anchor{:sI}
@anchor{:si}
@anchor{:sic}
@anchor{:sIc}
@anchor{:sie}
@anchor{:sIe}
@anchor{:sIg}
@anchor{:sIl}
@anchor{:sin}
@anchor{:sIn}
@anchor{:sIp}
@anchor{:sip}
@anchor{:sIr}
@anchor{:sir}
@anchor{:sr}
@anchor{:src}
@anchor{:srg}
@anchor{:sri}
@anchor{:srI}
@anchor{:srl}
@anchor{:srn}
@anchor{:srp}
@cindex :sc
@cindex :sce
@cindex :scg
@cindex :sci
@cindex :scI
@cindex :scl
@cindex :scp
@cindex :sg
@cindex :sgc
@cindex :sge
@cindex :sgi
@cindex :sgI
@cindex :sgl
@cindex :sgn
@cindex :sgp
@cindex :sgr
@cindex :sI
@cindex :si
@cindex :sic
@cindex :sIc
@cindex :sie
@cindex :sIe
@cindex :sIg
@cindex :sIl
@cindex :sin
@cindex :sIn
@cindex :sIp
@cindex :sip
@cindex :sIr
@cindex :sir
@cindex :sr
@cindex :src
@cindex :srg
@cindex :sri
@cindex :srI
@cindex :srl
@cindex :srn
@cindex :srp
@unnumberedsubsubsec 2 文字もしくは 3 文字の :substitute コマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
     List of :substitute commands
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
:substitute コマンド一覧
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
     |      c    e    g    i    I    n    p    l    r
     | c  :sc  :sce :scg :sci :scI :scn :scp :scl  ---
     | e
     | g  :sgc :sge :sg  :sgi :sgI :sgn :sgp :sgl :sgr
     | i  :sic :sie  --- :si  :siI :sin :sip  --- :sir
     | I  :sIc :sIe :sIg :sIi :sI  :sIn :sIp :sIl :sIr
     | n
     | p
     | l
     | r  :src  --- :srg :sri :srI :srn :srp :srl :sr
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
|      c    e    g    i    I    n    p    l    r
| c  :sc  :sce :scg :sci :scI :scn :scp :scl  ---
| e
| g  :sgc :sge :sg  :sgi :sgI :sgn :sgp :sgl :sgr
| i  :sic :sie  --- :si  :siI :sin :sip  --- :sir
| I  :sIc :sIe :sIg :sIi :sI  :sIn :sIp :sIl :sIr
| n
| p
| l
| r  :src  --- :srg :sri :srI :srn :srp :srl :sr
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Exceptions:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例外:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
     :scr  is  `:scriptnames`
     :se   is  `:set`
     :sig  is  `:sign`
     :sil  is  `:silent`
     :sn   is  `:snext`
     :sp   is  `:split`
     :sl   is  `:sleep`
     :sre  is  `:srewind`
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:scr  is  `:scriptnames`
:se   is  `:set`
:sig  is  `:sign`
:sil  is  `:silent`
:sn   is  `:snext`
:sp   is  `:split`
:sl   is  `:sleep`
:sre  is  `:srewind`
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Substitute with an expression			*sub-replace-expression*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sub-replace-expression}
@cindex sub-replace-expression
@unnumberedsubsubsec 式で置換する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*sub-replace-\=* *s/\=*
When the substitute string starts with "\=" the remainder is interpreted as an
expression.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sub-replace-\=}
@anchor{s/\=}
@cindex sub-replace-\=
@cindex s/\=
置換文字列が "\=" で始まるとき、それ以降の文字列は式として解釈される。これは再帰的に機能しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The special meaning for characters as mentioned at |sub-replace-special| does
not apply except for "<CR>".  A <NL> character is used as a line break, you
can get one with a double-quote string: "\n".  Prepend a backslash to get a
real <NL> character (which will be a NUL in the file).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"<CR>" 以外の文字の特別な意味 |sub-replace-special| は無効になる。<NL> 文字は改行として使われるのでダブルクォート文字列 "\n" で改行を入れることができる。実際の <NL> 文字 (ファイルにおける NUL 文字) を挿入するにはバックスラッシュを前置する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "\=" notation can also be used inside the third argument {sub} of
|substitute()| function.  In this case, the special meaning for characters as
mentioned at |sub-replace-special| does not apply at all. Especially, <CR> and
<NL> are interpreted not as a line break but as a carriage-return and a
new-line respectively.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"\=" 表記は |substitute()| 関数の第 3 引数 @{sub@} でも使うことができる。その場合、|sub-replace-special| で説明されている文字は特別な意味を持たなくなる。特に、<CR> と <NL> は改行として解釈されるのではなく、そのままキャリッジリターンとニューラインとして解釈される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the result is a |List| then the items are joined with separating line
breaks.  Thus each item becomes a line, except that they can contain line
breaks themselves.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
結果が |List| のときはその要素が改行を区切りとして連結される。よって要素がそれぞれ行となる。ただし要素が改行を含んでいる場合は除く。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The whole matched text can be accessed with "submatch(0)".  The text matched
with the first pair of () with "submatch(1)".  Likewise for further
sub-matches in ().
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マッチしたテキストの全体は "submatch(0)" で参照できる。1 番目の () 内でマッチしたテキストは "submatch(1)" で参照できる。以降の () 内でマッチしたテキストも同様に参照できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Be careful: The separation character must not appear in the expression!
Consider using a character like "@" or ":".  There is no problem if the result
of the expression contains the separation character.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
注意: 正規表現の区切り文字が expression 内に現れてはいけない！区切りには "@@" や ":" を使うよう検討すること。Expression の結果に区切り文字が現れても問題はない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples: >
	:s@\n@\="\r" . expand("$HOME") . "\r"@
This replaces an end-of-line with a new line containing the value of $HOME. >

	s/E/\="\<Char-0x20ac>"/g
This replaces each 'E' character with a euro sign.  Read more in |<Char->|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@verbatim
:s@\n@\="\r" . expand("$HOME") . "\r"@
@end verbatim
こうすると置換を行った行の下に、環境変数 $HOME の値を含む新しい行が挿入される。
@verbatim
s/E/\="\<Char-0x20ac>"/g
@end verbatim
これは文字 'E' をユーロ記号で置換する。詳しくは |<Char->| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
4.3 Search and replace					*search-replace*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{search-replace}
@cindex search-replace
@unnumberedsubsec 4.3 検索と置換
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:pro* *:promptfind*
:promptf[ind] [string]
			Put up a Search dialog.  When [string] is given, it is
			used as the initial search string.
			{only for Win32, Motif and GTK GUI}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:pro}
@anchor{:promptfind}
@cindex :pro
@cindex :promptfind
@table @asis
@item :promptf[ind] [string]
検索ダイアログを表示する。 [string] が与えられると、それが初期検索文字列になる。

@{Vim の Win32 版、Motif 版、GTK の GUI 版のみ@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:promptr* *:promptrepl*
:promptr[epl] [string]
			Put up a Search/Replace dialog.  When [string] is
			given, it is used as the initial search string.
			{only for Win32, Motif and GTK GUI}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:promptr}
@anchor{:promptrepl}
@cindex :promptr
@cindex :promptrepl
@item :promptr[epl] [string]
検索／置換ダイアログを表示する。 [string] が与えられると、それが初期検索文字列になる。

@{Vim の Win32 版、Motif 版、GTK の GUI 版のみ@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
4.4 Changing tabs					*change-tabs*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{change-tabs}
@cindex change-tabs
@unnumberedsubsec 4.4 タブの変換
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:ret* *:retab* *:retab!*
:[range]ret[ab][!] [new_tabstop]
			Replace all sequences of white-space containing a
			<Tab> with new strings of white-space using the new
			tabstop value given.  If you do not specify a new
			tabstop size or it is zero, Vim uses the current value
			of 'tabstop'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:ret}
@anchor{:retab}
@anchor{:retab!}
@cindex :ret
@cindex :retab
@cindex :retab!
@table @asis
@item :[range]ret[ab][!] [new_tabstop]
新たに指定されたタブストップ (タブ幅) に基づき、<Tab> を含む空白の連続を全て、新しい空白と <Tab> の列に置き換える。新たなタブストップの指定がないか0が指定されたときは、Vim はオプション '@option{tabstop}' の現在の値を使用する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			The current value of 'tabstop' is always used to
			compute the width of existing tabs.
			With !, Vim also replaces strings of only normal
			spaces with tabs where appropriate.
			With 'expandtab' on, Vim replaces all tabs with the
			appropriate number of spaces.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{tabstop}' の現在の値は、既存のタブの幅を計るために常に使用される。'!' を付けると、Vim は通常の空白のみの列も、適切なタブに置き換える。'@option{expandtab}' がオンのとき、Vim は全てのタブを適切な数の空白に置き換える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			This command sets 'tabstop' to the new value given,
			and if performed on the whole file, which is default,
			should not make any visible change.
			Careful: This command modifies any <Tab> characters
			inside of strings in a C program.  Use "\t" to avoid
			this (that's a good habit anyway).
			`:retab!` may also change a sequence of spaces by
			<Tab> characters, which can mess up a printf().
			{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このコマンドは '@option{tabstop}' を新たに指定された値に設定する @{訳注: この事実は重要である@}。ファイル全体に適用されたときは (それが既定の動作)、ファイルの見かけに変化が起こることはないはずだ。

注意: このコマンドは C プログラム中の文字列内部にある <Tab> 文字も修正する。これを避けるためには、プログラム内では "\t" を使うとよい (そうでなくても、これはよい習慣である)。

`:retab!` も空白の連続を <Tab> 文字に変えてしまい、printf() の出力をめちゃくちゃにするかもしれない。

@{Vi にはない@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*retab-example*
Example for using autocommands and ":retab" to edit a file which is stored
with tabstops at 8 but edited with tabstops set at 4.  Warning: white space
inside of strings can change!  Also see 'softtabstop' option. >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{retab-example}
@cindex retab-example
タブストップが 8 で保存され、タブストップが 4 で編集されたファイルを編集するために autocommand と "@command{:retab}" を使う例。警告: 文字列内の空白は変わってしまうことがある！オプション '@option{softtabstop}' も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  :auto BufReadPost	*.xx	retab! 4
  :auto BufWritePre	*.xx	retab! 8
  :auto BufWritePost	*.xx	retab! 4
  :auto BufNewFile	*.xx	set ts=4
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:auto BufReadPost   *.xx    retab! 4
:auto BufWritePre   *.xx    retab! 8
:auto BufWritePost  *.xx    retab! 4
:auto BufNewFile    *.xx    set ts=4
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
5. Copying and moving text				*copy-move*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{copy-move}
@cindex copy-move
@section 5. テキストのコピーと移動
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*quote*
"{a-zA-Z0-9.%#:-"}	Use register {a-zA-Z0-9.%#:-"} for next delete, yank
			or put (use uppercase character to append with
			delete and yank) ({.%#:} only work with put).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{quote}
@cindex quote
@table @asis
@item "@{a-zA-Z0-9.%#:-"@}
続く操作 (削除、コピー、貼り付け) にレジスタ @{a-zA-Z0-9.%#:-"@} を使う (削除、コピーでは大文字を使うことでレジスタに追記できる) (@{.%#:@} は貼り付けにのみ使用可能)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:reg* *:registers*
:reg[isters]		Display the contents of all numbered and named
			registers.  If a register is written to for |:redir|
			it will not be listed.
			{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:reg}
@anchor{:registers}
@cindex :reg
@cindex :registers
@item :reg[isters]
全ての名前付きレジスタおよび番号付きレジスタの内容を表示する。レジスタが |:redir| の書き込み先になっている場合はそのレジスタは表示されない。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
:reg[isters] {arg}	Display the contents of the numbered and named
			registers that are mentioned in {arg}.  For example: >
				:reg 1a
<			to display registers '1' and 'a'.  Spaces are allowed
			in {arg}.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :reg[isters] @{arg@}
@{arg@} に指定された名前付きレジスタおよび番号付きレジスタを表示する。例:
@example
:reg 1a
@end example
レジスタ '1' と 'a' が表示される。@{arg@} の中では空白を用いてよい。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:di* *:display*
:di[splay] [arg]	Same as :registers.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:di}
@anchor{:display}
@cindex :di
@cindex :display
@item :di[splay] [arg]
:registers と同じ。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*y* *yank*
["x]y{motion}		Yank {motion} text [into register x].  When no
			characters are to be yanked (e.g., "y0" in column 1),
			this is an error when 'cpoptions' includes the 'E'
			flag.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{y}
@anchor{yank}
@cindex y
@cindex yank
@item ["x]y@{motion@}
@{motion@} のテキストを [レジスタ x に] コピーする。コピーされるテキストがないとき (例えば 1 桁目で "y0" を行う)、オプション '@option{cpoptions}' がフラグ '@var{E}' を含んでいるならエラーになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*yy*
["x]yy			Yank [count] lines [into register x] |linewise|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{yy}
@cindex yy
@item ["x]yy
[count] 行を [レジスタ x に] コピーする (行単位 |linewise|)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*Y*
["x]Y			yank [count] lines [into register x] (synonym for
			yy, |linewise|).  If you like "Y" to work from the
			cursor to the end of line (which is more logical,
			but not Vi-compatible) use ":map Y y$".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Y}
@cindex Y
@item ["x]Y
[count] 行を [レジスタ x に] コピーする ("yy" と同義、行単位 |linewise|)。"Y" でカーソル位置から行の終わりまでコピーしたいときは (この方が論理的と言えるが、Vi 互換ではない) ":map Y y$" を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_y*
{Visual}["x]y		Yank the highlighted text [into register x] (for
			{Visual} see |Visual-mode|).  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_y}
@cindex v_y
@item @{Visual@}["x]y
ビジュアル選択されたテキストを [レジスタ x に] コピーする (@{Visual@} については |Visual-mode| を参照)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_Y*
{Visual}["x]Y		Yank the highlighted lines [into register x] (for
			{Visual} see |Visual-mode|).  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_Y}
@cindex v_Y
@item @{Visual@}["x]Y
ビジュアル選択された行を [レジスタ x に] コピーする (@{Visual@} については |Visual-mode| を参照)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:y* *:yank* *E850*
:[range]y[ank] [x]	Yank [range] lines [into register x]. Yanking to the
			"* or "+ registers is possible only when the
			|+clipboard| feature is included.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:y}
@anchor{:yank}
@anchor{E850}
@cindex :y
@cindex :yank
@cindex E850
@item :[range]y[ank] [x]
[range] の行を [レジスタ x に] コピーする。"* レジスタと "+ レジスタへのコピーは |+clipboard| 機能が有効な場合のみ可能。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]y[ank] [x] {count}
			Yank {count} lines, starting with last line number
			in [range] (default: current line |cmdline-ranges|),
			[into register x].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[range]y[ank] [x] @{count@}
[range] の最後の行 (省略時は現在行 |cmdline-ranges|) から数えて @{count@} 行を [レジスタ x に] コピーする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*p* *put* *E353*
["x]p			Put the text [from register x] after the cursor
			[count] times.  {Vi: no count}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{p}
@anchor{put}
@anchor{E353}
@cindex p
@cindex put
@cindex E353
@item ["x]p
カーソルの後に、テキストを [count] 回 [レジスタ x から] 貼り付ける。

@{Vi: カウントはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*P*
["x]P			Put the text [from register x] before the cursor
			[count] times.  {Vi: no count}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{P}
@cindex P
@item ["x]P
カーソルの前に、テキストを [count] 回 [レジスタ x から] 貼り付ける。

@{Vi: カウントはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*<MiddleMouse>*
["x]<MiddleMouse>	Put the text from a register before the cursor [count]
			times.  Uses the "* register, unless another is
			specified.
			Leaves the cursor at the end of the new text.
			Using the mouse only works when 'mouse' contains 'n'
			or 'a'.
			{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{<MiddleMouse>}
@cindex <MiddleMouse>
@item ["x]<MiddleMouse>
カーソルの前に、テキストを [count] 回 [レジスタ x から] 貼り付ける。レジスタ指定がない場合は "* が使われる。カーソルは挿入したテキストの末尾に置かれる。マウスは 'mouse' が 'n' か 'a' を含むときのみ使える。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			If you have a scrollwheel and often accidentally paste
			text, you can use these mappings to disable the
			pasting with the middle mouse button: >
				:map <MiddleMouse> <Nop>
				:imap <MiddleMouse> <Nop>
<			You might want to disable the multi-click versions
			too, see |double-click|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もしあなたがスクロールホイールを持っていて意図せずにテキストを貼り付けてしまうのなら、次のマッピングでマウスの真ん中のボタンを無効化できる。
@example
:map <MiddleMouse> <Nop>
:imap <MiddleMouse> <Nop>
@end example
複数クリックも無効にしたいなら |double-click| も参照のこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*gp*
["x]gp			Just like "p", but leave the cursor just after the new
			text.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gp}
@cindex gp
@item ["x]gp
"p" と似ているが、カーソルは挿入したテキストの直後に置かれる。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*gP*
["x]gP			Just like "P", but leave the cursor just after the new
			text.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gP}
@cindex gP
@item ["x]gP
"P" と似ているが、カーソルは挿入したテキストの直後に置かれる。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:pu* *:put*
:[line]pu[t] [x]	Put the text [from register x] after [line] (default
			current line).  This always works |linewise|, thus
			this command can be used to put a yanked block as new
			lines.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:pu}
@anchor{:put}
@cindex :pu
@cindex :put
@item :[line]pu[t] [x]
[line] 行目 (省略時は現在行) の後にテキストを [レジスタ x から] コピーする。このコマンドは常に行単位 |linewise| の動作をするので、コピーされたブロックを新しい行として挿入するときに使える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			If no register is specified, it depends on the 'cb'
			option: If 'cb' contains "unnamedplus", paste from the
			+ register |quoteplus|.  Otherwise, if 'cb' contains
			"unnamed", paste from the * register |quotestar|.
			Otherwise, paste from the unnamed register
			|quote_quote|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
レジスタが指定されていないときのレジスタは '@option{cb}' オプションに依存する。'@option{cb}' が "@var{unnamedplus}" を含むときは + レジスタ |quoteplus| からペーストする。そうではなく、'@option{cb}' が "@var{unnamed}" を含むときは * レジスタ |quotestar| からペーストする。そうでなければ、無名レジスタ |quote_quote| からペーストする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			The register can also be '=' followed by an optional
			expression.  The expression continues until the end of
			the command.  You need to escape the '|' and '"'
			characters to prevent them from terminating the
			command.  Example: >
				:put ='path' . \",/test\"
<			If there is no expression after '=', Vim uses the
			previous expression.  You can see it with ":dis =".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
レジスタには '=' に続けて式を指定することもできる。コマンドの末尾までが式として評価される。文字 '|' と '"' がコマンドの末尾として解釈されないようにするには、それらをエスケープする @{訳注: 前に '\' を置く@} 必要がある。例:
@example
:put ='path' . \",/test\"
@end example
'=' の後に式がないときは前回の式が使われる。それはコマンド ":dis =" で見ることができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[line]pu[t]! [x]	Put the text [from register x] before [line] (default
			current line).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[line]pu[t]! [x]
[line] 行目 (省略時は現在行) の前にテキストを [レジスタ x から] コピーする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
["x]]p		    or					*]p* *]<MiddleMouse>*
["x]]<MiddleMouse>	Like "p", but adjust the indent to the current line.
			Using the mouse only works when 'mouse' contains 'n'
			or 'a'.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{]p}
@anchor{]<MiddleMouse>}
@cindex ]p
@cindex ]<MiddleMouse>
@item ["x]]p または ["x]]<MiddleMouse>
"p" と似ているが、現在行に合わせてインデントが調整される。マウスは、'@option{mouse}' が '@var{n}' か '@var{a}' を含むときだけ使える。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
["x][P		    or					*[P*
["x]]P		    or					*]P*
["x][p		    or					*[p* *[<MiddleMouse>*
["x][<MiddleMouse>	Like "P", but adjust the indent to the current line.
			Using the mouse only works when 'mouse' contains 'n'
			or 'a'.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{[P}
@anchor{]P}
@anchor{[p}
@anchor{[<MiddleMouse>}
@cindex [P
@cindex ]P
@cindex [p
@cindex [<MiddleMouse>
@item ["x][P または ["x]]P または ["x][p または ["x][<MiddleMouse>
"P" と似ているが、現在行に合わせてインデントが調整される。マウスは、'@option{mouse}' が '@var{n}' か '@var{a}' を含むときだけ使える。

@{Vi にはない@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use these commands to copy text from one place to another.  Do this
by first getting the text into a register with a yank, delete or change
command, then inserting the register contents with a put command.  You can
also use these commands to move text from one file to another, because Vim
preserves all registers when changing buffers (the CTRL-^ command is a quick
way to toggle between two files).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのコマンドを使って、ある場所から別の場所へテキストをコピーできる。まずコピー、削除または変更コマンドを使って、テキストをレジスタに蓄える。そしてレジスタの内容を、貼り付けコマンドで文章中に挿入する。これらのコマンドで、あるファイルから別のファイルへテキストを移動させることもできる。Vim はバッファを切り替えても、全てのレジスタの内容を保っているからである (コマンド @kbd{CTRL-^} は、2 個のバッファを素早く切り替えられる)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*linewise-register* *characterwise-register*
You can repeat the put commands with "." (except for :put) and undo them.  If
the command that was used to get the text into the register was |linewise|,
Vim inserts the text below ("p") or above ("P") the line where the cursor is.
Otherwise Vim inserts the text after ("p") or before ("P") the cursor.  With
the ":put" command, Vim always inserts the text in the next line.  You can
exchange two characters with the command sequence "xp".  You can exchange two
lines with the command sequence "ddp".  You can exchange two words with the
command sequence "deep" (start with the cursor in the blank space before the
first word).  You can use the "']" or "`]" command after the put command to
move the cursor to the end of the inserted text, or use "'[" or "`[" to move
the cursor to the start.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{linewise-register}
@anchor{characterwise-register}
@cindex linewise-register
@cindex characterwise-register
貼り付けコマンド (":put" 以外) は、"." で繰り返したり、アンドゥできる。テキストをレジスタに蓄えるのに使われたコマンドが行単位 |linewise| のものだったら、テキストはカーソルのある行の次の行 ("p" のとき) や前の行 ("P" のとき) に貼り付けられる。そうでなければ、テキストはカーソルの後 ("p" のとき) や前 ("P" のとき) に挿入される。コマンド ":put" を使ったときは、テキストは常に次の行へ挿入される。

"xp" というコマンド列で、カーソル上の文字と次の文字との入れ替えができる。現在行と次の行との入れ替えには、コマンド列 "ddp" を使う。(カーソルが単語の前の空白の上にあるとき) 次の単語とその次の単語との入れ替えには、コマンド列 "deep" を使う。貼り付けコマンドを使った後には、コマンド "']" か "`]" で挿入された行の終わりに移動でき、コマンド "'[" か "`[" で挿入された行の最初に移動できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*put-Visual-mode* *v_p* *v_P*
When using a put command like |p| or |P| in Visual mode, Vim will try to
replace the selected text with the contents of the register.  Whether this
works well depends on the type of selection and the type of the text in the
register.  With blockwise selection it also depends on the size of the block
and whether the corners are on an existing character.  (Implementation detail:
it actually works by first putting the register after the selection and then
deleting the selection.)
The previously selected text is put in the unnamed register.  If you want to
put the same text into a Visual selection several times you need to use
another register.  E.g., yank the text to copy, Visually select the text to
replace and use "0p .  You can repeat this as many times as you like, the
unnamed register will be changed each time.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{put-Visual-mode}
@anchor{v_p}
@anchor{v_P}
@cindex put-Visual-mode
@cindex v_p
@cindex v_P
ビジュアルモードで |p| や |P| 等の貼り付けコマンドを使ったとき、Vim は選択されたテキストをレジスタの中身で置き換えようとする。これがうまく動作するかどうかは、選択領域の種類とレジスタ内のテキストの種類による。矩形選択では、ブロックのサイズと、選択領域の角が既存の文字上にあるかどうかにもよる。(実装上の詳細: 実際の動作は、まずレジスタの中身を選択領域の後に貼り付け、その後で選択領域を削除するようになっている)

それまで選択されていたテキストが無名レジスタに保存される。同じテキストを複数のビジュアル選択領域にプットしたい場合は、ほかのレジスタを使う必要がある。例えば、コピーしたいテキストをヤンクして、選択したテキストを "0p で置き換える。これを好きなだけ繰り返す。このとき、無名レジスタはプットするたびに変わる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you use a blockwise Visual mode command and yank only a single line into
a register, a paste on a visual selected area will paste that single line on
each of the selected lines (thus replacing the blockwise selected region by a
block of the pasted line).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
矩形ビジュアルモードで一行のみをヤンクしたとき、それをビジュアル選択した範囲に貼り付けると、選択範囲にその一行が貼り付けされる (つまり貼り付けた行のブロックによって矩形選択範囲が置換される)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*blockwise-register*
If you use a blockwise Visual mode command to get the text into the register,
the block of text will be inserted before ("P") or after ("p") the cursor
column in the current and next lines.  Vim makes the whole block of text start
in the same column.  Thus the inserted text looks the same as when it was
yanked or deleted.  Vim may replace some <Tab> characters with spaces to make
this happen.  However, if the width of the block is not a multiple of a <Tab>
width and the text after the inserted block contains <Tab>s, that text may be
misaligned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{blockwise-register}
@cindex blockwise-register
矩形ビジュアルモードで、レジスタにテキストを蓄えるコマンドを使うと、テキストのブロックはカーソルの前 ("P" のとき) または後 ("p" のとき) から、現在行と引き続く行にわたって、挿入される。テキストのブロック全体は同じ列から始まるように挿入される。そのため挿入されたテキストはコピーや削除されたときと同じ形を保っている。

Vim は、このようにするために <Tab> を空白で置き換えることがある。しかし、テキストのブロックの幅が <Tab> の幅の整数倍でなく、さらに挿入されたブロックの後のテキストが <Tab> を含むとき、列揃えがおかしくなることがある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that after a characterwise yank command, Vim leaves the cursor on the
first yanked character that is closest to the start of the buffer.  This means
that "yl" doesn't move the cursor, but "yh" moves the cursor one character
left.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
文字単位のコピーコマンドの後、コピーされたテキストの中でバッファの先頭に一番近い文字の上にカーソルが置かれることに注意。つまり "yl" ではカーソルは動かないが、"yh" ではカーソルは 1 文字左に動く。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Rationale:	In Vi the "y" command followed by a backwards motion would
		sometimes not move the cursor to the first yanked character,
		because redisplaying was skipped.  In Vim it always moves to
		the first character, as specified by Posix.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

理論的説明:	Viでは、後方移動を伴ったコマンド "y" ではコピーされたテキストの先頭にカーソルを移動させないことがあった。これは再表示が省かれたためである。Vim では Posix に定められた通り、常に先頭の文字にカーソルを移動させる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
With a linewise yank command the cursor is put in the first line, but the
column is unmodified, thus it may not be on the first yanked character.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

行単位のコピーコマンドではカーソルは選択の最初の行に置かれるが、カラムは変更されない。なのでその位置はコピーされた最初の文字の上ではないかもしれない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are ten types of registers:			*registers* *E354*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{registers}
@anchor{E354}
@cindex registers
@cindex E354
@unnumberedsubsec レジスタには 10 種類ある:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
1. The unnamed register ""
2. 10 numbered registers "0 to "9
3. The small delete register "-
4. 26 named registers "a to "z or "A to "Z
5. three read-only registers ":, "., "%
6. alternate buffer register "#
7. the expression register "=
8. The selection and drop registers "*, "+ and "~ 
9. The black hole register "_
10. Last search pattern register "/
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item 無名レジスタ ""
@item 10 個の番号付きレジスタ "0 から "9
@item 小削除用レジスタ "-
@item 26 個の名前付きレジスタ "a から "z または "A から "Z
@item 3 個の読み取り専用レジスタ ": と ". と "%
@item 代替バッファ用レジスタ "#
@item expression 用レジスタ "=
@item 選択領域用レジスタ "* と "+ と "~ 
@item 消去専用レジスタ "_
@item 最終検索パターン用レジスタ "/
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. Unnamed register ""				*quote_quote* *quotequote*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{quote_quote}
@anchor{quotequote}
@cindex quote_quote
@cindex quotequote
@unnumberedsubsubsec 1. 無名レジスタ ""
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Vim fills this register with text deleted with the "d", "c", "s", "x" commands
or copied with the yank "y" command, regardless of whether or not a specific
register was used (e.g.  "xdd).  This is like the unnamed register is pointing
to the last used register.  Thus when appending using an uppercase register
name, the unnamed register contains the same text as the named register.
An exception is the '_' register: "_dd does not store the deleted text in any
register.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このレジスタには、コマンド "d", "c", "s", "x" 等で削除されたテキストや、"y" 等のコピーコマンドでコピーされたテキストが蓄えられる。特定のレジスタが指定されていてもいなくても関係ない (例えば "xdd でもこれが使われる)。つまり無名レジスタは最後に使われたレジスタを指していると考えられる。よって、大文字レジスタを使って名前つきレジスタにテキストを追加したときも、無名レジスタの中身は、その名前つきレジスタと同じになる。

例外はレジスタ '_' である。"_dd は、削除されたテキストをどのレジスタにも蓄えない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Vim uses the contents of the unnamed register for any put command (p or P)
which does not specify a register.  Additionally you can access it with the
name '"'.  This means you have to type two double quotes.  Writing to the ""
register writes to register "0.
{Vi: register contents are lost when changing files, no '"'}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
無名レジスタの中身は、レジスタを指定しない貼り付けコマンド (p や P) で使うことができる。加えて、このレジスタは '"' という名前で使うことができる。これは、使うときには二重引用符 '"' を 2 個打ち込むということである。レジスタ "" に対する書き込みはレジスタ "0 にも書き込むことになる。

@{Vi ではレジスタの内容はファイルを変更するときに失われ、'"' もない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
2. Numbered registers "0 to "9		*quote_number* *quote0* *quote1*
					*quote2* *quote3* *quote4* *quote9*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{quote_number}
@anchor{quote0}
@anchor{quote1}
@anchor{quote2}
@anchor{quote3}
@anchor{quote4}
@anchor{quote9}
@cindex quote_number
@cindex quote0
@cindex quote1
@cindex quote2
@cindex quote3
@cindex quote4
@cindex quote9
@unnumberedsubsubsec 2. 番号付きレジスタ "0 から "9
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Vim fills these registers with text from yank and delete commands.
   Numbered register 0 contains the text from the most recent yank command,
unless the command specified another register with ["x].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのレジスタには、コピーや削除コマンドによってテキストが蓄えられる。番号付きレジスタの 0 には、一番最近にコピーしたテキストが蓄えられるが、コピーの際に ["x] として別のレジスタ名を指定したときは、これには蓄えられない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   Numbered register 1 contains the text deleted by the most recent delete or
change command, unless the command specified another register or the text is
less than one line (the small delete register is used then).  An exception is
made for the delete operator with these movement commands: |%|, |(|, |)|, |`|,
|/|, |?|, |n|, |N|, |{| and |}|.  Register "1 is always used then (this is Vi
compatible).  The "- register is used as well if the delete is within a line.
Note that these characters may be mapped.  E.g. |%| is mapped by the matchit
plugin.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
番号付きレジスタ 1 には、一番最近に削除したり変更したテキストが蓄えられるが、コマンドに別のレジスタ名を指定したり、削除や変更したテキストが 1 行以下だったりしたときは、これには蓄えられない (そのときは小削除用レジスタが使われる)。例外は、以下の移動コマンドと削除コマンドを組み合わせたときである。|%|, |(|, |)|, |`|, |/|, |?|, |n|, |N|, |@{|, |@}|。このときは必ずレジスタ "1 が使われる (これは Vi 互換の動作である)。削除や変更したテキストが 1 行以下だったときは、レジスタ "- も使われる。
@quotation
@strong{Note:} @*
これらの文字はマップ可能である。例: |%| は matchit プラグインによってマップされている。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   With each successive deletion or change, Vim shifts the previous contents
of register 1 into register 2, 2 into 3, and so forth, losing the previous
contents of register 9.
{Vi: numbered register contents are lost when changing files; register 0 does
not exist}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
削除や変更が行われるたびに、レジスタ 1 の内容はレジスタ 2 に、レジスタ 2 の内容はレジスタ 3 に、という風にずれていく。レジスタ 9 の内容は失われる。

@{Vi では番号付きレジスタの内容はファイルを変更する際に失われる。レジスタ 0 はない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
3. Small delete register "-				*quote_-* *quote-*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{quote_-}
@anchor{quote-}
@cindex quote_-
@cindex quote-
@unnumberedsubsubsec 3. 小削除用レジスタ "-
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This register contains text from commands that delete less than one line,
except when the command specifies a register with ["x].
{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このレジスタには、範囲が 1 行以下の削除コマンドで削除されたテキストが蓄えられる。ただし、コマンドに ["x] で別のレジスタ名を指定したときはこれには蓄えられない。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
4. Named registers "a to "z or "A to "Z			*quote_alpha* *quotea*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{quote_alpha}
@anchor{quotea}
@cindex quote_alpha
@cindex quotea
@unnumberedsubsubsec 4. 名前付きレジスタ "a から "z または "A から "Z
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Vim fills these registers only when you say so.  Specify them as lowercase
letters to replace their previous contents or as uppercase letters to append
to their previous contents.  When the '>' flag is present in 'cpoptions' then
a line break is inserted before the appended text.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのレジスタが使われるのは、ユーザーに指定されたときのみである。コピーや削除の際にこれらのレジスタを小文字で指定すると、コピーや削除されたテキストが蓄えられ、元から入っていたテキストは消える。大文字で指定すると、元から入っていた内容の後ろに新しいテキストを付け加える。'@option{cpoptions}' にフラグ '@var{>}' が入っていると、新しいテキストの前に改行が挿入される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
5. Read-only registers ":, ". and "%
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec 5. 読みとり専用レジスタ ": と ". と "%
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
These are '%', '#', ':' and '.'.  You can use them only with the "p", "P",
and ":put" commands and with CTRL-R.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
読みとり専用レジスタには '%' と '#' と ':' と '.' がある。コマンド "p", "P", ":put" および @kbd{CTRL-R} でのみ使うことができる。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*quote_.* *quote.* *E29*
	".	Contains the last inserted text (the same as what is inserted
		with the insert mode commands CTRL-A and CTRL-@).  Note: this
		doesn't work with CTRL-R on the command-line.  It works a bit
		differently, like inserting the text instead of putting it
		('textwidth' and other options affect what is inserted).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{quote_.}
@anchor{quote.}
@anchor{E29}
@cindex quote_.
@cindex quote.
@cindex E29
@table @asis
@item ".
最後に挿入されたテキストが蓄えられる (挿入モードのコマンド @kbd{CTRL-A} や @kbd{CTRL-@@} で挿入されるものと同じテキストである)。
@quotation
@strong{Note:} @*
これはコマンドライン上での @kbd{CTRL-R} では使えないことに注意。動作が少し異なり、テキストを貼り付けるというより挿入するような動作をする (挿入されるテキストに '@option{textwidth}' 等のオプションが影響する)。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*quote_%* *quote%*
	"%	Contains the name of the current file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{quote_%}
@anchor{quote%}
@cindex quote_%
@cindex quote%
@item "%
カレントファイルの名前が蓄えられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*quote_:* *quote:* *E30*
	":	Contains the most recent executed command-line.  Example: Use
		"@:" to repeat the previous command-line command.
		The command-line is only stored in this register when at least
		one character of it was typed.  Thus it remains unchanged if
		the command was completely from a mapping.
		{not available when compiled without the |+cmdline_hist|
		feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{quote_:}
@anchor{quote:}
@anchor{E30}
@cindex quote_:
@cindex quote:
@cindex E30
@item ":
一番最近に実行されたコマンドラインの内容が蓄えられる。例: 前回のコマンドラインによるコマンドを実行するには、"@@:" が使える。コマンドラインがこのレジスタに蓄えられるのは、コマンドライン内にコマンドが最低でも1文字打ち込まれたときである。そのため、コマンドが完全にキーマッピングから実行されたときには、この内容に変化はない。

@{Vim が |+cmdline_hist| 機能付きでコンパイルされたときのみ有効@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*quote_#* *quote#*
6. Alternate file register "#
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{quote_#}
@anchor{quote#}
@cindex quote_#
@cindex quote#
@unnumberedsubsubsec 6. 代替ファイルレジスタ "#
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Contains the name of the alternate file for the current window.  It will
change how the |CTRL-^| command works.
This register is writable, mainly to allow for restoring it after a plugin has
changed it.  It accepts buffer number: >
    let altbuf = bufnr(@#)
    ...
    let @# = altbuf
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カレントウィンドウの代替ファイルの名前を含む。これは |CTRL-^| コマンドがどのように働くかを変更する。

このレジスタは書き込み可能で、主にプラグインがこのレジスタを変更した後で元に戻すためである。バッファ番号を許容する:
@verbatim
let altbuf = bufnr(@#)
...
let @# = altbuf
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
It will give error |E86| if you pass buffer number and this buffer does not
exist.
It can also accept a match with an existing buffer name: >
    let @# = 'buffer_name'
Error |E93| if there is more than one buffer matching the given name or |E94|
if none of buffers matches the given name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バッファ番号が越えるあるいはそのバッファが存在しない場合はエラー |E86| を返す。
また存在するバッファ名でのマッチングを許容する:
@verbatim
let @# = 'buffer_name'
@end verbatim
与えられた名前にマッチしたバッファが 1 つより多い場合はエラー |E93| を、与えられた名前にマッチするバッファがない場合は |E94| を返す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
7. Expression register "=			*quote_=* *quote=* *@=*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{quote_=}
@anchor{quote=}
@ifnottex
@anchor{@@=}
@end ifnottex
@cindex quote_=
@cindex quote=
@ifnottex
@cindex @@=
@end ifnottex
@unnumberedsubsubsec 7. Expression レジスタ "=
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This is not really a register that stores text, but is a way to use an
expression in commands which use a register.  The expression register is
read-write.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは、本当はテキストを蓄えるレジスタではないが、レジスタを使うコマンドで式を評価するために使える。この expression レジスタは読み取り/書き込み可能である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When typing the '=' after " or CTRL-R the cursor moves to the command-line,
where you can enter any expression (see |expression|).  All normal
command-line editing commands are available, including a special history for
expressions.  When you end the command-line by typing <CR>, Vim computes the
result of the expression.  If you end it with <Esc>, Vim abandons the
expression.  If you do not enter an expression, Vim uses the previous
expression (like with the "/" command).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
" または @kbd{CTRL-R} の後に '=' を打ち込むと、カーソルはコマンド行に移動し、あらゆる式を入力することができる (|expression| を参照)。コマンドラインから入力できる普通の編集用コマンドは、式用の特別履歴も含め、全て使用可能である。<CR> を打ち込んでコマンドライン入力を終了させると、式の結果が計算される。@key{<Esc>} を打ち込んで終了させると、式は破棄される。式が入力されないときは、(コマンド"/" と同様) 前回の式が使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The expression must evaluate to a String.  A Number is always automatically
converted to a String.  For the "p" and ":put" command, if the result is a
Float it's converted into a String.  If the result is a List each element is
turned into a String and used as a line.  A Dictionary or FuncRef results in
an error message (use string() to convert).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
式を評価した結果は文字列でなければならない。評価した結果が数値なら、文字列に変換される。"p" と ":put" コマンドの場合、結果が浮動小数点数なら文字列に変換される。リストの場合、各要素が文字列に変換され、それぞれが 1 行として挿入される。辞書または FuncRef はエラーメッセージが出る (string() を使って変換する)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the "= register is used for the "p" command, the String is split up at <NL>
characters.  If the String ends in a <NL>, it is regarded as a linewise
register.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
レジスタ "= が "p" で使われると、文字列は <NL> 文字 @{訳注: New Line --改行@} の所で分割される。文字列が <NL> で終わっていたら、これは行単位のレジスタと見なされる。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
8. Selection and drop registers "*, "+ and "~ 
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec 8. 選択範囲レジスタ "* と "+ と "~ 
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Use these registers for storing and retrieving the selected text for the GUI.
See |quotestar| and |quoteplus|.  When the clipboard is not available or not
working, the unnamed register is used instead.  For Unix systems the clipboard
is only available when the |+xterm_clipboard| feature is present.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのレジスタは、GUI で、選択されたテキストを蓄えたり取り出すために使われる。|quotestar| と |quoteplus| を参照。クリップボードが利用できないときは、無名レジスタが代わりに使われる。Unix では |+xterm_clipboard| が有効になっているときだけクリップボードを利用できる。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that there is only a distinction between "* and "+ for X11 systems.  For
an explanation of the difference, see |x11-selection|.  Under MS-Windows, use
of "* and "+ is actually synonymous and refers to the |gui-clipboard|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"* と "+ に区別があるのは X11 システムのみであることに注意。違いについては |x11-selection| を参照。MS-Windows では "* と "+ は実際には同義で、クリップボード |gui-clipboard| を使用する。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*quote_~* *quote~* *<Drop>*
The read-only "~ register stores the dropped text from the last drag'n'drop
operation.  When something has been dropped onto Vim, the "~ register is
filled in and the <Drop> pseudo key is sent for notification.  You can remap
this key if you want; the default action (for all modes) is to insert the
contents of the "~ register at the cursor position.  {not in Vi}
{only available when compiled with the |+dnd| feature, currently only with the
GTK GUI}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{quote_~}
@anchor{quote~}
@anchor{<Drop>}
@cindex quote_~
@cindex quote~
@cindex <Drop>
この読み込み専用の "~ レジスタは最後にドラッグアンドドロップされたテキストを提供する。何かが Vim にドロップされたとき、"~ レジスタがそれで埋められ、<Drop> 仮想キーが通知される。このキーをリマップして使うことができる。デフォルトでは (全てのモードにおいて) "~ レジスタの内容をカーソルの位置に挿入する。

@{Vi にはない@}

@{|+dnd| 付きでコンパイルされたときのみ有効。現在は GTK GUI でのみ使える。@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: The "~ register is only used when dropping plain text onto Vim.
Drag'n'drop of URI lists is handled internally.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"~ レジスタはプレーンテキストを Vim にドロップしたときのみ使われる。URI のリストは内部で扱われる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
9. Black hole register "_				*quote_*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{quote_}
@cindex quote_
@unnumberedsubsubsec 9. 消去専用レジスタ "_
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
When writing to this register, nothing happens.  This can be used to delete
text without affecting the normal registers.  When reading from this register,
nothing is returned.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このレジスタを指定してテキストを削除しても、@{訳注: レジスタには@} 何も起こらない。そのため、普通のレジスタに影響を与えずに削除が行える。このレジスタから貼り付けようとしても、何も出てこない。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
10. Last search pattern register	"/			*quote_/* *quote/*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{quote_/}
@anchor{quote/}
@cindex quote_/
@cindex quote/
@unnumberedsubsubsec 10. 最終検索パターン用レジスタ	"/
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Contains the most recent search-pattern.  This is used for "n" and 'hlsearch'.
It is writable with `:let`, you can change it to have 'hlsearch' highlight
other matches without actually searching.  You can't yank or delete into this
register.  The search direction is available in |v:searchforward|.
Note that the value is restored when returning from a function
|function-search-undo|.
{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最後に使われた検索パターンが蓄えられる。これはコマンド "n" やオプション '@option{hlsearch}' による強調表示に使われる。このレジスタは `:let` で変更できるので、'@option{hlsearch}' による強調表示を、実際に検索を行わずに別のマッチに適用することができる。このレジスタを使ってコピーしたり削除することはできない。
@quotation
@strong{Note:} @*
関数から抜けると、この値は関数に入る前の値に復元される。|function-search-undo|
@end quotation

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*@/*
You can write to a register with a `:let` command |:let-@|.  Example: >
	:let @/ = "the"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@ifnottex
@anchor{@@/}
@cindex @@/
@end ifnottex
レジスタには、コマンド `:let` で書き込むことができる |:let-@@|。例:
@example
:let @@/ = "the"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you use a put command without specifying a register, Vim uses the register
that was last filled (this is also the contents of the unnamed register).  If
you are confused, use the `:dis` command to find out what Vim will put (this
command displays all named and numbered registers; the unnamed register is
labelled '"').
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
レジスタを指定せずに貼り付けコマンドを使うと、最後に書き込みが行われたレジスタが使われる (その内容は無名レジスタと同じである)。混乱したときは、コマンド `:dis` を使うとレジスタの内容が分かる (このコマンドは、全てのレジスタの内容を表示する。無名レジスタは '"' と示される)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The next three commands always work on whole lines.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下の 3 個のコマンドは、必ず行全体に対して働く。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]co[py] {address}				*:co* *:copy*
			Copy the lines given by [range] to below the line
			given by {address}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:co}
@anchor{:copy}
@cindex :co
@cindex :copy
@table @asis
@item :[range]co[py] @{address@}
[range] 行を、@{address@} 行目の下にコピーする。

@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:t*
:t			Synonym for copy.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:t}
@cindex :t
@item :t
":copy" と同義。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]m[ove] {address}			*:m* *:mo* *:move* *E134*
			Move the lines given by [range] to below the line
			given by {address}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:m}
@anchor{:mo}
@anchor{:move}
@anchor{E134}
@cindex :m
@cindex :mo
@cindex :move
@cindex E134
@item :[range]m[ove] @{address@}
[range] 行を、@{address@} 行目の下に移動する。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
6. Formatting text					*formatting*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{formatting}
@cindex formatting
@section 6. テキストの整形
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]ce[nter] [width]				*:ce* *:center*
			Center lines in [range] between [width] columns
			(default 'textwidth' or 80 when 'textwidth' is 0).
			{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:ce}
@anchor{:center}
@cindex :ce
@cindex :center
@table @asis
@item :[range]ce[nter] [width]
[range] の行を、幅 [width] (既定値は '@option{textwidth}', '@option{textwidth}' が 0 のときは 80) に基づいて中央揃えする。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]ri[ght] [width]					*:ri* *:right*
			Right-align lines in [range] at [width] columns
			(default 'textwidth' or 80 when 'textwidth' is 0).
			{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:ri}
@anchor{:right}
@cindex :ri
@cindex :right
@item :[range]ri[ght] [width]
[range] の行を、幅 [width] (既定値は '@option{textwidth}', '@option{textwidth}' が 0 のときは 80) に基づいて右揃えする。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:le* *:left*
:[range]le[ft] [indent]
			Left-align lines in [range].  Sets the indent in the
			lines to [indent] (default 0).  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:le}
@anchor{:left}
@cindex :le
@cindex :left
@item :[range]le[ft] [indent]
[range] の行を左揃えする。行中のインデントを [indent] (既定値 0) に設定する。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*gq*
gq{motion}		Format the lines that {motion} moves over.
			Formatting is done with one of three methods:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gq}
@cindex gq
@item gq@{motion@}
@{motion@} の行を整形する。整形は3種類の方法のうちどれかで行われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			1. If 'formatexpr' is not empty the expression is
			   evaluated.  This can differ for each buffer.
			2. If 'formatprg' is not empty an external program
			   is used.
			3. Otherwise formatting is done internally.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item
'@option{formatexpr}' が空でなければその expression が評価される。これはバッファごとに異なってもよい。
@item
'@option{formatprg}' が空でなければ外部プログラムが使われる。
@item
それ以外の場合は内部整形ルーチンが使われる。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			In the third case the 'textwidth' option controls the
			length of each formatted line (see below).
			If the 'textwidth' option is 0, the formatted line
			length is the screen width (with a maximum width of
			79).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
3 番目の場合は、オプション '@option{textwidth}' が整形された各行の長さを制御する (後述)。'@option{textwidth}' が 0 なら、整形された行の長さは画面の幅となる (ただし、最大で 79)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			The 'formatoptions' option controls the type of
			formatting |fo-table|.
			The cursor is left on the first non-blank of the last
			formatted line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{formatoptions}' は、整形の仕方を制御する |fo-table|。カーソルは最後に整形された行の最初の非空白文字の上に置かれる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			NOTE: The "Q" command formerly performed this
			function.  If you still want to use "Q" for
			formatting, use this mapping: >
				:nnoremap Q gq
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
以前はコマンド "Q" でこの機能を行っていた。やはり整形に "Q" を使いたいならば、次のマッピングを使うこと。
@example
:nnoremap Q gq
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
gqgq							*gqgq* *gqq*
gqq			Format the current line.  With a count format that
			many lines.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gqgq}
@anchor{gqq}
@cindex gqgq
@cindex gqq
@item gqgq or gqq
現在行を整形する。カウントを指定するとその行数だけ整形される。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_gq*
{Visual}gq		Format the highlighted text.  (for {Visual} see
			|Visual-mode|).  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_gq}
@cindex v_gq
@item @{Visual@}gq
ビジュアル選択されたテキストを整形する。(@{Visual@} については |Visual-mode| を参照)。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*gw*
gw{motion}		Format the lines that {motion} moves over.  Similar to
			|gq| but puts the cursor back at the same position in
			the text.  However, 'formatprg' and 'formatexpr' are
			not used.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gw}
@cindex gw
@item gw@{motion@}
@{motion@} で動いた範囲の行を整形する。|gq|に似ているがカーソルは元の位置に戻る。'@option{formatprg}' と '@option{formatexpr}' は使われない。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
gwgw							*gwgw* *gww*
gww			Format the current line as with "gw".  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gwgw}
@anchor{gww}
@cindex gwgw
@cindex gww
@item gwgw or gww
"gw" と同様にして現在行を整形する。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_gw*
{Visual}gw		Format the highlighted text as with "gw".  (for
			{Visual} see |Visual-mode|).  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_gw}
@cindex v_gw
@item @{Visual@}gw
選択されたテキストを "gw" と同様にして整形する。(@{Visual@} については |Visual-mode| を参照)。

@{Vi にはない@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Example: To format the current paragraph use:			*gqap*  >
	gqap
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gqap}
@cindex gqap
例: 現在の段落を整形するには、次のようにする。
@example
gqap
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "gq" command leaves the cursor in the line where the motion command takes
the cursor.  This allows you to repeat formatting repeated with ".".  This
works well with "gqj" (format current and next line) and "gq}" (format until
end of paragraph).  Note: When 'formatprg' is set, "gq" leaves the cursor on
the first formatted line (as with using a filter command).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンド "gq" は、移動コマンドによってカーソルが動くはずの位置にカーソルを移動させる。このため、"." で整形を繰り返すことができる。これは、"gqj" (現在行と次行を整形) と、"gq@}" (段落の最後までを整形) で有用である。
@quotation
@strong{Note:} @*
'@option{formatprg}' が設定されているときは、"gq" を実行すると (フィルタコマンド使用時と同様に) カーソルは整形された最初の行に移動する。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to format the current paragraph and continue where you were, use: >
	gwap
If you always want to keep paragraphs formatted you may want to add the 'a'
flag to 'formatoptions'.  See |auto-format|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カーソルのある位置の段落をフォーマットし、その位置からさらに編集を再開するにはこうする。
@example
gwap
@end example
いつも段落をフォーマットしておきたいなら '@option{formatoptions}' に 'a' フラグを追加すればよい。|auto-format| も参照のこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the 'autoindent' option is on, Vim uses the indent of the first line for
the following lines.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{autoindent}' がオンのとき、Vim は最初の行のインデントを続く行に対して適用する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Formatting does not change empty lines (but it does change lines with only
white space!).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
テキストの整形処理は空の行には変更を加えない (しかし、空白のみで構成された行には変更を行う！)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The 'joinspaces' option is used when lines are joined together.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{joinspaces}' は、行が連結されるときに使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can set the 'formatexpr' option to an expression or the 'formatprg' option
to the name of an external program for Vim to use for text formatting.  The
'textwidth' and other options have no effect on formatting by an external
program.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{formatexpr}' でテキストの整形に使う expression を設定したり、'@option{formatprg}' で外部プログラムの名前を設定することができる。外部プログラムによる整形処理には、'@option{textwidth}' や他のオプションは何の影響も与えない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*right-justify*
There is no command in Vim to right justify text.  You can do it with
an external command, like "par" (e.g.: "!}par" to format until the end of the
paragraph) or set 'formatprg' to "par".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{right-justify}
@cindex right-justify
テキストを右揃えするコマンドは、Vim には存在しない。"par" 等の外部コマンド (例: "!@}par" で段落の最後までを整形する) を実行したり、'@option{formatprg}' に "par" を指定することで、これを行うことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*format-comments*
An overview of comment formatting is in section |30.6| of the user manual.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{format-comments}
@cindex format-comments
コメント整形の概要がユーザーマニュアルの |@ref{30.6, , 30.6}| にある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim can automatically insert and format comments in a special way.  Vim
recognizes a comment by a specific string at the start of the line (ignoring
white space).  Three types of comments can be used:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は特殊な方法で自動的にコメントを挿入・整形できる。Vim は行の最初の特定の文字列 (空白を無視する) によって、コメントを認識できる。コメントには 3 種類が使える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- A comment string that repeats at the start of each line.  An example is the
  type of comment used in shell scripts, starting with "#".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize @minus
@item
各行の最初で繰り返されるコメント文字列。例えば、"#" で始まるシェルスクリプトのコメントなど。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- A comment string that occurs only in the first line, not in the following
  lines.  An example is this list with dashes.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
最初の行にのみ現れ、続きの行には現れないコメント文字列。例えば、このリストにおけるダッシュ '-'。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Three-piece comments that have a start string, an end string, and optional
  lines in between.  The strings for the start, middle and end are different.
  An example is the C style comment:
	/*
	 * this is a C comment
	 */
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
最初の文字列、最後の文字列、そしてその間の行の 3 つの部分から成るコメント。開始部分、中間部分、終了部分に使われる文字列は異なる。例えば、C 言語形式のコメント。
@verbatim
/*
* これは C のコメント
*/
@end verbatim
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The 'comments' option is a comma-separated list of parts.  Each part defines a
type of comment string.  A part consists of:
	{flags}:{string}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{comments}' は要素のコンマ区切りのリストである。各要素はコメント文字列の種類を定義している。要素は次のように構成される。
@verbatim
@{flags@}:@{string@}
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{string} is the literal text that must appear.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{string@} は普通のテキストで、これがなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{flags}:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{flags@}:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
  n	Nested comment.  Nesting with mixed parts is allowed.  If 'comments'
	is "n:),n:>" a line starting with "> ) >" is a comment.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item n @tab 入れ子になったコメント。混在した要素の入れ子も有効である。'@option{comments}' が "n:),n:>" であれば、"> ) >" で始まる行はコメント。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  b	Blank (<Space>, <Tab> or <EOL>) required after {string}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item b @tab @{string@} の後に余白 (<Space>、<Tab> または <EOL>) が必要。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  f	Only the first line has the comment string.  Do not repeat comment on
	the next line, but preserve indentation (e.g., a bullet-list).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item f @tab 最初の行のみがコメント文字列を持つ。次の行にはコメントを繰り返さないが、インデントは保持する (例、bullet-list)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  s	Start of three-piece comment
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item s @tab 3 部コメントの開始部分。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  m	Middle of a three-piece comment
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item m @tab 3 部コメントの中間部分。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  e	End of a three-piece comment
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item e @tab 3 部コメントの終了部分。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  l	Left align. Used together with 's' or 'e', the leftmost character of
	start or end will line up with the leftmost character from the middle.
	This is the default and can be omitted. See below for more details.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item l @tab 左揃え。's' か 'e' と共に指定された場合、それぞれ最初または最後の部分の一番左の文字が、真ん中の一番左の文字に対して揃えられる。この動作はデフォルトであるが、省略もできる。詳しくは後述。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  r	Right align. Same as above but rightmost instead of leftmost. See
	below for more details.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item r @tab 右揃え。一番左でなく一番右であること以外、l と同じ。詳しくは後述。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  O	Don't consider this comment for the "O" command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item O @tab コマンド "O" ではこのコメントを考慮しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  x	Allows three-piece comments to be ended by just typing the last
	character of the end-comment string as the first action on a new
	line when the middle-comment string has been inserted automatically.
	See below for more details.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item x @tab 3 部コメントで、中間部分のコメントがすでに自動で挿入されているとき、新しい行の最初のアクションとして、終了部分のコメント文字列の最後の文字を打ち込むだけで、コメントを終了させる。詳細は以下を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  {digits}
	When together with 's' or 'e': add {digit} amount of offset to an
	automatically inserted middle or end comment leader. The offset begins
	from a left alignment. See below for more details.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @{digits@} @tab 's' か 'e' と共に指定された場合: 自動的に挿入された、中間または最後のコメントの最初の部分に対し、@{digits@} 分のオフセットを加える。このオフセットは左端を基準とする。詳しくは後述。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  -{digits}
	Like {digits} but reduce the indent.  This only works when there is
	some indent for the start or end part that can be removed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item -@{digits@} @tab @{digits@} に似ているが、インデントを減らす。開始部分と終了部分に減らすべきインデントが存在しているときのみ機能する。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When a string has none of the 'f', 's', 'm' or 'e' flags, Vim assumes the
comment string repeats at the start of each line.  The flags field may be
empty.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コメント文字列にフラグ 'f', 's', 'm', 'e' のいずれも指定しないとき、Vim はコメント文字列を行の最初に繰り返すと仮定する。フラグ欄は空になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Any blank space in the text before and after the {string} is part of the
{string}, so do not include leading or trailing blanks unless the blanks are a
required part of the comment string.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{string@} の前や後にある余白は、@{string@} の一部とされる。コメント文字列に必要でない限り、余白を前や後に付けないこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When one comment leader is part of another, specify the part after the whole.
For example, to include both "-" and "->", use >
	:set comments=f:->,f:-
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
あるコメント開始文字列が他のコメントの一部であるときは、共通部分の後で特定の部分を指定すること。例えば、"-" と "->" の両方を含みたいときは、次のようにする。
@example
:set comments=f:->,f:-
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A three-piece comment must always be given as start,middle,end, with no other
parts in between.  An example of a three-piece comment is >
	sr:/*,mb:*,ex:*/
for C-comments.  To avoid recognizing "*ptr" as a comment, the middle string
includes the 'b' flag.  For three-piece comments, Vim checks the text after
the start and middle strings for the end string.  If Vim finds the end string,
the comment does not continue on the next line.  Three-piece comments must
have a middle string because otherwise Vim can't recognize the middle lines.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
3 部コメントには常に開始部分、中間部分、終了部分を指定しなければならない。そして、他の要素を間に入れてはならない。C言語での3部コメントの例は次の通り。
@example
sr:/*,mb:*,ex:*/
@end example
"*ptr" がコメントとして認識されないように、中間部分の文字列がフラグ 'b' を含んでいる。3 部コメントでは、Vim は開始部分と中間部分の文字列の後のテキスト内に、最後の文字列が含まれていないかを調べる。終了部分の文字列が見つかると、コメントは次の行には続かない。3 部コメントには、Vim が中間の行を認識できるようにするために、中間部分の文字列を指定しなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Notice the use of the "x" flag in the above three-piece comment definition.
When you hit Return in a C-comment, Vim will insert the middle comment leader
for the new line: " * ".  To close this comment you just have to type "/"
before typing anything else on the new line.  This will replace the
middle-comment leader with the end-comment leader and apply any specified
alignment, leaving just " */".  There is no need to hit Backspace first.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上記の 3 部コメントの定義における、フラグ "x" の使用について注意しておく。C コメントでリターンを打てば、Vim は新しい行に対して " * " のようなコメントの中間部分の開始文字列を挿入する。このコメントを閉じるには、新しい行において何も打ち込む前に "/" と打ち込めばよい。これは中間のコメント指示を最後のコメント指示に置き換え、" */" とする。指定された桁揃えは適用される。その前にバックスペースを打ち込む必要はない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When there is a match with a middle part, but there also is a matching end
part which is longer, the end part is used.  This makes a C style comment work
without requiring the middle part to end with a space.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
中間部分がマッチしたとき、終了部分もマッチしていてそちらの方が長い場合は、終了部分が使われる。これによって C スタイルコメントが中間部分の末尾にスペースを付けなくても機能するようになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here is an example of alignment flags at work to make a comment stand out
(kind of looks like a 1 too). Consider comment string: >
	:set comments=sr:/***,m:**,ex-2:******/
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
桁揃えフラグを使ってコメントを目立たせる例を示す。'@option{comments}' が次のようになっている場合:
@example
:set comments=sr:/***,m:**,ex-2:******/
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
                                   /*** ~
                                     **<--right aligned from "r" flag ~
                                     ** ~
offset 2 spaces for the "-2" flag--->** ~
                                   ******/ ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
                                   /***
                                     **<--"r" フラグによって右揃えされている
                                     **
 "-2" フラグによってスペース         **
 2 個分のオフセットがついている  --->**
                                   ******/
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
In this case, the first comment was typed, then return was pressed 4 times,
then "/" was pressed to end the comment.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これを入力する際、コメントの開始行を入力し、リターンを 4 回押す。そして "/" を押せばコメントが終了する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here are some finer points of three part comments. There are three times when
alignment and offset flags are taken into consideration: opening a new line
after a start-comment, opening a new line before an end-comment, and
automatically ending a three-piece comment.  The end alignment flag has a
backwards perspective; the result is that the same alignment flag used with
"s" and "e" will result in the same indent for the starting and ending pieces.
Only one alignment per comment part is meant to be used, but an offset number
will override the "r" and "l" flag.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
3 部コメントについて、より細かいことをいくつか説明する。桁揃えフラグとオフセットフラグが考慮される箇所は、次の 3 箇所ある。コメント開始行のあとの新規行を開くとき、コメント終了行の前の新規行を開くとき、自動的にコメントを終了させるときである。終了部分の桁揃えフラグは、上の行を参照する。これによって、"s" と "e" に同じ桁揃えフラグを指定したとき、開始部分と終了部分のインデント量が同じになる。コメントの部分ごとに 1 個だけの桁揃えが使われるようになっている。しかし、オフセットの数は "r" と "l" フラグより優先する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Enabling 'cindent' will override the alignment flags in many cases.
Reindenting using a different method like |gq| or |=| will not consult
alignment flags either. The same behaviour can be defined in those other
formatting options. One consideration is that 'cindent' has additional options
for context based indenting of comments but cannot replicate many three piece
indent alignments.  However, 'indentexpr' has the ability to work better with
three piece comments.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{cindent}' をオンにしていると、多くの場合、桁揃えフラグより優先される。|gq| や |=| を使って再インデントするときも、桁揃えフラグは適用されない。同じ挙動を定義するには、それらのコマンドのオプションを使う。1 つの考えとしては、'@option{cindent}' に文脈に応じてコメントをインデントさせるオプションを追加することであるが、3 部コメントの桁揃えを模倣することはほとんどできない。しかし '@option{indentexpr}' は 3 部コメントをもっとうまく扱える可能性を持つ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Other examples: >
   "b:*"	Includes lines starting with "*", but not if the "*" is
		followed by a non-blank.  This avoids a pointer dereference
		like "*str" to be recognized as a comment.
   "n:>"	Includes a line starting with ">", ">>", ">>>", etc.
   "fb:-"	Format a list that starts with "- ".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
他の例:
@multitable @columnfractions .15 .85
@item "b:*" @tab "*" の後に非ブランク文字が付いていなければ、"*" で始まる行を含む。これはポインタの値への参照 "*str" が、コメントとして認識されるのを防ぐ。
@item "n:>" @tab ">", ">>", ">>>" などで始まる行を含む。
@item "fb:-" @tab "- " で始まるリストを整形する。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
By default, "b:#" is included.  This means that a line that starts with
"#include" is not recognized as a comment line.  But a line that starts with
"# define" is recognized.  This is a compromise.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
既定では "b:#" が含まれている。これは "#include" で始まる行がコメントとならないことを意味する。しかし、"# define" で始まる行はコメントとなる。これは妥協的解決である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{not available when compiled without the |+comments| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{Vimが |+comments| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*fo-table*
You can use the 'formatoptions' option  to influence how Vim formats text.
'formatoptions' is a string that can contain any of the letters below.  The
default setting is "tcq".  You can separate the option letters with commas for
readability.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{fo-table}
@cindex fo-table
テキストの整形方法はオプション '@option{formatoptions}' で調整できる。'@option{formatoptions}' は以下のフラグを含む文字列である。既定値は "@var{tcq}" である。読みやすくするために、フラグをコンマで区切ってもよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
letter	 meaning when present in 'formatoptions'    ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec フラグ 'formatoptions' に指定されたときの作用
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
t	Auto-wrap text using textwidth
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item t @tab '@option{textwidth}' を使ってテキストを自動折返しする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
c	Auto-wrap comments using textwidth, inserting the current comment
	leader automatically.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item c @tab '@option{textwidth}' を使ってコメントを自動折返して、現在のコメント開始文字列を自動挿入する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
r	Automatically insert the current comment leader after hitting
	<Enter> in Insert mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item r @tab 挿入モードで @key{<Enter>} を打ち込んだ後に、現在のコメント開始文字列を自動挿入する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
o	Automatically insert the current comment leader after hitting 'o' or
	'O' in Normal mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item o @tab ノーマルモードで 'o', 'O' を打ち込んだ後に、現在のコメント開始文字列を自動的に挿入する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
q	Allow formatting of comments with "gq".
	Note that formatting will not change blank lines or lines containing
	only the comment leader.  A new paragraph starts after such a line,
	or when the comment leader changes.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item q @tab "gq" でコメントを整形する。
@quotation
@strong{Note:} @*
整形は空行やコメント開始文字列のみの行は変更しないことに注意。新しい段落はそのような行の次、またはコメント開始文字列が変わった所から始まる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
w	Trailing white space indicates a paragraph continues in the next line.
	A line that ends in a non-white character ends a paragraph.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item w @tab 行末に空白が付いているとき、段落が次行に続いていると認識する。行末が空白以外の行で段落が終わるとする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
a	Automatic formatting of paragraphs.  Every time text is inserted or
	deleted the paragraph will be reformatted.  See |auto-format|.
	When the 'c' flag is present this only happens for recognized
	comments.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item a @tab 段落を自動整形する。テキストが挿入されたり削除されるたび、段落は再整形される。|auto-format| を参照。'c' フラグも設定されているときはコメント挿入時のみ機能する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
n	When formatting text, recognize numbered lists.  This actually uses
	the 'formatlistpat' option, thus any kind of list can be used.  The
	indent of the text after the number is used for the next line.  The
	default is to find a number, optionally followed by '.', ':', ')',
	']' or '}'.  Note that 'autoindent' must be set too.  Doesn't work
	well together with "2".
	Example: >
		1. the first item
		   wraps
		2. the second item
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item n @tab テキストの整形時、番号付きリストを認識する。これは実際には '@option{formatlistpat}' を使う。それゆえ、どんな種類のリストでも処理できる。

数字の後のテキストのインデントが次の行に使われる。数字の後に '.', ':', ')', ']' や '@}' が付いてもよい。オプション '@option{autoindent}' がオンでなければならないことに注意。"2" と一緒には機能しない。例:
@verbatim
1. 1 つ目の項目
   折り返し
2. 2 つ目の項目
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
2	When formatting text, use the indent of the second line of a paragraph
	for the rest of the paragraph, instead of the indent of the first
	line.  This supports paragraphs in which the first line has a
	different indent than the rest.  Note that 'autoindent' must be set
	too.  Example: >
			first line of a paragraph
		second line of the same paragraph
		third line.
<	This also works inside comments, ignoring the comment leader.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 2 @tab テキストを整形するとき、段落の最初の行ではなく 2 番目の行のインデントを使ってそれ以降の行を整形する。これは最初の行のインデントが他の行と異なるような段落をサポートする。'@option{autoindent}' もオンである必要がある。例:
@verbatim
        ここはある段落の 1 行目
ここは上の行と同じ段落の 2 行目
ここは 3 行目。
@end verbatim
これはコメントの中でも機能します (コメント文字がないかのように)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
v	Vi-compatible auto-wrapping in insert mode: Only break a line at a
	blank that you have entered during the current insert command.  (Note:
	this is not 100% Vi compatible.  Vi has some "unexpected features" or
	bugs in this area.  It uses the screen column instead of the line
	column.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item v @tab 挿入モードでVi互換の自動折返しを使う: 挿入モードに入って以来入力された空白でのみ折返しが行われる。(@strong{Note:} これは 100% の Vi 互換ではない。Vi にはこのあたりに「予期できない機能」、というかバグがあった。Vi は実際のテキストの列の代わりに画面上の列を使用する。)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
b	Like 'v', but only auto-wrap if you enter a blank at or before
	the wrap margin.  If the line was longer than 'textwidth' when you
	started the insert, or you do not enter a blank in the insert before
	reaching 'textwidth', Vim does not perform auto-wrapping.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item b @tab 'v' と同様だが、折返し余白の中または前で、空白を入力したときのみ自動折返しをする。挿入開始時に '@option{textwidth}' より行が長かったり、'@option{textwidth}' に達するまで空白を入力しなかったときは、Vim は自動折返しをしない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
l	Long lines are not broken in insert mode: When a line was longer than
	'textwidth' when the insert command started, Vim does not
	automatically format it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item l @tab 挿入モードでは長い行は折り返されない: 挿入開始時に行が '@option{textwidth}' より長い場合、Vim は自動で整形を行わない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
m	Also break at a multi-byte character above 255.  This is useful for
	Asian text where every character is a word on its own.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item m @tab 文字コードが 255 より後のマルチバイト文字の間でも改行する。これは文字全てがそれだけで単語であるような、アジア言語のテキストで便利である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
M	When joining lines, don't insert a space before or after a multi-byte
	character.  Overrules the 'B' flag.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item M @tab 行の連結時に、マルチバイト文字の前後に空白を挿入しない。こちらの方がフラグ 'B' より優先する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
B	When joining lines, don't insert a space between two multi-byte
	characters.  Overruled by the 'M' flag.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item B @tab 行の連結時に、マルチバイト文字同士の間に空白を挿入しない。こちらよりフラグ 'M' の方が優先する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
1	Don't break a line after a one-letter word.  It's broken before it
	instead (if possible).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 1 @tab 1 文字の単語の後では改行しない。代わりにその前で改行される (可能ならば)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
j	Where it makes sense, remove a comment leader when joining lines.  For
	example, joining:
		int i;   // the index ~
		         // in the list ~
	Becomes:
		int i;   // the index in the list ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item j @tab 可能ならば、行を連結する際にコメントリーダーを削除する。例えば、以下の行を連結する場合:
@verbatim
int i;   // the index
         // in the list
@end verbatim
以下のようになる:
@verbatim
int i;   // the index in the list
@end verbatim
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
With 't' and 'c' you can specify when Vim performs auto-wrapping:
value	action	~
""	no automatic formatting (you can use "gq" for manual formatting)
"t"	automatic formatting of text, but not comments
"c"	automatic formatting for comments, but not text (good for C code)
"tc"	automatic formatting for text and comments
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
't' と 'c' で Vim が自動折返しを行うタイミングを指定できる。
@multitable @columnfractions .2 .8
@item フラグ @tab 作用
@item "" @tab 自動整形しない ("gq" で手動の整形処理を行う)
@item "t" @tab テキストを自動整形するが、コメントにはしない
@item "c" @tab コメントを自動整形するが、テキストにはしない (C 言語コードに適している)
@item "tc" @tab テキストとコメントを自動整形する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that when 'textwidth' is 0, Vim does no automatic formatting anyway (but
does insert comment leaders according to the 'comments' option).  An exception
is when the 'a' flag is present. |auto-format|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
'@option{textwidth}' が 0 のとき、Vim はいかなる自動整形も行わないので注意 ('@option{comments}' によるコメント開始文字列の挿入はする)。例外はフラグ 'a' が入っている場合である。|auto-format|
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that when 'paste' is on, Vim does no formatting at all.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
'@option{paste}' がオンのとき、Vim は全ての整形処理を行わないので注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that 'textwidth' can be non-zero even if Vim never performs auto-wrapping;
'textwidth' is still useful for formatting with "gq".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
Vim に自動折返しをさせなくても、'@option{textwidth}' は非 0 であってよいことに注意。'@option{textwidth}' は "gq" による整形処理でも便利だからである。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the 'comments' option includes "/*", "*" and/or "*/", then Vim has some
built in stuff to treat these types of comments a bit more cleverly.
Opening a new line before or after "/*" or "*/" (with 'r' or 'o' present in
'formatoptions') gives the correct start of the line automatically.  The same
happens with formatting and auto-wrapping.  Opening a line after a line
starting with "/*" or "*" and containing "*/", will cause no comment leader to
be inserted, and the indent of the new line is taken from the line containing
the start of the comment.
E.g.:
    /* ~
     * Your typical comment. ~
     */ ~
    The indent on this line is the same as the start of the above
    comment.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{comments}' が "/*" と ("*" と) "*/" を含んでいるときは、Vim 組み込みの機能によりこれらのタイプのコメントをもう少し巧く扱うことができる。

('@option{formatoptions}' に 'r' か 'o' が含まれているとき) "/*" または "*/" の前か後で新しい行を始めると、行の正しい開始位置が自動的に与えられる。同じことが整形処理と自動折返しでも行われる。"/*" や "*" で始まり、かつ "*/" を含む行の後で行を始めるときは、コメント開始文字列が挿入されず、新しい行のインデントはコメントの最初の行に合わせられる。

例:
@verbatim
/*
 * 典型的なコメント。
 */
この行のインデントは、上のコメントの先頭行と同じになる。
@end verbatim

@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
All of this should be really cool, especially in conjunction with the new
:autocmd command to prepare different settings for different types of file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これら全ては、特に異なるファイルタイプに対する異なる設定に対応する際、新しい autocommand と連携して、クールに振舞うはずである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Some examples:
  for C code (only format comments): >
	:set fo=croq
< for Mail/news	(format all, don't start comment with "o" command): >
	:set fo=tcrq
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
いくつかの例:

C 言語コード用 (コメントの整形のみ):
@example
:set fo=croq
@end example
メール／ネットニューズ用 (全て整形、コマンド "o" でコメントを始めない):
@example
:set fo=tcrq
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Automatic formatting				*auto-format* *autoformat*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{auto-format}
@anchor{autoformat}
@cindex auto-format
@cindex autoformat
@unnumberedsubsec 自動整形
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the 'a' flag is present in 'formatoptions' text is formatted
automatically when inserting text or deleting text.  This works nice for
editing text paragraphs.  A few hints on how to use this:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{formatoptions}' にフラグ '@var{a}' が含まれると、テキストを挿入したり削除したときに自動整形が行われる。これはテキストの段落分けを編集するときに便利である。以下では使い方についてのヒントをいくつか。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- You need to properly define paragraphs.  The simplest is paragraphs that are
  separated by a blank line.  When there is no separating blank line, consider
  using the 'w' flag and adding a space at the end of each line in the
  paragraphs except the last one.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize @minus
@item
段落を適切に定義する必要がある。もっとも単純なものは、空行が区切りになる場合である。区切りとなる空行がないときは、フラグ 'w' を使い、段落の最終行以外の行末に空白を付けるようにしてみること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- You can set the 'formatoptions' based on the type of file |filetype| or
  specifically for one file with a |modeline|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
'@option{formatoptions}' をファイルタイプ |filetype| に基づいて設定することができる。またはモードライン |modeline| で特定のファイルに対して設定することもできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- Set 'formatoptions' to "aw2tq" to make text with indents like this:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
'@option{formatoptions}' を "@var{aw2tcq}" に設定し、テキストのインデントを次のようにすることもできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	    bla bla foobar bla 
	bla foobar bla foobar bla
	    bla bla foobar bla 
	bla foobar bla bla foobar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
    bla bla foobar bla 
bla foobar bla foobar bla
    bla bla foobar bla 
bla foobar bla bla foobar
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- Add the 'c' flag to only auto-format comments.  Useful in source code.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
コメントだけを自動整形するには 'c' フラグを追加する。ソースコードの編集向き。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- Set 'textwidth' to the desired width.  If it is zero then 79 is used, or the
  width of the screen if this is smaller.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
行の長さを望みどおりにするには '@option{textwidth}' を設定する。これが 0 ならば 79 になる。画面の幅が 79 桁より小さい場合は画面幅になる。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
And a few warnings:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 次にいくつかの警告:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- When part of the text is not properly separated in paragraphs, making
  changes in this text will cause it to be formatted anyway.  Consider doing >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize @minus
@item
テキストの部分部分が段落内で適切に分割されていないとき、そのテキスト内で変更を行うと、有無をいわさず整形が始まってしまう。次のようにしてみること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set fo-=a
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set fo-=a
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- When using the 'w' flag (trailing space means paragraph continues) and
  deleting the last line of a paragraph with |dd|, the paragraph will be
  joined with the next one.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
フラグ 'w' (行末の空白で段落が終わっていないことを判断する) を使っているときに |dd| で段落の最終行を削除すると、その段落が次の段落とつながってしまう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- Changed text is saved for undo.  Formatting is also a change.  Thus each
  format action saves text for undo.  This may consume quite a lot of memory.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
変更されたテキストは、アンドゥのために記憶される。整形も変更の一種である。そのため、整形を行う度にテキストがアンドゥ用に記憶される。すると大量のメモリを消費するかもしれない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- Formatting a long paragraph and/or with complicated indenting may be slow.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 長い段落や、複雑なインデントの段落を整形するのには、時間がかかることがある。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
7. Sorting text						*sorting*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sorting}
@cindex sorting
@section 7. テキストのソート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim has a sorting function and a sorting command.  The sorting function can be
found here: |sort()|, |uniq()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vimはソート関数とソートコマンドを備えている。ソート関数については |sort()|, |uniq()| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:sor* *:sort*
:[range]sor[t][!] [b][f][i][n][o][r][u][x] [/{pattern}/]
			Sort lines in [range].  When no range is given all
			lines are sorted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:sor}
@anchor{:sort}
@cindex :sor
@cindex :sort
@table @asis
@item :[range]sor[t][!] [b][f][i][n][o][r][u][x] [/@{pattern@}/]
[range]の行をソートする。範囲が指定されない場合は全行をソートする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			With [!] the order is reversed.

			With [i] case is ignored.

			Options [n][f][x][o][b] are mutually exclusive.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[!] をつけると順序が逆になる。
			
[i] をつけると大文字・小文字を区別しない。

[n][f][x][o][b] オプションはどれかひとつのみ指定できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			With [n] sorting is done on the first decimal number
			in the line (after or inside a {pattern} match).
			One leading '-' is included in the number.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[n] をつけると行の (@{pattern@} のマッチの後ろまたは内側の) 最初の 10 進数の数字でソートする。数字が '-' で始まる場合、マイナスとみなされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			With [f] sorting is done on the Float in the line.
			The value of Float is determined similar to passing
			the text (after or inside a {pattern} match) to
			str2float() function. This option is available only
			if Vim was compiled with Floating point support.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[f] をつけると行の小数点数でソートする。小数点数の値は (@{pattern@} によるマッチの後ろまたは内側の) テキストを str2float() に渡すようにして決定される。このオプションは Vim が小数点数サポートを有効にしてコンパイルされたときのみ使える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			With [x] sorting is done on the first hexadecimal
			number in the line (after or inside a {pattern}
			match).  A leading "0x" or "0X" is ignored.
			One leading '-' is included in the number.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[x] をつけると行の (@{pattern@} のマッチの後ろまたは内側の) 最初の 16 進数の数字でソートする。"0x" と "0X" は無視される。数字が '-' で始まる場合、マイナスとみなされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			With [o] sorting is done on the first octal number in
			the line (after or inside a {pattern} match).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[o] をつけると行の (@{pattern@} のマッチの後ろまたは内側の) 最初の 8 進数の数字でソートする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			With [b] sorting is done on the first binary number in
			the line (after or inside a {pattern} match).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[b] をつけると (@{pattern@} によるマッチの後ろまたは内側の) 行の最初の 2 進数でソートする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			With [u] (u stands for unique) only keep the first of
			a sequence of identical lines (ignoring case when [i]
			is used).  Without this flag, a sequence of identical
			lines will be kept in their original order.
			Note that leading and trailing white space may cause
			lines to be different.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[u] をつけると (u は unique=「一意の」という意味に基づく) 連続する同一行の最初の行だけを残す。([i] がつくと大文字・小文字を無視する) このフラグがつかない場合、連続する同一行はそのままの順序で残される。
@quotation
@strong{Note:} @*
先頭と末尾の空白が原因で異なる行にみなされるかもしれない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			When /{pattern}/ is specified and there is no [r] flag
			the text matched with {pattern} is skipped, so that
			you sort on what comes after the match.
			Instead of the slash any non-letter can be used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
/pattern/ が指定され、フラグ [r] がない場合は @{pattern@} にマッチするテキストはスキップされる。これによって、そのマッチの後に来るテキストでソートできる。スラッシュの代わりにどんな non-letter でも使うことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			For example, to sort on the second comma-separated
			field: >
				:sort /[^,]*,/
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば、コンマで区切られた2番目のフィールドでソートするには:
@example
:sort /[^,]*,/
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			To sort on the text at virtual column 10 (thus
			ignoring the difference between tabs and spaces): >
				:sort /.*\%10v/
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
画面上の10桁目でソートするには(そのためタブとスペースは同一視される):
@example
:sort /.*\%10v/
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			To sort on the first number in the line, no matter
			what is in front of it: >
				:sort /.\{-}\ze\d/
<			(Explanation: ".\{-}" matches any text, "\ze" sets the
			end of the match and \d matches a digit.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
行中の最初の数字でソートするには:
@example
:sort /.\@{-@}\ze\d/
@end example
(解説: ".\@{-@}" は任意のテキストにマッチする。"\ze" はそのマッチの終わりをセットし、"\d" は数字にマッチする。)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			With [r] sorting is done on the matching {pattern}
			instead of skipping past it as described above.
			For example, to sort on only the first three letters
			of each line: >
				:sort /\a\a\a/ r
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[r] がつくと、前述のように @{pattern@} をスキップするのでなく、@{pattern@} にマッチする部分でソートする。例えば、各行の最初の 3 文字だけでソートするには:
@example
:sort /\a\a\a/ r
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<			If a {pattern} is used, any lines which don't have a
			match for {pattern} are kept in their current order,
			but separate from the lines which do match {pattern}.
			If you sorted in reverse, they will be in reverse
			order after the sorted lines, otherwise they will be
			in their original order, right before the sorted
			lines.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{pattern@} が使われると @{pattern@} を含まない行は現在の順序のままになる。逆順でソートすると、それらはソートされた行の後で逆順になる。逆順でなければ、ソートされた行の前でもとの順序のまま置かれる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			If {pattern} is empty (e.g. // is specified), the
			last search pattern is used.  This allows trying out
			a pattern first.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{pattern@} が空である場合 (例: // が指定されたとき)、最後に使われた検索パターンが使われる。よって、まず検索コマンドでパターンを確かめてみることができる。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that using `:sort` with `:global` doesn't sort the matching lines, it's
quite useless.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
`:global` といっしょに `:sort` を使ってもマッチする行をソートすることにはならない。これはまったく無意味である。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The details about sorting depend on the library function used.  There is no
guarantee that sorting obeys the current locale.  You will have to try it out.
Vim does do a "stable" sort.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ソートの詳細は使っているライブラリ関数による。ソートが現在のロケールに従うという保証はない。それを調べるには実行してみるしかない。ソートは「安定」ソートである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The sorting can be interrupted, but if you interrupt it too late in the
process you may end up with duplicated lines.  This also depends on the system
library function used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ソートは中断することができる。しかし中断するのが遅いと行が重複してしまうかもしれない。これも使っているシステムのライブラリ関数による。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 vim:tw=78:ts=8:ft=help:norl:
@end ifset
