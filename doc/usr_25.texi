@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@node テキストの整形, 繰り返し, 素早く入力する, 目次
@unnumbered テキストの整形
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*usr_25.txt*	For Vim version 8.0.  Last change: 2016 Mar 28

		     VIM USER MANUAL - by Bram Moolenaar

			     Editing formatted text
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{usr_25.txt}
@cindex usr_25.txt
@verbatim
*usr_25.txt*	For Vim バージョン 8.0.  Last change: 2016 Mar 28

		     VIM USER MANUAL - by Bram Moolenaar

				テキストの整形
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Text hardly ever comes in one sentence per line.  This chapter is about
breaking sentences to make them fit on a page and other formatting.
Vim also has useful features for editing single-line paragraphs and tables.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文章を 1 行に 1 文ずつ書くようなことはほとんどありません。この章では、テキストが画面に収まるように整形する方法などを説明します。
1 行段落や表を編集するための便利な機能もあります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|25.1|	Breaking lines
|25.2|	Aligning text
|25.3|	Indents and tabs
|25.4|	Dealing with long lines
|25.5|	Editing tables

     Next chapter: |usr_26.txt|  Repeating
 Previous chapter: |usr_24.txt|  Inserting quickly
Table of contents: |usr_toc.txt|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@menu
* 行を改行する:: 25.1
* テキストの位置揃え:: 25.2
* インデントとタブ:: 25.3
* 長い行の扱い:: 25.4
* 表の編集:: 25.5
@end menu
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*25.1*	Breaking lines
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{25.1}
@node 行を改行する
@section 行を改行する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim has a number of functions that make dealing with text easier.  By default,
the editor does not perform automatic line breaks.  In other words, you have
to press <Enter> yourself.  This is useful when you are writing programs where
you want to decide where the line ends.  It is not so good when you are
creating documentation and want the text to be at most 70 character wide.
   If you set the 'textwidth' option, Vim automatically inserts line breaks.
Suppose, for example, that you want a very narrow column of only 30
characters.  You need to execute the following command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文章を快適に編集するための機能がいくつかあります。初期設定では行は自動的に改行されません。つまり自分で @key{<Enter>} を押す必要があります。プログラムを書くときはその方が便利ですが、ドキュメントを書くときは少し不便です。文章が 70 桁の幅に収まるように自分で整形するのは大変でしょう。
'@option{textwidth}' オプションを設定すると、行が自動的に改行されるようになります。例えば、30 桁の幅で文章を書きたい場合は次のように設定します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set textwidth=30
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set textwidth=30
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now you start typing (ruler added):
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
そして、テキストを入力します (上の数字はルーラーです):
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		 1	   2	     3
	12345678901234567890123456789012345
	I taught programming for a whi ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
1        2         3
12345678901234567890123456789012345
I taught programming for a whi
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you type "l" next, this makes the line longer than the 30-character limit.
When Vim sees this, it inserts a line break and you get the following:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次に "l" を入力すると一行が 30 桁の制限を超えるので、自動的に改行が挿入されます。その結果、次のようになります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		 1	   2	     3
	12345678901234567890123456789012345
	I taught programming for a ~
	whil ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
1        2         3
12345678901234567890123456789012345
I taught programming for a
whil
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Continuing on, you can type in the rest of the paragraph:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
そのまま続けて文章の残りを入力しましょう:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		 1	   2	     3
	12345678901234567890123456789012345
	I taught programming for a ~
	while. One time, I was stopped ~
	by the Fort Worth police, ~
	because my homework was too ~
	hard. True story. ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
1        2         3
12345678901234567890123456789012345
I taught programming for a
while. One time, I was stopped
by the Fort Worth police,
because my homework was too
hard. True story.
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You do not have to type newlines; Vim puts them in automatically.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
自分で改行する必要はありません。改行は自動的に挿入されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Note:
	The 'wrap' option makes Vim display lines with a line break, but this
	doesn't insert a line break in the file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
'@option{wrap}' オプションを使うと長い行を改行して表示できますが、実際に改行文字が挿入されるわけではありません。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
REFORMATTING
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 再整形
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The Vim editor is not a word processor.  In a word processor, if you delete
something at the beginning of the paragraph, the line breaks are reworked.  In
Vim they are not; so if you delete the word "programming" from the first line,
all you get is a short line:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim はワードプロセッサーではありません。ワードプロセッサーなら、段落の最初の方で文字を削除すると、改行の位置が調整されますが、Vim は違います。つまり、1 行目の "@samp{programming}" を削除すると、単にその行が短くなるだけです:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		 1	   2	     3
	12345678901234567890123456789012345
	I taught for a ~
	while. One time, I was stopped ~
	by the Fort Worth police, ~
	because my homework was too ~
	hard. True story. ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
1        2         3
12345678901234567890123456789012345
I taught for a
while. One time, I was stopped
by the Fort Worth police,
because my homework was too
hard. True story.
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This does not look good.  To get the paragraph into shape you use the "gq"
operator.
   Let's first use this with a Visual selection.  Starting from the first
line, type: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはよくありません。"gq" オペレータを使って段落を整形しましょう。
まず、ビジュアルモードを使ってやってみます。1 行目に移動して次のように入力します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	v4jgq
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
v4jgq
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
"v" to start Visual mode, "4j" to move to the end of the paragraph and then
the "gq" operator.  The result is:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"v" はビジュアルモードの開始、"4j" で段落の最後まで移動し、"gq" オペレータを実行します。結果:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		 1	   2	     3
	12345678901234567890123456789012345
	I taught for a while. One ~
	time, I was stopped by the ~
	Fort Worth police, because my ~
	homework was too hard. True ~
	story. ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
1        2         3
12345678901234567890123456789012345
I taught for a while. One
time, I was stopped by the
Fort Worth police, because my
homework was too hard. True
story.
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: there is a way to do automatic formatting for specific types of text
layouts, see |auto-format|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
特定の書式に従った文章なら自動的に整形することもできます。|auto-format| 参照。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Since "gq" is an operator, you can use one of the three ways to select the
text it works on: With Visual mode, with a movement and with a text object.
   The example above could also be done with "gq4j".  That's less typing, but
you have to know the line count.  A more useful motion command is "}".  This
moves to the end of a paragraph.  Thus "gq}" formats from the cursor to the
end of the current paragraph.
   A very useful text object to use with "gq" is the paragraph.  Try this: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"gp" はオペレータなので、ビジュアルモード、カーソルモーション、テキストオブジェクト、の 3 つの方法で適用範囲を選択できます。
上記の例は "gq4j" とすることもできます。これはコマンドは短くなりますが、行数を数えないといけません。"@}" というモーションコマンドを使えばもっと簡単です。これは段落の末尾に移動するコマンドです。"gq@}" でカーソル位置から段落の末尾までが整形されます。
テキストオブジェクトを使うともっと簡単にできます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	gqap
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
gqap
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
"ap" stands for "a-paragraph".  This formats the text of one paragraph
(separated by empty lines).  Also the part before the cursor.
   If you have your paragraphs separated by empty lines, you can format the
whole file by typing this: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"ap" は "a-paragraph" という意味です。(空行区切りの) 1 つの段落が整形されます。カーソル位置より前の部分も範囲に入ります。
段落が空行で区切られているなら、次のコマンドでファイル全体を整形できます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	gggqG
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
gggqG
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
"gg" to move to the first line, "gqG" to format until the last line.
   Warning: If your paragraphs are not properly separated, they will be joined
together.  A common mistake is to have a line with a space or tab.  That's a
blank line, but not an empty line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"gg" でファイル先頭に移動し、"gqG" でファイル末尾まで整形します。
@quotation
@strong{警告:} @*
段落が適切に区切られていない場合、それらの文章は 1 つにつながってしまいます。スペースや Tab 文字だけの行があったりするのはよくあるミスです。それは空白行です。空行ではありません。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim is able to format more than just plain text.  See |fo-table| for how to
change this.  See the 'joinspaces' option to change the number of spaces used
after a full stop.
   It is possible to use an external program for formatting.  This is useful
if your text can't be properly formatted with Vim's builtin command.  See the
'formatprg' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
整形できるのは単純なプレーンテキストだけではありません。整形の設定については |fo-table| を参照してください。ピリオドの後ろに挿入されるスペースの数を変更するには '@option{joinspaces}' を参照してください。
外部プログラムを使って整形することもできます。Vim の組み込みコマンドで正しく整形できないようなテキストを編集するのに便利です。'@option{formatprg}' オプション参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*25.2*	Aligning text
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{25.2}
@node テキストの位置揃え
@section テキストの位置揃え
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To center a range of lines, use the following command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
テキストを中央揃えするには、次のコマンドを使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:{range}center [width]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:@{range@}center [width]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{range} is the usual command-line range.  [width] is an optional line width to
use for centering.  If [width] is not specified, it defaults to the value of
'textwidth'.  (If 'textwidth' is 0, the default is 80.)
   For example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{range@} は通常のコマンドライン範囲指定です。 [width] には中央揃えに使う行の幅を指定できます。 [width] を指定しなかった場合は '@option{textwidth}' の設定が使われます。('@option{textwidth}' が 0 なら 80 が使われます)
例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:1,5center 40
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:1,5center 40
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
results in the following:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のような結果になります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
       I taught for a while. One ~
       time, I was stopped by the ~
     Fort Worth police, because my ~
      homework was too hard. True ~
		 story. ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
  I taught for a while. One
  time, I was stopped by the
Fort Worth police, because my
 homework was too hard. True
            story.
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
RIGHT ALIGNMENT
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 右端揃え
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Similarly, the ":right" command right-justifies the text: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
同様に、右端揃えするには "@command{:right}" コマンドを使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:1,5right 37
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:1,5right 37
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
gives this result:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
結果:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	    I taught for a while. One ~
	   time, I was stopped by the ~
	Fort Worth police, because my ~
	  homework was too hard. True ~
			       story. ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
    I taught for a while. One
   time, I was stopped by the
Fort Worth police, because my
  homework was too hard. True
                       story.
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
LEFT ALIGNMENT
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 左端揃え
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Finally there is this command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のコマンドで左端揃えできます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:{range}left [margin]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:@{range@}left [margin]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Unlike ":center" and ":right", however, the argument to ":left" is not the
length of the line.  Instead it is the left margin.  If it is omitted, the
text will be put against the left side of the screen (using a zero margin
would do the same).  If it is 5, the text will be indented 5 spaces.  For
example, use these commands: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:center}" や "@command{:right}" と違い、"@command{:left}" の引数に指定する値は行の幅ではありません。左マージンを指定します。省略した場合は、文章は左端にぴったり寄せられます (マージンに 0 を指定したのと同じ)。5 を指定した場合は 5 つのスペースでインデントされます。例えば、次のように使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:1left 5
	:2,5left
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:1left 5
:2,5left
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This results in the following:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のような結果になります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	     I taught for a while. One ~
	time, I was stopped by the ~
	Fort Worth police, because my ~
	homework was too hard. True ~
	story. ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
     I taught for a while. One
time, I was stopped by the
Fort Worth police, because my
homework was too hard. True
story.
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
JUSTIFYING TEXT
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 両端揃え
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim has no built-in way of justifying text.  However, there is a neat macro
package that does the job.  To use this package, execute the following
command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
両端揃えするための組み込みコマンドはありません。しかし、そのためのマクロパッケージが用意されています。パッケージを使うには、次のコマンドを実行します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:packadd justify
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:packadd justify
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Or put this line in your |vimrc|: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
または次の行を |vimrc| に加えてください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	packadd! justify
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
packadd! justify
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This Vim script file defines a new visual command "_j".  To justify a block of
text, highlight the text in Visual mode and then execute "_j".
   Look in the file for more explanations.  To go there, do "gf" on this name:
$VIMRUNTIME/pack/dist/opt/justify/plugin/justify.vim.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しいビジュアルモードコマンド "@command{_j}" が定義されます。ビジュアルモードで範囲選択して "@command{_j}" を実行すればテキストを両端揃えできます。
詳しい説明はスクリプトファイルを参照してください。この名前の上で "@command{gf}" を使えばファイルを開けます: @file{$VIMRUNTIME/pack/dist/opt/justify/plugin/justify.vim}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An alternative is to filter the text through an external program.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
外部コマンドを使って整形することもできます。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:%!fmt
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:%!fmt
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*25.3*	Indents and tabs
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{25.3}
@node インデントとタブ
@section インデントとタブ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Indents can be used to make text stand out from the rest.  The example texts
in this manual, for example, are indented by eight spaces or a tab.  You would
normally enter this by typing a tab at the start of each line.  Take this
text:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
テキストをインデントすればその部分を目立たせることができます。例えばこのマニュアルでは、例文を示すときに 8 個のスペースまたは Tab 文字でインデントしています。通常なら行頭で Tab キーを押せばインデントできます。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	the first line ~
	the second line ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
the first line
the second line
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This is entered by typing a tab, some text, <Enter>, tab and more text.
   The 'autoindent' option inserts indents automatically: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@key{Tab} キーを押してテキストを挿入、@key{<Enter>}、また @key{Tab} キーを押してテキストを挿入します。
'@option{autoindent}' オプションを設定すると、自動的にインデントできます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set autoindent
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set autoindent
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When a new line is started it gets the same indent as the previous line.  In
the above example, the tab after the <Enter> is not needed anymore.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しい行を開始すると、直前の行と同じだけのインデントが挿入されます。上の例なら、@key{<Enter>} を押した後の @key{Tab} キーが必要なくなります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
INCREASING INDENT
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec インデントを増やす
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To increase the amount of indent in a line, use the ">" operator.  Often this
is used as ">>", which adds indent to the current line.
   The amount of indent added is specified with the 'shiftwidth' option.  The
default value is 8.  To make ">>" insert four spaces worth of indent, for
example, type this: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
行のインデント量を増やすには "@command{>}" オペレータを使います。現在行のインデントを増やしたい場合は "@command{>>}" を使うと簡単です。
インデントの増加量は '@option{shiftwidth}' オプションで設定できます。初期設定は 8 です。例えば、"@command{>>}" でスペース 4 つ分のインデントを増やしたい場合は次のように設定します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set shiftwidth=4
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set shiftwidth=4
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When used on the second line of the example text, this is what you get:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上記例文の 2 行目で ">>" を使うと、次のようになります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	the first line ~
	    the second line ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
the first line
    the second line
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
"4>>" will increase the indent of four lines.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"4>>" は 4 つの行のインデントを増やすコマンドです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
TABSTOP
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec タブストップ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to make indents a multiple of 4, you set 'shiftwidth' to 4.  But
when pressing a <Tab> you still get 8 spaces worth of indent.  To change this,
set the 'softtabstop' option: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
インデントを 4 桁にしたい場合は '@option{shiftwidth}' を 4 に設定します。しかしそれだけでは、@key{<Tab>} を押したときのインデントの量はスペース 8 個分のままです。これを変更するには '@option{softtabstop}' オプションを設定します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set softtabstop=4
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set softtabstop=4
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This will make the <Tab> key insert 4 spaces worth of indent.  If there are
already four spaces, a <Tab> character is used (saving seven characters in the
file).  (If you always want spaces and no tab characters, set the 'expandtab'
option.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これで、@key{<Tab>} キーがスペース 4 個分のインデントになります。既に 4 つスペースでインデントされている場合は <Tab> 文字に置き換えられます (7 バイト節約)。(Tab 文字を使いたくない場合は '@option{expandtab}' を設定してください。)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Note:
	You could set the 'tabstop' option to 4.  However, if you edit the
	file another time, with 'tabstop' set to the default value of 8, it
	will look wrong.  In other programs and when printing the indent will
	also be wrong.  Therefore it is recommended to keep 'tabstop' at eight
	all the time.  That's the standard value everywhere.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
'@option{tabstop}' オプションを 4 に設定することもできますが、その設定で編集したファイルを '@option{tabstop}' の初期設定 (@var{8}) で見ると見た目が崩れてしまいます。他のプログラムで印刷する場合もインデントが崩れてしまうかもしれません。したがって、'@option{tabstop}' は常に 8 のままにしておきましょう。それが標準的な値です。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
CHANGING TABS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec TAB 幅を変更する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You edit a file which was written with a tabstop of 3.  In Vim it looks ugly,
because it uses the normal tabstop value of 8.  You can fix this by setting
'tabstop' to 3.  But you have to do this every time you edit this file.
   Vim can change the use of tabstops in your file.  First, set 'tabstop' to
make the indents look good, then use the ":retab" command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
tabstop が 3 で書かれたファイルを (tabstop が 8 の) Vim で開くと表示が崩れてしまいます。'@option{tabstop}' を 3 に設定すれば表示を直すことができますが、ファイルを開くたびに設定を変更しなければなりません。
ファイルの tabstop 幅を変更することができます。インデントが正しく表示されるように '@option{tabstop}' を設定してから "@command{:retab}" コマンドを使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set tabstop=3
	:retab 8
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set tabstop=3
:retab 8
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The ":retab" command will change 'tabstop' to 8, while changing the text such
that it looks the same.  It changes spans of white space into tabs and spaces
for this.  You can now write the file.  Next time you edit it the indents will
be right without setting an option.
   Warning: When using ":retab" on a program, it may change white space inside
a string constant.  Therefore it's a good habit to use "\t" instead of a
real tab.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:retab}" コマンドを使って '@option{tabstop}' を 8 に変更しています。ただし、テキストの見た目は変更されません。空白部分が Tab 文字とスペースに置き換えられます。その状態でファイルを保存すれば、次からは設定を変更しなくてもインデントが正しく表示されます。
@quotation
@strong{警告:} @*
プログラムに対して "@command{:retab}" を使った場合、文字列定数の中の空白記号が変更されてしまうかもしれません。文字列定数の中では Tab 文字ではなく "\t" を使うようにしましょう。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*25.4*	Dealing with long lines
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{25.4}
@node 長い行の扱い
@section 長い行の扱い
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Sometimes you will be editing a file that is wider than the number of columns
in the window.  When that occurs, Vim wraps the lines so that everything fits
on the screen.
   If you switch the 'wrap' option off, each line in the file shows up as one
line on the screen.  Then the ends of the long lines disappear off the screen
to the right.
   When you move the cursor to a character that can't be seen, Vim will scroll
the text to show it.  This is like moving a viewport over the text in the
horizontal direction.
   By default, Vim does not display a horizontal scrollbar in the GUI.  If you
want to enable one, use the following command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ウィンドウの幅に収まりきらないようなファイルを編集することがあると思います。その場合、すべての行が画面に収まるように折り返して表示されます。
'@option{wrap}' オプションをオフにすると、すべての行が 1 行で表示されます。長い行の画面に収まりきらない部分は表示されません。
表示されていない部分にカーソルを動かすと、テキストがスクロールされ、その部分が表示されます。ウィンドウの枠を右に動かすような感じです。
初期設定では、GUI の水平スクロールバーは表示されません。表示したい場合は次のコマンドを使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set guioptions+=b
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set guioptions+=b
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
One horizontal scrollbar will appear at the bottom of the Vim window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim ウィンドウの下部に水平スクロールバーが表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you don't have a scrollbar or don't want to use it, use these commands to
scroll the text.  The cursor will stay in the same place, but it's moved back
into the visible text if necessary.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
スクロールバーが使えない、または使いたくない場合は、次のコマンドでテキストをスクロールしてください。カーソルは同じ位置にとどまりますが、画面外に出てしまうときは画面内に移動されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	zh		scroll right
	4zh		scroll four characters right
	zH		scroll half a window width right
	ze		scroll right to put the cursor at the end
	zl		scroll left
	4zl		scroll four characters left
	zL		scroll half a window width left
	zs		scroll left to put the cursor at the start
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .1 .8
@item @tab zh @tab 右にスクロール
@item @tab 4zh @tab 右に 4 文字分スクロール
@item @tab zH @tab 右にウィンドウの半分だけスクロール
@item @tab ze @tab カーソル位置が右端になるように右スクロール
@item @tab zl @tab 左にスクロール
@item @tab 4zl @tab 左に 4 文字分スクロール
@item @tab zL @tab 左にウィンドウの半分だけスクロール
@item @tab zs @tab カーソル位置が左端になるように左スクロール
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Let's attempt to show this with one line of text.  The cursor is on the "w" of
"which".  The "current window" above the line indicates the text that is
currently visible.  The "window"s below the text indicate the text that is
visible after the command left of it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例を使って説明します。カーソルは "@samp{which}" の "@samp{w}" にあります。上部の "@samp{current window}" はウィンドウに表示されている範囲を示しています。コマンド実行後の表示範囲を "@samp{window}" で示します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			      |<-- current window -->|
		some long text, part of which is visible in the window ~
	ze	  |<--	   window     -->|
	zH	   |<--     window     -->|
	4zh		  |<--	   window     -->|
	zh		     |<--     window	 -->|
	zl		       |<--	window	   -->|
	4zl			  |<--	   window     -->|
	zL				|<--	 window     -->|
	zs			       |<--	window	   -->|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
                      |<-- current window -->|
        some long text, part of which is visible in the window
ze        |<--     window     -->|
zH         |<--     window     -->|
4zh               |<--     window     -->|
zh                   |<--     window     -->|
zl                     |<--     window     -->|
4zl                       |<--     window     -->|
zL                              |<--     window     -->|
zs                             |<-- window     -->|
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MOVING WITH WRAP OFF
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 折り返し無しの場合の移動
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When 'wrap' is off and the text has scrolled horizontally, you can use the
following commands to move the cursor to a character you can see.  Thus text
left and right of the window is ignored.  These never cause the text to
scroll:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{wrap}' がオフで、テキストが水平スクロールされているとき、次のコマンドで画面の表示範囲を基準にして移動できます。ウィンドウの左右のテキストは無視されます。これらのコマンドはテキストをスクロールしません:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	g0		to first visible character in this line
	g^		to first non-blank visible character in this line
	gm		to middle of this line
	g$		to last visible character in this line
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .2 .7
@item @tab g0 @tab 行の右端に移動
@item @tab g^ @tab 行の右端の最初の非空白文字に移動
@item @tab gm @tab 行の中央に移動
@item @tab g$ @tab 行の左端に移動
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		|<--	 window    -->|
	some long    text, part of which is visible ~
		 g0  g^    gm	     g$
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
        |<--     window    -->|
some long    text, part of which is visible
         g0  g^    gm        g$
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
BREAKING AT WORDS				*edit-no-break*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{edit-no-break}
@cindex edit-no-break
@unnumberedsubsec 禁則処理
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When preparing text for use by another program, you might have to make
paragraphs without a line break.  A disadvantage of using 'nowrap' is that you
can't see the whole sentence you are working on.  When 'wrap' is on, words are
broken halfway, which makes them hard to read.
   A good solution for editing this kind of paragraph is setting the
'linebreak' option.  Vim then breaks lines at an appropriate place when
displaying the line.  The text in the file remains unchanged.
   Without 'linebreak' text might look like this:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
他のプログラムで使うテキストを編集する場合、1 つの段落を改行無しで書かなければならないことがあります。'@option{nowrap}' を使うと編集中の文全体を表示することができません。'@option{wrap}' をオンにすると単語の途中で行が折り返されて読み難くなってしまいます。
そのような場合は '@option{linebreak}' オプションを使ってください。適切な場所で行が折り返されるようになります。ファイルの内容は変更されません。
'@option{linebreak}' がオフの状態では次のように表示されますが:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	+---------------------------------+
	|letter generation program for a b|
	|ank.  They wanted to send out a s|
	|pecial, personalized letter to th|
	|eir richest 1000 customers.  Unfo|
	|rtunately for the programmer, he |
	+---------------------------------+
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
+---------------------------------+
|letter generation program for a b|
|ank.  They wanted to send out a s|
|pecial, personalized letter to th|
|eir richest 1000 customers.  Unfo|
|rtunately for the programmer, he |
+---------------------------------+
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
After: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{linebreak}' を設定すると:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set linebreak
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set linebreak
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
it looks like this:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のように表示されます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	+---------------------------------+
	|letter generation program for a  |
	|bank.  They wanted to send out a |
	|special, personalized letter to  |
	|their richest 1000 customers.    |
	|Unfortunately for the programmer,|
	+---------------------------------+
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
+---------------------------------+
|letter generation program for a  |
|bank.  They wanted to send out a |
|special, personalized letter to  |
|their richest 1000 customers.    |
|Unfortunately for the programmer,|
+---------------------------------+
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Related options:
'breakat' specifies the characters where a break can be inserted.
'showbreak' specifies a string to show at the start of broken line.
Set 'textwidth' to zero to avoid a paragraph to be split.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関連オプション:
@multitable @columnfractions .1 .2 .8
@item @tab 'breakat' @tab 折り返し可能な文字を指定する。
@item @tab 'showbreak' @tab 折り返された行の先頭に表示される文字。
@item @tab 'textwidth' @tab 0 に設定して段落が改行されないようにしてください。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MOVING BY VISIBLE LINES
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 表示行単位の移動
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "j" and "k" commands move to the next and previous lines.  When used on
a long line, this means moving a lot of screen lines at once.
   To move only one screen line, use the "gj" and "gk" commands.  When a line
doesn't wrap they do the same as "j" and "k".  When the line does wrap, they
move to a character displayed one line below or above.
   You might like to use these mappings, which bind these movement commands to
the cursor keys: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{j}" と "@command{k}" で上下の行に移動できますが、長い行の上で使うと、1 度に複数の表示行を移動することになります。
画面上で 1 行だけ移動したい場合は "@command{gj}" と "@command{gk}" を使ってください。行が折り返されていないときは "@command{j}" と "@command{k}" と同じ動作をします。折り返されているときは、画面上の 1 行だけ移動します。
次のようなマップを定義しておくと便利かもしれません:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:map <Up> gk
	:map <Down> gj
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:map <Up> gk
:map <Down> gj
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
TURNING A PARAGRAPH INTO ONE LINE			*edit-paragraph-join*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{edit-paragraph-join}
@cindex edit-paragraph-join
@unnumberedsubsec 段落を一行につなげる
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to import text into a program like MS-Word, each paragraph should
be a single line.  If your paragraphs are currently separated with empty
lines, this is how you turn each paragraph into a single line: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
MS-Word のようなプログラムにテキストをコピーするとき、段落は一行につながっていなければなりません。段落が空行で区切られているなら、次のコマンドでそれぞれの段落を一行につなげることができます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:g/./,/^$/join
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:g/./,/^$/join
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
That looks complicated.  Let's break it up in pieces:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
すこし複雑ですね。分解して説明します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:g/./		A ":global" command that finds all lines that contain
			at least one character.
	     ,/^$/	A range, starting from the current line (the non-empty
			line) until an empty line.
		  join	The ":join" command joins the range of lines together
			into one line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .1 .8
@item @tab :g/./ @tab 1 文字以上の文字を含んでいる行を探す "@command{:global}" コマンド
@item @tab ,/^$/ @tab 現在行(非空行)から空行までの範囲を指定
@item @tab join @tab 指定された範囲の行を "@command{:join}" コマンドで 1 行につなげる
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Starting with this text, containing eight lines broken at column 30:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
30 桁で改行された次のようなテキストが:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	+----------------------------------+
	|A letter generation program	   |
	|for a bank.  They wanted to	   |
	|send out a special,		   |
	|personalized letter.		   |
	|				   |
	|To their richest 1000		   |
	|customers.  Unfortunately for	   |
	|the programmer,		   |
	+----------------------------------+
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
+----------------------------------+
|A letter generation program       |
|for a bank.  They wanted to       |
|send out a special,               |
|personalized letter.              |
|                                  |
|To their richest 1000             |
|customers.  Unfortunately for     |
|the programmer,                   |
+----------------------------------+
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You end up with two lines:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2 行にまとめられます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	+----------------------------------+
	|A letter generation program for a |
	|bank.	They wanted to send out a s|
	|pecial, personalized letter.	   |
	|To their richest 1000 customers.  |
	|Unfortunately for the programmer, |
	+----------------------------------+
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
+----------------------------------+
|A letter generation program for a |
|bank.  They wanted to send out a s|
|pecial, personalized letter.      |
|To their richest 1000 customers.  |
|Unfortunately for the programmer, |
+----------------------------------+
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that this doesn't work when the separating line is blank but not empty;
when it contains spaces and/or tabs.  This command does work with blank lines:
>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
スペースや Tab 文字を含んでいる空白行 (空行ではない) で段落が区切られている場合、上記のコマンドは機能しません。次のコマンドは空白行でも機能します:
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:g/\S/,/^\s*$/join
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:g/\S/,/^\s*$/join
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This still requires a blank or empty line at the end of the file for the last
paragraph to be joined.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最後の段落を処理するには、ファイル末尾に空行または空白行が必要です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*25.5*	Editing tables
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{25.5}
@node 表の編集
@section 表の編集
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Suppose you are editing a table with four columns:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のような 4 列の表を編集していて:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	nice table	  test 1	test 2	    test 3 ~
	input A		  0.534 ~
	input B		  0.913 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .25 .25 .25 .25
@item nice table @tab test 1 @tab test 2 @tab test 3
@item input A @tab 0.534 @tab @tab 
@item input B @tab 0.913 @tab @tab 
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You need to enter numbers in the third column.  You could move to the second
line, use "A", enter a lot of spaces and type the text.
   For this kind of editing there is a special option: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
4 列目に数字を入力したいと思いました。2 行目に移動して "A" を使い、いくつかスペースとテキストを入力すればできます。
このような編集のための特別なオプションがあります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	set virtualedit=all
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
set virtualedit=all
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now you can move the cursor to positions where there isn't any text.  This is
called "virtual space".  Editing a table is a lot easier this way.
   Move the cursor by searching for the header of the last column: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これを設定すると、文字が無い場所にもカーソルを移動できるようになります。これを "virtual space" (仮想空白) と呼びます。この方法を使えば簡単に表を編集できます。
検索を実行して 4 列目のヘッダーに移動します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	/test 3
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
/test 3
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now press "j" and you are right where you can enter the value for "input A".
Typing "0.693" results in:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"j" を押すとカーソルが適切な場所に移動するので、そのまま "input A" の値を入力できます。"0.693" と入力します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	nice table	  test 1     test 2	 test 3 ~
	input A		  0.534			 0.693 ~
	input B		  0.913 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .25 .25 .25 .25
@item nice table @tab test 1 @tab test 2 @tab test 3
@item input A @tab 0.534 @tab @tab 0.693
@item input B @tab 0.913 @tab @tab 
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim has automatically filled the gap in front of the new text for you.  Now,
to enter the next field in this column use "Bj".  "B" moves back to the start
of a white space separated word.  Then "j" moves to the place where the next
field can be entered.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
テキストが無かった部分は空白で埋められます。"@command{Bj}" コマンドを使って次の行に移動しましょう。"B" で単語の先頭に移動し、"j" で次のフィールドに移動します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Note:
	You can move the cursor anywhere in the display, also beyond the end
	of a line.  But Vim will not insert spaces there, until you insert a
	character in that position.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
画面上のどの場所にでもカーソルを移動できます。行末を超えて移動することもできます。文字を挿入しない限り、スペースは挿入されません。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
COPYING A COLUMN
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 列のコピー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You want to add a column, which should be a copy of the third column and
placed before the "test 1" column.  Do this in seven steps:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
4 列目をコピーして "test 1" 列の前に追加します。次の手順でできます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
1.  Move the cursor to the left upper corner of this column, e.g., with
    "/test 3".
2.  Press CTRL-V to start blockwise Visual mode.
3.  Move the cursor down two lines with "2j".  You are now in "virtual space":
    the "input B" line of the "test 3" column.
4.  Move the cursor right, to include the whole column in the selection, plus
    the space that you want between the columns.  "9l" should do it.
5.  Yank the selected rectangle with "y".
6.  Move the cursor to "test 1", where the new column must be placed.
7.  Press "P".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item カーソルを列の左上隅に移動する。例: "/test 3"。
@item CTRL-V を押して矩形選択開始。
@item "2j" で二行下に移動。カーソルは仮想空白の上 ("input B" 行の "test 3" 列)
@item 右に移動して列全体を選択。列を区切るためのスペースも選択する。例えば "9l" で移動する。
@item "y" で選択範囲をヤンク。
@item カーソルを "text 1" に移動。この場所に新しい列を挿入する。
@item "P" を押す。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The result should be:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
結果は次のようになります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	nice table	  test 3    test 1     test 2	   test 3 ~
	input A		  0.693     0.534		   0.693 ~
	input B			    0.913 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .20 .20 .20 .20 .20
@item nice table @tab test 3 @tab test 1 @tab test 2 @tab test 3
@item input A @tab 0.693 @tab 0.534 @tab @tab 0.693
@item input B @tab @tab 0.913 @tab @tab
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Notice that the whole "test 1" column was shifted right, also the line where
the "test 3" column didn't have text.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"test 1" 列全体が右側に押し出されます。"test 3" 列のテキストが無い行も同様に移動していますね。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Go back to non-virtual cursor movements with: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のコマンドでカーソル移動を通常に戻せます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set virtualedit=
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set virtualedit=
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
VIRTUAL REPLACE MODE
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec バーチャル置換モード
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The disadvantage of using 'virtualedit' is that it "feels" different.  You
can't recognize tabs or spaces beyond the end of line when moving the cursor
around.  Another method can be used: Virtual Replace mode.
   Suppose you have a line in a table that contains both tabs and other
characters.  Use "rx" on the first tab:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{virtualedit}' の不便なところは感覚が狂ってしまうところです。カーソルを動かしているときに、カーソルが Tab 文字の上にあるのか、行末を越えた位置にあるのか、認識することができません。そこで「バーチャル置換モード」を使います。
例えば、表の中で Tab 文字が使われているとします。その Tab 文字の上で "rx" を使ってみます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	inp	0.693   0.534	0.693 ~

	       |
	   rx  |
	       V

	inpx0.693   0.534	0.693 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
inp     0.693   0.534   0.693

       |
   rx  |
       V

inpx0.693   0.534       0.693
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The layout is messed up.  To avoid that, use the "gr" command:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
レイアウトが崩れてしまいました。こうならないように、"gr" コマンドを使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	inp	0.693   0.534	0.693 ~

	       |
	  grx  |
	       V

	inpx	0.693   0.534	0.693 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
inp     0.693   0.534   0.693

       |
  grx  |
       V

inpx    0.693   0.534   0.693
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
What happens is that the "gr" command makes sure the new character takes the
right amount of screen space.  Extra spaces or tabs are inserted to fill the
gap.  Thus what actually happens is that a tab is replaced by "x" and then
blanks added to make the text after it keep its place.  In this case a
tab is inserted.
   When you need to replace more than one character, you use the "R" command
to go to Replace mode (see |04.9|).  This messes up the layout and replaces
the wrong characters:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{gr}" コマンドで置換すると、置換した結果がスクリーン上で同じ幅になるように調整されます。足りない分はスペースか Tab 文字で埋められます。つまり上の例は、Tab 文字が "x" で置換され、残りの部分を埋めるように空白が追加されたのです。例では Tab 文字が挿入されてます。
複数の文字を置き換えたい場合は "@command{R}" コマンドの置換モード (|@ref{04.9, , 04.9}|参照) を使いますが、それだとレイアウトが崩れて意図しない文字が置換されてしまいます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	inp	0	0.534	0.693 ~

		|
	 R0.786 |
		V

	inp	0.78634	0.693 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
inp     0       0.534   0.693

        |
 R0.786 |
        V

inp     0.78634 0.693
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "gR" command uses Virtual Replace mode.  This preserves the layout:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{gR}" コマンドのバーチャル置換モードを使いましょう。これならレイアウトは崩れません:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	inp	0	0.534	0.693 ~

		|
	gR0.786 |
		V

	inp	0.786	0.534	0.693 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
inp     0       0.534   0.693

        |
gR0.786 |
        V

inp     0.786   0.534   0.693
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================

Next chapter: |usr_26.txt|  Repeating

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
@end ifset
