@ifset JA  @c ----------- v -----------  JA  -*- tab-width: 8 -*-
@node usr_24.txt, usr_25.txt, usr_23.txt, 目次
@unnumbered 素早く入力する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*usr_24.txt*	For Vim version 8.0.  Last change: 2018 Mar 18

		     VIM USER MANUAL - by Bram Moolenaar

			     Inserting quickly
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex usr_24.txt
@verbatim
*usr_24.txt*	For Vim バージョン 8.0.  Last change: 2018 Mar 18

		     VIM USER MANUAL - by Bram Moolenaar

				素早く入力する
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
When entering text, Vim offers various ways to reduce the number of keystrokes
and avoid typing mistakes.  Use Insert mode completion to repeat previously
typed words.  Abbreviate long words to short ones.  Type characters that
aren't on your keyboard.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
テキストを入力するときに、キーストロークを減らしたり入力ミスを防いだりする方法がいくつかあります。補完機能を使えば以前に入力した単語を繰り返し入力できます。長い単語を短縮形で入力することもできます。キーボードに無い文字を入力する方法もあります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|24.1|	Making corrections
|24.2|	Showing matches
|24.3|	Completion
|24.4|	Repeating an insert
|24.5|	Copying from another line
|24.6|	Inserting a register
|24.7|	Abbreviations
|24.8|	Entering special characters
|24.9|	Digraphs
|24.10|	Normal mode commands

     Next chapter: |usr_25.txt|  Editing formatted text
 Previous chapter: |usr_23.txt|  Editing other files
Table of contents: |usr_toc.txt|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item |@ref{24.1, , 24.1}| @tab 修正する
@item |@ref{24.2, , 24.2}| @tab 対応する括弧を表示する
@item |@ref{24.3, , 24.3}| @tab 補完
@item |@ref{24.4, , 24.4}| @tab 挿入を繰り返す
@item |@ref{24.5, , 24.5}| @tab 隣の行からコピーする
@item |@ref{24.6, , 24.6}| @tab レジスタを挿入する
@item |@ref{24.7, , 24.7}| @tab 短縮形 (Abbreviations)
@item |@ref{24.8, , 24.8}| @tab 特殊な文字を入力する
@item |@ref{24.9, , 24.9}| @tab ダイグラフ (Digraph)
@item |@ref{24.10, , 24.10}| @tab ノーマルモードコマンド
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*24.1*	Making corrections
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{24.1}
@section 修正する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The <BS> key was already mentioned.  It deletes the character just before the
cursor.  The <Del> key does the same for the character under (after) the
cursor.
   When you typed a whole word wrong, use CTRL-W:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@key{<BS>} キーは既に説明しましたね。@key{<BS>} はカーソル直前の文字を削除します。@key{<Del>} キーはカーソルの下(後)の文字を削除します。

直前の単語をまるごと削除したい場合は @kbd{CTRL-W} を使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	The horse had fallen to the sky ~
				       CTRL-W
	The horse had fallen to the ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
The horse had fallen to the sky
              CTRL-W
The horse had fallen to the
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you really messed up a line and want to start over, use CTRL-U to delete
it.  This keeps the text after the cursor and the indent.  Only the text from
the first non-blank to the cursor is deleted.  With the cursor on the "f" of
"fallen" in the next line pressing CTRL-U does this:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
行全体を削除して行頭から入力しなおしたい場合は @kbd{CTRL-U} を使います。カーソルより後ろの文字とインデントは削除されません。最初の非空白文字からカーソルまでのテキストだけが削除されます。例えば、カーソルが "@samp{fallen}" の "@samp{f}" にある場合、@kbd{CTRL-U} を押すと次のようになります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	The horse had fallen to the ~
		      CTRL-U
	fallen to the ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
The horse had fallen to the
          CTRL-U
fallen to the
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you spot a mistake a few words back, you need to move the cursor there to
correct it.  For example, you typed this:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
何個か前の単語だけを修正したい場合はカーソルを動かす必要があります。例えば、次のように入力してから:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	The horse had follen to the ground ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
The horse had follen to the ground
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You need to change "follen" to "fallen".  With the cursor at the end, you
would type this to correct it: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
途中にある "@samp{follen}" を "@samp{fallen}" に修正してみます。カーソルが末尾にある場合、次のように入力すれば修正できます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					<Esc>4blraA
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
<Esc>4blraA
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<	get out of Insert mode		<Esc>
	four words back			     4b
	move on top of the "o"		       l
	replace with "a"			ra
	restart Insert mode			  A
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .85 .15
@item 挿入モードを抜ける @tab <Esc>
@item 4 単語戻る @tab 4b
@item 最初の "o" に移動する @tab l
@item "a" に置換する @tab ra
@item 行末に移動して挿入モードを再開 @tab A
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Another way to do this: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
他の方法もあります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		<C-Left><C-Left><C-Left><C-Left><Right><Del>a<End>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
<C-Left><C-Left><C-Left><C-Left><Right><Del>a<End>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<	four words back		     <C-Left><C-Left><C-Left><C-Left>
	move on top of the "o"			<Right>
	delete the "o"				       <Del>
	insert an "a"					    a
	go to end of the line				     <End>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item 4 単語戻る。 @tab <C-Left><C-Left><C-Left><C-Left>
@item 最初の "o" に移動する @tab <Right>
@item "o" を削除する @tab <Del>
@item "a" を挿入する @tab a
@item 行末に移動する @tab <End>
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This uses special keys to move around, while remaining in Insert mode.  This
resembles what you would do in a modeless editor.  It's easier to remember,
but takes more time (you have to move your hand from the letters to the cursor
keys, and the <End> key is hard to press without looking at the keyboard).
   These special keys are most useful when writing a mapping that doesn't
leave Insert mode.  The extra typing doesn't matter then.
   An overview of the keys you can use in Insert mode:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
挿入モードの中で特殊キーを使って移動しています。これは普通のモードレスエディタの操作と似ています。操作方法は覚えやすいかもしれませんが少し面倒です (カーソルキーを押すには手をホームポジションから離さなければならないし、@key{<End>} キーを押すにはキーボードに視線を移さなければならない)。

特殊キーは挿入モードの中で使えるのでマップを書くときに重宝します。マップの中で使う分には入力が面倒になることもありません。

挿入モードでは次の特殊キーが使えます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	<C-Home>	to start of the file
	<PageUp>	a whole screenful up
	<Home>		to start of line
	<S-Left>	one word left
	<C-Left>	one word left
	<S-Right>	one word right
	<C-Right>	one word right
	<End>		to end of the line
	<PageDown>	a whole screenful down
	<C-End>		to end of the file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item <C-Home> @tab ファイルの先頭に移動
@item <PageUp> @tab 1 画面分、逆スクロール
@item <Home> @tab 行頭へ移動
@item <S-Left> @tab 1 単語左へ移動
@item <C-Left> @tab 1 単語左へ移動
@item <S-Right> @tab 1 単語右へ移動
@item <C-Right> @tab 1 単語右へ移動
@item <End> @tab 行末へ移動
@item <PageDown> @tab 1 画面分、スクロール
@item <C-End> @tab ファイルの末尾に移動
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are a few more, see |ins-special-special|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
使えるキーは他にもあります。|ins-special-special| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*24.2*	Showing matches
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{24.2}
@section 対応する括弧を表示する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you type a ) it would be nice to see with which ( it matches.  To make
Vim do that use this command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@samp{)}" を入力したときに、対応する "@samp{(}" の場所を確認できたら便利ですよね。次のコマンドでそのように設定できます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set showmatch
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set showmatch
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you now type a text like "(example)", as soon as you type the ) Vim will
briefly move the cursor to the matching (, keep it there for half a second,
and move back to where you were typing.
   In case there is no matching (, Vim will beep.  Then you know that you
might have forgotten the ( somewhere, or typed a ) too many.
   The match will also be shown for [] and {} pairs.  You don't have to wait
with typing the next character, as soon as Vim sees it the cursor will move
back and inserting continues as before.
   You can change the time Vim waits with the 'matchtime' option.  For
example, to make Vim wait one and a half second: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば "@samp{(example)}" と入力したとき、"@samp{)}" を入力した瞬間に、対応する括弧にカーソルが移動します。カーソルは 0.5 秒くらいその場所に留まり、再び元の場所に帰ってきます。

対応する括弧が見つからなかった場合はビープ音が鳴ります。そのときは、@samp{(} を入力し忘れてないか、@samp{)} を入力し過ぎてないか、確認しましょう。

この機能は、@samp{[]} や @samp{@{@}} の組み合わせにも対応しています。カーソルが移動しているときに、戻ってくるまで次の入力を待つ必要はありません。次の文字を入力した瞬間にカーソルは元に戻るので、すぐに入力を再開できます。

カーソルが移動先で待機する時間は '@option{matchtime}' オプションで設定できます。例えば、1.5 秒待機するには次のように設定します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set matchtime=15
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set matchtime=15
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The time is specified in tenths of a second.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
時間は 1/10 秒単位で指定してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*24.3*	Completion
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{24.3}
@section 補完
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim can automatically complete words on insertion.  You type the first part of
a word, press CTRL-P, and Vim guesses the rest.
   Suppose, for example, that you are creating a C program and want to type in
the following:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
テキストの中から単語を検索して補完することができます。単語の出だしを入力して @kbd{CTRL-P} を押すと、残りの部分が入力されます。

例えば、C プログラムを書いていて、次のように入力したいとします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	total = ch_array[0] + ch_array[1] + ch_array[2]; ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
total = ch_array[0] + ch_array[1] + ch_array[2];
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You start by entering the following:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
まず、次のように入力してください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	total = ch_array[0] + ch_ ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
total = ch_array[0] + ch_
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
At this point, you tell Vim to complete the word using the command CTRL-P.
Vim searches for a word that starts with what's in front of the cursor.  In
this case, it is "ch_", which matches with the word ch_array.  So typing
CTRL-P gives you the following:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここで、@kbd{CTRL-P} コマンドを使って単語を補完します。カーソル直前の文字列にマッチする単語が検索されます。この場合なら、"@samp{ch_}" にマッチする単語、つまり "@samp{ch_array}" がヒットします。したがって、@kbd{CTRL-P} を押すと次のようになります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	total = ch_array[0] + ch_array ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
total = ch_array[0] + ch_array
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
After a little more typing, you get this (ending in a space):
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
続けて入力し、次のようになりました (末尾に空白があります):
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	total = ch_array[0] + ch_array[1] +  ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
total = ch_array[0] + ch_array[1] +
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you now type CTRL-P Vim will search again for a word that completes the
word before the cursor.  Since there is nothing in front of the cursor, it
finds the first word backwards, which is "ch_array".  Typing CTRL-P again
gives you the next word that matches, in this case "total".  A third CTRL-P
searches further back.  If there is nothing else, it causes the editor to run
out of words, so it returns to the original text, which is nothing.  A fourth
CTRL-P causes the editor to start over again with "ch_array".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
さて、ここで @kbd{CTRL-P} を押すと再びカーソル直前の文字列が補完されます。今回は文字が無いので、最初に見つかった単語、つまり "@samp{ch_array}" が補完されます。もう一度 @kbd{CTRL-P} を押すと、さらに次の候補が補完されます。この場合は "total" です。もう一度 @kbd{CTRL-P} を押せばさらに次の候補が補完されます。次の単語が見つからなかった場合は元の文字列に戻ります。この例では空文字列です。4 度目に @kbd{CTRL-P} を押すと再び最初の "ch_array" が補完されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To search forward, use CTRL-N.  Since the search wraps around the end of the
file, CTRL-N and CTRL-P will find the same matches, but in a different
sequence.  Hint: CTRL-N is Next-match and CTRL-P is Previous-match.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
前方検索する場合は @kbd{CTRL-N} を使います。検索はファイル終端を超えて処理されるので、@kbd{CTRL-N} と @kbd{CTRL-P} は順番が違うだけで、同じ単語が検索されます。
@strong{Hint:} @kbd{CTRL-N} は Next-match (次の候補)、@kbd{CTRL-P} は Previous-match (前の候補) です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The Vim editor goes through a lot of effort to find words to complete.  By
default, it searches the following places:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
単語の補完では、様々な場所から単語を検索できます。初期設定では、次の場所が検索されます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	1. Current file
	2. Files in other windows
	3. Other loaded files (hidden buffers)
	4. Files which are not loaded (inactive buffers)
	5. Tag files
	6. All files #included by the current file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item カレントファイル
@item 他のウィンドウのファイル
@item ロードされたファイル (隠しバッファ)
@item ロードされてないファイル (休眠バッファ)
@item タグファイル
@item カレントファイルが #include しているファイル
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
OPTIONS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec オプション
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can customize the search order with the 'complete' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
検索場所の順番は '@option{complete}' オプションで設定できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The 'ignorecase' option is used.  When it is set, case differences are ignored
when searching for matches.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
検索には '@option{ignorecase}' オプションが使われます。このオプションがオンのときは、大文字と小文字は区別されません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A special option for completion is 'infercase'.  This is useful to find
matches while ignoring case ('ignorecase' must be set) but still using the
case of the word typed so far.  Thus if you type "For" and Vim finds a match
"fortunately", it will result in "Fortunately".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{infercase}' は補完用の特別なオプションです。大文字と小文字を区別しない ('@option{ignorecase}' がオンに設定されている) ときでも、自分で入力した文字の種類をそのまま使えます。つまり、"@samp{For}" と入力して "@samp{fortunately}" がマッチしたとき、結果は "@samp{Fortunately}" になります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
COMPLETING SPECIFIC ITEMS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 補完タイプの指定
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you know what you are looking for, you can use these commands to complete
with a certain type of item:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
補完したい単語の種類がわかっている場合は、次のコマンドで補完の種類を指定できます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-X CTRL-F		file names
	CTRL-X CTRL-L		whole lines
	CTRL-X CTRL-D		macro definitions (also in included files)
	CTRL-X CTRL-I		current and included files
	CTRL-X CTRL-K		words from a dictionary
	CTRL-X CTRL-T		words from a thesaurus
	CTRL-X CTRL-]		tags
	CTRL-X CTRL-V		Vim command line
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item CTRL-X CTRL-F @tab ファイル名
@item CTRL-X CTRL-L @tab 行全体
@item CTRL-X CTRL-D @tab マクロ定義 (インクルードファイルの中も探す)
@item CTRL-X CTRL-I @tab カレントファイルとインクルードファイル
@item CTRL-X CTRL-K @tab 辞書
@item CTRL-X CTRL-T @tab 同義語辞書 (シソーラス)
@item CTRL-X CTRL-] @tab タグ
@item CTRL-X CTRL-V @tab Vim のコマンドライン
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
After each of them CTRL-N can be used to find the next match, CTRL-P to find
the previous match.
   More information for each of these commands here: |ins-completion|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
補完を実行した後は、@kbd{CTRL-N} で次の候補、@kbd{CTRL-P} で前の候補を検索できます。
各コマンドの詳細は |ins-completion| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
COMPLETING FILE NAMES
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec ファイル名の補完
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Let's take CTRL-X CTRL-F as an example.  This will find file names.  It scans
the current directory for files and displays each one that matches the word in
front of the cursor.
   Suppose, for example, that you have the following files in the current
directory:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例として @kbd{CTRL-X} @kbd{CTRL-F} を使って説明します。これはファイル名を補完するコマンドです。カレントディレクトリのファイルが検索され、カーソル直前の文字列にマッチするファイル名が補完されます。

例えば、カレントディレクトリに次のファイルがあるとします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	main.c  sub_count.c  sub_done.c  sub_exit.c
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
main.c  sub_count.c  sub_done.c  sub_exit.c
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now enter Insert mode and start typing:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
挿入モードに入って次のように入力します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	The exit code is in the file sub ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
The exit code is in the file sub
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
At this point, you enter the command CTRL-X CTRL-F.  Vim now completes the
current word "sub" by looking at the files in the current directory.  The
first match is sub_count.c.  This is not the one you want, so you match the
next file by typing CTRL-N.  This match is sub_done.c.  Typing CTRL-N again
takes you to sub_exit.c.  The results:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
そして、@kbd{CTRL-X} @kbd{CTRL-F} を入力します。カレントディレクトリから "sub" にマッチするファイルが検索されます。最初にマッチするのは @file{sub_count.c} です。このファイルは求めているファイルではありませんでした。@kbd{CTRL-N} を押して次の候補を検索しましょう。次に @file{sub_done.c} がマッチします。もう一度 @kbd{CTRL-N} を押すと @file{sub_exit.c} がマッチします。結果:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	The exit code is in the file sub_exit.c ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
The exit code is in the file sub_exit.c
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the file name starts with / (Unix) or C:\ (MS-Windows) you can find all
files in the file system.  For example, type "/u" and CTRL-X CTRL-F.  This
will match "/usr" (this is on Unix):
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイル名の先頭を @samp{/} (Unix) や @samp{C:\} (MS-Windows) で開始すれば、ファイルシステム全体からファイルを検索できます。例えば、"/u" と入力してから @kbd{CTRL-X} @kbd{CTRL-F} と入力すると "/usr" がヒットします (Unix の場合):
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	the file is found in /usr/ ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
the file is found in /usr/
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you now press CTRL-N you go back to "/u".  Instead, to accept the "/usr/"
and go one directory level deeper, use CTRL-X CTRL-F again:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もう一度 @kbd{CTRL-N} を押すと "/u" に戻ってしまいます。"/usr/" を確定してからさらに深い階層へ進みたい場合は再び @kbd{CTRL-X} @kbd{CTRL-F} を使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	the file is found in /usr/X11R6/ ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
the file is found in /usr/X11R6/
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The results depend on what is found in your file system, of course.  The
matches are sorted alphabetically.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もちろん、ファイル構成が違えば結果は異なるでしょう。検索結果はアルファベット順にソートされます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
COMPLETING IN SOURCE CODE
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec ソースコードの補完
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Source code files are well structured.  That makes it possible to do
completion in an intelligent way.  In Vim this is called Omni completion.  In
some other editors it's called intellisense, but that is a trademark.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ソースコードは書式が決まっているので、より賢い補完を実装することができます。Vim ではそれをオムニ補完 (Omni completion) と呼びます。某エディタではインテリセンスと呼ばれていますが、それは商標です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The key to Omni completion is CTRL-X CTRL-O.  Obviously the O stands for Omni
here, so that you can remember it easier.  Let's use an example for editing C
source:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オムニ補完のキーは @kbd{CTRL-X} @kbd{CTRL-O} です。O は Omni の頭文字なので覚えやすいでしょう。C 言語のソースを使って説明します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	{ ~
	    struct foo *p; ~
	    p-> ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
{
    struct foo *p;
    p->
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The cursor is after "p->".  Now type CTRL-X CTRL-O.  Vim will offer you a list
of alternatives, which are the items that "struct foo" contains.  That is
quite different from using CTRL-P, which would complete any word, while only
members of "struct foo" are valid here.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カーソルは "@samp{p->}" の後ろにあります。@kbd{CTRL-X} @kbd{CTRL-O} を押すと、"struct foo" のメンバが候補として表示されます。これは @kbd{CTRL-P} の補完とはまったく違います。@kbd{CTRL-P} ではあらゆる単語が候補になりますが、オムニ補完は "struct foo" のメンバだけが補完されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For Omni completion to work you may need to do some setup.  At least make sure
filetype plugins are enabled.  Your vimrc file should contain a line like
this: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オムニ補完を使うには設定が必要です。最低でもファイルタイププラグインを有効にしておく必要があります。vimrc に以下の行を書き加えてください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	filetype plugin on
Or: >
	filetype plugin indent on
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
        filetype plugin on
または:
        filetype plugin indent on
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For C code you need to create a tags file and set the 'tags' option.  That is
explained |ft-c-omni|.  For other filetypes you may need to do something
similar, look below |compl-omni-filetypes|.  It only works for specific
filetypes.  Check the value of the 'omnifunc' option to find out if it would
work.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
C 言語の場合はタグファイルを作成して '@option{tags}' オプションを設定する必要があります。|ft-c-omni| を参照してください。他のファイルタイプでも似たような設定が必要になります。|compl-omni-filetypes| を参照してください。オムニ補完は特定のファイルタイプでしか利用できません。'@option{omnifunc}' オプションを確認し、オムニ補完が利用できるかどうか確認してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*24.4*	Repeating an insert
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{24.4}
@section 挿入を繰り返す
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you press CTRL-A, the editor inserts the text you typed the last time you
were in Insert mode.
   Assume, for example, that you have a file that begins with the following:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-A} を押すと、前回の挿入モードで入力したテキストを挿入できます。

例えば、次のようなファイルがあったとします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	"file.h" ~
	/* Main program begins */ ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
"file.h"
/* Main program begins */
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You edit this file by inserting "#include " at the beginning of the first
line:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
1 行目の行頭に "#include " を挿入します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	#include "file.h" ~
	/* Main program begins */ ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
#include "file.h"
/* Main program begins */
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You go down to the beginning of the next line using the commands "j^".  You
now start to insert a new "#include" line.  So you type: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{j^}" コマンドで次の行の行頭に移動し、再び "#include " を挿入してみます。次のように入力しましょう:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	i CTRL-A
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
i CTRL-A
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The result is as follows:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
結果は次のようになります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	#include "file.h" ~
	#include /* Main program begins */ ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
#include "file.h" ~
#include /* Main program begins */
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "#include " was inserted because CTRL-A inserts the text of the previous
insert.  Now you type  "main.h"<Enter>  to finish the line:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-A} は前回に入力したテキストを挿入するコマンドなので、"#include " が挿入されました。続けて "main.h" @key{<Enter>} と入力し、行を完成させましょう:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
	#include "file.h" ~
	#include "main.h" ~
	/* Main program begins */ ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
#include "file.h"
#include "main.h"
/* Main program begins */
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The CTRL-@ command does a CTRL-A and then exits Insert mode.  That's a quick
way of doing exactly the same insertion again.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-@@} コマンドは @kbd{CTRL-A} と同じことを実行してから挿入モードを抜けます。まったく同じ挿入を繰り返したいときに使います。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*24.5*	Copying from another line
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{24.5}
@section 隣の行からコピーする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The CTRL-Y command inserts the character above the cursor.  This is useful
when you are duplicating a previous line.  For example, you have this line of
C code:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-Y} コマンドを使うと、カーソルの上の文字を挿入できます。一つ上の行を複製したい場合に便利です。例えば、次のような C 言語のコードがあるとして:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	b_array[i]->s_next = a_array[i]->s_next; ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
b_array[i]->s_next = a_array[i]->s_next;
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now you need to type the same line, but with "s_prev" instead of "s_next".
Start the new line, and press CTRL-Y 14 times, until you are at the "n" of
"next":
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"s_next" を "s_prev" に変えただけの同じ行を入力してみます。新しい行を開いて @kbd{CTRL-Y} を 14 回押して、"next" の "n" の直前まで進みます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_ ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
b_array[i]->s_next = a_array[i]->s_next;
b_array[i]->s_
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now you type "prev":
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
そして "prev" と入力します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_prev ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
b_array[i]->s_next = a_array[i]->s_next;
b_array[i]->s_prev
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Continue pressing CTRL-Y until the following "next":
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
続けて、次の "next" まで @kbd{CTRL-Y} を押します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_prev = a_array[i]->s_ ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
b_array[i]->s_next = a_array[i]->s_next;
b_array[i]->s_prev = a_array[i]->s_
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now type "prev;" to finish it off.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"prev;" と入力すれば、行が完成です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The CTRL-E command acts like CTRL-Y except it inserts the character below the
cursor.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-Y} と似たコマンドに @kbd{CTRL-E} があります。これはカーソルの下の文字を挿入するコマンドです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*24.6*	Inserting a register
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{24.6}
@section レジスタを挿入する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The command CTRL-R {register} inserts the contents of the register.  This is
useful to avoid having to type a long word.  For example, you need to type
this:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-R} @{register@} コマンドを使うと、レジスタの内容を挿入できます。長い単語を入力するのが簡単になります。例えば、次の行を入力したいとします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	r = VeryLongFunction(a) + VeryLongFunction(b) + VeryLongFunction(c) ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
r = VeryLongFunction(a) + VeryLongFunction(b) + VeryLongFunction(c)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The function name is defined in a different file.  Edit that file and move the
cursor on top of the function name there, and yank it into register v: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数名は別のファイルで定義されています。そのファイルを開いてカーソルを関数名の先頭に移動し、次のコマンドでレジスタ v にヤンクします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	"vyiw
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
"vyiw
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
"v is the register specification, "yiw" is yank-inner-word.  Now edit the file
where the new line is to be inserted, and type the first letters:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"v はレジスタの指定、"yiw" は yank-inner-word (単語をヤンクする) です。さて、元のファイルに戻り、挿入モードを開始して次のように入力します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	r = ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
r =
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now use CTRL-R v to insert the function name:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここで、@kbd{CTRL-R v} を押して関数の名前を挿入します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	r = VeryLongFunction ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
r = VeryLongFunction
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You continue to type the characters in between the function name, and use
CTRL-R v two times more.
   You could have done the same with completion.  Using a register is useful
when there are many words that start with the same characters.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
続けて関数の引数などを入力し、関数名を入力するときになったら再び @kbd{CTRL-R v} を使います。

同じことは補完を使ってもできますが、同じ文字で始まる単語がたくさんある場合にはレジスタが便利です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the register contains characters such as <BS> or other special characters,
they are interpreted as if they had been typed from the keyboard.  If you do
not want this to happen (you really want the <BS> to be inserted in the text),
use the command CTRL-R CTRL-R {register}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
レジスタの中に @key{<BS>} などの特殊な文字が含まれている場合、その文字は、実際にキーボードから入力されたのと同じように処理されます。それが望みの動作ではない場合 (例えば、@key{<BS>} をテキストとして挿入したい場合) は @kbd{CTRL-R} @kbd{CTRL-R} @{register@} を使ってください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*24.7*	Abbreviations
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{24.7}
@section 短縮形 (Abbreviations)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An abbreviation is a short word that takes the place of a long one.  For
example, "ad" stands for "advertisement".  Vim enables you to type an
abbreviation and then will automatically expand it for you.
   To tell Vim to expand "ad" into "advertisement" every time you insert it,
use the following command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
短縮形とは長い単語を置き換える短い単語のことです。例えば、"ad" は "advertisement" の短縮形です。Vim では、入力した短縮形を自動的に展開することができます。

"ad" を "advertisement" の短縮形として登録するには、次のコマンドを使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:iabbrev ad advertisement
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:iabbrev ad advertisement
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now, when you type "ad", the whole word "advertisement" will be inserted into
the text.  This is triggered by typing a character that can't be part of a
word, for example a space:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これで、"ad" と入力すると、完全形の "advertisement" がテキストに挿入されます。短縮形の置き換えは、スペースなどの、単語の一部として認識されない文字を入力したときに実行されます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	What Is Entered		What You See
	I saw the a		I saw the a ~
	I saw the ad		I saw the ad ~
	I saw the ad<Space>	I saw the advertisement<Space> ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .45 .55
@item 入力した文字 @tab 画面上での見え方
@item I saw the a @tab I saw the a
@item I saw the ad @tab I saw the ad
@item I saw the ad<Space> @tab I saw the advertisement<Space>
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The expansion doesn't happen when typing just "ad".  That allows you to type a
word like "add", which will not get expanded.  Only whole words are checked
for abbreviations.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"ad" と入力しただけでは展開されません。これは例えば "add" のような単語も入力できるようにするためです。単語の境界が確定してから短縮形の展開が適用されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ABBREVIATING SEVERAL WORDS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 複数の単語の短縮形
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It is possible to define an abbreviation that results in multiple words.  For
example, to define "JB" as "Jack Benny", use the following command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
複数の単語に展開される短縮形を定義できます。例えば、"JB" を "Jack Benny" の短縮形として登録するには、次のコマンドを使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:iabbrev JB Jack Benny
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:iabbrev JB Jack Benny
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
As a programmer, I use two rather unusual abbreviations: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プログラムを書くとき、私は少し変った短縮形を使っています:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:iabbrev #b /****************************************
	:iabbrev #e <Space>****************************************/
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:iabbrev #b /****************************************
:iabbrev #e <Space>****************************************/
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These are used for creating boxed comments.  The comment starts with #b, which
draws the top line.  I then type the comment text and use #e to draw the
bottom line.
   Notice that the #e abbreviation begins with a space.  In other words, the
first two characters are space-star.  Usually Vim ignores spaces between the
abbreviation and the expansion.  To avoid that problem, I spell space as seven
characters: <, S, p, a, c, e, >.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはコメントブロックを作成するときに使います。コメントを開始するときに #b で最初の行を描き、コメントを書いてから、#e で末尾の行を描きます。#e の展開形がスペースで始まっています。

別の言い方をすれば、最初の 2 文字がスペースとスターになっています。通常、短縮形と展開形の間の空白は無視されるので、スペースを入れたい場合は @samp{<}, @samp{S}, @samp{p}, @samp{a}, @samp{c}, @samp{e}, @samp{>} という 7 文字の特殊な表記を使います。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Note:
	":iabbrev" is a long word to type.  ":iab" works just as well.
	That's abbreviating the abbreviate command!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"@command{:iabbrev}" は入力するのが長くて大変なので、"@command{:iab}" でも構いません。これは短縮コマンドの短縮形です！
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
FIXING TYPING MISTAKES
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 入力ミスを直す
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It's very common to make the same typing mistake every time.  For example,
typing "teh" instead of "the".  You can fix this with an abbreviation: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
入力ミスの癖ってありますよね。例えば、"the" と入力するはずが "teh" になってしまったり。短縮形を使って修正しましょう:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:abbreviate teh the
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:abbreviate teh the
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can add a whole list of these.  Add one each time you discover a common
mistake.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このような短縮形のリストを作成し、入力ミスの癖を見つけたら追加しましょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
LISTING ABBREVIATIONS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 短縮形を一覧表示する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The ":abbreviate" command lists the abbreviations:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:abbreviate}" コマンドで短縮形の一覧を表示できます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:abbreviate
	i  #e		  ****************************************/
	i  #b		 /****************************************
	i  JB		 Jack Benny
	i  ad		 advertisement
	!  teh		 the
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:abbreviate
i  #e             ****************************************/
i  #b            /****************************************
i  JB            Jack Benny
i  ad            advertisement
!  teh           the
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "i" in the first column indicates Insert mode.  These abbreviations are
only active in Insert mode.  Other possible characters are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
行頭の "i" は挿入モードの意味です。その短縮形は挿入モードの中だけで有効です。他にも、次のような文字が表示されます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	c	Command-line mode			:cabbrev
	!	both Insert and Command-line mode	:abbreviate
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .7 .2
@item c @tab コマンドラインモード @tab @command{:cabbrev}
@item ! @tab 挿入モードとコマンドラインモード @tab @command{:abbreviate}
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Since abbreviations are not often useful in Command-line mode, you will mostly
use the ":iabbrev" command.  That avoids, for example, that "ad" gets expanded
when typing a command like: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインモードで短縮形が役に立つことはあまりないので、"@command{iabbrev}" コマンドを主に使うことになるでしょう。"@command{iabbrev}" なら、次のようなコマンドで "ad" が展開される心配はありません:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:edit ad
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:edit ad
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DELETING ABBREVIATIONS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 短縮形の削除
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To get rid of an abbreviation, use the ":unabbreviate" command.  Suppose you
have the following abbreviation: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
短縮形を取り除くには "@command{:unabbreviate}" コマンドを使います。次のような短縮形が登録されているなら:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:abbreviate @f fresh
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:abbreviate @@f fresh
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can remove it with this command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のコマンドで削除できます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:unabbreviate @f
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:unabbreviate @@f
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
While you type this, you will notice that @f is expanded to "fresh".  Don't
worry about this, Vim understands it anyway (except when you have an
abbreviation for "fresh", but that's very unlikely).
   To remove all the abbreviations: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このコマンドを入力すると @@f が "fresh" に展開されてしまいますが、心配はいりません。コマンドは正しく処理されます (ただし、"fresh" という別の短縮形が定義されている場合は期待した動作になりません。まぁそんなことはほとんどないはずですが)。

すべての短縮形を削除するには次のコマンドを使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:abclear
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:abclear
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
":unabbreviate" and ":abclear" also come in the variants for Insert mode
(":iunabbreviate and ":iabclear") and Command-line mode (":cunabbreviate" and
":cabclear").
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:unabbreviate}" と "@command{:abclear}" にも、挿入モード用 ("@command{:iunabbreviate}" と "@command{:iabclear}") とコマンドライン用 ("@command{:cunabbreviate}" と "@command{:cabclear}") があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
REMAPPING ABBREVIATIONS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 短縮形の再マップ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There is one thing to watch out for when defining an abbreviation: The
resulting string should not be mapped.  For example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
短縮形を定義するときに注意すべき点がもう 1 つあります。展開された文字列がマップされないようにしなくてはなりません。例をあげましょう:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:abbreviate @a adder
	:imap dd disk-door
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:abbreviate @@a adder
:imap dd disk-door
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you now type @a, you will get "adisk-doorer".  That's not what you want.
To avoid this, use the ":noreabbrev" command.  It does the same as
":abbreviate", but avoids that the resulting string is used for mappings: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@@a" を入力すると "adisk-doorer" になってしまいます。これは意図した動作ではないはずです。これを避けるには、"@command{:noreabbrev}" コマンドを使います。"@command{:abbreviate}" と機能は同じですが、展開結果にマップが適用されません:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:noreabbrev @a adder
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:noreabbrev @@a adder
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Fortunately, it's unlikely that the result of an abbreviation is mapped.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これで、展開結果がマップされなくなります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*24.8*	Entering special characters
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{24.8}
@section 特殊な文字を入力する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The CTRL-V command is used to insert the next character literally.  In other
words, any special meaning the character has, it will be ignored.  For
example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-V} コマンドを使うと、その次に入力した文字をそのまま挿入できます。つまり、文字の特殊効果が無視されます。例えば、このように入力すると:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-V <Esc>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
CTRL-V <Esc>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Inserts an escape character.  Thus you don't leave Insert mode.  (Don't type
the space after CTRL-V, it's only to make this easier to read).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
エスケープ文字が挿入されます。挿入モードは終了しません。(@kbd{CTRL-V} の後ろの空白は見やすくするためのものなので、実際には入力しないでください)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Note:
	On MS-Windows CTRL-V is used to paste text.  Use CTRL-Q instead of
	CTRL-V.  On Unix, on the other hand, CTRL-Q does not work on some
	terminals, because it has a special meaning.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
MS-Windows では @kbd{CTRL-V} はテキストのペーストに使われています。@kbd{CTRL-V} の代わりに @kbd{CTRL-Q} を使ってください。Unixでは逆に一部の端末で @kbd{CTRL-Q} に特別な意味があるので使えないかもしれません。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can also use the command CTRL-V {digits} to insert a character with the
decimal number {digits}.  For example, the character number 127 is the <Del>
character (but not necessarily the <Del> key!).  To insert <Del> type: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
また、@kbd{CTRL-V} @{digits@} コマンドを使うと、文字コードを 10 進数で指定して、その文字を入力できます。例えば、文字コード 127 は <Del> 文字 (@key{<Del>} @strong{キー} と同じとは限りません) です。<Del> を挿入するには次のように入力します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-V 127
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
CTRL-V 127
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can enter characters up to 255 this way.  When you type fewer than two
digits, a non-digit will terminate the command.  To avoid the need of typing a
non-digit, prepend one or two zeros to make three digits.
   All the next commands insert a <Tab> and then a dot:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
同じやりかたで文字コード 255 までの文字を入力できます。文字コードが 2 桁以下の場合は、数字以外の文字を入力してコマンドを確定してください。数字以外の文字を入力したくない場合は、数値が 3 桁になるように 1 つか 2 つの "0" を数値の前に付けてください。

次のコマンドはいずれも @key{<Tab>} と "@key{.}" を挿入します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-V 9.
	CTRL-V 09.
	CTRL-V 009.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
CTRL-V 9.
CTRL-V 09.
CTRL-V 009.
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To enter a character in hexadecimal, use an "x" after the CTRL-V: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字コードは 16 進数でも指定できます。その場合は @kbd{CTRL-V} の直後に "x" を指定します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-V x7f
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
CTRL-V x7f
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This also goes up to character 255 (CTRL-V xff).  You can use "o" to type a
character as an octal number and two more methods allow you to type up to
a 16 bit and a 32 bit number (e.g., for a Unicode character): >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この場合もコード 255 (@kbd{CTRL-V} xff) までの文字が入力できます。"o" で 8 進数の数値を指定することもできます。他にも "u" と "U" でそれぞれ 16 ビットと 32 ビットの文字コード (例えば Unicode の文字) を指定できます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-V o123
	CTRL-V u1234
	CTRL-V U12345678
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
CTRL-V o123
CTRL-V u1234
CTRL-V U12345678
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*24.9*	Digraphs
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{24.9}
@section ダイグラフ (Digraph)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Some characters are not on the keyboard.  For example, the copyright character
(©).  To type these characters in Vim, you use digraphs, where two characters
represent one.  To enter a ©, for example, you press three keys: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば、コピーライト文字 (©) など、キーボードに無い文字がいくつかあります。そのような文字を Vim で入力するにはダイグラフを使います。つまり、2 文字で 1 文字を表現します。例えば、コピーライト文字 (©) を入力するには、次のようにします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-K Co
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
CTRL-K Co
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To find out what digraphs are available, use the following command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
使用できるダイグラフの一覧を表示するには、次のコマンドを使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:digraphs
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:digraphs
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim will display the digraph table.  Here are three lines of it:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
一部抜粋:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  AC ~_ 159  NS |  160  !I ¡  161  Ct ¢  162  Pd £  163  Cu ¤  164  Ye ¥  165 ~
  BB ¦  166  SE §  167  ': ¨  168  Co ©  169  -a ª  170  << «  171  NO ¬  172 ~
  -- ­  173  Rg ®  174  'm ¯  175  DG °  176  +- ±  177  2S ²  178  3S ³  179 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
AC ~_ 159  NS |  160  !I ¡  161  Ct ¢  162  Pd £  163  Cu ¤  164  Ye ¥  165
BB ¦  166  SE §  167  ': ¨  168  Co ©  169  -a ª  170  << «  171  NO ¬  172
-- ­  173  Rg ®  174  'm ¯  175  DG °  176  +- ±  177  2S ²  178  3S ³  179
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This shows, for example, that the digraph you get by typing CTRL-K Pd is the
character (£).  This is character number 163 (decimal).
   Pd is short for Pound.  Most digraphs are selected to give you a hint about
the character they will produce.  If you look through the list you will
understand the logic.
   You can exchange the first and second character, if there is no digraph for
that combination.  Thus CTRL-K dP also works.  Since there is no digraph for
"dP" Vim will also search for a "Pd" digraph.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これを見れば、例えば @kbd{CTRL-K} Pd でポンド記号 (£) が入力できることがわかります。文字番号は 163 (10進数) です。

Pd は Pound (ポンド) の略です。ほとんどのダイグラフには、生成される文字が連想しやすい文字が割り当てられています。法則は表を見ればだいたいわかると思います。

ダイグラフの 1 文字目と 2 文字目は逆の順番で入力しても構いません。ただし、その組み合わせが他のダイグラフで使われていない場合に限ります。すなわち、@kbd{CTRL-K} dP もポンド記号になります。"dP" という組み合わせが他に使われていないので、"Pd" のダイグラフが使われるのです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Note:
	The digraphs depend on the character set that Vim assumes you are
	using.  On MS-DOS they are different from MS-Windows.  Always use
	":digraphs" to find out which digraphs are currently available.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ダイグラフはユーザーが使っている (と Vim が認識している) 文字セットに依存します。MS-DOS の文字セットと MS-Windows の文字セットは違います。"@command{:digraphs}" を使って、利用可能なダイグラフを確認してください。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can define your own digraphs.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
自分でダイグラフを定義することもできます。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:digraph a" ä
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:digraph a" ä
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This defines that CTRL-K a" inserts an ä character.  You can also specify the
character with a decimal number.  This defines the same digraph: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-K} a" を入力すると ä になります。文字コードを 10 進数で指定することもできます。次のコマンドは上記のコマンドと同じです:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:digraph a" 228
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:digraph a" 228
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
More information about digraphs here: |digraphs|
   Another way to insert special characters is with a keymap.  More about that
here: |45.5|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ダイグラフについての詳細は |digraphs| を参照してください。

他にも、キーマップを使って特殊な文字を入力することもできます。詳しくは |@ref{45.5, , 45.5}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*24.10*	Normal mode commands
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{24.10}
@section ノーマルモードコマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Insert mode offers a limited number of commands.  In Normal mode you have many
more.  When you want to use one, you usually leave Insert mode with <Esc>,
execute the Normal mode command, and re-enter Insert mode with "i" or "a".
   There is a quicker way.  With CTRL-O {command} you can execute any Normal
mode command from Insert mode.  For example, to delete from the cursor to the
end of the line: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
挿入モードで使えるコマンドはそれほど多くありませんが、ノーマルモードにはたくさんのコマンドがあります。それらのコマンドを使うには @key{<Esc>} で挿入モードを抜けて、ノーマルモードコマンドを実行し、"i" または "a" で挿入モードに戻ってこなければなりません。

もっと簡単な方法があります。@kbd{CTRL-O} @{command@} を使えばノーマルモードコマンドを挿入モードの中で実行できます。例えば、次のコマンドでカーソル位置から行末まで削除できます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-O D
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
CTRL-O D
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can execute only one Normal mode command this way.  But you can specify a
register or a count.  A more complicated example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この方法で実行できるのは 1 つのコマンドだけです。ただし、レジスタやカウントの指定はできます。もう少し複雑な例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	CTRL-O "g3dw
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
CTRL-O "g3dw
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This deletes up to the third word into register g.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
3 つの単語を削除してレジスタ g に格納します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================

Next chapter: |usr_25.txt|  Editing formatted text

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
@end ifset
