@ifset JA  @c ----------- v -----------  JA  -*- tab-width: 8 -*-
@node cmdline.txt, , , 目次
@unnumbered コマンドラインの編集
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*cmdline.txt*   For Vim version 8.0.  Last change: 2017 Sep 17


		  VIM REFERENCE MANUAL    by Bram Moolenaar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
*cmdline.txt*   For Vim バージョン 8.0.  Last change: 2017 Sep 17


		  VIMリファレンスマニュアル    by Bram Moolenaar
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
				*Cmdline-mode* *Command-line-mode*
Command-line mode		*Cmdline* *Command-line* *mode-cmdline* *:*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Cmdline-mode}
@anchor{Command-line-mode}
@anchor{Cmdline}
@anchor{Command-line}
@anchor{mode-cmdline}
@anchor{:}
@cindex Cmdline-mode
@cindex Command-line-mode
@cindex Cmdline
@cindex Command-line
@cindex mode-cmdline
@cindex :
コマンドラインモード
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Command-line mode is used to enter Ex commands (":"), search patterns
("/" and "?"), and filter commands ("!").
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインモードは Ex コマンド (":")、検索パターン ("/" と "?")、フィルタコマンド ("!") の入力に使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Basic command line editing is explained in chapter 20 of the user manual
|usr_20.txt|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドライン編集の基本は、ユーザーマニュアルの第 20 章で説明されている |@ref{usr_20.txt, , usr_20.txt}|。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. Command-line editing		|cmdline-editing|
2. Command-line completion	|cmdline-completion|
3. Ex command-lines		|cmdline-lines|
4. Ex command-line ranges	|cmdline-ranges|
5. Ex command-line flags	|ex-flags|
6. Ex special characters	|cmdline-special|
7. Command-line window		|cmdline-window|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .55 .45
@item 1. コマンドラインの編集 @tab |@ref{cmdline-editing, , cmdline-editing}|
@item 2. コマンドラインの補完 @tab |@ref{cmdline-completion, , cmdline-completion}|
@item 3. Ex コマンドライン @tab |@ref{cmdline-lines, , cmdline-lines}|
@item 4. Ex コマンドラインの範囲 @tab |@ref{cmdline-ranges, , cmdline-ranges}|
@item 5. Ex コマンドラインのフラグ @tab |@ref{ex-flags, , ex-flags}|
@item 6. Ex コマンド用の特別な文字 @tab |@ref{cmdline-special, , cmdline-special}|
@item 7. コマンドラインウィンドウ @tab |@ref{cmdline-window, , cmdline-window}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
1. Command-line editing					*cmdline-editing*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cmdline-editing}
@cindex cmdline-editing
@section  1. コマンドラインの編集
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Normally characters are inserted in front of the cursor position.  You can
move around in the command-line with the left and right cursor keys.  With the
<Insert> key, you can toggle between inserting and overstriking characters.
{Vi: can only alter the last character in the line}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
通常、文字はカーソル位置の前に挿入される。コマンドラインでは左右のカーソルキーで移動ができる。@key{<Insert>} キーで挿入と上書を切り替えることができる。

@{Vi: 行の最後の文字しか変更できない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that if your keyboard does not have working cursor keys or any of the
other special keys, you can use ":cnoremap" to define another key for them.
For example, to define tcsh style editing keys:		*tcsh-style*  >
	:cnoremap <C-A> <Home>
	:cnoremap <C-F> <Right>
	:cnoremap <C-B> <Left>
	:cnoremap <Esc>b <S-Left>
	:cnoremap <Esc>f <S-Right>
(<> notation |<>|; type all this literally)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
キーボードに有効なカーソルキーまたは他の特殊なキーが一切ないときでも、コマンド ":cnoremap" を使って他のキーをそれらに割り当てられることに注意。例えば、tcsh 風の編集キーを定義する方法は以下の通り。
@anchor{tcsh-style}
@cindex tcsh-style
@verbatim
:cnoremap <C-A> <Home>
:cnoremap <C-F> <Right>
:cnoremap <C-B> <Left>
:cnoremap <Esc>b <S-Left>
:cnoremap <Esc>f <S-Right>
@end verbatim
(<> 記法を使っている |<>|．これらを全て文字通り打ち込むこと)
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*cmdline-too-long*
When the command line is getting longer than what fits on the screen, only the
part that fits will be shown.  The cursor can only move in this visible part,
thus you cannot edit beyond that.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cmdline-too-long}
@cindex cmdline-too-long
コマンドラインが長くなりすぎて画面に収まらなくなったときは、画面に入るだけの部分が表示される。カーソルはこの見える部分しか動けない。そのため、これ以上は編集できない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*cmdline-history* *history*
The command-lines that you enter are remembered in a history table.  You can
recall them with the up and down cursor keys.  There are actually five
history tables:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cmdline-history}
@anchor{history}
@cindex cmdline-history
@cindex history
ユーザーの打ち込んだコマンドは、履歴表に記録される。これらの履歴は上下矢印キーで呼び出せる。実際には 4 つの履歴表がある。

履歴表:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- one for ':' commands
- one for search strings
- one for expressions
- one for input lines, typed for the |input()| function.
- one for debug mode commands
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize @minus
@item ':' コマンド用
@item 検索文字列用
@item 式 (expression) 用
@item インプット行 (関数 |input()| に対して入力されたテキスト) 用
@item デバッグモードコマンド用
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
These are completely separate.  Each history can only be accessed when
entering the same type of line.
Use the 'history' option to set the number of lines that are remembered
(default: 50).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらは全く別のものである。それぞれの履歴は同種の入力をしたときだけ使用できる。オプション '@option{history}' で保存されるコマンド数を設定できる (既定値: 50)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Notes:
- When you enter a command-line that is exactly the same as an older one, the
  old one is removed (to avoid repeated commands moving older commands out of
  the history).
- Only commands that are typed are remembered.  Ones that completely come from
  mappings are not put in the history.
- All searches are put in the search history, including the ones that come
  from commands like "*" and "#".  But for a mapping, only the last search is
  remembered (to avoid that long mappings trash the history).
{Vi: no history}
{not available when compiled without the |+cmdline_hist| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:}
@itemize @minus
@item 以前と全く同じコマンドを打ち込んだときは、古い方の記録が消される (繰り返されたコマンドが古いコマンドの履歴を追い出して消すのを避けるため)。
@item 打ち込んだコマンドだけが記録される。完全にマッピングから実行されたコマンドは履歴に残らない。
@item 全ての検索パターンは、コマンド "*" や "#" 等によるものも含め、検索用の履歴に記録される。しかしマッピングからの検索に対しては、最後の検索のみが記録される (長いマッピングが履歴の内容を捨ててしまうのを避けるため)。
@end itemize
@end quotation
@{Vi: 履歴はない@}

@{Vimが |+cmdline_hist| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There is an automatic completion of names on the command-line; see
|cmdline-completion|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインには名前の自動補完機能がある。|cmdline-completion| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*c_CTRL-V*
CTRL-V		Insert next non-digit literally.  Up to three digits form the
		decimal value of a single byte.  The non-digit and the three
		digits are not considered for mapping.  This works the same
		way as in Insert mode (see above, |i_CTRL-V|).
		Note: Under Windows CTRL-V is often mapped to paste text.
		Use CTRL-Q instead then.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-V}
@cindex c_CTRL-V
@table @asis
@item @kbd{CTRL-V}
次に打ち込まれた非数字文字を、その通りに挿入する。また最大 3 個の数字により、1 バイト文字をコードの 10 進表現に基づいて入力できる。打ち込んだ非数字文字と 3 個の数字にはマッピングは適用されない。これは挿入モードと同じ働きをする (|i_CTRL-V| を参照)。
@quotation
@strong{Note:} @*
Windows では CTRL-V はテキストの貼り付けにマッピングされていることが多い。そのときは代わりに CTRL-Q を使うこと。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*c_CTRL-Q*
CTRL-Q		Same as CTRL-V.  But with some terminals it is used for
		control flow, it doesn't work then.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-Q}
@cindex c_CTRL-Q
@item @kbd{CTRL-Q}
@kbd{CTRL-V} と同様だが、ターミナルによっては表示制御に使われている。その場合は使えない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*c_<Left>* *c_Left*
<Left>		cursor left
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_<Left>}
@anchor{c_Left}
@cindex c_<Left>
@cindex c_Left
@item @key{<Left>}
カーソルを左へ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*c_<Right>* *c_Right*
<Right>		cursor right
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_<Right>}
@anchor{c_Right}
@cindex c_<Right>
@cindex c_Right
@item @key{<Right>}
カーソルを右へ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*c_<S-Left>*
<S-Left> or <C-Left>					*c_<C-Left>*
		cursor one WORD left
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_<S-Left>}
@anchor{c_<C-Left>}
@cindex c_<S-Left>
@cindex c_<C-Left>
@item <S-Left> または
@itemx <C-Left>
カーソルを 1 WORD 分左へ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*c_<S-Right>*
<S-Right> or <C-Right>					*c_<C-Right>*
		cursor one WORD right
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_<S-Right>}
@anchor{c_<C-Right>}
@cindex c_<S-Right>
@cindex c_<C-Right>
@item <S-Right> または
@itemx <C-Right>
カーソルを 1 WORD 分右へ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
CTRL-B or <Home>				*c_CTRL-B* *c_<Home>* *c_Home*
		cursor to beginning of command-line
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-B}
@anchor{c_<Home>}
@anchor{c_Home}
@cindex c_CTRL-B
@cindex c_<Home>
@cindex c_Home
@item @kbd{CTRL-B} または
@itemx @key{<Home>}
カーソルをコマンドライン先頭へ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
CTRL-E or <End>					*c_CTRL-E* *c_<End>* *c_End*
		cursor to end of command-line
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-E}
@anchor{c_<End>}
@anchor{c_End}
@cindex c_CTRL-E
@cindex c_<End>
@cindex c_End
@item @kbd{CTRL-E} または
@itemx @key{<End>}
カーソルをコマンドライン末尾へ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*c_<LeftMouse>*
<LeftMouse>	Move the cursor to the position of the mouse click.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_<LeftMouse>}
@cindex c_<LeftMouse>
@item <LeftMouse>
カーソルをマウスでクリックした所へ移動する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*c_<MiddleMouse>*
<MiddleMouse>	Paste the contents of the clipboard (for X11 the primary
		selection).  This is similar to using CTRL-R *, but no CR
		characters are inserted between lines.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_<MiddleMouse>}
@cindex c_<MiddleMouse>
@item <MiddleMouse>
クリップボード (X11 ではプライマリ選択)の内容を貼り付ける。これは CTRL-R * を使った動作に似ているが、行間に CR は挿入されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CTRL-H						*c_<BS>* *c_CTRL-H* *c_BS*
<BS>		Delete the character in front of the cursor (see |:fixdel| if
		your <BS> key does not do what you want).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_<BS>}
@anchor{c_CTRL-H}
@anchor{c_BS}
@cindex c_<BS>
@cindex c_CTRL-H
@cindex c_BS
@item @kbd{CTRL-H} または
@itemx @key{<BS>}
カーソル前の文字を削除する (@key{<BS>} キーが思い通り働かないときは |:fixdel| を参照)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*c_<Del>* *c_Del*
<Del>		Delete the character under the cursor (at end of line:
		character before the cursor) (see |:fixdel| if your <Del>
		key does not do what you want).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_<Del>}
@anchor{c_Del}
@cindex c_<Del>
@cindex c_Del
@item @key{<Del>}
カーソル下の文字を削除する (行の最後では: カーソル前の文字) (@key{<Del>} キーが思い通り働かないときは |:fixdel| を参照。)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*c_CTRL-W*
CTRL-W		Delete the |word| before the cursor.  This depends on the
		'iskeyword' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-W}
@cindex c_CTRL-W
@item CTRL-W
カーソルの前の |word| を削除。これは '@option{iskeyword}' オプションに依存する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*c_CTRL-U*
CTRL-U		Remove all characters between the cursor position and
		the beginning of the line.  Previous versions of vim
		deleted all characters on the line.  If that is the
		preferred behavior, add the following to your .vimrc: >
			:cnoremap <C-U> <C-E><C-U>
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-U}
@cindex c_CTRL-U
@item @kbd{CTRL-U}
行頭とカーソル位置の間の全ての文字を削除する。Vim の以前のバージョンでは行内の文字を全て削除していた。その動作の方がよいなら、次の行をファイル .vimrc に加えること。
@example
:cnoremap <C-U> <C-E><C-U>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*c_<Insert>* *c_Insert*
<Insert>	Toggle between insert and overstrike.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_<Insert>}
@anchor{c_Insert}
@cindex c_<Insert>
@cindex c_Insert
@item @key{<Insert>}
挿入／上書の切り替え

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{char1} <BS> {char2}	or				*c_digraph*
CTRL-K {char1} {char2}					*c_CTRL-K*
		enter digraph (see |digraphs|).  When {char1} is a special
		key, the code for that key is inserted in <> form.  {not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_digraph}
@anchor{c_CTRL-K}
@cindex c_digraph
@cindex c_CTRL-K
@item @{char1@} @key{<BS>} @{char2@} または
@itemx @kbd{CTRL-K} @{char1@} @{char2@}
ダイグラフの入力 (|digraphs| を参照)。@{char1@} が特殊キーのときは、そのキーコードは <> 形式で挿入される。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CTRL-R {0-9a-z"%#:-=.}					*c_CTRL-R* *c_<C-R>*
		Insert the contents of a numbered or named register.  Between
		typing CTRL-R and the second character '"' will be displayed
		to indicate that you are expected to enter the name of a
		register.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-R}
@anchor{c_<C-R>}
@cindex c_CTRL-R
@cindex c_<C-R>
@item @kbd{CTRL-R} @{0-9a-z"%#:-=.@}
番号/名前付きレジスタの内容を挿入する。@kbd{CTRL-R} を打ち込んで次の文字を打ち込むまでの間、レジスタ名の入力待ちであることを示すため '"' が表示される。

@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The text is inserted as if you typed it, but mappings and
		abbreviations are not used.  Command-line completion through
		'wildchar' is not triggered though.  And characters that end
		the command line are inserted literally (<Esc>, <CR>, <NL>,
		<C-C>).  A <BS> or CTRL-W could still end the command line
		though, and remaining characters will then be interpreted in
		another mode, which might not be what you intended.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
テキストは打ち込まれた通りに挿入され、マッピングや短縮入力は無効である。'@option{wildchar}' によるコマンドライン補完も行われない。またコマンドラインを終了する文字 (<Esc>, <CR>, <NL>, <C-C>) も文字通り挿入される。

@kbd{<BS>} や @kbd{CTRL-W} はコマンドラインを終了できるが、コマンドラインに残っている文字が違うモードで解釈されることなるので、意図とは異なる動作になるかもしれない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Special registers:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
特殊なレジスタ:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			'"'	the unnamed register, containing the text of
				the last delete or yank
			'%'	the current file name
			'#'	the alternate file name
			'*'	the clipboard contents (X11: primary selection)
			'+'	the clipboard contents
			'/'	the last search pattern
			':'	the last command-line
			'-'	the last small (less than a line) delete
			'.'	the last inserted text
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item '"' @tab 無名レジスタ、最後の削除やコピーによるテキストを格納する。
@item '%' @tab カレントファイル名
@item '#' @tab 代替ファイル名
@item '*' @tab クリップボードの内容 (X11: プライマリ選択)
@item '+' @tab クリップボードの内容
@item '/' @tab 最後の検索パターン
@item ':' @tab 最後のコマンドラインの内容
@item '-' @tab 最後の小規模な (1 行未満の) 削除の内容
@item '.' @tab 最後に挿入されたテキスト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*c_CTRL-R_=*
			'='	the expression register: you are prompted to
				enter an expression (see |expression|)
				(doesn't work at the expression prompt; some
				things such as changing the buffer or current
				window are not allowed to avoid side effects)
				When the result is a |List| the items are used
				as lines.  They can have line breaks inside
				too.
				When the result is a Float it's automatically
				converted to a String.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-R_=}
@cindex c_CTRL-R_=
@item '=' @tab Expression レジスタ: 式を入力するよう要求される (|expression| を参照) (Expression プロンプトでは機能しない。バッファ変更やカレントウィンドウ変更などは副作用を避けるため許可されていない)

結果がリスト |List| である場合、各要素が 1 行として挿入される。行の中に改行文字が含まれていてもよい。結果が浮動小数点数である場合、自動的に文字列に変換される。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		See |registers| about registers.  {not in Vi}
		Implementation detail: When using the |expression| register
		and invoking setcmdpos(), this sets the position before
		inserting the resulting string.  Use CTRL-R CTRL-R to set the
		position afterwards.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
レジスタに関しては |registers| を参照。

@{Vi にはない@}

実装上の詳細: |expression|レジスタを使っているときに setcmdpos() を呼ぶと結果文字列を挿入する前の位置をセットする。挿入後の位置をセットするには CTRL-R CTRL-R を使うこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CTRL-R CTRL-F				*c_CTRL-R_CTRL-F* *c_<C-R>_<C-F>*
CTRL-R CTRL-P				*c_CTRL-R_CTRL-P* *c_<C-R>_<C-P>*
CTRL-R CTRL-W				*c_CTRL-R_CTRL-W* *c_<C-R>_<C-W>*
CTRL-R CTRL-A				*c_CTRL-R_CTRL-A* *c_<C-R>_<C-A>*
		Insert the object under the cursor:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-R_CTRL-F}
@anchor{c_<C-R>_<C-F>}
@anchor{c_CTRL-R_CTRL-P}
@anchor{c_<C-R>_<C-P>}
@anchor{c_CTRL-R_CTRL-W}
@anchor{c_<C-R>_<C-W>}
@anchor{c_CTRL-R_CTRL-A}
@anchor{c_<C-R>_<C-A>}
@cindex c_CTRL-R_CTRL-F
@cindex c_<C-R>_<C-F>
@cindex c_CTRL-R_CTRL-P
@cindex c_<C-R>_<C-P>
@cindex c_CTRL-R_CTRL-W
@cindex c_<C-R>_<C-W>
@cindex c_CTRL-R_CTRL-A
@cindex c_<C-R>_<C-A>
@item @kbd{CTRL-R} @kbd{CTRL-F} または
@itemx @kbd{CTRL-R} @kbd{CTRL-P} または
@itemx @kbd{CTRL-R} @kbd{CTRL-W} または
@itemx @kbd{CTRL-R} @kbd{CTRL-A}
カーソル下にオブジェクトを挿入する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			CTRL-F	the Filename under the cursor
			CTRL-P	the Filename under the cursor, expanded with
				'path' as in |gf|
			CTRL-W	the Word under the cursor
			CTRL-A	the WORD under the cursor; see |WORD|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item @kbd{CTRL-F} @tab カーソル下のファイル名
@item @kbd{CTRL-P} @tab |gf| と同様に 'path' を使って展開された、カーソル下のファイル名
@item @kbd{CTRL-W} @tab カーソル下の word
@item @kbd{CTRL-A} @tab カーソル下の WORD; |WORD| を参照
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When 'incsearch' is set the cursor position at the end of the
		currently displayed match is used.  With CTRL-W the part of
		the word that was already typed is not inserted again.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{incsearch}' がセットされてるとき、現在表示されているマッチの末尾のカーソル位置が使われる。@kbd{CTRL-W} では word の一部がすでに入力されているとき、その部分がもう一度入力されることはない。

@{訳注: word という単語のrの上にカーソルを置き、@command{:wo<C-r><C-w>} としてみると、'@option{incsearch}' の値によって結果が違うことがわかる@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{not in Vi}
		CTRL-F and CTRL-P: {only when |+file_in_path| feature is
		included}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@{Vi にはない@}

@kbd{CTRL-F} と @kbd{CTRL-P}: @{Vimが |+file_in_path| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*c_CTRL-R_CTRL-R* *c_<C-R>_<C-R>*
					*c_CTRL-R_CTRL-O* *c_<C-R>_<C-O>*
CTRL-R CTRL-R {0-9a-z"%#:-=. CTRL-F CTRL-P CTRL-W CTRL-A}
CTRL-R CTRL-O {0-9a-z"%#:-=. CTRL-F CTRL-P CTRL-W CTRL-A}
		Insert register or object under the cursor.  Works like
		|c_CTRL-R| but inserts the text literally.  For example, if
		register a contains "xy^Hz" (where ^H is a backspace),
		"CTRL-R a" will insert "xz" while "CTRL-R CTRL-R a" will
		insert "xy^Hz".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-R_CTRL-R}
@anchor{c_<C-R>_<C-R>}
@anchor{c_CTRL-R_CTRL-O}
@anchor{c_<C-R>_<C-O>}
@cindex c_CTRL-R_CTRL-R
@cindex c_<C-R>_<C-R>
@cindex c_CTRL-R_CTRL-O
@cindex c_<C-R>_<C-O>
@item @kbd{CTRL-R} @kbd{CTRL-R} @{0-9a-z"%#:-=. @kbd{CTRL-F} @kbd{CTRL-P} @kbd{CTRL-W} @kbd{CTRL-A}@} または
@itemx @kbd{CTRL-R} @kbd{CTRL-O} @{0-9a-z"%#:-=. @kbd{CTRL-F} @kbd{CTRL-P} @kbd{CTRL-W} @kbd{CTRL-A}@}
カーソル下にレジスタの内容またはオブジェクトを挿入。|c_CTRL-R| と同様の動作だが、テキストを文字通り挿入する。例えば、レジスタ "a の内容が "xy^Hz" (ここで ^H はバックスペース) のとき、"@kbd{CTRL-R} a" は "xz" を挿入するのに対し、"@kbd{CTRL-R} @kbd{CTRL-R} a" は"xy^Hz" を挿入する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CTRL-\ e {expr}						*c_CTRL-\_e*
		Evaluate {expr} and replace the whole command line with the
		result.  You will be prompted for the expression, type <Enter>
		to finish it.  It's most useful in mappings though.  See
		|expression|.
		See |c_CTRL-R_=| for inserting the result of an expression.
		Useful functions are |getcmdtype()|, |getcmdline()| and
		|getcmdpos()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-\_e}
@cindex c_CTRL-\_e
@item @kbd{CTRL-\} e @{expr@}
コマンドラインを @{expr@} を評価した結果で置き換える。式を入力し @key{<Enter>} を押せば完了する。マッピングする時に使うと便利である。|expression| も参照のこと。

式の評価を挿入するには |c_CTRL-R_=| を使う。便利な関数に |getcmdtype()| と |getcmdline()| と |getcmdpos()| がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The cursor position is unchanged, except when the cursor was
		at the end of the line, then it stays at the end.
		|setcmdpos()| can be used to set the cursor position.
		The |sandbox| is used for evaluating the expression to avoid
		nasty side effects.
		Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カーソルが行末になければカーソル位置は変更されない。カーソルが行末にあるときのコマンドライン変更後のカーソル位置は行末である。|setcmdpos()| を使うとカーソル位置を変更できる。|sandbox| を使うと不要な副作用を避けて式を評価することができる。

例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			:cmap <F7> <C-\>eAppendSome()<CR>
			:func AppendSome()
			   :let cmd = getcmdline() . " Some()"
			   :" place the cursor on the )
			   :call setcmdpos(strlen(cmd))
			   :return cmd
			:endfunc
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:cmap <F7> <C-\>eAppendSome()<CR>
:func AppendSome()
   :let cmd = getcmdline() . " Some()"
   :" place the cursor on the )
   :call setcmdpos(strlen(cmd))
   :return cmd
:endfunc
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		This doesn't work recursively, thus not when already editing
		an expression.  But it is possible to use in a mapping.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは再帰的には機能しない。つまり、すでに式を編集しているときは動作しない。ただしマップの中では再帰的に使える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*c_CTRL-Y*
CTRL-Y		When there is a modeless selection, copy the selection into
		the clipboard. |modeless-selection|
		If there is no selection CTRL-Y is inserted as a character.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-Y}
@cindex c_CTRL-Y
@item @kbd{CTRL-Y}
モードレスセレクションでテキストを選択中のとき、テキストをクリップボードにコピーする。|modeless-selection| 選択中でないときは、@kbd{CTRL-Y} は文字として挿入される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CTRL-M or CTRL-J		*c_CTRL-M* *c_CTRL-J* *c_<NL>* *c_<CR>* *c_CR*
<CR> or <NL>	start entered command
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-M}
@anchor{c_CTRL-J}
@anchor{c_<NL>}
@anchor{c_<CR>}
@anchor{c_CR}
@cindex c_CTRL-M
@cindex c_CTRL-J
@cindex c_<NL>
@cindex c_<CR>
@cindex c_CR
@item @kbd{CTRL-M} または
@itemx @kbd{CTRL-J} または
@itemx @key{<CR>} または
@itemx <NL>
入力されたコマンドの実行
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CTRL-[						*c_CTRL-[* *c_<Esc>* *c_Esc*
<Esc>		When typed and 'x' not present in 'cpoptions', quit
		Command-line mode without executing.  In macros or when 'x'
		present in 'cpoptions', start entered command.
		Note: If your <Esc> key is hard to hit on your keyboard, train
		yourself to use CTRL-[.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-[}
@anchor{c_<Esc>}
@anchor{c_Esc}
@cindex c_CTRL-[
@cindex c_<Esc>
@cindex c_Esc
@item @kbd{CTRL-[} または
@itemx @key{<Esc>}
打ち込まれたときにオプション '@option{cpoptions}' にフラグ '@var{x}' が含まれていなければ、コマンドを実行せずにコマンドラインモードを終了する。マクロ内で使われたとき、または '@option{cpoptions}' に '@var{x}' が含まれているときは、コマンドラインを実行する。
@quotation
@strong{Note:} @*
お使いのキーボードで @key{<Esc>} が押しづらい場合は、@kbd{CTRL-[} を使うよう練習してください。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*c_CTRL-C*
CTRL-C		quit command-line without executing
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-C}
@cindex c_CTRL-C
@item @kbd{CTRL-C}
コマンドを実行せずにコマンドラインモードを終了する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*c_<Up>* *c_Up*
<Up>		recall older command-line from history, whose beginning
		matches the current command-line (see below).
		{not available when compiled without the |+cmdline_hist|
		feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_<Up>}
@anchor{c_Up}
@cindex c_<Up>
@cindex c_Up
@item @key{<Up>}
古いコマンドラインの内容のうち、先頭部分が現在のコマンドラインとマッチするものを履歴から呼び出す (下を参照)。

@{Vim が |+cmdline_hist| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*c_<Down>* *c_Down*
<Down>		recall more recent command-line from history, whose beginning
		matches the current command-line (see below).
		{not available when compiled without the |+cmdline_hist|
		feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_<Down>}
@anchor{c_Down}
@cindex c_<Down>
@cindex c_Down
@item @key{<Down>}
さらに最近のコマンドラインの内容のうち、先頭部分が現在のコマンドラインとマッチするものを履歴から呼び出す (下を参照)。@{訳注: 変な訳ですが、@key{<Up>} で行き過ぎたら @key{<Down>} で戻るということです@}

@{Vim が |+cmdline_hist| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*c_<S-Up>* *c_<PageUp>*
<S-Up> or <PageUp>
		recall older command-line from history
		{not available when compiled without the |+cmdline_hist|
		feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_<S-Up>}
@anchor{c_<PageUp>}
@cindex c_<S-Up>
@cindex c_<PageUp>
@item <S-Up> または
@itemx @key{<PageUp>}
履歴から古いコマンドラインの内容を呼び出す。

@{Vim が |+cmdline_hist| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*c_<S-Down>* *c_<PageDown>*
<S-Down> or <PageDown>
		recall more recent command-line from history
		{not available when compiled without the |+cmdline_hist|
		feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_<S-Down>}
@anchor{c_<PageDown>}
@cindex c_<S-Down>
@cindex c_<PageDown>
@item <S-Down> または
@itemx @key{<PageDown>}
履歴からさらに最近のコマンドラインの内容を呼び出す。

@{Vim が |+cmdline_hist| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CTRL-D		command-line completion (see |cmdline-completion|)
'wildchar' option
		command-line completion (see |cmdline-completion|)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-D}
コマンドライン補完 (|cmdline-completion|を参照)

オプション '@option{wildchar}' で指定したキーコマンドライン補完 (|cmdline-completion|を参照)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
CTRL-N		command-line completion (see |cmdline-completion|)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-N}
コマンドライン補完 (|cmdline-completion|を参照)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
CTRL-P		command-line completion (see |cmdline-completion|)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-P}
コマンドライン補完 (|cmdline-completion|を参照)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
CTRL-A		command-line completion (see |cmdline-completion|)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-A}
コマンドライン補完 (|cmdline-completion|を参照)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
CTRL-L		command-line completion (see |cmdline-completion|)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-L}
コマンドライン補完 (|cmdline-completion|を参照)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*c_CTRL-_*
CTRL-_		a - switch between Hebrew and English keyboard mode, which is
		private to the command-line and not related to hkmap.
		This is useful when Hebrew text entry is required in the
		command-line, searches, abbreviations, etc.  Applies only if
		Vim is compiled with the |+rightleft| feature and the
		'allowrevins' option is set.
		See |rileft.txt|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-_}
@cindex c_CTRL-_
@item @kbd{CTRL-_}
@enumerate
@item
キーボードのヘブライ語モードと英語モードを切り替える。これはコマンドラインのみに適用され、'@option{hkmap}' とは関係ない。

コマンドライン、検索や短縮入力等にヘブライ語テキストの項目が必要とされるときに便利である。Vim が |+rightleft| 機能付きでコンパイルされ、'@option{allowrevins}' がオンのときのみ有効。

|rileft.txt| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		b - switch between Farsi and English keyboard mode, which is
		private to the command-line and not related to fkmap.  In
		Farsi keyboard mode the characters are inserted in reverse
		insert manner.  This is useful when Farsi text entry is
		required in the command-line, searches, abbreviations, etc.
		Applies only if Vim is compiled with the |+farsi| feature.
		See |farsi.txt|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
キーボードのペルシア語モードと英語モードを切り替える。これはコマンドラインのみに適用され、オプション '@option{fkmap}' には関係しない。

ペルシア語モードでは、文字は普段とは反対の方向に挿入される。コマンドライン、検索や短縮入力等にペルシア語テキストの項目が必要とされるときに便利である。Vim が |+farsi| 機能付きでコンパイルされたときのみ有効。

|farsi.txt| を参照。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*c_CTRL-^*
CTRL-^		Toggle the use of language |:lmap| mappings and/or Input
		Method.
		When typing a pattern for a search command and 'imsearch' is
		not -1, VAL is the value of 'imsearch', otherwise VAL is the
		value of 'iminsert'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-^}
@cindex c_CTRL-^
@item @kbd{CTRL-^}
言語マッピング |:lmap| を切り替えたり、Input Method (IM) を切り替える。

検索コマンドのためにパターンを入力するとき、オプション '@option{imsearch}' が -1 でなければ VAL は '@option{imsearch}' の値に、そうでなければ VAL は '@option{iminsert}' の値になる。

@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When language mappings are defined:
		- If VAL is 1 (langmap mappings used) it becomes 0 (no langmap
		  mappings used).
		- If VAL was not 1 it becomes 1, thus langmap mappings are
		  enabled.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
言語マッピングが定義されているとき:
@itemize @minus
@item VAL が 1 のとき (言語マッピングが使われているとき) 0 に変わる (言語マッピングは使われなくなる)。
@item VAL が 1 でなければ 1 に変わり、言語マッピングが有効になる。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When no language mappings are defined:
		- If VAL is 2 (Input Method is used) it becomes 0 (no input
		  method used)
		- If VAL has another value it becomes 2, thus the Input Method
		  is enabled.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
言語マッピングが全く定義されていないとき:
@itemize @minus
@item VAL が 2 のとき (IM が使われているとき) 0 に変わる (IM は使われなくなる)
@item VAL が 2 以外のときは 2 に変わり、IM が有効になる。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		These language mappings are normally used to type characters
		that are different from what the keyboard produces.  The
		'keymap' option can be used to install a whole number of them.
		When entering a command line, langmap mappings are switched
		off, since you are expected to type a command.  After
		switching it on with CTRL-^, the new state is not used again
		for the next command or Search pattern.
		{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
普通、言語マッピングは、キーボードが生成するのと違う文字を打ち込むのに使われる。オプション '@option{keymap}' を使えばまとめて設定できる。

コマンドラインに入ったときは、コマンドを打ち込むはずなので、言語マッピングはオフに切り替えられる。@kbd{CTRL-^} でオンにした後も、次にコマンドや検索パターンを打ち込むときにはその状態は使われない。

@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*c_CTRL-]*
CTRL-]		Trigger abbreviation, without inserting a character.  {not in
		Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-]}
@cindex c_CTRL-]
@item @kbd{CTRL-]}
文字を挿入することなく短縮入力を展開する。

@{Vi にはない@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For Emacs-style editing on the command-line see |emacs-keys|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインを Emacs スタイルで編集する方法については |emacs-keys| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The <Up> and <Down> keys take the current command-line as a search string.
The beginning of the next/previous command-lines are compared with this
string.  The first line that matches is the new command-line.  When typing
these two keys repeatedly, the same string is used again.  For example, this
can be used to find the previous substitute command: Type ":s" and then <Up>.
The same could be done by typing <S-Up> a number of times until the desired
command-line is shown.  (Note: the shifted arrow keys do not work on all
terminals)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
キー @key{<Up>} と @key{<Down>} は現在のコマンドラインを検索文字列として扱う。次／以前のコマンドラインの先頭部分が、この文字列と比較される。マッチした最初の行が新しいコマンドラインとなる。

これら 2 つのキーを繰り返し入力すると、同じ文字列が検索に使われる。例えば、以前の置換コマンドを見つけるためにはこうする: ":s" の後 @key{<Up>} を打ち込むこと。同じことは、@kbd{<S-Up>} を望んだ行が出るまで数回打ち込むことでもできる。
@quotation
@strong{Note:} @*
シフトキーと矢印キーとの同時押しは、全ての端末で機能するわけではないことに注意
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:his* *:history*
:his[tory]	Print the history of last entered commands.
		{not in Vi}
		{not available when compiled without the |+cmdline_hist|
		feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:his}
@anchor{:history}
@cindex :his
@cindex :history
@table @asis
@item :his[tory]
最近入力されたコマンドの履歴を表示する。

@{Vi にはない@}

@{Vim が |+cmdline_hist| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:his[tory] [{name}] [{first}][, [{last}]]
		List the contents of history {name} which can be:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :his[tory] [@{name@}] [@{first@}][, [@{last@}]]
@{name@} の種類の履歴内容を一覧表示する。@{name@} に入るものは:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		c[md]	 or :		command-line history
		s[earch] or / or ?	search string history
		e[xpr]	 or =		expression register history
		i[nput]	 or @		input line history
		d[ebug]	 or >		debug command history
		a[ll]			all of the above
		{not in Vi}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .5 .5
@item c[md]	または : @tab コマンドラインの履歴
@item s[earch] または / または ? @tab 検索文字列の履歴
@item [xpr]	または = @tab Expression レジスタの履歴
@item i[nput] または @ @tab 入力行の履歴
@item d[ebug] または > @tab デバッグコマンドの履歴
@item a[ll] @tab 上記のもの全て
@end multitable
@{Vi にはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If the numbers {first} and/or {last} are given, the respective
		range of entries from a history is listed.  These numbers can
		be specified in the following form:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{first@} や @{last@} が指定されたときは、履歴中の指定された範囲の項目が表示される。これらの数字は次の形式で指定する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:history-indexing*
		A positive number represents the absolute index of an entry
		as it is given in the first column of a :history listing.
		This number remains fixed even if other entries are deleted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:history-indexing}
@cindex :history-indexing
正数は、"@command{:history}" の一覧表示で最初の列に表示される、項目の絶対的な番号を表す。この数字は、他の項目が削除されても固定されたままである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		A negative number means the relative position of an entry,
		counted from the newest entry (which has index -1) backwards.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
負数は項目の相対的な位置を示す。これは最も新しい項目 (番号 -1 を持つ) から後ろ向きに数えたものである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Examples:
		List entries 6 to 12 from the search history: >
			:history / 6,12
<
		List the penultimate entry from all histories: >
			:history all -2
<
		List the most recent two entries from all histories: >
			:history all -2,
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:

検索履歴の項目 6 から 12 までを一覧表示する。
@example
:history / 6,12
@end example
全履歴の最後から 2 番目を一覧表示する。
@example
:history all -2
@end example
全履歴の最近の 2 項目を一覧表示する。
@example
:history all -2,
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:keepp[atterns] {command}			*:keepp* *:keeppatterns*
		Execute {command}, without adding anything to the search
		history
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:keepp}
@anchor{:keeppatterns}
@cindex :keepp
@cindex :keeppatterns
@item :keepp[atterns] @{command@}
検索履歴に何も加えずに、@{command@} を実行する。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
2. Command-line completion				*cmdline-completion*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cmdline-completion}
@cindex cmdline-completion
@section 2. コマンドラインの補完
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When editing the command-line, a few commands can be used to complete the
word before the cursor.  This is available for:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインの編集をしているとき、いくつかのコマンドを使ってカーソル前の単語を補完できる。補完は以下のものに対して有効である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- Command names: At the start of the command-line.
- Tags: Only after the ":tag" command.
- File names: Only after a command that accepts a file name or a setting for
  an option that can be set to a file name.  This is called file name
  completion.
- Shell command names: After ":!cmd", ":r !cmd" and ":w !cmd".  $PATH is used.
- Options: Only after the ":set" command.
- Mappings: Only after a ":map" or similar command.
- Variable and function names: Only after a ":if", ":call" or similar command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize @minus
@item コマンド名: コマンドラインの先頭で使われる
@item タグ: コマンド "@command{:tag}" の後でのみ使われる
@item ファイル名: ファイル名を取るコマンドの後、またはファイル名に対して設定されるオプションの設定時のみ使われる。これはファイル名補完と呼ばれる。
@item シェルコマンド名: "@command{:!cmd}", "@command{:r !cmd}", "@command{:w !cmd}" の後で使われる。@env{$PATH} が考慮される。
@item オプション: コマンド "@command{:set}" の後でのみ使われる。
@item マッピング: "@command{:map}" や類似コマンドの後でのみ使われる。
@item 変数／関数名: "@command{:if}", "@command{:call}" や類似コマンドの後でのみ使われる。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When Vim was compiled without the |+cmdline_compl| feature only file names,
directories and help items can be completed.  The number of help item matches
is limited (currently to 300) to avoid a long delay when there are very many
matches.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim が |+cmdline_compl| 機能付きでコンパイルされなかったときは、ファイル名、ディレクトリ名、ヘルプの項目のみが補完される。マッチするヘルプ項目の個数には上限がある (現在のところは 300)。非常に多くのマッチがあったとき、遅くなるのを避けるためである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These are the commands that can be used:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
補完に使えるコマンドは以下の通り。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*c_CTRL-D*
CTRL-D		List names that match the pattern in front of the cursor.
		When showing file names, directories are highlighted (see
		'highlight' option).  Names where 'suffixes' matches are moved
		to the end.
		The 'wildoptions' option can be set to "tagfile" to list the
		file of matching tags.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-D}
@cindex c_CTRL-D
@table @asis
@item @kbd{CTRL-D}
カーソルより前のパターンに一致する名前を一覧表示する。ファイル名を表示しているときには、ディレクトリは強調表示される (オプション '@option{highlight}' を参照)。オプション '@option{suffixes}' の値がマッチした名前は、末尾の方に移動される。

'@option{wildoptions}' を "@var{tagfile}" にセットすると、マッチするタグを含むファイル名をリストすることができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*c_CTRL-I* *c_wildchar* *c_<Tab>*
'wildchar' option
		A match is done on the pattern in front of the cursor.  The
		match (if there are several, the first match) is inserted
		in place of the pattern.  (Note: does not work inside a
		macro, because <Tab> or <Esc> are mostly used as 'wildchar',
		and these have a special meaning in some macros.) When typed
		again and there were multiple matches, the next
		match is inserted.  After the last match, the first is used
		again (wrap around).
		The behavior can be changed with the 'wildmode' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-I}
@anchor{c_wildchar}
@anchor{c_<Tab>}
@cindex c_CTRL-I
@cindex c_wildchar
@cindex c_<Tab>
@item オプション '@option{wildchar}' で指定したキー
カーソルより前のパターンに対してマッチの検索が行われる。マッチ (いくつかあるなら、最初のもの) が、そのパターンの位置に挿入される。
@quotation
@strong{Note:} @*
これはマクロの中では機能しない。なぜなら <Tab> と <Esc> は大抵 '@option{wildchar}' として使われ、またいくつかのマクロの中ではこれらが特別な意味を持つからである
@end quotation
このキーを再び入力すると、複数のマッチがあるときは、次のマッチが挿入される。最後のマッチの後には、最初のマッチが再び使われる (繰り返し)。この動作は、オプション '@option{wildmode}' で変更できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*c_CTRL-N*
CTRL-N		After using 'wildchar' which got multiple matches, go to next
		match.  Otherwise recall more recent command-line from history.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-N}
@cindex c_CTRL-N
@item @kbd{CTRL-N}
'@option{wildchar}' を使ったら複数のマッチがあったとき、その後に使うと次のマッチが挿入される。それ以外のときには、より最近使ったコマンドラインを履歴から呼び出す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<S-Tab>							*c_CTRL-P* *c_<S-Tab>*
CTRL-P		After using 'wildchar' which got multiple matches, go to
		previous match.  Otherwise recall older command-line from
		history.  <S-Tab> only works with the GUI, on the Amiga and
		with MS-DOS.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-P}
@anchor{c_<S-Tab>}
@cindex c_CTRL-P
@cindex c_<S-Tab>
@item <S-Tab> または
@itemx @kbd{CTRL-P}
'@option{wildchar}' を使ったら複数のマッチがあったとき、その後に使うと前のマッチが挿入される。それ以外のときには、より昔に使ったコマンドラインを履歴から呼び出す。<S-Tab> は GUI 版、Amiga 版と MS-DOS 版でのみ機能する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*c_CTRL-A*
CTRL-A		All names that match the pattern in front of the cursor are
		inserted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-A}
@cindex c_CTRL-A
@item @kbd{CTRL-A}
カーソルより前のパターンに一致する、全ての名前が挿入される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*c_CTRL-L*
CTRL-L		A match is done on the pattern in front of the cursor.  If
		there is one match, it is inserted in place of the pattern.
		If there are multiple matches the longest common part is
		inserted in place of the pattern.  If the result is shorter
		than the pattern, no completion is done.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-L}
@cindex c_CTRL-L
@item @kbd{CTRL-L}
カーソルより前のパターンに対してマッチの検索が行われる。マッチが 1 個のときは、それがパターンの位置に挿入される。複数個のマッチがあったときは、最も長い共通部分がパターンの位置に挿入される。その結果がパターンより短い場合には、補完は行われない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*/_CTRL-L*
		When 'incsearch' is set, entering a search pattern for "/" or
		"?" and the current match is displayed then CTRL-L will add
		one character from the end of the current match.  If
		'ignorecase' and 'smartcase' are set and the command line has
		no uppercase characters, the added character is converted to
		lowercase.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{/_CTRL-L}
@cindex /_CTRL-L
'@option{incsearch}' がセットされていると、"/" や "?" で検索パターンを入力するとき現在のマッチが表示され、@kbd{CTRL-L} を押すと現在のマッチの末尾から1文字追加する。'@option{ignorecase}' と '@option{smartcase}' がセットされていてコマンドラインに大文字が含まれていないときは、追加された文字は小文字に変換される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	                                            *c_CTRL-G* */_CTRL-G*
CTRL-G		When 'incsearch' is set, entering a search pattern for "/" or
		"?" and the current match is displayed then CTRL-G will move
		to the next match (does not take |search-offset| into account)
		Use CTRL-T to move to the previous match.  Hint: on a regular
		keyboard T is above G.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-G}
@anchor{/_CTRL-G}
@cindex c_CTRL-G
@cindex /_CTRL-G
@item @kbd{CTRL-G}
'@option{incsearch}' が設定され "/" や "?" にパターンを入力して現在のマッチが表示されている時に、@kbd{CTRL-G} を押すと次のマッチに移動する (|search-offset| は考慮しない)。@kbd{CTRL-T} を押すと前のマッチに移動する。@strong{Hint:} 通常のキーボードでは、@key{T} は @key{G} より上にある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	                                            *c_CTRL-T* */_CTRL-T*
CTRL-T		When 'incsearch' is set, entering a search pattern for "/" or
		"?" and the current match is displayed then CTRL-T will move
		to the previous match (does not take |search-offset| into
		account).
		Use CTRL-G to move to the next match.  Hint: on a regular
		keyboard T is above G.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-T}
@anchor{/_CTRL-T}
@cindex c_CTRL-T
@cindex /_CTRL-T
@item @kbd{CTRL-T}
'@option{incsearch}' が設定され "/" や "?" にパターンを入力して現在のマッチが表示されている時に、@kbd{CTRL-T} は前のマッチに移動する (|search-offset| は考慮しない)。@kbd{CTRL-G} を使うと次のマッチに移動する。@strong{Hint:} 通常のキーボードは、@key{T} は @key{G} より上にある。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The 'wildchar' option defaults to <Tab> (CTRL-E when in Vi compatible mode; in
a previous version <Esc> was used).  In the pattern standard wildcards '*' and
'?' are accepted when matching file names.  '*' matches any string, '?'
matches exactly one character.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{wildchar}' の既定値は <Tab> である (Vi 互換モードの場合は CTRL-E である。以前のバージョンでは <Esc> が使われていた)。パターンがファイル名に対して適用されるときは標準のワイルドカード '*' と '?' が使用できる。'*' はあらゆる文字列に一致し、'?' はちょうど 1文字に一致する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The 'wildignorecase' option can be set to ignore case in filenames.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{wildignorecase}' を設定するとファイル名の大文字と小文字を区別しないようにできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The 'wildmenu' option can be set to show the matches just above the command
line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{wildmenu}' を設定するとコマンドラインのちょうど上にふさわしいものを表示する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you like tcsh's autolist completion, you can use this mapping:
	:cnoremap X <C-L><C-D>
(Where X is the command key to use, <C-L> is CTRL-L and <C-D> is CTRL-D)
This will find the longest match and then list all matching files.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
tcsh の autolist 補完が好みなら、このマッピングが使える。
@example
:cnoremap X <C-L><C-D>
@end example
(ここで X は使いたいコマンドキー。<C-L> は @kbd{CTRL-L}, <C-D> は @kbd{CTRL-D} のこと)

これは最長のマッチを見つけ、マッチしたファイルを全て一覧表示する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you like tcsh's autolist completion, you can use the 'wildmode' option to
emulate it.  For example, this mimics autolist=ambiguous:
	:set wildmode=longest,list
This will find the longest match with the first 'wildchar', then list all
matching files with the next.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
tcsh の autolist 補完が好みなら、オプション 'wildmode' を使ってその動作をエミュレートできる。例えば、次の設定は autolist=ambiguous という設定を真似る。
@example
:set wildmode=longest,list
@end example
これは、最初の '@option{wildchar}' で最長のマッチを見つけ、次はマッチするファイルを全て一覧表示する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*suffixes*
For file name completion you can use the 'suffixes' option to set a priority
between files with almost the same name.  If there are multiple matches,
those files with an extension that is in the 'suffixes' option are ignored.
The default is ".bak,~,.o,.h,.info,.swp,.obj", which means that files ending
in ".bak", "~", ".o", ".h", ".info", ".swp" and ".obj" are sometimes ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{suffixes}
@cindex suffixes
ファイル名補完では、オプション '@option{suffixes}' を使い、ほぼ同じ名前のファイル名に優先度を設定できる。複数のマッチがあったとき、あるファイルの拡張子が '@option{suffixes}' の値に含まれていると、そのファイルは無視される。既定値は "@var{.bak,~,.o,.h,.info,.swp}" であり、これは ".bak", "~", ".o", ".h", ".info", ".swp" で終わるファイルが無視されることがあるということである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An empty entry, two consecutive commas, match a file name that does not
contain a ".", thus has no suffix.  This is useful to ignore "prog" and prefer
"prog.c".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
空の項目(つまり2つの連続するコンマ)は "." を含まないファイル名(つまり拡張子を持たない)にマッチする。これは "prog" を無視させ、かつ "prog.c" にマッチさせたいときに便利である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  pattern:	files:				match:	~
   test*	test.c test.h test.o		test.c
   test*	test.h test.o			test.h and test.o
   test*	test.i test.h test.c		test.i and test.c
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .20 .45 .35
@item パターン: @tab 存在するファイル: @tab マッチ:
@item test* @tab test.c test.h test.o @tab test.c
@item test* @tab test.h test.o @tab test.h and test.o
@item test* @tab test.i test.h test.c @tab test.i and test.c
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It is impossible to ignore suffixes with two dots.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2 つのドットを持つ拡張子を無視することはできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If there is more than one matching file (after ignoring the ones matching
the 'suffixes' option) the first file name is inserted.  You can see that
there is only one match when you type 'wildchar' twice and the completed
match stays the same.  You can get to the other matches by entering
'wildchar', CTRL-N or CTRL-P.  All files are included, also the ones with
extensions matching the 'suffixes' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
(オプション '@option{suffixes}' による除外が行われた後で) マッチするファイルが複数個あるときは、最初のファイル名が挿入される。'@option{wildchar}' のキーを 2 度打ち込んでも補完されたマッチが同じだったら、マッチが 1 つしかないことが分かる。他のマッチは、'@option{wildchar}' のキーまたは @kbd{CTRL-N}, @kbd{CTRL-P} を入力することで得られる。それには '@option{suffixes}' に設定された拡張子にマッチするものも含め、全てのファイルが含まれる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To completely ignore files with some extension use 'wildignore'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ある拡張子のファイルを完全に無視するにはオプション '@option{wildignore}' を使うこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To match only files that end at the end of the typed text append a "$".  For
example, to match only files that end in ".c": >
	:e *.c$
This will not match a file ending in ".cpp".  Without the "$" it does match.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
入力されたテキストで終わるファイルにのみマッチさせるには、"$" をつけること。例として、".c" で終わるファイルにのみマッチさせるには:
@example
:e *.c$
@end example
これは ".cpp" で終わるファイルにはマッチしない。"$" をつけないとマッチする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The old value of an option can be obtained by hitting 'wildchar' just after
the '='.  For example, typing 'wildchar' after ":set dir=" will insert the
current value of 'dir'.  This overrules file name completion for the options
that take a file name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプションの、以前に設定された値は、'=' の後で '@option{wildchar}' のキーを打ち込むことで得られる。例えば、"@command{:set dir=}" の後で '@option{wildchar}' のキーを打ち込むと、'@var{dir}' の現在の値が挿入される。この動作は、ファイル名を取るオプションに対するファイル名補完より優先する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you would like using <S-Tab> for CTRL-P in an xterm, put this command in
your .cshrc: >
	xmodmap -e "keysym Tab = Tab Find"
And this in your .vimrc: >
	:cmap <Esc>[1~ <C-P>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
xterm で @kbd{<S-Tab>} を @kbd{CTRL-P} として使いたいときは、このコマンドをユーザーの @file{.cshrc} に加えること。
@verbatim
xmodmap -e "keysym Tab = Tab Find"
@end verbatim
そして次を @file{.vimrc} に加えること。
@verbatim
cmap <Esc>[1~ <C-P>
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
3. Ex command-lines					*cmdline-lines*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cmdline-lines}
@cindex cmdline-lines
@section 3. Exコマンドライン
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The Ex commands have a few specialties:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Ex コマンドはいくつかの特徴を持っている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:quote* *:comment*
'"' at the start of a line causes the whole line to be ignored.  '"'
after a command causes the rest of the line to be ignored.  This can be used
to add comments.  Example: >
	:set ai		"set 'autoindent' option
It is not possible to add a comment to a shell command ":!cmd" or to the
":map" command and a few others, because they see the '"' as part of their
argument.  This is mentioned where the command is explained.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:quote}
@anchor{:comment}
@cindex :quote
@cindex :comment
行の最初に '"' があると、その行全てが無視される。'"' がコマンドの後にあると、その行の残りの部分が無視される。これはコメントを加えるために使われる。例:
@verbatim
:set ai		"set 'autoindent' option
@end verbatim
シェルコマンド "@command{:!cmd}", コマンド "@command{:map}" とその他いくつかのコマンドにはコメントを付けることができない。これらのコマンドは '"' を引数の一部として認識するからである。各コマンドの説明のところにその旨の注意がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:bar* *:\bar*
'|' can be used to separate commands, so you can give multiple commands in one
line.  If you want to use '|' in an argument, precede it with '\'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:bar}
@anchor{:\bar}
@cindex :bar
@cindex :\bar
'|' を使ってコマンドを区切ることができる。これにより一行に複数のコマンドを書き込める。引数に '|' を使いたいときは、'\' を前に置くこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These commands see the '|' as their argument, and can therefore not be
followed by another Vim command:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下のコマンドは '|' を引数として認識するため、後に他のコマンドを続けることはできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    :argdo
    :autocmd
    :bufdo
    :cdo
    :cfdo
    :command
    :cscope
    :debug
    :folddoopen
    :folddoclosed
    :function
    :global
    :help
    :helpfind
    :lcscope
    :ldo
    :lfdo
    :make
    :normal
    :perl
    :perldo
    :promptfind
    :promptrepl
    :pyfile
    :python
    :registers
    :read !
    :scscope
    :sign
    :tcl
    :tcldo
    :tclfile
    :vglobal
    :windo
    :write !
    :[range]!
    a user defined command without the "-bar" argument |:command|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:argdo
:autocmd
:bufdo
:cdo
:cfdo
:command
:cscope
:debug
:folddoopen
:folddoclosed
:function
:global
:help
:helpfind
:lcscope
:ldo
:lfdo
:make
:normal
:perl
:perldo
:promptfind
:promptrepl
:pyfile
:python
:registers
:read !
:scscope
:sign
:tcl
:tcldo
:tclfile
:vglobal
:windo
:write !
:[range]!
@end verbatim
引数 "-bar" なしで定義されたユーザーコマンド |:command|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that this is confusing (inherited from Vi): With ":g" the '|' is included
in the command, with ":s" it is not.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
(Vi から継承されたのだが) 次の点は混乱を招きやすいので注意: '|' は ":g" と共に使うとコマンドの引数に含まれるが、":s" ではコマンドの区切りになる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To be able to use another command anyway, use the ":execute" command.
Example (append the output of "ls" and jump to the first line): >
	:execute 'r !ls' | '[
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
どうしても他のコマンドを使いたいときは、コマンド "@command{:execute}" を使うこと。例 (バッファに外部コマンド "ls" の出力を追加し、最初の行にジャンプする):
@example
:execute 'r !ls' | '[
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There is one exception: When the 'b' flag is present in 'cpoptions', with the
":map" and ":abbr" commands and friends CTRL-V needs to be used instead of
'\'.  You can also use "<Bar>" instead.  See also |map_bar|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例外が 1 点ある: オプション '@option{cpoptions}' にフラグ '@var{b}' が含まれるときは、"@command{:map}", "@command{:abbr}" またはその類似コマンドの引数に '|' を使うとき、'\' の代わりに @kbd{CTRL-V} を使う必要がある。代わりに "<Bar>" を使うこともできる。|map_bar| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:!ls | wc		view the output of two commands
	:r !ls | wc		insert the same output in the text
	:%g/foo/p|>		moves all matching lines one shiftwidth
	:%s/foo/bar/|>		moves one line one shiftwidth
	:map q 10^V|		map "q" to "10|"
	:map q 10\| map \ l	map "q" to "10\" and map "\" to "l"
					(when 'b' is present in 'cpoptions')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item :!ls | wc @tab 2 つのコマンドの出力を見る
@item :r !ls | wc @tab その出力をテキストに挿入する
@item :%g/foo/p|> @tab 一致した全ての行を shiftwidth 1 個分ずらす
@item :%s/foo/bar/|> @tab 1 つの行を shiftwidth 1 個分ずらす
@item :map q 10^V| @tab "q" に "10|" をマッピングする
@item :map q 10\| map \ l @tab "q" に "10\" を、"\" に "l" をマッピングする @* ('@var{b}' が '@option{cpoptions}' に含まれるとき)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can also use <NL> to separate commands in the same way as with '|'.  To
insert a <NL> use CTRL-V CTRL-J.  "^@" will be shown.  Using '|' is the
preferred method.  But for external commands a <NL> must be used, because a
'|' is included in the external command.  To avoid the special meaning of <NL>
it must be preceded with a backslash.  Example: >
	:r !date<NL>-join
This reads the current date into the file and joins it with the previous line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
<NL> を使って、'|' と同様にコマンドを区切ることができる。<NL> を挿入するには @kbd{CTRL-V} @kbd{CTRL-J} を使うこと。すると "^@@" が表示される。'|' を使う方が好ましいが、外部コマンドに対しては、'|' が外部コマンドに含まれてしまうため、<NL> を使わなければならない。<NL> の特別な作用を避けるためには、前に '\' を置く必要がある。例:
@example
:r !date<NL>-join
@end example
これは現在の日時をファイルに読み込み、それを前の行につなげる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that when the command before the '|' generates an error, the following
commands will not be executed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
'|' の前のコマンドがエラーを起こしたときは、以降のコマンドは実行されないことに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Because of Vi compatibility the following strange commands are supported: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vi との互換性のために、以下の奇妙なコマンドがサポートされている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:|			print current line (like ":p")
	:3|			print line 3 (like ":3p")
	:3			goto line 3
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item :| @tab 現在行を表示する (":p" と同様)
@item :3| @tab 3 行目を表示する (":3p" と同様)
@item :3 @tab 3 行目に移動する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A colon is allowed between the range and the command name.  It is ignored
(this is Vi compatible).  For example: >
	:1,$:s/pat/string
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
範囲とコマンド名の間にコロンを入れることができる。このコロンは無視される (これは Vi 互換の動作である)。例:
@example
:1,$:s/パターン/文字列
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the character '%' or '#' is used where a file name is expected, they are
expanded to the current and alternate file name (see the chapter "editing
files" |:_%| |:_#|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイル名が入るべき場所に、文字 '%' または '#' が使われているときは、それらはカレントファイル名、代替ファイル名に展開される ("ファイルの編集" の章を参照 |:_%| |:_#|)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Embedded spaces in file names are allowed on the Amiga if one file name is
expected as argument.  Trailing spaces will be ignored, unless escaped with a
backslash or CTRL-V.  Note that the ":next" command uses spaces to separate
file names.  Escape the spaces to include them in a file name.  Example: >
	:next foo\ bar goes\ to school\
starts editing the three files "foo bar", "goes to" and "school ".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Amiga では、引数がファイル名1個になるはずのとき、空白を含むファイル名が使用できる。ファイル名末尾の空白は、'\' や @kbd{CTRL-V} でエスケープされていない限り無視される。
@quotation
@strong{Note:} @*
コマンド "@command{:next}" では、ファイル名の区切りに空白を使うことに注意。ファイル名に空白を含むには、エスケープすること。例:
@example
:next foo\ bar goes\ to school\
@end example
こうすると3個のファイル "foo bar", "goes to", "school " の編集を開始する。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you want to use the special characters '"' or '|' in a command, or want
to use '%' or '#' in a file name, precede them with a backslash.  The
backslash is not required in a range and in the ":substitute" command.
See also |`=|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドで特別な文字 '"', '|' を使いたいとき、あるいはファイル名に '%', '#' を使いたいときは、'\' を前に置く。範囲指定やコマンド "@command{:substitute}" では '\' は必要ない。|`=| も参照のこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:_!*
The '!' (bang) character after an Ex command makes the command behave in a
different way.  The '!' should be placed immediately after the command, without
any blanks in between.  If you insert blanks the '!' will be seen as an
argument for the command, which has a different meaning.  For example:
	:w! name	write the current buffer to file "name", overwriting
			any existing file
	:w !name	send the current buffer as standard input to command
			"name"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:_!}
@cindex :_!
Ex コマンドの後に文字 '!' (bang) を置くと、コマンドの動作方法が変わる。'!' はコマンドの直後に置かなければならず、間に空白を入れてはならない。空白を挿入すると、'!' はコマンドの引数と見なされ、違った意味を持つことになる。例:
@multitable @columnfractions .2 .8
@item :w! name @tab 現在のバッファをファイル "name" に保存し、ファイルがすでに存在していると上書きする
@item :w !name @tab 現在のバッファを、標準入力からの入力としてコマンド "name" に送る
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
4. Ex command-line ranges	*cmdline-ranges* *[range]* *E16*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cmdline-ranges}
@anchor{[range]}
@anchor{E16}
@cindex cmdline-ranges
@cindex [range]
@cindex E16
@section 4. Ex コマンドラインの範囲
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Some Ex commands accept a line range in front of them.  This is noted as
[range].  It consists of one or more line specifiers, separated with ',' or
';'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Ex コマンドには、その前に行単位の範囲を指定できるものがある。これは [range] と表記される。それは ',' か ';' で区切られた、1個以上の行指定子から成る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The basics are explained in section |10.3| of the user manual.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
基本事項はユーザーマニュアルの |@ref{10.3, , 10.3}| 章で説明されている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:,* *:;*
When separated with ';' the cursor position will be set to that line
before interpreting the next line specifier.  This doesn't happen for ','.
Examples: >
   4,/this line/
<	from line 4 till match with "this line" after the cursor line. >
   5;/that line/
<	from line 5 till match with "that line" after line 5.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:,}
@anchor{:;}
@cindex :,
@cindex :;
区切りに ';' を使うと、次の行指定子を解釈する前にカーソル位置がその行に移動する。',' ではこうならない。例:
@example
4,/この行/
@end example
4 行目から、カーソルより後の、"この行" がマッチする行まで。
@example
5;/あの行/
@end example
5 行目から、5 行目より後の、"あの行" がマッチする行まで。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The default line specifier for most commands is the cursor position, but the
commands ":write" and ":global" have the whole file (1,$) as default.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ほとんどのコマンドでは、範囲の既定値はカーソルのある行である。しかしコマンド "@option{:write}", "@option{:global}" での既定値はファイル全体 (1,$) である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If more line specifiers are given than required for the command, the first
one(s) will be ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドに必要以上の行指定子が指定されたときは、先頭の方に指定されたものから順に除外される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Line numbers may be specified with:		*:range* *E14* *{address}*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:range}
@anchor{E14}
@anchor{@{address@}}
@cindex :range
@cindex E14
@cindex @{address@}
行番号は以下の方法で指定できる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	{number}	an absolute line number
	.		the current line			  *:.*
	$		the last line in the file		  *:$*
	%		equal to 1,$ (the entire file)		  *:%*
	't		position of mark t (lowercase)		  *:'*
	'T		position of mark T (uppercase); when the mark is in
			another file it cannot be used in a range
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .25 .75
@item @{number@} @tab 絶対的な行番号
@anchor{:.}
@cindex :.
@item . @tab 現在の行
@anchor{:$}
@cindex :$
@item $ @tab ファイルの最終行
@anchor{:%}
@cindex :%
@item % @tab 1,$と同じ (ファイル全体)
@anchor{:'}
@cindex :'
@item 't @tab マーク tの位置 (小文字)
@item 'T @tab マーク Tの位置 (大文字); マーク位置が別ファイルにあるときには範囲指定には使えない
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	/{pattern}[/]	the next line where {pattern} matches	  *:/*
	?{pattern}[?]	the previous line where {pattern} matches *:?*
	\/		the next line where the previously used search
			pattern matches
	\?		the previous line where the previously used search
			pattern matches
	\&		the next line where the previously used substitute
			pattern matches
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:/}
@cindex :/
@item /@{pattern@}[/] @tab 次に @{pattern@} のマッチする行 (下向き)
@anchor{:?}
@cindex :?
@item ?@{pattern@}[?] @tab 次に @{pattern@} のマッチする行 (上向き)
@item \/ @tab 次に直前の検索パターンのマッチする行 (下向き)
@item \? @tab 次に直前の検索パターンのマッチする行 (上向き)
@item \& @tab 次に直前の置換元パターンのマッチする行 (下向き)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Each may be followed (several times) by '+' or '-' and an optional number.
This number is added or subtracted from the preceding line number.  If the
number is omitted, 1 is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらの後に '+' または '-' と数値を付けてもよい (複数も可)。この数は直前の行番号に加算または減算される。数が省略された場合は 1 が指定されたと見なされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "/" and "?" after {pattern} are required to separate the pattern from
anything that follows.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{pattern@} の後の "/" と "?" は、パターンとその後の項目とを区別するために必要となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "/" and "?" may be preceded with another address.  The search starts from
there.  The difference from using ';' is that the cursor isn't moved.
Examples: >
	/pat1//pat2/	Find line containing "pat2" after line containing
			"pat1", without moving the cursor.
	7;/pat2/	Find line containing "pat2", after line 7, leaving
			the cursor in line 7.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"/" と "?" は別の場所指定の後に付くことがある。すると検索はそこから始まる。';' との違いは、カーソルが移動しない点である。例:
@multitable @columnfractions .25 .77
@item /pat1//pat2/ @tab "pat1" を含む行より後の、"pat2" を含む行を見つける。このときカーソルは移動しない。
@item 7;/pat2/ @tab 7行目より後の、"pat2" を含む行を見つける。このときカーソルは 7 行目に留まる。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The {number} must be between 0 and the number of lines in the file.  When
using a 0 (zero) this is interpreted as a 1 by most commands.  Commands that
use it as a count do use it as a zero (|:tag|, |:pop|, etc).  Some commands
interpret the zero as "before the first line" (|:read|, search pattern, etc).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{number@} は 0 からファイルの行数までの数でなければならない。0 (零) を使うと、コマンドの大半では 1 と解釈される。その数をカウントとして使うコマンド (|:tag|, |:pop| 等) では確かに 0 として使われる。0 を「先頭行の前」として解釈するコマンドもある (|:read|, 検索パターン等)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	.+3		three lines below the cursor
	/that/+1	the line below the next line containing "that"
	.,$		from current line until end of file
	0;/that		the first line containing "that", also matches in the
			first line.
	1;/that		the first line after line 1 containing "that"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .25 .77
@item .+3 @tab カーソルの 3 行下
@item /that/+1 @tab 次行より下の、"that" を含む行
@item .,$ @tab 現在行からファイル末尾まで
@item 0;/that @tab "that" を含む最初の行 (第 1 行にもマッチ可能)
@item 1;/that @tab 第 1 行より下の、"that" を含む行
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Some commands allow for a count after the command.  This count is used as the
number of lines to be used, starting with the line given in the last line
specifier (the default is the cursor line).  The commands that accept a count
are the ones that use a range but do not have a file name argument (because
a file name can also be a number).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
いくつかのコマンドには、後にカウントを指定できる。そのコマンドは、最後の行指定子で指定された行 (既定値はカーソルの行) から始まる、そのカウントの行数の範囲に使われる。カウントを取ることができるのは、範囲指定は取るがファイル名の引数を取らないコマンドである (ファイル名は数字でもよいから)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:s/x/X/g 5	substitute 'x' by 'X' in the current line and four
			following lines
	:23d 4		delete lines 23, 24, 25 and 26
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .25 .75
@item :s/x/X/g 5 @tab 現在行から始まる5行で 'x' を 'X' に置換
@item :23d 4 @tab 第23, 24, 25, 26行を削除
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Folds and Range
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 折り畳みと範囲指定
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When folds are active the line numbers are rounded off to include the whole
closed fold.  See |fold-behavior|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
折り畳みがアクティブなときは、閉じられた折り畳み全体を含むように範囲が切り上げ／切り下げられる。|fold-behavior| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Reverse Range						*E493*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E493}
@cindex E493
@unnumberedsubsec 逆向きの範囲指定
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A range should have the lower line number first.  If this is not the case, Vim
will ask you if it should swap the line numbers.
	Backwards range given, OK to swap ~
This is not done within the global command ":g".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
範囲には小さい行番号を先に指定しなければならない。そうでないときは、Vim はその行番号を入れ替えてよいかを尋ねる。
@display
Backwards range given, OK to swap
@end display
ただしグローバルコマンド ":g" では尋ねない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use ":silent" before a command to avoid the question, the range will
always be swapped then.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドの前に "@command{:silent}" をつけるとこの質問が出ないようになる。そのときは常に範囲が入れ替えられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Count and Range						*N:*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{N:}
@cindex N:
@unnumberedsubsec カウントと範囲指定
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When giving a count before entering ":", this is translated into:
		:.,.+(count - 1)
In words: The 'count' lines at and after the cursor.  Example: To delete
three lines: >
		3:d<CR>		is translated into: .,.+2d<CR>
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
":" を入力する前にカウントを指定すると、次のように変換される。
@example
:.,.+(count - 1)
@end example
つまりカーソルの行から始まる [count] 行のことである。例: 3 行を削除するにはこうする。
@example
3:d<CR>	    は    .,.+2d<CR>    に変換される
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Visual Mode and Range					*v_:*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_:}
@cindex v_:
@unnumberedsubsec ビジュアルモードと範囲指定
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{Visual}:	Starts a command-line with the Visual selected lines as a
		range.  The code `:'<,'>` is used for this range, which makes
		it possible to select a similar line from the command-line
		history for repeating a command on different Visually selected
		lines.
		When Visual mode was already ended, a short way to use the
		Visual area for a range is `:*`.  This requires that "*" does
		not appear in 'cpo', see |cpo-star|.  Otherwise you will have
		to type `:'<,'>`
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item @{Visual@}:
ビジュアルに選択された行を範囲として、コマンドライン入力を始める。この範囲指定にはコード `:'<,'>` が使われるので、コマンドライン履歴から同様のコマンド行を呼び出して、別のビジュアル選択行にコマンドを繰り返すことができる。

ビジュアルモードがすでに終了しているときは、`:*` を使うことで簡単にビジュアル選択を範囲指定できる。ただし "*" が 'cpo' オプションに含まれているときは使えない (|cpo-star| 参照)。そのときは `:'<,'>` を使う必要がある。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
==============================================================================
5. Ex command-line flags				*ex-flags*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ex-flags}
@cindex ex-flags
@section 5. Ex コマンドラインのフラグ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These flags are supported by a selection of Ex commands.  They print the line
that the cursor ends up after executing the command:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下のフラグがExコマンドの選択においてサポートされている。これらはコマンドを実行した後にカーソルが移動する位置の行を表示する:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	l	output like for |:list|
	#	add line number
	p	output like for |:print|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item l @tab |:list| のように表示する
@item # @tab 行番号をつける
@item p @tab |:print| のように表示する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The flags can be combined, thus "l#" uses both a line number and |:list| style
output.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのフラグは組み合わせることができる。つまり "l#" とすると行番号をつけて ":list" のスタイルで表示する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
6. Ex special characters				*cmdline-special*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cmdline-special}
@cindex cmdline-special
@section 6. Exコマンド用の特別な文字
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: These are special characters in the executed command line.  If you want
to insert special things while typing you can use the CTRL-R command.  For
example, "%" stands for the current file name, while CTRL-R % inserts the
current file name right away.  See |c_CTRL-R|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
以下はコマンドラインの実行における特別な文字である。@kbd{CTRL-R} コマンドを使うとこれらの特別な文字列を挿入することができる。例えば "%" は現在のファイル名を表す。@kbd{CTRL-R %}とするとその場に現在のファイル名を挿入する。|c_CTRL-R| を参照。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note:  If you want to avoid the effects of special characters in a Vim script
you may want to use |fnameescape()|.  Also see |`=|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
Vim script 内で特別な文字をエスケープするには |fnameescape()| を使うとよいかもしれない。|`=| も参照のこと。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
In Ex commands, at places where a file name can be used, the following
characters have a special meaning.  These can also be used in the expression
function |expand()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Ex コマンドの、ファイル名が使えるところでは、以下の文字は特別な意味を持つ。これらは式や関数 |expand()| 内でも使うことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	%	Is replaced with the current file name.		  *:_%* *c_%*
	#	Is replaced with the alternate file name.	  *:_#* *c_#*
		This is remembered for every window.
	#n	(where n is a number) is replaced with		  *:_#0* *:_#n*
		the file name of buffer n.  "#0" is the same as "#".     *c_#n*
	##	Is replaced with all names in the argument list	  *:_##* *c_##*
		concatenated, separated by spaces.  Each space in a name
		is preceded with a backslash.
	#<n	(where n is a number > 0) is replaced with old	  *:_#<* *c_#<*
		file name n.  See |:oldfiles| or |v:oldfiles| to get the
		number.							*E809*
		{only when compiled with the |+eval| and |+viminfo| features}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@anchor{:_%}
@anchor{c_%}
@cindex :_%
@cindex c_%
@item % @tab カレントファイル名に置き換えられる。
@anchor{:_#}
@anchor{c_#}
@cindex :_#
@cindex c_#
@item # @tab 代替ファイル名に置き換えられる。これはウィンドウごとに記憶される。
@anchor{:_#0}
@anchor{:_#n}
@anchor{c_#n}
@cindex :_#0
@cindex :_#n
@cindex c_#n
@item #n @tab (ここで n は数) バッファ n のファイル名に置き換えられる。"#0" は "#" と同じ。
@anchor{:_##}
@anchor{c_##}
@cindex :_##
@cindex c_##
@item ## @tab 引数リスト内の全てのファイル名を、空白で区切って列挙したものに置き換えられる。ファイル名の中の空白には、全て前に '\' が付けられる。
@anchor{:_#<}
@anchor{c_#<}
@anchor{E809}
@cindex :_#<
@cindex c_#<
@cindex E809
@item #<n @tab (n は > 0 の数値)。n 番目の old file 名に置き換えられる。この番号については |:oldfiles| や |v:oldfiles| を参照。

@{|+eval| と |+viminfo| 機能つきでコンパイルされたときのみ有効@}
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that these, except "#<n", give the file name as it was typed.  If an
absolute path is needed (when using the file name from a different directory),
you need to add ":p".  See |filename-modifiers|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"#<n" 以外は、ユーザーに打ち込まれた通りのファイル名を与えることに注意 @{訳注: 普通、カレントディレクトリのファイルは、パスを付けずにファイル名のみを打ち込んで編集を始めるはずだが、その形でファイル名が呼び出される@}。絶対パスが必要なとき (違うディレクトリのファイル名を使うとき) は、":p" を付け加える必要がある。|filename-modifiers| を参照。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "#<n" item returns an absolute path, but it will start with "~/" for files
below your home directory.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"#<n" は絶対パスを返す。ただしホームディレクトリ以下のファイルに対しては "~/" で始まる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that backslashes are inserted before spaces, so that the command will
correctly interpret the file name.  But this doesn't happen for shell
commands.  For those you probably have to use quotes (this fails for files
that contain a quote and wildcards): >
	:!ls "%"
	:r !spell "%"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
コマンドが適切に解釈できるように、スペースの前にはバックスラッシュがつく。しかしシェルコマンドに対してはこれは行われない。シェルコマンドに対しては、引用符を使うとよいかもしれない(しかしこれは引用符とワイルドカードを含む文字列に対しては失敗する):
@example
:!ls "%"
:r !spell "%"
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To avoid the special meaning of '%' and '#' insert a backslash before it.
Detail: The special meaning is always escaped when there is a backslash before
it, no matter how many backslashes.
	you type:		result	~
	   #			alternate.file
	   \#			#
	   \\#			\#
Also see |`=|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'%' と '#' の特別な意味を避けるためには、その前に '\' を挿入する。詳細: これらの文字の特別な意味は、'\' がその前に置かれれば、それがいくつあるかに関わらず、常にエスケープ (無効化) される。
@multitable @columnfractions .5 .5
@headitem 打ち込むキー: @tab 結果
@item # @tab 代替ファイル名
@item \# @tab #
@item \\# @tab \#
@end multitable
|`=| も参照のこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			       *:<cword>* *:<cWORD>* *:<cfile>* *<cfile>*
			       *:<sfile>* *<sfile>* *:<afile>* *<afile>*
			       *:<abuf>* *<abuf>* *:<amatch>* *<amatch>*
			       *:<cexpr>* *<cexpr>*
			       *<slnum>* *E495* *E496* *E497* *E499* *E500*
Note: these are typed literally, they are not special keys!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:<cword>}
@anchor{:<cWORD>}
@anchor{:<cfile>}
@anchor{<cfile>}
@anchor{:<sfile>}
@anchor{<sfile>}
@anchor{:<afile>}
@anchor{<afile>}
@anchor{:<abuf>}
@anchor{<abuf>}
@anchor{:<amatch>}
@anchor{<amatch>}
@anchor{:<cexpr>}
@anchor{<cexpr>}
@anchor{<slnum>}
@anchor{E495}
@anchor{E496}
@anchor{E497}
@anchor{E499}
@anchor{E500}
@cindex :<cword>
@cindex :<cWORD>
@cindex :<cfile>
@cindex <cfile>
@cindex :<sfile>
@cindex <sfile>
@cindex :<afile>
@cindex <afile>
@cindex :<abuf>
@cindex <abuf>
@cindex :<amatch>
@cindex <amatch>
@cindex :<cexpr>
@cindex <cexpr>
@cindex <slnum>
@cindex E495
@cindex E496
@cindex E497
@cindex E499
@cindex E500
@strong{Note:} これらは文字通りに打ち込まれる、これらは特別なキーではない！
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	<cword>    is replaced with the word under the cursor (like |star|)
	<cWORD>    is replaced with the WORD under the cursor (see |WORD|)
	<cexpr>    is replaced with the word under the cursor, including more
		   to form a C expression.  E.g., when the cursor is on "arg"
		   of "ptr->arg" then the result is "ptr->arg"; when the
		   cursor is on "]" of "list[idx]" then the result is
		   "list[idx]".  This is used for |v:beval_text|.
	<cfile>    is replaced with the path name under the cursor (like what
		   |gf| uses)
	<afile>    When executing autocommands, is replaced with the file name
		   for a file read or write.
	<abuf>     When executing autocommands, is replaced with the currently
		   effective buffer number (for ":r file" and ":so file" it is
		   the current buffer, the file being read/sourced is not in a
		   buffer).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item <cword>
カーソル下の word に置き換えられる (|star| と同様)
@item <cWORD>
カーソル下の WORD に置き換えられる (|WORD| を参照)
@item <cexpr>
カーソル下の word に置き換えられる。C 言語よりもっとたくさんの式において。例えば、カーソルが "ptr->arg" の "arg" 上にある時、結果は "ptr->arg" となる。カーソルが "list[idx]" の "]" 上にある時、結果は "list[idx]" となる。これは |v:beval_text| のために使われる。
@item <cfile>
カーソル下のパス名に置き換えられる (|gf| が使うものと同様)
@item <afile>
自動コマンドの実行時、ファイルの読み書き用のファイル名に置き換えられる
@item <abuf>
自動コマンドの実行時、カレントバッファの番号に置き換えられる (":r file" と ":so file" のときにもカレントバッファの番号に置き換えられる。読み込まれているファイルはバッファ内にない)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	<amatch>   When executing autocommands, is replaced with the match for
		   which this autocommand was executed.  It differs from
		   <afile> only when the file name isn't used to match with
		   (for FileType, Syntax and SpellFileMissing events).
	<sfile>    When executing a ":source" command, is replaced with the
		   file name of the sourced file.  *E498*
		   When executing a function, is replaced with:
		   "function {function-name}[{lnum}]"
		   function call nesting is indicated like this:
		   "function {function-name1}[{lnum}]..{function-name2}[{lnum}]"
		   Note that filename-modifiers are useless when <sfile> is
		   used inside a function.
	<slnum>	   When executing a ":source" command, is replaced with the
	           line number.  *E842*
		   When executing a function it's the line number relative to
		   the start of the function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item <amatch>
自動コマンドの実行時、この自動コマンドが実行されたときのマッチに置き換えられる。そのファイル名がマッチの検索に使われていないときのみ、<afile> と違う値になる (イベント FileType, Syntax, SpellFileMissing 用)。
@anchor{E498}
@cindex E498
@item <sfile>
コマンド "@command{:source}" の実行時、取り込まれたファイルのファイル名に置き換えられる。

関数の実行時はこのように置き換えられる:
@verbatim
"function {関数名}[{行番号}]"
@end verbatim
関数呼び出しのネスト (入れ子状態) はこのように表される:
@verbatim
"function {関数名1}[{行番号}]..{関数名2}[{行番号}]"
@end verbatim
@quotation
@strong{Note} @*
関数内で <sfile> が使われている場合、ファイル名修飾子は無効になることに注意。
@end quotation
@anchor{E842}
@cindex E842
@item <slnum>
コマンド "@command{:source}" の実行時、行番号に置き換えられる。関数の中では、関数の先頭からの相対的な行番号になる。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							 *filename-modifiers*
*:_%:* *::8* *::p* *::.* *::~* *::h* *::t* *::r* *::e* *::s* *::gs* *::S*
     *%:8* *%:p* *%:.* *%:~* *%:h* *%:t* *%:r* *%:e* *%:s* *%:gs* *%:S*
The file name modifiers can be used after "%", "#", "#n", "<cfile>", "<sfile>",
"<afile>" or "<abuf>".  They are also used with the |fnamemodify()| function.
These are not available when Vim has been compiled without the |+modify_fname|
feature.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{filename-modifiers}
@anchor{:_%:}
@anchor{::8}
@anchor{::p}
@anchor{::.}
@anchor{::~}
@anchor{::h}
@anchor{::t}
@anchor{::r}
@anchor{::e}
@anchor{::s}
@anchor{::gs}
@anchor{::S}
@anchor{%:8}
@anchor{%:p}
@anchor{%:.}
@anchor{%:~}
@anchor{%:h}
@anchor{%:t}
@anchor{%:r}
@anchor{%:e}
@anchor{%:s}
@anchor{%:gs}
@anchor{%:S}
@cindex filename-modifiers
@cindex :_%:
@cindex ::8
@cindex ::p
@cindex ::.
@cindex ::~
@cindex ::h
@cindex ::t
@cindex ::r
@cindex ::e
@cindex ::s
@cindex ::gs
@cindex ::S
@cindex %:8
@cindex %:p
@cindex %:.
@cindex %:~
@cindex %:h
@cindex %:t
@cindex %:r
@cindex %:e
@cindex %:s
@cindex %:gs
@cindex %:S
ファイル名修飾子は "%", "#", "#n", "<cfile>", "<sfile>", "<afile>", "<abuf>" の後で使うことができる。これらは関数 |fnamemodify()| と使うこともできる。Vim が |+modify_fname| 機能付きでコンパイルされていなければ、これらの修飾子を使うことはできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
These modifiers can be given, in this order:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらの修飾子は次の順で指定できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:p	Make file name a full path.  Must be the first modifier.  Also
		changes "~/" (and "~user/" for Unix and VMS) to the path for
		the home directory.  If the name is a directory a path
		separator is added at the end.  For a file name that does not
		exist and does not have an absolute path the result is
		unpredictable.  On MS-Windows an 8.3 filename is expanded to
		the long name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item :p
ファイル名を完全パスにする。最初の修飾子でなければならない。また "~/" (およびUnixやVMSで使われる "~user/" の形式のもの) もホームディレクトリのパスに変換する。

これが付けられたものがディレクトリ名に展開されるならば、パスの区切り文字が末尾に追加される。

これが付けられたものが、ディスク上に存在せず絶対パスを持たないファイルに展開されるときは、結果は予期できない。MS-Windows では 8.3 形式のファイル名はロングファイル名に展開される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:8	Converts the path to 8.3 short format (currently only on
		MS-Windows).  Will act on as much of a path that is an
		existing path.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :8
パスを短い 8.3 形式に変換する (現在のところ MS-Windows 版でのみ)。パスの内、実際に存在する部分に対して機能する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:~	Reduce file name to be relative to the home directory, if
		possible.  File name is unmodified if it is not below the home
		directory.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :~
ファイル名をホームディレクトリについて相対的な名前に (可能ならば) 切り詰める。ファイルがホームディレクトリの下になければ、ファイル名は修正されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:.	Reduce file name to be relative to current directory, if
		possible.  File name is unmodified if it is not below the
		current directory.
		For maximum shortness, use ":~:.".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :.
ファイル名をカレントディレクトリについて相対的な名前に (可能ならば) 切り詰める。ファイル名がカレントディレクトリの下になければ、ファイル名は修正されない。最も短く切り詰めるには ":~:." を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:h	Head of the file name (the last component and any separators
		removed).  Cannot be used with :e, :r or :t.
		Can be repeated to remove several components at the end.
		When the file name ends in a path separator, only the path
		separator is removed.  Thus ":p:h" on a directory name results
		on the directory name itself (without trailing slash).
		When the file name is an absolute path (starts with "/" for
		Unix; "x:\" for MS-DOS, WIN32, OS/2; "drive:" for Amiga), that
		part is not removed.  When there is no head (path is relative
		to current directory) the result is empty.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :h
ファイル名のヘッド (末尾の部分と全ての区切りが除かれたもの)。:e, :r, :t には使えない。繰り返すと、末尾から順に複数の部分を取り除くことができる。

ファイル名がパス区切りで終わるときは、パス区切りのみが取り除かれる。そのためディレクトリ名に ":p:h" を使うと、(末尾にパス区切りなしの) ディレクトリ名そのものが得られる。

ファイル名が絶対パス (Unix では "/"; MS-DOS, WIN32, OS/2 では "x:\"; Amiga では "drive:" で始まるもの) のときは、この部分は取り除かれない。

ヘッドがないときは (パスがカレントディレクトリに対して相対的なとき)、結果は空となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:t	Tail of the file name (last component of the name).  Must
		precede any :r or :e.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :t
ファイル名のテイル (名前の末尾の部分)。:r または :e よりも前に指定しなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:r	Root of the file name (the last extension removed).  When
		there is only an extension (file name that starts with '.',
		e.g., ".vimrc"), it is not removed.  Can be repeated to remove
		several extensions (last one first).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :r
ファイル名のルート (最後の拡張子が取り除かれたもの)。拡張子だけしかないときは ('.' で始まるファイル名、例えば ".vimrc" 等)、それは取り除かれない。繰り返し使うと、複数の拡張子を (最後のものから順に) 取り除くことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:e	Extension of the file name.  Only makes sense when used alone.
		When there is no extension the result is empty.
		When there is only an extension (file name that starts with
		'.'), the result is empty.  Can be repeated to include more
		extensions.  If there are not enough extensions (but at least
		one) as much as possible are included.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :e
ファイル名の拡張子。単独で使われたときのみ意味を持つ。拡張子がないときは、結果は空となる。

拡張子だけしかないときは ('.' で始まるファイル名)、結果は空となる。繰り返すと、複数の拡張子が得られる。繰り返した回数より拡張子の数の方が少ないときは、可能なだけ取り込まれる (しかし最低でも 1 個はないと取り込まれない)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:s?pat?sub?
		Substitute the first occurrence of "pat" with "sub".  This
		works like the |:s| command.  "pat" is a regular expression.
		Any character can be used for '?', but it must not occur in
		"pat" or "sub".
		After this, the previous modifiers can be used again.  For
		example ":p", to make a full path after the substitution.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :s?pat?sub?
最初に "pat" に一致したものを "sub" に置き換える。これはコマンド |:s| と同様に機能する。"pat" は正規表現である。'?' には任意の文字を使えるが、"pat" や "sub" 内に現れてはならない。

この後、上述の修飾子を再び使うことができる。例えば、":p" では置換した後でフルパスに変える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:gs?pat?sub?
		Substitute all occurrences of "pat" with "sub".  Otherwise
		this works like ":s".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :gs?pat?sub?
"pat" に一致したものを全て "sub" に置き換える。その他の点では ":s" と同様に機能する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:S	Escape special characters for use with a shell command (see
		|shellescape()|). Must be the last one. Examples: >
		    :!dir <cfile>:S
		    :call system('chmod +w -- ' . expand('%:S'))
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :S
シェルコマンドで利用できるように特別な文字をエスケープする。(|shellescape()| を参照)。最後でなければならない。例:
@example
:!dir <cfile>:S
:call system('chmod +w -- ' . expand('%:S'))
@end example
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples, when the file name is "src/version.c", current dir
"/home/mool/vim": >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイル名が "src/version.c"、カレントディレクトリが "/home/mool/vim" のときの例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
  :p			/home/mool/vim/src/version.c
  :p:.				       src/version.c
  :p:~				 ~/vim/src/version.c
  :h				       src
  :p:h			/home/mool/vim/src
  :p:h:h		/home/mool/vim
  :t					   version.c
  :p:t					   version.c
  :r				       src/version
  :p:r			/home/mool/vim/src/version
  :t:r					   version
  :e						   c
  :s?version?main?		       src/main.c
  :s?version?main?:p	/home/mool/vim/src/main.c
  :p:gs?/?\\?		\home\mool\vim\src\version.c
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:p                    /home/mool/vim/src/version.c
:p:.                                 src/version.c
:p:~                           ~/vim/src/version.c
:h                                   src
:p:h                  /home/mool/vim/src
:p:h:h                /home/mool/vim
:t                                       version.c
:p:t                                     version.c
:r                                   src/version
:p:r                  /home/mool/vim/src/version
:t:r                                     version
:e                                               c
:s?version?main?                     src/main.c
:s?version?main?:p    /home/mool/vim/src/main.c
:p:gs?/?\\?           \home\mool\vim\src\version.c
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples, when the file name is "src/version.c.gz": >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイル名が "src/version.c.gz" のときの例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
  :p			/home/mool/vim/src/version.c.gz
  :e						     gz
  :e:e						   c.gz
  :e:e:e					   c.gz
  :e:e:r					   c
  :r				       src/version.c
  :r:e						   c
  :r:r				       src/version
  :r:r:r			       src/version
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:p            /home/mool/vim/src/version.c.gz
:e                                         gz
:e:e                                     c.gz
:e:e:e                                   c.gz
:e:e:r                                   c
:r                           src/version.c
:r:e                                     c
:r:r                         src/version
:r:r:r                       src/version
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*extension-removal* *:_%<*
If a "<" is appended to "%", "#", "#n" or "CTRL-V p" the extension of the file
name is removed (everything after and including the last '.' in the file
name).  This is included for backwards compatibility with version 3.0, the
":r" form is preferred.  Examples: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{extension-removal}
@anchor{:_%<}
@cindex extension-removal
@cindex :_%<
"%", "#", "#n" または "CTRL-V p" に "<" を付け加えたとき、ファイル名の拡張子 (ファイル名の最後の '.' とそれ以降の全て) は取り除かれる。これは Vim version 3.0 との下位互換性のために残されており、":r" 形式を使う方がよい。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	%		current file name
	%<		current file name without extension
	#		alternate file name for current window
	#<		idem, without extension
	#31		alternate file number 31
	#31<		idem, without extension
	<cword>		word under the cursor
	<cWORD>		WORD under the cursor (see |WORD|)
	<cfile>		path name under the cursor
	<cfile><	idem, without extension
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item % @tab カレントファイル名
@item %< @tab 拡張子なしのカレントファイル名
@item # @tab カレントウィンドウでの代替ファイル名
@item #< @tab 同上、ただし拡張子なし
@item #31 @tab 代替ファイル番号 31
@item #31< @tab 同上、ただし拡張子なし
@item <cword> @tab カーソル下の word
@item <cWORD> @tab カーソル下の WORD (|WORD| を参照)
@item <cfile> @tab カーソル下のパス名
@item <cfile>< @tab 同上、ただし拡張子なし
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: Where a file name is expected wildcards expansion is done.  On Unix the
shell is used for this, unless it can be done internally (for speed).
Unless in |restricted-mode|, backticks work also, like in >
	:n `echo *.c`
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ファイル名が来る筈の所では、ワイルドカードの展開が行われる。Unix では展開にはシェルが使われる。ただし Vim 内部でできない展開だけである (スピードのため)。|restricted-mode| でなければ、バッククォート '`' も次のように使える。
@example
:n `echo *.c`
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
But expansion is only done if there are any wildcards before expanding the
'%', '#', etc..  This avoids expanding wildcards inside a file name.  If you
want to expand the result of <cfile>, add a wildcard character to it.
Examples: (alternate file name is "?readme?")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
しかし展開は、'%' や '#' 等が展開される前にワイルドカードが存在したときにのみ行われる。これはファイル名に含まれるワイルドカードを展開しないためである。<cfile> の結果を展開したいときは、ワイルドカードの文字を追加すればよい。例: (代替ファイル名は "?readme?" とする)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	command		expands to  ~
	:e #		:e ?readme?
	:e `ls #`	:e {files matching "?readme?"}
	:e #.*		:e {files matching "?readme?.*"}
	:cd <cfile>	:cd {file name under cursor}
	:cd <cfile>*	:cd {file name under cursor plus "*" and then expanded}
Also see |`=|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@headitem コマンド @tab 展開結果
@item :e # @tab :e ?readme?
@item :e `ls #` @tab :e @{"?readme?" にマッチしたファイル全て@}
@item :e #.* @tab :e @{"?readme?.*" にマッチしたファイル全て@}
@item :cd <cfile> @tab :cd @{カーソル下のファイル名@}
@item :cd <cfile>* @tab :cd @{カーソル下のファイル名に "*" を加え展開したもの@}
@end multitable
|`=| も参照のこと。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the expanded argument contains a "!" and it is used for a shell command
(":!cmd", ":r !cmd" or ":w !cmd"), the "!" is escaped with a backslash to
avoid it being expanded into a previously used command.  When the 'shell'
option contains "sh", this is done twice, to avoid the shell trying to expand
the "!".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
展開された後のコマンド引数に "!" に含まれていて、それがシェルコマンドに使われる (":!cmd", ":r !cmd" や ":w !cmd") とき、"!" は '\' でエスケープされ、前回のコマンドに展開されるのを防ぐ。オプション 'shell' の値が "sh" を含むときは、エスケープは 2 回行われ、シェルが "!" を展開するのを防ぐ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*filename-backslash*
For filesystems that use a backslash as directory separator (MS-DOS, Windows,
OS/2), it's a bit difficult to recognize a backslash that is used to escape
the special meaning of the next character.  The general rule is: If the
backslash is followed by a normal file name character, it does not have a
special meaning.  Therefore "\file\foo" is a valid file name, you don't have
to type the backslash twice.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{filename-backslash}
@cindex filename-backslash
'\' をディレクトリの区切りに使うファイルシステム (MS-DOS, Windows, OS/2) では、次のキャラクタの特別な意味をエスケープする目的の '\' を認識するのが少し困難である。一般的な規則は次の通り。'\' が普通のファイル名の文字の後にある場合は、特別な意味を持たない。したがって、"\file\foo" は有効なファイル名であり、'\' を 2 度打つ必要はない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An exception is the '$' sign.  It is a valid character in a file name.  But
to avoid a file name like "$home" to be interpreted as an environment variable,
it needs to be preceded by a backslash.  Therefore you need to use "/\$home"
for the file "$home" in the root directory.  A few examples:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例外は '$' 記号である。これはファイル名で有効な文字である。しかし "$home" のようなファイル名が環境変数として解釈されるのを避けるため、'\' をこの前に付ける必要がある。従ってルートディレクトリのファイル "$home" の指定には、"/\$home" を使う必要がある。いくつかの例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	FILE NAME	INTERPRETED AS	~
	$home		expanded to value of environment var $home
	\$home		file "$home" in current directory
	/\$home		file "$home" in root directory
	\\$home		file "\\", followed by expanded $home
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@headitem ファイル名 @tab その解釈
@item $home @tab 環境変数 $home の値に展開される
@item \$home @tab カレントディレクトリのファイル "$home"
@item /\$home @tab ルートディレクトリのファイル "$home"
@item \\$home @tab "\\" の後に $home の値を付け加えた名前のファイル
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Also see |`=|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|`=| も参照のこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
7. Command-line window				*cmdline-window* *cmdwin*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cmdline-window}
@anchor{cmdwin}
@cindex cmdline-window
@cindex cmdwin
@section 7. コマンドラインウィンドウ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*command-line-window*
In the command-line window the command line can be edited just like editing
text in any window.  It is a special kind of window, because you cannot leave
it in a normal way.
{not available when compiled without the |+cmdline_hist| or |+vertsplit|
feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{command-line-window}
@cindex command-line-window
コマンドラインウィンドウでは、普通のウィンドウでテキストを編集するのと同じようにコマンドラインを編集できる。コマンドラインウィンドウは特殊なウィンドウで、普通の方法でそこから出ることはできない。

@{Vim が |+cmdline_hist| 機能と |+vertsplit| 機能付きでコンパイルされたときのみ有効である。@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
OPEN						*c_CTRL-F* *q:* *q/* *q?*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_CTRL-F}
@anchor{q:}
@anchor{q/}
@anchor{q?}
@cindex c_CTRL-F
@cindex q:
@cindex q/
@cindex q?
@unnumberedsubsec 開 始
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are two ways to open the command-line window:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインウィンドウを開くには2通りの方法がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
1. From Command-line mode, use the key specified with the 'cedit' option.
   The default is CTRL-F when 'compatible' is not set.
2. From Normal mode, use the "q:", "q/" or "q?" command.
   This starts editing an Ex command-line ("q:") or search string ("q/" or
   "q?").  Note that this is not possible while recording is in progress (the
   "q" stops recording then).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item
コマンドラインモードで、オプション '@option{cedit}' で指定されたキーを使う。'@option{compatible}' がオフのときの既定値は @kbd{CTRL-F} である。
@item
ノーマルモードで、コマンド "q:", "q/" または "q?" を使う。"q:" でExコマンドラインの編集を始め、"q/" または "q?" で文字列を検索する。
@quotation
@strong{Note:} @*
打ち込んだキーの記録中にはこの方法は使えないことに注意 (そのときは "q" では記録が終了する)。
@end quotation
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the window opens it is filled with the command-line history.  The last
line contains the command as typed so far.  The left column will show a
character that indicates the type of command-line being edited, see
|cmdwin-char|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインウィンドウが開かれたとき、中にはコマンドラインの履歴が並んでいる。末尾の行には、その時点までに打ち込まれたコマンドが含まれる。左の列には、編集されているコマンドラインの種類を表す1文字が表示される。|cmdwin-char| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim will be in Normal mode when the editor is opened, except when 'insertmode'
is set.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインウィンドウが開かれたとき、Vim はノーマルモードに移るが、オプション '@option{insertmode}' がオンのときは挿入モードに移る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The height of the window is specified with 'cmdwinheight' (or smaller if there
is no room).  The window is always full width and is positioned just above the
command-line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインウィンドウの高さはオプション '@option{cmdwinheight}' で指定できる (ただし余裕がないとこれより低くなる)。常に幅は最大になり、場所はコマンドラインの直上である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
EDIT
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 編 集
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can now use commands to move around and edit the text in the window.  Both
in Normal mode and Insert mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインウィンドウ内では、コマンドを使ってあちこちへ移動したり、ウィンドウ内のテキストを編集できる。ノーマルモードと挿入モードが使える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It is possible to use ":", "/" and other commands that use the command-line,
but it's not possible to open another command-line window then.  There is no
nesting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
":" や "/" を始めとする、コマンドラインを使うコマンドも使えるが、そこから別のコマンドラインウィンドウを開くことはできない。コマンドラインウィンドウはネスト(入れ子状になること) できない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*E11*
The command-line window is not a normal window.  It is not possible to move to
another window or edit another buffer.  All commands that would do this are
disabled in the command-line window.  Of course it _is_ possible to execute
any command that you entered in the command-line window.  Other text edits are
discarded when closing the window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E11}
@cindex E11
コマンドラインウィンドウは普通のウィンドウではないので、別のウィンドウに移動したり、別のバッファを編集したりはできない。コマンドラインウィンドウでは、それらを行うコマンドは無効化されている。もちろんコマンドラインウィンドウで入力したコマンドならどんなものでも @strong{実 行 可 能} である。他のテキスト編集はコマンドラインウィンドウを閉じるときに破棄される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
CLOSE							*E199*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E199}
@cindex E199
@unnumberedsubsec 終了
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are several ways to leave the command-line window:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインウィンドウを終了するには、以下の通りの方法がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<CR>		Execute the command-line under the cursor.  Works both in
		Insert and in Normal mode.
CTRL-C		Continue in Command-line mode.  The command-line under the
		cursor is used as the command-line.  Works both in Insert and
		in Normal mode.  There is no redraw, thus the window will
		remain visible.
:quit		Discard the command line and go back to Normal mode.
		":close", ":exit", ":xit" and CTRL-\ CTRL-N also work.
:qall		Quit Vim, unless there are changes in some buffer.
:qall!		Quit Vim, discarding changes to any buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .15 .85
@item <CR> @tab カーソル下のコマンドラインを実行する。挿入モードと Normal モードの両方で有効である。
@item @kbd{CTRL-C} @tab コマンドラインモードとして継続する。カーソル下のコマンドラインが引き継がれる。挿入モードとノーマルモードの両方で有効である。再描画は行われないので、ウィンドウは可視状態のままになる。
@item :quit @tab コマンドラインを破棄してノーマルモードに戻る。":close", ":exit", ":xit" や CTRL-\ CTRL-N も有効である。
@item :qall @tab Vim を終了する (他のバッファに変更がない限り)。
@item :qall! @tab Vim を終了し、どのバッファの変更も破棄する。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Once the command-line window is closed the old window sizes are restored.  The
executed command applies to the window and buffer where the command-line was
started from.  This works as if the command-line window was not there, except
that there will be an extra screen redraw.
The buffer used for the command-line window is deleted.  Any changes to lines
other than the one that is executed with <CR> are lost.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインウィンドウが閉じられると、他のウィンドウのサイズは復元される。実行されたコマンドはコマンドラインウィンドウの開始元のウィンドウやバッファに適用される。これはコマンドラインウィンドウがなかったかのように動作するが、画面の再描画だけは余計に行われる。

コマンドラインウィンドウに使われたバッファは削除される。<CR> で実行された行以外に対する変更は、全て失われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you would like to execute the command under the cursor and then have the
command-line window open again, you may find this mapping useful: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カーソル下のコマンドを実行した後、もう一度コマンドラインウィンドウを開きたければ、このマップを使うとよいかもしれない:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:autocmd CmdwinEnter * map <buffer> <F5> <CR>q:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:autocmd CmdwinEnter * map <buffer> <F5> <CR>q:
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
VARIOUS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec その他
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The command-line window cannot be used:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec コマンドラインウィンドウは、以下のときには使えない:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- when there already is a command-line window (no nesting)
- for entering an encryption key or when using inputsecret()
- when Vim was not compiled with the |+vertsplit| feature
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize @minus
@item 既にコマンドラインウィンドウを開いているとき (ネストすなわち入れ子は不可)
@item 暗号化キーの入力時や関数 |inputsecret()| の使用時
@item Vim が |+vertsplit| 機能付きでコンパイルされていないとき
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Some options are set when the command-line window is opened:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec コマンドラインウィンドウが開かれると、以下のオプションの設定が変わる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
'filetype'	"vim", when editing an Ex command-line; this starts Vim syntax
		highlighting if it was enabled
'rightleft'	off
'modifiable'	on
'buftype'	"nofile"
'swapfile'	off
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item 'filetype' @tab "vim" (Ex コマンドラインの編集時に) これは、可能なら Vim script に対する構文強調表示を開始する
@item 'rightleft' @tab オフ
@item 'modifiable' @tab オン
@item 'buftype' @tab "nofile"
@item 'swapfile' @tab オフ
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It is allowed to write the buffer contents to a file.  This is an easy way to
save the command-line history and read it back later.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインウィンドウの内容をファイルに書き出すことができる。こうすれば、簡単にコマンドライン履歴を保存し、後で読み込むことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the 'wildchar' option is set to <Tab>, and the command-line window is used
for an Ex command, then two mappings will be added to use <Tab> for completion
in the command-line window, like this: >
	:imap <buffer> <Tab> <C-X><C-V>
	:nmap <buffer> <Tab> a<C-X><C-V>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{wildchar}' が @var{<Tab>} であり、コマンドラインウィンドウが Ex コマンドに対して使われているときは、以下の 2 個のマッピングが追加され、コマンドラインウィンドウ内でも @key{<Tab>} で補完ができるようになる。
@example
:imap <buffer> <Tab> <C-X><C-V>
:nmap <buffer> <Tab> a<C-X><C-V>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Note that hitting <Tab> in Normal mode will do completion on the next
character.  That way it works at the end of the line.
If you don't want these mappings, disable them with: >
	au CmdwinEnter [:>] iunmap <Tab>
	au CmdwinEnter [:>] nunmap <Tab>
You could put these lines in your vimrc file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ノーマルモードで @key{<Tab>} を打ち込むと、カーソルの次の文字の位置で補完を行うことに注意。この方法なら行末でも補完が行われる。それらのマッピングを望まないなら、次のようにして無効化すること。
@example
au CmdwinEnter [:>] iunmap <Tab>
au CmdwinEnter [:>] nunmap <Tab>
@end example
ユーザーの @file{.vimrc} ファイルに上の行を書き込んでおけばよい。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
While in the command-line window you cannot use the mouse to put the cursor in
another window, or drag statuslines of other windows.  You can drag the
statusline of the command-line window itself and the statusline above it.
Thus you can resize the command-line window, but not others.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドラインウィンドウ内では、マウスでカーソルを別のウィンドウに移したり、別のウィンドウのステータスラインをドラッグしたりはできない。コマンドラインウィンドウ自身のステータスラインはドラッグできる。上向きにずっとドラッグすると、直上のウィンドウのステータスラインも動き、コマンドラインウィンドウがさらに広くなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The |getcmdwintype()| function returns the type of the command-line being
edited as described in |cmdwin-char|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|getcmdwintype()| 関数は開いているコマンドラインの種類を返す。値の説明は |cmdwin-char| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
AUTOCOMMANDS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec 自動コマンドの適用
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Two autocommand events are used: |CmdwinEnter| and |CmdwinLeave|.  Since this
window is of a special type, the WinEnter, WinLeave, BufEnter and BufLeave
events are not triggered.  You can use the Cmdwin events to do settings
specifically for the command-line window.  Be careful not to cause side
effects!
Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2 種類の 自動コマンドのイベントが使われる: |CmdwinEnter| と |CmdwinLeave|。コマンドラインウィンドウは特別なウィンドウなので、イベント WinEnter, WinLeave, BufEnter, BufLeave は発生しない。コマンドラインウィンドウに対して特別に設定をするには、イベント Cmdwin を使う。副作用を引き起こさないよう注意！

例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:au CmdwinEnter :  let b:cpt_save = &cpt | set cpt=.
	:au CmdwinLeave :  let &cpt = b:cpt_save
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:au CmdwinEnter :  let b:cpt_save = &cpt | set cpt=.
:au CmdwinLeave :  let &cpt = b:cpt_save
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This sets 'complete' to use completion in the current window for |i_CTRL-N|.
Another example: >
	:au CmdwinEnter [/?]  startinsert
This will make Vim start in Insert mode in the command-line window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはカレントウィンドウで |i_CTRL-N| によって補完を行うよう '@option{complete}' を設定する。

別の例:
@example
:au CmdwinEnter [/?]  startinsert
@end example
こうすれば、コマンドラインウィンドウでは Vim は挿入モードに移る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*cmdwin-char*
The character used for the pattern indicates the type of command-line:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cmdwin-char}
@cindex cmdwin-char
パターンに使われる文字は、コマンドラインの種類を表す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:	normal Ex command
	>	debug mode command |debug-mode|
	/	forward search string
	?	backward search string
	=	expression for "= |expr-register|
	@	string for |input()|
	-	text for |:insert| or |:append|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item : @tab 普通の Ex コマンド
@item > @tab デバッグモードのコマンド |debug-mode|
@item / @tab 前方検索に使われる文字列
@item ? @tab 後方検索に使われる文字列
@item = @tab Expression レジスタ "= 用の expression |expr-register|
@item @ @tab 関数 |input()| に対して入力する文字列
@item - @tab コマンド |:insert| や |:append| に対して入力する文字列
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 vim:tw=78:ts=8:ft=help:norl:
@end ifset
