@ifset JA  @c ----------- v -----------  JA  -*- tab-width: 8 -*-
@node usr_41.txt, usr_42.txt, usr_40.txt, 目次
@unnumbered Vim script 書法
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*usr_41.txt*	For Vim version 8.1.  Last change: 2019 Jun 09

		     VIM USER MANUAL - by Bram Moolenaar

			      Write a Vim script
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
*usr_41.txt*	For Vim バージョン 8.1.  Last change: 2019 Jun 09

		     VIM USER MANUAL - by Bram Moolenaar

			      Vim script 書法
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
The Vim script language is used for the startup vimrc file, syntax files, and
many other things.  This chapter explains the items that can be used in a Vim
script.  There are a lot of them, thus this is a long chapter.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim script 言語は vimrc ファイルや構文ファイルなど、さまざまな目的に使われます。この章では Vim script の書き方を説明します。説明することがたくさんあるので大きな章になっています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|41.1|	Introduction
|41.2|	Variables
|41.3|	Expressions
|41.4|	Conditionals
|41.5|	Executing an expression
|41.6|	Using functions
|41.7|	Defining a function
|41.8|	Lists and Dictionaries
|41.9|	Exceptions
|41.10|	Various remarks
|41.11|	Writing a plugin
|41.12|	Writing a filetype plugin
|41.13|	Writing a compiler plugin
|41.14|	Writing a plugin that loads quickly
|41.15|	Writing library scripts
|41.16|	Distributing Vim scripts

     Next chapter: |usr_42.txt|  Add new menus
 Previous chapter: |usr_40.txt|  Make new commands
Table of contents: |usr_toc.txt|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item |@ref{41.1}| @tab はじめに
@item |@ref{41.2}| @tab 変数
@item |@ref{41.3}| @tab 式
@item |@ref{41.4}| @tab 条件式
@item |@ref{41.5}| @tab 式を実行する
@item |@ref{41.6}| @tab 関数を使う
@item |@ref{41.7}| @tab 関数を定義する
@item |@ref{41.8}| @tab リストと辞書
@item |@ref{41.9}| @tab 例外
@item |@ref{41.10}| @tab 注意事項
@item |@ref{41.11}| @tab プラグインを書く
@item |@ref{41.12}| @tab ファイルタイププラグインを書く
@item |@ref{41.13}| @tab コンパイラプラグインを書く
@item |@ref{41.14}| @tab プラグインを書く (高速ロード版)
@item |@ref{41.15}| @tab ライブラリスクリプトを書く
@item |@ref{41.16}| @tab Vim script を配布する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*41.1*	Introduction				*vim-script-intro* *script*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{41.1}
@anchor{vim-script-intro}
@anchor{script}
@cindex Vim script はじめに
@cindex vim-script-intro
@cindex script
@section はじめに
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Your first experience with Vim scripts is the vimrc file.  Vim reads it when
it starts up and executes the commands.  You can set options to values you
prefer.  And you can use any colon command in it (commands that start with a
":"; these are sometimes referred to as Ex commands or command-line commands).
   Syntax files are also Vim scripts.  As are files that set options for a
specific file type.  A complicated macro can be defined by a separate Vim
script file.  You can think of other uses yourself.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
誰もが最初に触れる Vim script は vimrc ファイルです。Vim が起動するときに読み込まれ、書かれているコマンドが実行されます。それにより好きなように設定を変更できます。vimrc の中ではすべてのコロンコマンドが使えます (":" で始まるコマンドのこと。Ex コマンドやコマンドラインコマンドと呼ばれることもある)。

シンタックスファイルも Vim script です。シンタックスファイルは、ファイルタイプ別にオプションを設定するファイルの一種です。複雑なマクロ定義を別ファイルに分けて保存しておくこともできます。このように、いろいろな使用方法が考えられます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Let's start with a simple example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
簡単な例から始めましょう:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let i = 1
	:while i < 5
	:  echo "count is" i
	:  let i += 1
	:endwhile
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let i = 1
:while i < 5
:  echo "count is" i
:  let i += 1
:endwhile
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	Note:
	The ":" characters are not really needed here.  You only need to use
	them when you type a command.  In a Vim script file they can be left
	out.  We will use them here anyway to make clear these are colon
	commands and make them stand out from Normal mode commands.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
実際には ":" を書く必要はありません。":" が必要なのはコマンドラインで入力するときだけです。Vim script ファイルを書くときは省略できます。このヘルプでは、コロンコマンドであることを強調し、ノーマルモードと区別するためにコロンを表記しています。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	Note:
	You can try out the examples by yanking the lines from the text here
	and executing them with :@"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
例文をヤンクして :@@" コマンドで実際に実行できます。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The output of the example code is:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
出力は次のようになります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	count is 1 ~
	count is 2 ~
	count is 3 ~
	count is 4 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
count is 1
count is 2
count is 3
count is 4
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In the first line the ":let" command assigns a value to a variable.  The
generic form is: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
1 行目では ":let" コマンドで変数に値を代入しています。書式は次のとおりです:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let {variable} = {expression}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:let @{variable@} = @{expression@}
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In this case the variable name is "i" and the expression is a simple value,
the number one.
   The ":while" command starts a loop.  The generic form is: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例では、変数名が "i"、式が 1 です。

"@command{:while}" コマンドでループを開始します。書式は次のとおりです:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:while {condition}
	:  {statements}
	:endwhile
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:while {condition}
:  {statements}
:endwhile
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The statements until the matching ":endwhile" are executed for as long as the
condition is true.  The condition used here is the expression "i < 5".  This
is true when the variable i is smaller than five.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
条件式が真である間、ステートメントが実行されます。例では、条件式は "i < 5" です。これは、i が 5 より小さい場合に真になります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	Note:
	If you happen to write a while loop that keeps on running, you can
	interrupt it by pressing CTRL-C (CTRL-Break on MS-Windows).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
何かのミスで while ループが止まらなかった場合は、@kbd{CTRL-C} を押せば中断できます (MS-Windows では @kbd{CTRL-Break})。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The ":echo" command prints its arguments.  In this case the string "count is"
and the value of the variable i.  Since i is one, this will print:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:echo}" コマンドは引数を出力します。例では、"count is" という文字列と、変数 i の値を出力しています。i が 1 なら、次のように表示されます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	count is 1 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
count is 1
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Then there is the ":let i += 1" command.  This does the same thing as
":let i = i + 1".  This adds one to the variable i and assigns the new value
to the same variable.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
":let i += 1" は ":let i = i + 1" と同じ意味です。変数 i に 1 を加算し、新しい値を同じ変数に代入します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The example was given to explain the commands, but would you really want to
make such a loop, it can be written much more compact: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上述の例は、実際にはもっと簡潔に書くことができます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:for i in range(1, 4)
	:  echo "count is" i
	:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:for i in range(1, 4)
:  echo "count is" i
:endfor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
We won't explain how |:for| and |range()| work until later.  Follow the links
if you are impatient.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:for}| と |@ref{range()}| の説明はもっと先です。すぐに知りたい人はリンク先にジャンプしてください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
FOUR KINDS OF NUMBERS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 4 種類の数値
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Numbers can be decimal, hexadecimal, octal or binary.  A hexadecimal number
starts with "0x" or "0X".  For example "0x1f" is decimal 31.  An octal number
starts with a zero.  "017" is decimal 15.  A binary number starts with "0b" or
"0B".  For example "0b101" is decimal 5.  Careful: don't put a zero before a
decimal number, it will be interpreted as an octal number!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
数値は 10 進数、16 進数、8 進数および 2 進数のいずれかで表記します。16 進数は "0x" か "0X" で開始します。例えば "0x1f" は 10 進数の 31 です。8 進数は "0" で開始します。例えば "017" は 10 進数の 15 です。2 進数は "0b" か "0B" で開始します。例えば "0b101" は 10 進数の 5 です。
@quotation
@strong{注意:} @*
10 進数で書くときは先頭に "0" を付けないでください。8 進数として扱われてしまいます。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   The ":echo" command always prints decimal numbers.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:echo}" コマンドは常に 10 進数で出力します。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:echo 0x7f 036
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:echo 0x7f 036
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	127 30 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
127 30
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A number is made negative with a minus sign.  This also works for hexadecimal,
octal and binary numbers.  A minus sign is also used for subtraction.  Compare
this with the previous example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
数値にマイナス記号を付けると負数になります。8 進数、16 進数や 2 進数も負数にできます。マイナス記号は減算記号としても使われます。次の例を上の例と比べてみてください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:echo 0x7f -036
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:echo 0x7f -036
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	97 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
97
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
White space in an expression is ignored.  However, it's recommended to use it
for separating items, to make the expression easier to read.  For example, to
avoid the confusion with a negative number above, put a space between the
minus sign and the following number: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
式の途中にある空白は無視されますが、可読性を高めるために、適切に空白で区切ることをお勧めします。例えば上記の数値が負数であると勘違いしてしまわないように、マイナス記号と数値の間に空白をいれましょう:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:echo 0x7f - 036
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:echo 0x7f - 036
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*41.2*	Variables
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{41.2}
@cindex Vim script 変数
@section 変数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A variable name consists of ASCII letters, digits and the underscore.  It
cannot start with a digit.  Valid variable names are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数名にはアルファベット、数字、アンダースコアが使えます。変数名を数字で開始することはできません。次のような変数名が使えます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	counter
	_aap3
	very_long_variable_name_with_underscores
	FuncLength
	LENGTH
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
counter
_aap3
very_long_variable_name_with_underscores
FuncLength
LENGTH
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Invalid names are "foo+bar" and "6var".
   These variables are global.  To see a list of currently defined variables
use this command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"foo+var" や "6var" のような名前は使えません。

例に挙げた変数はグローバル変数です。定義されている変数の一覧を見るのは次のコマンドを使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use global variables everywhere.  This also means that when the
variable "count" is used in one script file, it might also be used in another
file.  This leads to confusion at least, and real problems at worst.  To avoid
this, you can use a variable local to a script file by prepending "s:".  For
example, one script contains this code: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
グローバル変数はどこでも使えます。そのため、あるスクリプトファイルで "count" という変数を使ったとき、その変数は他のスクリプトでも使われている可能性があります。これは混乱を招きますし、トラブルの元です。それを避けるには "s:" を付けてスクリプトローカル変数を使います。例えば、次のように使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let s:count = 1
	:while s:count < 5
	:  source other.vim
	:  let s:count += 1
	:endwhile
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let s:count = 1
:while s:count < 5
:  source other.vim
:  let s:count += 1
:endwhile
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Since "s:count" is local to this script, you can be sure that sourcing the
"other.vim" script will not change this variable.  If "other.vim" also uses an
"s:count" variable, it will be a different copy, local to that script.  More
about script-local variables here: |script-variable|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"s:count" はスクリプトローカル変数なので、他のスクリプトファイルによって変更される心配はありません。他のスクリプトファイルで "s:count" 変数が使われていたとしても、それは別の変数です。スクリプトローカル変数についての詳細は |@ref{script-variable}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are more kinds of variables, see |internal-variables|.  The most often
used ones are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数の種類は他にもあります。|@ref{internal-variables}| 参照。次の変数がよく使われます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	b:name		variable local to a buffer
	w:name		variable local to a window
	g:name		global variable (also in a function)
	v:name		variable predefined by Vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item b:name @tab バッファローカル変数
@item w:name @tab ウィンドウローカル変数
@item g:name @tab グローバル変数 (関数内では g: 必須)
@item v:name @tab Vim が定義する変数
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DELETING VARIABLES
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 変数の削除
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Variables take up memory and show up in the output of the ":let" command.  To
delete a variable use the ":unlet" command.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数はメモリを消費します。"@command{:let}" コマンドの出力にも表示されます。変数を削除するには "@command{:unlet}" コマンドを使います。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:unlet s:count
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:unlet s:count
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This deletes the script-local variable "s:count" to free up the memory it
uses.  If you are not sure if the variable exists, and don't want an error
message when it doesn't, append !: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
スクリプトローカル変数の "@command{s:count}" が削除され、使用されていたメモリが開放されます。変数が存在しない場合でもエラーを起こしたくない場合は @samp{!} を付けてください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:unlet! s:count
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:unlet! s:count
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When a script finishes, the local variables used there will not be
automatically freed.  The next time the script executes, it can still use the
old value.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
スクリプトの実行が終了したとき、ローカル変数は自動的には削除されません。次に同じスクリプトを実行したときにその変数を使うことができます。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:if !exists("s:call_count")
	:  let s:call_count = 0
	:endif
	:let s:call_count = s:call_count + 1
	:echo "called" s:call_count "times"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if !exists("s:call_count")
:  let s:call_count = 0
:endif
:let s:call_count = s:call_count + 1
:echo "called" s:call_count "times"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "exists()" function checks if a variable has already been defined.  Its
argument is the name of the variable you want to check.  Not the variable
itself!  If you would do this: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"exists()" 関数は変数が定義されているかどうかをチェックします。引数に調べたい変数の名前を指定します。変数自体を指定するのではありません。例えば:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:if !exists(s:call_count)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:if !exists(s:call_count)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Then the value of s:call_count will be used as the name of the variable that
exists() checks.  That's not what you want.
   The exclamation mark ! negates a value.  When the value was true, it
becomes false.  When it was false, it becomes true.  You can read it as "not".
Thus "if !exists()" can be read as "if not exists()".
   What Vim calls true is anything that is not zero.  Zero is false.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは、s:call_count の値を変数名として exists() 関数を呼び出しているので、意味が違ってしまいます。

感嘆符 (! 記号) は値を反転します。値が真なら偽になり、偽なら真になります。この記号は "not" と読むことができます。つまり、"if !exists()" は "if not exists()" と読むことができます。

Vim では、0 以外の値はすべて真です。0 は偽です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	Note:
	Vim automatically converts a string to a number when it is looking for
	a number.  When using a string that doesn't start with a digit the
	resulting number is zero.  Thus look out for this: >
		:if "true"
<	The "true" will be interpreted as a zero, thus as false!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
数値が必要なところで文字列を使ったとき、文字列は自動的に数値に変換されます。文字列の先頭が数字ではなかった場合は 0 に変換されます。つまり: @*
        :if "true" @*
"true" は 0 に変換されるので偽になります。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
STRING VARIABLES AND CONSTANTS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 文字列変数と定数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
So far only numbers were used for the variable value.  Strings can be used as
well.  Numbers and strings are the basic types of variables that Vim supports.
The type is dynamic, it is set each time when assigning a value to the
variable with ":let".  More about types in |41.8|.
   To assign a string value to a variable, you need to use a string constant.
There are two types of these.  First the string in double quotes: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここまでは変数の値に数値だけを使っていましたが、文字列を使うこともできます。Vim は数値と文字列を基本型としてサポートしています。変数は動的に型付けされます。型は "@command{:let}" コマンドで変数に値を代入するたびに変化します。詳しくは |@ref{41.8}| を参照してください。

変数に文字列を代入するには文字列定数を使う必要があります。文字列定数には 2 つの種類があります。1 つはダブルクォート文字列です:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let name = "peter"
	:echo name
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let name = "peter"
:echo name
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	peter ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
peter
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to include a double quote inside the string, put a backslash in
front of it: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列の中でダブルクォートを使いたい場合は、バックスラッシュを前置してください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let name = "\"peter\""
	:echo name
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let name = "\"peter\""
:echo name
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	"peter" ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
"peter"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To avoid the need for a backslash, you can use a string in single quotes: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バックスラッシュを使いたくない場合はシングルクォート文字列を使ってください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let name = '"peter"'
	:echo name
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let name = '"peter"'
:echo name
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	"peter" ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
"peter"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Inside a single-quote string all the characters are as they are.  Only the
single quote itself is special: you need to use two to get one.  A backslash
is taken literally, thus you can't use it to change the meaning of the
character after it.
   In double-quote strings it is possible to use special characters.  Here are
a few useful ones:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シングルクォート文字列の中ではすべての文字がそのまま使われます。ただし、シングルクォートだけは特別で、1 つのシングルクォートを表すためには 2 つのシングルクォートを書く必要があります。バックスラッシュはそのまま使われるので、特殊文字は使えません。

ダブルクォート文字列の中では特殊文字が使えます。次のようなものがあります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	\t		<Tab>
	\n		<NL>, line break
	\r		<CR>, <Enter>
	\e		<Esc>
	\b		<BS>, backspace
	\"		"
	\\		\, backslash
	\<Esc>		<Esc>
	\<C-W>		CTRL-W
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item \t @tab <Tab>
@item \n @tab <NL>, 改行
@item \r @tab <CR>, <Enter>
@item \e @tab <Esc>
@item \b @tab <BS>, バックスペース
@item \" @tab "
@item \\ @tab \, バックスラッシュ
@item \<Esc> @tab <Esc>
@item \<C-W> @tab CTRL-W
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The last two are just examples.  The  "\<name>" form can be used to include
the special key "name".
   See |expr-quote| for the full list of special items in a string.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最後の 2 つはただの 1 例です。"\<name>" 形式で "name" という特殊キーを使うことができます。

文字列で使える特殊表記については |@ref{expr-quote}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*41.3*	Expressions
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{41.3}
@cindex Vim script 式
@section 式
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim has a rich, yet simple way to handle expressions.  You can read the
definition here: |expression-syntax|.  Here we will show the most common
items.
   The numbers, strings and variables mentioned above are expressions by
themselves.  Thus everywhere an expression is expected, you can use a number,
string or variable.  Other basic items in an expression are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim の式は高機能でシンプルです。式の定義については |@ref{expression-syntax}| を参照してください。ここでは基本的なことだけを説明します。

数値と文字列と変数はそれ自体が式です。つまり、式が必要なところでは数値でも文字列でも変数でも使えます。他にも次のようなものが使えます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	$NAME		environment variable
	&name		option
	@r		register
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .5 .5
@item $NAME @tab 環境変数
@item &name @tab オプション
@item @@r @tab レジスタ
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:echo "The value of 'tabstop' is" &ts
	:echo "Your home directory is" $HOME
	:if @a > 5
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:echo "The value of 'tabstop' is" &ts
:echo "Your home directory is" $HOME
:if @@a > 5
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The &name form can be used to save an option value, set it to a new value,
do something and restore the old value.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
&name 形式を使うと、オプションを保存し、別の値に設定し、何かを実行して、オプションを元に戻す、というようなことができます。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let save_ic = &ic
	:set noic
	:/The Start/,$delete
	:let &ic = save_ic
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let save_ic = &ic
:set noic
:/The Start/,$delete
:let &ic = save_ic
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This makes sure the "The Start" pattern is used with the 'ignorecase' option
off.  Still, it keeps the value that the user had set.  (Another way to do
this would be to add "\C" to the pattern, see |/\C|.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{ignorecase}' オプションをオフにしてから "The Start" パターンを検索しています。しかし設定は変更されません。(パターンに "\C" を加える方法でも同じことができます。|@ref{/\C}| 参照。)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MATHEMATICS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 数値計算
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It becomes more interesting if we combine these basic items.  Let's start with
mathematics on numbers:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
基本的な要素を組み合わせると面白くなってきます。まずは数値計算です:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	a + b		add
	a - b		subtract
	a * b		multiply
	a / b		divide
	a % b		modulo
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item a + b @tab 加算
@item a - b @tab 減算
@item a * b @tab 乗算
@item a / b @tab 除算
@item a % b @tab 剰余演算(余りを得る)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The usual precedence is used.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
演算子の優先順位は一般的な規則と同じです:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:echo 10 + 5 * 2
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:echo 10 + 5 * 2
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	20 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
20
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Grouping is done with parentheses.  No surprises here.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カッコを使って優先順位を変更できます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:echo (10 + 5) * 2
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:echo (10 + 5) * 2
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	30 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
30
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Strings can be concatenated with ".".  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列は "." で連結できます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:echo "foo" . "bar"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:echo "foo" . "bar"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	foobar ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
foobar
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the ":echo" command gets multiple arguments, it separates them with a
space.  In the example the argument is a single expression, thus no space is
inserted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:echo}" コマンドに複数の引数を指定すると、スペースで区切られて表示されます。これらの例では 1 つの式しか使われていないので、スペースは挿入されていません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Borrowed from the C language is the conditional expression:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
C 言語と同じ条件演算子も使えます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	a ? b : c
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
a ? b : c
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If "a" evaluates to true "b" is used, otherwise "c" is used.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"a" が真なら "b" が使われ、そうでなければ "c" が使われます。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let i = 4
	:echo i > 5 ? "i is big" : "i is small"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let i = 4
:echo i > 5 ? "i is big" : "i is small"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	i is small ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
i is small
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The three parts of the constructs are always evaluated first, thus you could
see it work as:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
被演算子の部分は優先的に評価されるので、次のように見なすことができます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	(a) ? (b) : (c)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
(a) ? (b) : (c)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*41.4*	Conditionals
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{41.4}
@cindex Vim script 条件式
@section 条件式
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The ":if" commands executes the following statements, until the matching
":endif", only when a condition is met.  The generic form is:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
":if" コマンドは条件が真の場合に ":endif" までのステートメントを実行します。書式は次のとおり:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:if {condition}
	   {statements}
	:endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if @{condition@}
   @{statements@}
:endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Only when the expression {condition} evaluates to true (non-zero) will the
{statements} be executed.  These must still be valid commands.  If they
contain garbage, Vim won't be able to find the ":endif".
   You can also use ":else".  The generic form for this is:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{condition@} を評価した結果が真 (0以外) であれば、@{statements@} の内容が実行されます。@{statements@} は正しく記述されている必要があります。不正な記述があると ":endif" までたどり着けません。

":else" を使うこともできます。書式は次のとおり:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:if {condition}
	   {statements}
	:else
	   {statements}
	:endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if @{condition@}
   @{statements@}
:else
   @{statements@}
:endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The second {statements} is only executed if the first one isn't.
   Finally, there is ":elseif":
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2 つ目の @{statements@} は条件が偽の場合にだけ実行されます。

":elseif" を使うこともできます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:if {condition}
	   {statements}
	:elseif {condition}
	   {statements}
	:endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if @{condition@}
   @{statements@}
:elseif @{condition@}
   @{statements@}
:endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This works just like using ":else" and then "if", but without the need for an
extra ":endif".
   A useful example for your vimrc file is checking the 'term' option and
doing something depending upon its value: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは ":else" に続けて "if" 文を使うのと同じ動作ですが、余計な ":endif" を使わなくて済みます。

vimrc ファイルで便利に使える例を示しましょう。'@option{term}' オプションの値を調べ、その値に応じて処理を分けます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:if &term == "xterm"
	:  " Do stuff for xterm
	:elseif &term == "vt100"
	:  " Do stuff for a vt100 terminal
	:else
	:  " Do something for other terminals
	:endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if &term == "xterm"
:  " xterm 用の設定
:elseif &term == "vt100"
:  " vt100 端末用の設定
:else
:  " その他の端末用の設定
:endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
LOGIC OPERATIONS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 論理演算子
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
We already used some of them in the examples.  These are the most often used
ones:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
今までの説明で既に論理演算子を使いました。次の演算子がよく使われます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	a == b		equal to
	a != b		not equal to
	a >  b		greater than
	a >= b		greater than or equal to
	a <  b		less than
	a <= b		less than or equal to
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item a == b @tab 等しい
@item a != b @tab 等しくない
@item a >  b @tab より大きい
@item a >= b @tab より大きいか等しい
@item a <  b @tab より小さい
@item a <= b @tab より小さいか等しい
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The result is one if the condition is met and zero otherwise.  An example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
条件が成立するなら 1、そうでなければ 0 が返ります。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:if v:version >= 700
	:  echo "congratulations"
	:else
	:  echo "you are using an old version, upgrade!"
	:endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if v:version >= 700
:  echo "おめでとう"
:else
:  echo "古いバージョンを使っています。更新してね!"
:endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here "v:version" is a variable defined by Vim, which has the value of the Vim
version.  600 is for version 6.0.  Version 6.1 has the value 601.  This is
very useful to write a script that works with multiple versions of Vim.
|v:version|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"v:version" は Vim によって定義されている変数で、Vim のバージョンが入っています。バージョン 6.0 なら 600、バージョン 6.1 なら 601 です。これは複数のバージョンに対応するスクリプトを書くときに便利です。|@ref{v:version}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The logic operators work both for numbers and strings.  When comparing two
strings, the mathematical difference is used.  This compares byte values,
which may not be right for some languages.
   When comparing a string with a number, the string is first converted to a
number.  This is a bit tricky, because when a string doesn't look like a
number, the number zero is used.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
論理演算子は数値でも文字列でも扱えます。文字列どうしを比較するときは数学的な差が比較されます。文字のバイト値を比較するので、一部の言語では正しい結果にならないかもしれません。

文字列と数値を比較するときは、文字列を数値に変換します。文字列が数字ではなかったときは 0 になるので注意してください。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:if 0 == "one"
	:  echo "yes"
	:endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if 0 == "one"
:  echo "yes"
:endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This will echo "yes", because "one" doesn't look like a number, thus it is
converted to the number zero.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは "yes" と表示されます。"one" は数字ではないので 0 に変換されるのです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For strings there are two more items:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列にはさらに 2 つの論理演算子があります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	a =~ b		matches with
	a !~ b		does not match with
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item a =~ b @tab パターンにマッチする
@item a !~ b @tab パターンにマッチしない
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The left item "a" is used as a string.  The right item "b" is used as a
pattern, like what's used for searching.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
左辺の "a" は文字列として扱われます。右辺の "b" は検索パターンとして扱われます。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:if str =~ " "
	:  echo "str contains a space"
	:endif
	:if str !~ '\.$'
	:  echo "str does not end in a full stop"
	:endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if str =~ " "
:  echo "str にはスペースが含まれている"
:endif
:if str !~ '\.$'
:  echo "str の末尾はピリオドではない"
:endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Notice the use of a single-quote string for the pattern.  This is useful,
because backslashes would need to be doubled in a double-quote string and
patterns tend to contain many backslashes.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
パターンを指定するのにシングルクォート文字列を使うのがコツです。ダブルクォート文字列ではバックスラッシュを二重に書く必要があり、そして、検索パターンではバックスラッシュをよく使うので、バックスラッシュだらけになってしまいます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The 'ignorecase' option is used when comparing strings.  When you don't want
that, append "#" to match case and "?" to ignore case.  Thus "==?" compares
two strings to be equal while ignoring case.  And "!~#" checks if a pattern
doesn't match, also checking the case of letters.  For the full table see
|expr-==|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列を比較するときは '@option{ignorecase}' オプションが使われます。大文字小文字の区別を明示的に指定したい場合は比較演算子に "#" (区別する) または "?" (区別しない) をつけます。大文字小文字を区別せずに等しいかどうかを比較したい場合は "==?" を使います。"!~#" ならパターンにマッチしないことを、大文字と小文字を区別して確認できます。演算子の一覧は |@ref{expr-==}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MORE LOOPING
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 他のループコマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The ":while" command was already mentioned.  Two more statements can be used
in between the ":while" and the ":endwhile":
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:while}" コマンドは既に説明しました。"@command{:while}" ループの中では 2 つのステートメントが使えます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:continue		Jump back to the start of the while loop; the
				loop continues.
	:break			Jump forward to the ":endwhile"; the loop is
				discontinued.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .25 .75
@item :continue @tab ループの先頭にジャンプしてループを継続する。
@item :break @tab "@command{:endwhile}" までジャンプしてループを脱ける。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:while counter < 40
	:  call do_something()
	:  if skip_flag
	:    continue
	:  endif
	:  if finished_flag
	:    break
	:  endif
	:  sleep 50m
	:endwhile
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:while counter < 40
:  call do_something()
:  if skip_flag
:    continue
:  endif
:  if finished_flag
:    break
:  endif
:  sleep 50m
:endwhile
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The ":sleep" command makes Vim take a nap.  The "50m" specifies fifty
milliseconds.  Another example is ":sleep 4", which sleeps for four seconds.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:sleep}" コマンドは Vim を一定時間停止します。"50m" は 50 ミリ秒です。"@command{:sleep 4}" なら 4 秒間スリープします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Even more looping can be done with the ":for" command, see below in |41.8|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
":for" コマンドを使ってループすることもできます。|@ref{41.8}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*41.5*	Executing an expression
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{41.5}
@cindex Vim script 式を実行する
@section 式を実行する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
So far the commands in the script were executed by Vim directly.  The
":execute" command allows executing the result of an expression.  This is a
very powerful way to build commands and execute them.
   An example is to jump to a tag, which is contained in a variable: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
今まではコマンドを直接書いてきました。"@command{:execute}" コマンドを使うと、式の評価結果をコマンドとして実行できます。これによってコマンドを動的に生成することができます。

例えば、変数に格納された文字列を使ってタグジャンプするには次のようにします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:execute "tag " . tag_name
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:execute "tag " . tag_name
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "." is used to concatenate the string "tag " with the value of variable
"tag_name".  Suppose "tag_name" has the value "get_cmd", then the command that
will be executed is: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列 "tag " と変数 "tag_name" の値を "." で連結しています。仮に "tag_name" の値が "get_cmd" だった場合、次のコマンドが実行されることになります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:tag get_cmd
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:tag get_cmd
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The ":execute" command can only execute colon commands.  The ":normal" command
executes Normal mode commands.  However, its argument is not an expression but
the literal command characters.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:execute}" コマンドはコロンコマンドのみ実行できます。"@command{:normal}" コマンドでノーマルモードコマンドを実行できますが、このコマンドの引数は文字がそのまま使われ、式としては評価されません。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:normal gg=G
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:normal gg=G
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This jumps to the first line and formats all lines with the "=" operator.
   To make ":normal" work with an expression, combine ":execute" with it.
Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このコマンドは一行目にジャンプしてから "=" オペレータですべての行を整形します。

"@command{:normal}" コマンドで式の値を使いたい場合は "@command{:execute}" と組み合わせてください。
例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:execute "normal " . normal_commands
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:execute "normal " . normal_commands
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The variable "normal_commands" must contain the Normal mode commands.
   Make sure that the argument for ":normal" is a complete command.  Otherwise
Vim will run into the end of the argument and abort the command.  For example,
if you start Insert mode, you must leave Insert mode as well.  This works: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数 "normal_commands" にはノーマルモードコマンドを入れておく必要があります。

"@command{:normal}" には完結したコマンドを指定するようにしてください。引数が最後まで実行された段階でコマンドは中断されます。例えば、挿入モードを開始した場合は挿入モードを終了しなくてはなりません。次のコマンドは正しく動作します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:execute "normal Inew text \<Esc>"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:execute "normal Inew text \<Esc>"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This inserts "new text " in the current line.  Notice the use of the special
key "\<Esc>".  This avoids having to enter a real <Esc> character in your
script.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは現在行に "new text" を挿入します。特殊キー "\<ESC>" を使っていることに注目してください。これによりスクリプトの中で本物の <Esc> 文字を使わないですみます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you don't want to execute a string but evaluate it to get its expression
value, you can use the eval() function: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列を実行するのではなく、その式の値を得たい場合は、eval() 関数を使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let optname = "path"
	:let optval = eval('&' . optname)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:let optname = "path"
:let optval = eval('&' . optname)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A "&" character is prepended to "path", thus the argument to eval() is
"&path".  The result will then be the value of the 'path' option.
   The same thing can be done with: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字 "&" と "path" を連結しているので eval() の引数は "&path" になります。戻り値は '@option{path}' オプションの値です。

次のようにすることもできます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:exe 'let optval = &' . optname
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:exe 'let optval = &' . optname
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*41.6*	Using functions
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{41.6}
@cindex Vim script 関数を使う
@section 関数を使う
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim defines many functions and provides a large amount of functionality that
way.  A few examples will be given in this section.  You can find the whole
list here: |functions|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
たくさんの関数があらかじめ定義され、豊富な機能が提供されています。このセクションの説明にもいくつか登場します。関数の一覧は |@ref{functions}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A function is called with the ":call" command.  The parameters are passed in
between parentheses separated by commas.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数は "@option{:call}" コマンドで呼び出します。引数はカッコで囲み、それぞれをコンマで区切ります。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:call search("Date: ", "W")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:call search("Date: ", "W")
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This calls the search() function, with arguments "Date: " and "W".  The
search() function uses its first argument as a search pattern and the second
one as flags.  The "W" flag means the search doesn't wrap around the end of
the file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは "Date: " と "W" を引数にして search() 関数を呼び出しています。search() 関数は 1 つ目の引数を検索パターンとして使い、2 つ目の引数をフラグとして使います。"W" フラグを指定するとファイル末尾で検索が終了します (折り返さない)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A function can be called in an expression.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数は式の中で使うこともできます。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let line = getline(".")
	:let repl = substitute(line, '\a', "*", "g")
	:call setline(".", repl)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:let line = getline(".")
:let repl = substitute(line, '\a', "*", "g")
:call setline(".", repl)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The getline() function obtains a line from the current buffer.  Its argument
is a specification of the line number.  In this case "." is used, which means
the line where the cursor is.
   The substitute() function does something similar to the ":substitute"
command.  The first argument is the string on which to perform the
substitution.  The second argument is the pattern, the third the replacement
string.  Finally, the last arguments are the flags.
   The setline() function sets the line, specified by the first argument, to a
new string, the second argument.  In this example the line under the cursor is
replaced with the result of the substitute().  Thus the effect of the three
statements is equal to: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
getline() 関数はカレントバッファから行を取得する関数です。引数には行番号を指定します。この例では "." ですが、これはカーソルのある行を示します。

substitute() 関数は "@command{:substitute}" コマンドとほぼ同じです。最初の引数は置換対象の文字列、2 つ目の引数はパターン、3 つ目は置き換え文字列、最後はフラグです。

setline() 関数は行の内容を置き換えます。最初の引数は行番号、2 つ目の引数は置き換える文字列です。この例では、substitute() の結果で現在行を置き換えています。上記の 3 行のコマンドは次のコマンドと同じことをしています:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:substitute/\a/*/g
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:substitute/\a/*/g
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Using the functions becomes more interesting when you do more work before and
after the substitute() call.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
substitute() コマンドの前後にいろいろな処理を入れたりすると、もっと面白いことができるようになります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
FUNCTIONS						*function-list*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{function-list}
@cindex function-list
@cindex Vim script 関数一覧
@unnumberedsubsec 関数一覧
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are many functions.  We will mention them here, grouped by what they are
used for.  You can find an alphabetical list here: |functions|.  Use CTRL-] on
the function name to jump to detailed help on it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
たくさんの関数があります。ここでは機能別に分類して紹介します。アルファベット順の一覧は |@ref{functions}| を参照してください。関数の名前の上で @kbd{CTRL-]} を押すと、詳細な説明にジャンプできます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
String manipulation:					*string-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{string-functions}
@cindex string-functions
@cindex Vim script 文字列繰作
@unnumberedsubsubsec 文字列繰作:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	nr2char()		get a character by its number value
	list2str()		get a character string from a list of numbers
	char2nr()		get number value of a character
	str2list()		get list of numbers from a string
	str2nr()		convert a string to a Number
	str2float()		convert a string to a Float
	printf()		format a string according to % items
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item @ref{nr2char()} @tab 数値から文字を得る
@item @ref{list2str()} @tab 数値のリストから文字列を得る
@item @ref{char2nr()} @tab 文字の数値を得る
@item @ref{str2list()} @tab 文字列から数値のリストを得る
@item @ref{str2nr()} @tab 文字列を数値に変換する
@item @ref{str2float()} @tab 文字列を浮動小数点数に変換する
@item @ref{printf()} @tab 書式付き文字列を整形する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	escape()		escape characters in a string with a '\'
	shellescape()		escape a string for use with a shell command
	fnameescape()		escape a file name for use with a Vim command
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{escape()} @tab 文字列の特定の文字を '\' でエスケープ
@item @ref{shellescape()} @tab シェルコマンドで使えるように文字列をエスケープ
@item @ref{fnameescape()} @tab Vim コマンド用にファイル名をエスケープ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	tr()			translate characters from one set to another
	strtrans()		translate a string to make it printable
	tolower()		turn a string to lowercase
	toupper()		turn a string to uppercase
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{tr()} @tab ある文字の集合から別の文字の集合へ置換する
@item @ref{strtrans()} @tab 文字列を印刷可能な状態とする
@item @ref{tolower()} @tab 文字列を小文字にする
@item @ref{toupper()} @tab 文字列を大文字にする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	match()			position where a pattern matches in a string
	matchend()		position where a pattern match ends in a string
	matchstr()		match of a pattern in a string
	matchstrpos()		match and positions of a pattern in a string
	matchlist()		like matchstr() and also return submatches
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{match()} @tab 文字列の中でパターンにマッチした位置
@item @ref{matchend()} @tab 文字列の中でパターンにマッチした末尾の位置
@item @ref{matchstr()} @tab 文字列の中でパターンにマッチした文字列
@item @ref{matchstrpos()} @tab 文字列の中でパターンにマッチした文字列と位置
@item @ref{matchlist()} @tab matchstr()と同様だが、部分マッチも返す
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	stridx()		first index of a short string in a long string
	strridx()		last index of a short string in a long string
	strlen()		length of a string in bytes
	strchars()		length of a string in characters
	strwidth()		size of string when displayed
	strdisplaywidth()	size of string when displayed, deals with tabs
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{stridx()} @tab 文字列の中で部分文字列が見つかった最初の位置
@item @ref{strridx()} @tab 文字列の中で部分文字列が見つかった最後の位置
@item @ref{strlen()} @tab 文字列のバイト単位での長さ
@item @ref{strchars()} @tab 文字列の文字単位での長さ
@item @ref{strwidth()} @tab 表示された文字列のサイズ
@item @ref{strdisplaywidth()} @tab 表示された文字列のサイズ、タブに関係する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	substitute()		substitute a pattern match with a string
	submatch()		get a specific match in ":s" and substitute()
	strpart()		get part of a string using byte index
	strcharpart()		get part of a string using char index
	strgetchar()		get character from a string using char index
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{substitute()} @tab パターンにマッチする文字列を置換
@item @ref{submatch()} @tab ":s" と substitute() の中で部分マッチを得る
@item @ref{strpart()} @tab 文字列の一部分を得る(バイト数指定)
@item @ref{strcharpart()} @tab 文字のインデックスで指定された部分文字列を得る
@item @ref{strgetchar()} @tab 文字のインデックスで指定された文字コードを得る
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	expand()		expand special keywords
	expandcmd()		expand a command like done for `:edit`
	iconv()			convert text from one encoding to another
	byteidx()		byte index of a character in a string
	byteidxcomp()		like byteidx() but count composing characters
	repeat()		repeat a string multiple times
	eval()			evaluate a string expression
	execute()		execute an Ex command and get the output
	win_execute()		like execute() but in a specified window
	trim()			trim characters from a string
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{expand()} @tab 特殊キーワードを展開する
@item @ref{expandcmd()} @tab `@command{:edit}` のようにコマンドを展開する
@item @ref{iconv()} @tab テキストのエンコーディングを変換する
@item @ref{byteidx()} @tab 文字列中の文字のバイトインデックス
@item @ref{byteidxcomp()} @tab byteidx() と同様だが合成文字を数に入れる
@item @ref{repeat()} @tab 文字列を複数回繰り返す
@item @ref{eval()} @tab 文字列を式として評価する
@item @ref{execute()} @tab Ex コマンドを実行し出力を得る
@item @ref{win_execute()} @tab execute() に似ているが指定ウィンドウで実行する
@item @ref{trim()} @tab 文字列から文字をトリムする
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
List manipulation:					*list-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{list-functions}
@cindex list-functions
@cindex Vim script リスト操作
@unnumberedsubsubsec リスト操作:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	get()			get an item without error for wrong index
	len()			number of items in a List
	empty()			check if List is empty
	insert()		insert an item somewhere in a List
	add()			append an item to a List
	extend()		append a List to a List
	remove()		remove one or more items from a List
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .25 .75
@item @ref{get()} @tab 要素を取得。存在しないインデックスでもエラーを出さない
@item @ref{len()} @tab リスト中の要素の個数
@item @ref{empty()} @tab リストが空であるか判定する
@item @ref{insert()} @tab リストの任意の位置に要素を挿入する
@item @ref{add()} @tab リストに要素を追加する
@item @ref{extend()} @tab リストにリストを連結する
@item @ref{remove()} @tab リストから1個以上の要素を取り除く
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	copy()			make a shallow copy of a List
	deepcopy()		make a full copy of a List
	filter()		remove selected items from a List
	map()			change each List item
	sort()			sort a List
	reverse()		reverse the order of a List
	uniq()			remove copies of repeated adjacent items
	split()			split a String into a List
	join()			join List items into a String
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{copy()} @tab リストの浅いコピーを作成する
@item @ref{deepcopy()} @tab リストの完全なコピーを作成する
@item @ref{filter()} @tab リストから選択された要素を取り除く
@item @ref{map()} @tab リストの各要素を変換する
@item @ref{sort()} @tab リストをソートする
@item @ref{reverse()} @tab リストの並び順を反転させる
@item @ref{uniq()} @tab 隣接して繰り返される要素のコピーを削除する
@item @ref{split()} @tab 文字列を分割し、リストにする
@item @ref{join()} @tab リストの要素を連結し、文字列にする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	range()			return a List with a sequence of numbers
	string()		String representation of a List
	call()			call a function with List as arguments
	index()			index of a value in a List
	max()			maximum value in a List
	min()			minimum value in a List
	count()			count number of times a value appears in a List
	repeat()		repeat a List multiple times
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{range()} @tab 数列リストを返す
@item @ref{string()} @tab リストの文字列表現
@item @ref{call()} @tab リストを引数として関数を呼ぶ
@item @ref{index()} @tab リスト中の要素のインデックス
@item @ref{max()} @tab リスト中の最大値
@item @ref{min()} @tab リスト中の最小値
@item @ref{count()} @tab ある要素がリスト中に出現する回数を返す
@item @ref{repeat()} @tab リストを複数回繰り返す
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Dictionary manipulation:				*dict-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{dict-functions}
@cindex dict-functions
@cindex Vim script 辞書操作
@unnumberedsubsubsec 辞書操作:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	get()			get an entry without an error for a wrong key
	len()			number of entries in a Dictionary
	has_key()		check whether a key appears in a Dictionary
	empty()			check if Dictionary is empty
	remove()		remove an entry from a Dictionary
	extend()		add entries from one Dictionary to another
	filter()		remove selected entries from a Dictionary
	map()			change each Dictionary entry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .25 .75
@item @ref{get()} @tab 辞書の要素を返す。存在しないキーでもエラーを出さない
@item @ref{len()} @tab 辞書の要素の個数
@item @ref{has_key()} @tab あるキーが辞書に含まれているか判定する
@item @ref{empty()} @tab 辞書が空であるか判定する
@item @ref{remove()} @tab 辞書から要素を取り除く
@item @ref{extend()} @tab ある辞書の要素をすべて別の辞書に追加する
@item @ref{filter()} @tab 辞書から選択された要素を取り除く
@item @ref{map()} @tab 辞書の各要素を変換する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	keys()			get List of Dictionary keys
	values()		get List of Dictionary values
	items()			get List of Dictionary key-value pairs
	copy()			make a shallow copy of a Dictionary
	deepcopy()		make a full copy of a Dictionary
	string()		String representation of a Dictionary
	max()			maximum value in a Dictionary
	min()			minimum value in a Dictionary
	count()			count number of times a value appears
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{keys()} @tab 辞書の全キーのリストを取得する
@item @ref{values()} @tab 辞書の全値のリストを取得する
@item @ref{items()} @tab 辞書の全キー・値のペアを取得する
@item @ref{copy()} @tab 辞書の浅いコピーを作成する
@item @ref{deepcopy()} @tab 辞書の完全なコピーを作成する
@item @ref{string()} @tab 辞書の文字列表現
@item @ref{max()} @tab 辞書中の最大値
@item @ref{min()} @tab 辞書中の最小値
@item @ref{count()} @tab ある値が出現する回数を返す
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Floating point computation:				*float-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{float-functions}
@cindex float-functions
@cindex Vim script 浮動小数点数の計算
@unnumberedsubsubsec 浮動小数点数の計算:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	float2nr()		convert Float to Number
	abs()			absolute value (also works for Number)
	round()			round off
	ceil()			round up
	floor()			round down
	trunc()			remove value after decimal point
	fmod()			remainder of division
	exp()			exponential
	log()			natural logarithm (logarithm to base e)
	log10()			logarithm to base 10
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item @ref{float2nr()} @tab Float を Number に変換
@item @ref{abs()} @tab 絶対値 (Numberも処理可能)
@item @ref{round()} @tab 丸め
@item @ref{ceil()} @tab 切り上げ
@item @ref{floor()} @tab 切り下げ
@item @ref{trunc()} @tab 小数点以下切り捨て
@item @ref{fmod()} @tab 除法の余り
@item @ref{exp()} @tab 指数
@item @ref{log()} @tab 自然対数 (eを底とする対数)
@item @ref{log10()} @tab 10 を底とする対数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	pow()			value of x to the exponent y
	sqrt()			square root
	sin()			sine
	cos()			cosine
	tan()			tangent
	asin()			arc sine
	acos()			arc cosine
	atan()			arc tangent
	atan2()			arc tangent
	sinh()			hyperbolic sine
	cosh()			hyperbolic cosine
	tanh()			hyperbolic tangent
	isnan()			check for not a number
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{pow()} @tab x の y 乗
@item @ref{sqrt()} @tab 平方根
@item @ref{sin()} @tab 正弦 (サイン)
@item @ref{cos()} @tab 余弦 (コサイン)
@item @ref{tan()} @tab 正接 (タンジェント)
@item @ref{asin()} @tab 逆正弦 (アークサイン)
@item @ref{acos()} @tab 逆余弦 (アークコサイン)
@item @ref{atan()} @tab 逆正接 (アークタンジェント)
@item @ref{atan2()} @tab 逆正接 (アークタンジェント)
@item @ref{sinh()} @tab 双曲線正弦 (ハイパボリックサイン)
@item @ref{cosh()} @tab 双曲線余弦 (ハイパボリックコサイン)
@item @ref{tanh()} @tab 双曲線正接 (ハイパボリックタンジェント)
@item @ref{isnan()} @tab 数値でないかどうかのチェック
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Other computation:					*bitwise-function*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{bitwise-function}
@cindex bitwise-function
@cindex Vim script その他の計算
@unnumberedsubsubsec その他の計算:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	and()			bitwise AND
	invert()		bitwise invert
	or()			bitwise OR
	xor()			bitwise XOR
	sha256()		SHA-256 hash
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item @ref{and()} @tab ビットごとの論理積
@item @ref{invert()} @tab ビットごとの否定
@item @ref{or()} @tab ビットごとの論理和
@item @ref{xor()} @tab ビットごとの排他的論理和
@item @ref{sha256()} @tab SHA-256 ハッシュ
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Variables:						*var-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{var-functions}
@cindex var-functions
@cindex Vim script 変数
@unnumberedsubsubsec 変数:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	type()			type of a variable
	islocked()		check if a variable is locked
	funcref()		get a Funcref for a function reference
	function()		get a Funcref for a function name
	getbufvar()		get a variable value from a specific buffer
	setbufvar()		set a variable in a specific buffer
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item @ref{type()} @tab 変数の型
@item @ref{islocked()} @tab 変数がロックされているか判定する
@item @ref{funcref()} @tab 関数参照へのFuncrefを取得する
@item @ref{function()} @tab 関数名から Funcref を取得する
@item @ref{getbufvar()} @tab 指定バッファの変数値を得る
@item @ref{setbufvar()} @tab 指定バッファに変数を設定する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	getwinvar()		get a variable from specific window
	gettabvar()		get a variable from specific tab page
	gettabwinvar()		get a variable from specific window & tab page
	setwinvar()		set a variable in a specific window
	settabvar()		set a variable in a specific tab page
	settabwinvar()		set a variable in a specific window & tab page
	garbagecollect()	possibly free memory
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{getwinvar()} @tab 指定ウィンドウの変数値を得る
@item @ref{gettabvar()} @tab 指定タブページから変数値を得る
@item @ref{gettabwinvar()} @tab 指定ウィンドウ・タブページから変数値を取得する
@item @ref{setwinvar()} @tab 指定ウィンドウに変数を設定する
@item @ref{settabvar()} @tab 指定タブページに変数を設定する
@item @ref{settabwinvar()} @tab 指定ウィンドウ・タブページに変数を設定する
@item @ref{garbagecollect()} @tab 開放可能なメモリを解放する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Cursor and mark position:		*cursor-functions* *mark-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cursor-functions}
@anchor{mark-functions}
@cindex cursor-functions
@cindex mark-functions
@cindex Vim script カーソルとマークの位置
@unnumberedsubsubsec カーソルとマークの位置:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	col()			column number of the cursor or a mark
	virtcol()		screen column of the cursor or a mark
	line()			line number of the cursor or mark
	wincol()		window column number of the cursor
	winline()		window line number of the cursor
	cursor()		position the cursor at a line/column
	screencol()		get screen column of the cursor
	screenrow()		get screen row of the cursor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item @ref{col()} @tab カーソルやマークの列番号を取得する
@item @ref{virtcol()} @tab カーソルやマークの画面上の列番号を得る
@item @ref{line()} @tab カーソルやマークの行番号を取得する
@item @ref{wincol()} @tab カーソルのウィンドウでの列番号
@item @ref{winline()} @tab カーソルのウィンドウでの行番号
@item @ref{cursor()} @tab カーソルを指定した位置に移動させる
@item @ref{screencol()} @tab カーソルのスクリーン列を取得する
@item @ref{screenrow()} @tab カーソルのスクリーン行を取得する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	getcurpos()		get position of the cursor
	getpos()		get position of cursor, mark, etc.
	setpos()		set position of cursor, mark, etc.
	byte2line()		get line number at a specific byte count
	line2byte()		byte count at a specific line
	diff_filler()		get the number of filler lines above a line
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{getcurpos()} @tab カーソルの位置を取得する
@item @ref{getpos()} @tab カーソルやマークなどの位置を取得する
@item @ref{setpos()} @tab カーソルやマークなどの位置を設定する
@item @ref{byte2line()} @tab 指定のバイト位置の行番号を取得する
@item @ref{line2byte()} @tab 指定の行のバイト位置を取得する
@item @ref{diff_filler()} @tab ある行より上の詰め行の数を取得する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	screenattr()		get attribute at a screen line/row
	screenchar()		get character code at a screen line/row
	screenchars()		get character codes at a screen line/row
	screenstring()		get string of characters at a screen line/row
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{screenattr()} @tab スクリーン列/行の属性を取得する
@item @ref{screenchar()} @tab スクリーン列/行の文字コードを取得する
@item @ref{screenchars()} @tab スクリーン列/行の文字コードのリストを取得する
@item @ref{screenstring()} @tab スクリーン列/行の文字列を取得する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Working with text in the current buffer:		*text-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{text-functions}
@cindex text-functions
@cindex Vim script カレントバッファで動作するもの
@unnumberedsubsubsec カレントバッファで動作するもの:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	getline()		get a line or list of lines from the buffer
	setline()		replace a line in the buffer
	append()		append line or list of lines in the buffer
	indent()		indent of a specific line
	cindent()		indent according to C indenting
	lispindent()		indent according to Lisp indenting
	nextnonblank()		find next non-blank line
	prevnonblank()		find previous non-blank line
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item @ref{getline()} @tab バッファから行を得る
@item @ref{setline()} @tab バッファの行を置き換える
@item @ref{append()} @tab 行または行のリストをバッファに追加する
@item @ref{indent()} @tab 行のインデントを得る
@item @ref{cindent()} @tab C 言語におけるインデントを得る
@item @ref{lispindent()} @tab Lisp 言語におけるインデントを得る
@item @ref{nextnonblank()} @tab 次の非空行を探す
@item @ref{prevnonblank()} @tab 前の非空行を探す
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	search()		find a match for a pattern
	searchpos()		find a match for a pattern
	searchpair()		find the other end of a start/skip/end
	searchpairpos()		find the other end of a start/skip/end
	searchdecl()		search for the declaration of a name
	getcharsearch()		return character search information
	setcharsearch()		set character search information
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{search()} @tab パターンにマッチする場所を探す
@item @ref{searchpos()} @tab パターンにマッチする場所を探す
@item @ref{searchpair()} @tab start/skip/end の対を探す
@item @ref{searchpairpos()} @tab start/skip/end の対を探す
@item @ref{searchdecl()} @tab 名前が宣言されている場所を探す
@item @ref{getcharsearch()} @tab 文字検索情報を返す
@item @ref{setcharsearch()} @tab 文字検索情報を設定する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*system-functions* *file-functions*
System functions and manipulation of files:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{system-functions}
@anchor{file-functions}
@cindex system-functions
@cindex file-functions
@cindex Vim script システム関数とファイル繰作
@unnumberedsubsubsec システム関数とファイル繰作:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	glob()			expand wildcards
	globpath()		expand wildcards in a number of directories
	glob2regpat()		convert a glob pattern into a search pattern
	findfile()		find a file in a list of directories
	finddir()		find a directory in a list of directories
	resolve()		find out where a shortcut points to
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .25 .75
@item @ref{glob()} @tab ワイルドカードを展開する
@item @ref{globpath()} @tab 複数のディレクトリを対象にワイルドカードを展開
@item @ref{glob2regpat()} @tab glob パターンを正規表現に変換する
@item @ref{findfile()} @tab 複数のディレクトリからファイルを探す
@item @ref{finddir()} @tab 複数のディレクトリからディレクトリを探す
@item @ref{resolve()} @tab ショートカットのリンク先を得る
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	fnamemodify()		modify a file name
	pathshorten()		shorten directory names in a path
	simplify()		simplify a path without changing its meaning
	executable()		check if an executable program exists
	exepath()		full path of an executable program
	filereadable()		check if a file can be read
	filewritable()		check if a file can be written to
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{fnamemodify()} @tab ファイル名を修飾する
@item @ref{pathshorten()} @tab パス中のディレクトリ名を短くする
@item @ref{simplify()} @tab パスの意味を変えずに簡略化する
@item @ref{executable()} @tab 実行形式ファイルかどうかをチェックする
@item @ref{exepath()} @tab 実行ファイルのフルパスを得る
@item @ref{filereadable()} @tab ファイルが読み込み可能かどうかをチェックする
@item @ref{filewritable()} @tab ファイルが書き込み可能かどうかをチェックする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	getfperm()		get the permissions of a file
	setfperm()		set the permissions of a file
	getftype()		get the kind of a file
	isdirectory()		check if a directory exists
	getfsize()		get the size of a file
	getcwd()		get the current working directory
	haslocaldir()		check if current window used |:lcd| or |:tcd|
	tempname()		get the name of a temporary file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{getfperm()} @tab ファイルのパーミッションを得る
@item @ref{setfperm()} @tab ファイルのパーミッションを設定する
@item @ref{getftype()} @tab ファイルの種類を得る
@item @ref{isdirectory()} @tab ディレクトリの存在をチェックする
@item @ref{getfsize()} @tab ファイルのサイズを得る
@item @ref{getcwd()} @tab カレントディレクトリを得る
@item @ref{haslocaldir()} @tab カレントウィンドウが |@ref{:lcd}| もしくは |@ref{:tcd}| を使用するかどうかをチェックする
@item @ref{tempname()} @tab 一時ファイルの名前を得る
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	mkdir()			create a new directory
	chdir()			change current working directory
	delete()		delete a file
	rename()		rename a file
	system()		get the result of a shell command as a string
	systemlist()		get the result of a shell command as a list
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{mkdir()} @tab ディレクトリを作成する
@item @ref{chdir()} @tab 現在の作業ディレクトリを変更する
@item @ref{delete()} @tab ファイルを削除する
@item @ref{rename()} @tab ファイルの名前を変更する
@item @ref{system()} @tab シェルコマンドを実行し、その結果を文字列で得る
@item @ref{systemlist()} @tab シェルコマンドを実行し、その結果をリストで得る
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	environ()		get all environment variables
	getenv()		get one environment variable
	setenv()		set an environment variable
	hostname()		name of the system
	readfile()		read a file into a List of lines
	readdir()		get a List of file names in a directory
	writefile()		write a List of lines or Blob into a file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{environ()} @tab すべての環境変数を得る
@item @ref{getenv()} @tab 環境変数を得る
@item @ref{setenv()} @tab 環境変数を設定する
@item @ref{hostname()} @tab システムの名称を得る
@item @ref{readfile()} @tab ファイルを読み込み、行のリストを得る
@item @ref{writefile()} @tab 行のリストをファイルに書き込む
@item @ref{readdir()} @tab ディレクトリ内のファイル名のリストを得る
@item @ref{writefile()} @tab 行のリストまたは Blob をファイルに書き込む
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Date and Time:				*date-functions* *time-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{date-functions}
@anchor{time-functions}
@cindex date-functions
@cindex time-functions
@cindex Vim script 日付と時刻
@unnumberedsubsubsec 日付と時刻:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	getftime()		get last modification time of a file
	localtime()		get current time in seconds
	strftime()		convert time to a string
	reltime()		get the current or elapsed time accurately
	reltimestr()		convert reltime() result to a string
	reltimefloat()		convert reltime() result to a Float
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item @ref{getftime()} @tab ファイルの最終更新日時を得る
@item @ref{localtime()} @tab 現在時刻を秒単位で得る
@item @ref{strftime()} @tab 時刻を文字列に変換する
@item @ref{reltime()} @tab 現在時刻または経過時間を正確に取得する
@item @ref{reltimestr()} @tab reltime() の結果を文字列に変換する
@item @ref{reltimefloat()} @tab reltime() の結果を浮動小数点に変換する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			*buffer-functions* *window-functions* *arg-functions*
Buffers, windows and the argument list:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{buffer-functions}
@anchor{window-functions}
@anchor{arg-functions}
@cindex buffer-functions
@cindex window-functions
@cindex arg-functions
@cindex Vim script バッファ、ウィンドウ、引数リスト
@unnumberedsubsubsec バッファ、ウィンドウ、引数リスト:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	argc()			number of entries in the argument list
	argidx()		current position in the argument list
	arglistid()		get id of the argument list
	argv()			get one entry from the argument list
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item @ref{argc()} @tab 引数リストの大きさ
@item @ref{argidx()} @tab 引数リスト中の現在の位置
@item @ref{arglistid()} @tab 引数リストのIDを得る
@item @ref{argv()} @tab 引数リストの中身を得る
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	bufexists()		check if a buffer exists
	buflisted()		check if a buffer exists and is listed
	bufloaded()		check if a buffer exists and is loaded
	bufname()		get the name of a specific buffer
	bufnr()			get the buffer number of a specific buffer
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{bufexists()} @tab バッファの存在をチェックする
@item @ref{buflisted()} @tab バッファが存在し、リストされているかどうか
@item @ref{bufloaded()} @tab バッファが存在し、ロードされているかどうか
@item @ref{bufname()} @tab バッファの名前を得る
@item @ref{bufnr()} @tab バッファの番号を得る
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	tabpagebuflist()	return List of buffers in a tab page
	tabpagenr()		get the number of a tab page
	tabpagewinnr()		like winnr() for a specified tab page
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{tabpagebuflist()} @tab タブページ中のバッファのリストを返す
@item @ref{tabpagenr()} @tab タブページの番号を取得する
@item @ref{tabpagewinnr()} @tab タブページを対象に winnr() と同様
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	winnr()			get the window number for the current window
	bufwinid()		get the window ID of a specific buffer
	bufwinnr()		get the window number of a specific buffer
	winbufnr()		get the buffer number of a specific window
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{winnr()} @tab カレントウィンドウの番号を得る
@item @ref{bufwinid()} @tab バッファのウィンドウ ID を得る
@item @ref{bufwinnr()} @tab バッファのウィンドウ番号を得る
@item @ref{winbufnr()} @tab ウィンドウのバッファ番号を得る
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	getbufline()		get a list of lines from the specified buffer
	setbufline()		replace a line in the specified buffer
	appendbufline()		append a list of lines in the specified buffer
	deletebufline()		delete lines from a specified buffer
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{getbufline()} @tab バッファの行のリストを得る
@item @ref{setbufline()} @tab 指定されたバッファ内で 1 行を置換する
@item @ref{appendbufline()} @tab 指定されたバッファ内で行のリストを追加する
@item @ref{deletebufline()} @tab 指定されたバッファから行を削除する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	listener_add()		add a callback to listen to changes
	listener_flush()	invoke listener callbacks
	listener_remove()	remove a listener callback
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{listener_add()} @tab 変更を監視するためのコールバックを追加する
@item @ref{listener_flush()} @tab リスナーコールバックを呼び出す
@item @ref{listener_remove()} @tab リスナーコールバックを削除する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	win_findbuf()		find windows containing a buffer
	win_getid()		get window ID of a window
	win_gotoid()		go to window with ID
	win_id2tabwin()		get tab and window nr from window ID
	win_id2win()		get window nr from window ID
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{win_findbuf()} @tab バッファが含まれるウィンドウを探す
@item @ref{win_getid()} @tab ウィンドウのウィンドウIDを得る
@item @ref{win_gotoid()} @tab IDで指定されたウィンドウへ移動する
@item @ref{win_id2tabwin()} @tab ID で指定されたタブとウィンドウの番号を得る
@item @ref{win_id2win()} @tab IDで指定されたウィンドウの番号を得る
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	getbufinfo()		get a list with buffer information
	gettabinfo()		get a list with tab page information
	getwininfo()		get a list with window information
	getchangelist()		get a list of change list entries
	getjumplist()		get a list of jump list entries
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{getbufinfo()} @tab バッファの情報一覧を得る
@item @ref{gettabinfo()} @tab タブページの情報一覧を得る
@item @ref{getwininfo()} @tab ウィンドウの情報一覧を得る
@item @ref{getchangelist()} @tab 変更リストのエントリ一覧を得る
@item @ref{getjumplist()} @tab ジャンプリストのエントリ一覧を得る
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	swapinfo()		information about a swap file
	swapname()		get the swap file path of a buffer
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{swapinfo()} @tab スワップファイルに関する情報
@item @ref{swapname()} @tab バッファのスワップファイルパスを取得する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Command line:					*command-line-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{command-line-functions}
@cindex command-line-functions
@cindex Vim script コマンドライン
@unnumberedsubsubsec コマンドライン:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	getcmdline()		get the current command line
	getcmdpos()		get position of the cursor in the command line
	setcmdpos()		set position of the cursor in the command line
	getcmdtype()		return the current command-line type
	getcmdwintype()		return the current command-line window type
	getcompletion()		list of command-line completion matches
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item @ref{getcmdline()} @tab 現在のコマンドラインを取得
@item @ref{getcmdpos()} @tab コマンドラインにおけるカーソル位置を取得
@item @ref{setcmdpos()} @tab コマンドラインにおけるカーソル位置を設定
@item @ref{getcmdtype()} @tab 現在のコマンドラインの種類を返す
@item @ref{getcmdwintype()} @tab 現在のコマンドラインウィンドウの種類を返す
@item @ref{getcompletion()} @tab マッチするコマンド補完リストを返す
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Quickfix and location lists:			*quickfix-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{quickfix-functions}
@cindex quickfix-functions
@cindex Vim script QuickFix とロケーションリスト
@unnumberedsubsubsec QuickFix とロケーションリスト:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	getqflist()		list of quickfix errors
	setqflist()		modify a quickfix list
	getloclist()		list of location list items
	setloclist()		modify a location list
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item @ref{getqflist()} @tab QuickFix エラーのリスト
@item @ref{setqflist()} @tab QuickFix を変更する
@item @ref{getloclist()} @tab ロケーションリストの項目のリスト
@item @ref{setloclist()} @tab ロケーションリストを変更する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Insert mode completion:				*completion-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{completion-functions}
@cindex completion-functions
@cindex Vim script 挿入モード補完
@unnumberedsubsubsec 挿入モード補完:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	complete()		set found matches
	complete_add()		add to found matches
	complete_check()	check if completion should be aborted
	complete_info()		get current completion information
	pumvisible()		check if the popup menu is displayed
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item @ref{complete()} @tab 補完候補を設定する
@item @ref{complete_add()} @tab 補完候補を追加する
@item @ref{complete_check()} @tab 補完処理を終えるべきかどうかをチェックする
@item @ref{complete_info()} @tab 現在の補完情報を得る
@item @ref{pumvisible()} @tab ポップアップメニューが表示されているかチェック
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Folding:					*folding-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{folding-functions}
@cindex folding-functions
@cindex Vim script 折り畳み
@unnumberedsubsubsec 折り畳み:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	foldclosed()		check for a closed fold at a specific line
	foldclosedend()		like foldclosed() but return the last line
	foldlevel()		check for the fold level at a specific line
	foldtext()		generate the line displayed for a closed fold
	foldtextresult()	get the text displayed for a closed fold
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item @ref{foldclosed()} @tab 行が折り畳まれているかどうかをチェックする
@item @ref{foldclosedend()} @tab foldclosed() と同様。折り畳み末尾の行番号を返す
@item @ref{foldlevel()} @tab 行の折り畳みレベルを得る
@item @ref{foldtext()} @tab 閉じた折り畳みを代替表示するテキストを生成
@item @ref{foldtextresult()} @tab 閉じた折り畳みを代替表示するテキストを得る
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Syntax and highlighting:	  *syntax-functions* *highlighting-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{syntax-functions}
@anchor{highlighting-functions}
@cindex syntax-functions
@cindex highlighting-functions
@cindex Vim script シンタックスハイライト
@unnumberedsubsubsec シンタックスハイライト:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	clearmatches()		clear all matches defined by |matchadd()| and
				the |:match| commands
	getmatches()		get all matches defined by |matchadd()| and
				the |:match| commands
	hlexists()		check if a highlight group exists
	hlID()			get ID of a highlight group
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item @ref{clearmatches()} @tab |@ref{matchadd()}| と |@ref{:match}| コマンドで定義されたマッチをクリアする
@item @ref{getmatches()} @tab |@ref{matchadd()}| と |@ref{:match}| コマンドで定義されたすべてのマッチを得る
@item @ref{hlexists()} @tab ハイライトグループの存在をチェック
@item @ref{hlID()} @tab ハイライトグループの ID を得る
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	synID()			get syntax ID at a specific position
	synIDattr()		get a specific attribute of a syntax ID
	synIDtrans()		get translated syntax ID
	synstack()		get list of syntax IDs at a specific position
	synconcealed()		get info about concealing
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{synID()} @tab 指定位置のシンタックス ID を得る
@item @ref{synIDattr()} @tab シンタックス ID から指定の属性を得る
@item @ref{synIDtrans()} @tab 変換したシンタックス ID を得る
@item @ref{synstack()} @tab 指定位置のシンタックス ID のリストを得る
@item @ref{synconcealed()} @tab conceal の情報を得る
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	diff_hlID()		get highlight ID for diff mode at a position
	matchadd()		define a pattern to highlight (a "match")
	matchaddpos()		define a list of positions to highlight
	matcharg()		get info about |:match| arguments
	matchdelete()		delete a match defined by |matchadd()| or a
				|:match| command
	setmatches()		restore a list of matches saved by
				|getmatches()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{diff_hlID()} @tab 差分モードの指定位置のシンタックス ID を得る
@item @ref{matchadd()} @tab 強調表示するパターンを定義する
@item @ref{matchaddpos()} @tab 強調表示する位置のリストを定義する
@item @ref{matcharg()} @tab |@ref{:match}| の引数の情報を得る
@item @ref{matchdelete()} @tab |@ref{matchadd()}| と |@ref{:match}| コマンドで定義されたマッチを削除する
@item @ref{setmatches()} @tab |@ref{getmatches()}| で得たマッチを使って復元する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Spelling:					*spell-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{spell-functions}
@cindex spell-functions
@cindex Vim script スペリング
@unnumberedsubsubsec スペリング:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	spellbadword()		locate badly spelled word at or after cursor
	spellsuggest()		return suggested spelling corrections
	soundfold()		return the sound-a-like equivalent of a word
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item @ref{spellbadword()} @tab カーソル位置以降のスペルミスを探す
@item @ref{spellsuggest()} @tab スペル訂正の候補を返す
@item @ref{soundfold()} @tab 単語の同音等値(sound-a-like equivalent)を返す
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
History:					*history-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{history-functions}
@cindex history-functions
@cindex Vim script 履歴
@unnumberedsubsubsec 履歴:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	histadd()		add an item to a history
	histdel()		delete an item from a history
	histget()		get an item from a history
	histnr()		get highest index of a history list
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item @ref{histadd()} @tab 履歴に項目を追加
@item @ref{histdel()} @tab 履歴から項目を削除
@item @ref{histget()} @tab 履歴の項目を得る
@item @ref{histnr()} @tab 履歴リストの最大インデックスを得る
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Interactive:					*interactive-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{interactive-functions}
@cindex interactive-functions
@cindex Vim script 対話インターフェイス
@unnumberedsubsubsec 対話インターフェイス:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	browse()		put up a file requester
	browsedir()		put up a directory requester
	confirm()		let the user make a choice
	getchar()		get a character from the user
	getcharmod()		get modifiers for the last typed character
	feedkeys()		put characters in the typeahead queue
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item @ref{browse()} @tab ファイル選択ダイアログを開く
@item @ref{browsedir()} @tab ディレクトリ選択ダイアログを開く
@item @ref{confirm()} @tab ユーザーに選択をさせる
@item @ref{getchar()} @tab ユーザーが入力した文字を得る
@item @ref{getcharmod()} @tab 最後に入力した文字の修飾子(modifier)を得る
@item @ref{feedkeys()} @tab 先行入力キューに文字を入れる
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	input()			get a line from the user
	inputlist()		let the user pick an entry from a list
	inputsecret()		get a line from the user without showing it
	inputdialog()		get a line from the user in a dialog
	inputsave()		save and clear typeahead
	inputrestore()		restore typeahead
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{input()} @tab ユーザーが入力した行を得る
@item @ref{inputlist()} @tab ユーザーにリストから項目を選択させる
@item @ref{inputsecret()} @tab ユーザーが入力した行を得る。ただし表示はしない
@item @ref{inputdialog()} @tab ダイアログを使ってユーザーが入力した行を得る
@item @ref{inputsave()} @tab 先行入力キューを保存して空にする
@item @ref{inputrestore()} @tab inputsave() で保存した状態に戻す
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
GUI:						*gui-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-functions}
@cindex gui-functions
@cindex Vim script GUI
@unnumberedsubsubsec GUI:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	getfontname()		get name of current font being used
	getwinpos()		position of the Vim window
	getwinposx()		X position of the Vim window
	getwinposy()		Y position of the Vim window
	balloon_show()		set the balloon content
	balloon_split()		split a message for a balloon
	balloon_gettext()	get the text in the balloon
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item @ref{getfontname()} @tab 現在使われているフォントの名前を取得
@item @ref{getwinpos()} @tab Vim ウィンドウの座標
@item @ref{getwinposx()} @tab Vim ウィンドウの X 座標
@item @ref{getwinposy()} @tab Vim ウィンドウの Y 座標
@item @ref{balloon_show()} @tab バルーンの内容を設定する
@item @ref{balloon_split()} @tab バルーン用にメッセージを分割する
@item @ref{balloon_gettext()} @tab バルーンのテキストを得る
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim server:					*server-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{server-functions}
@cindex server-functions
@cindex Vim script Vim サーバー
@unnumberedsubsubsec Vim サーバー:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	serverlist()		return the list of server names
	remote_startserver()	run a server
	remote_send()		send command characters to a Vim server
	remote_expr()		evaluate an expression in a Vim server
	server2client()		send a reply to a client of a Vim server
	remote_peek()		check if there is a reply from a Vim server
	remote_read()		read a reply from a Vim server
	foreground()		move the Vim window to the foreground
	remote_foreground()	move the Vim server window to the foreground
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item @ref{serverlist()} @tab サーバー名のリストを返す
@item @ref{remote_startserver()} @tab サーバーをスタートする
@item @ref{remote_send()} @tab Vim サーバーにコマンド文字を送る
@item @ref{remote_expr()} @tab Vim サーバーで式を評価する
@item @ref{server2client()} @tab Vim サーバーのクライアントに応答を返す
@item @ref{remote_peek()} @tab Vim サーバーから返信があったかどうかをチェック
@item @ref{remote_read()} @tab Vim サーバーからの返信を読む
@item @ref{foreground()} @tab Vim のウィンドウを前面に持ってくる
@item @ref{remote_foreground()} @tab Vim サーバーのウィンドウを前面に持ってくる
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Window size and position:			*window-size-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{window-size-functions}
@cindex window-size-functions
@cindex Vim script ウィンドウサイズと位置
@unnumberedsubsubsec ウィンドウサイズと位置:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	winheight()		get height of a specific window
	winwidth()		get width of a specific window
	win_screenpos()		get screen position of a window
	winlayout()		get layout of windows in a tab page
	winrestcmd()		return command to restore window sizes
	winsaveview()		get view of current window
	winrestview()		restore saved view of current window
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item @ref{winheight()} @tab ウィンドウの高さを取得
@item @ref{winwidth()} @tab ウィンドウの幅を取得
@item @ref{win_screenpos()} @tab ウィンドウのスクリーン座標を取得
@item @ref{winlayout()} @tab タブページ内のウィンドウレイアウトを取得
@item @ref{winrestcmd()} @tab ウィンドウサイズを復元するコマンドを返す
@item @ref{winsaveview()} @tab カレントウィンドウのビューを取得
@item @ref{winrestview()} @tab カレントウィンドウのビューを復元
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Mappings:				    *mapping-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{mapping-functions}
@cindex mapping-functions
@cindex Vim script マッピング
@unnumberedsubsubsec マッピング:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	hasmapto()		check if a mapping exists
	mapcheck()		check if a matching mapping exists
	maparg()		get rhs of a mapping
	wildmenumode()		check if the wildmode is active
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item @ref{hasmapto()} @tab マップの存在をチェック
@item @ref{mapcheck()} @tab マッチするマップの存在をチェック
@item @ref{maparg()} @tab マップの rhs (展開結果)を得る
@item @ref{wildmenumode()} @tab wildmode が有効かどうかをチェック
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Testing:				    *test-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{test-functions}
@cindex test-functions
@cindex Vim script テスト
@unnumberedsubsubsec テスト用:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	assert_equal()		assert that two expressions values are equal
	assert_equalfile()	assert that two file contents are equal
	assert_notequal()	assert that two expressions values are not equal
	assert_inrange()	assert that an expression is inside a range
	assert_match()		assert that a pattern matches the value
	assert_notmatch()	assert that a pattern does not match the value
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item @ref{assert_equal()} @tab 2 つの式が等しい事をテストする
@item @ref{assert_equalfile()} @tab 2 つのファイル内容が等しいことをテストする
@item @ref{assert_notequal()} @tab 2 つの式が等しくない事をテストする
@item @ref{assert_inrange()} @tab 式が範囲内にある事をテストする
@item @ref{assert_match()} @tab 値がパターンにマッチする事をテストする
@item @ref{assert_notmatch()} @tab 値がパターンにマッチしない事をテストする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	assert_false()		assert that an expression is false
	assert_true()		assert that an expression is true
	assert_exception()	assert that a command throws an exception
	assert_beeps()		assert that a command beeps
	assert_fails()		assert that a command fails
	assert_report()		report a test failure
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{assert_false()} @tab 式が false かどうかテストする
@item @ref{assert_true()} @tab 式が true かどうかテストする
@item @ref{assert_exception()} @tab コマンドが例外を投げる事をテストする
@item @ref{assert_beeps()} @tab コマンドがビープ音を慣らすことをテストする
@item @ref{assert_fails()} @tab コマンドが失敗する事をテストする
@item @ref{assert_report()} @tab テストの失敗をレポートする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	test_alloc_fail()	make memory allocation fail
	test_autochdir()	enable 'autochdir' during startup
	test_override()		test with Vim internal overrides
	test_garbagecollect_now()   free memory right now
	test_getvalue()		get value of an internal variable
	test_ignore_error()	ignore a specific error message
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{test_alloc_fail()} @tab メモリの確保を失敗させる
@item @ref{test_autochdir()} @tab 起動中に 'autochdir' を有効にする
@item @ref{test_override()} @tab Vimの 内部処理を置き換えてテストする
@item @ref{test_garbagecollect_now()} @tab 直ちにメモリを解放する
@item @ref{test_getvalue()} @tab 内部変数の値を取得する
@item @ref{test_ignore_error()} @tab 特定のエラーメッセージを無視する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	test_null_blob()	return a null Blob
	test_null_channel()	return a null Channel
	test_null_dict()	return a null Dict
	test_null_job()		return a null Job
	test_null_list()	return a null List
	test_null_partial()	return a null Partial function
	test_null_string()	return a null String
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{test_null_blob()} @tab null の Blob を返す
@item @ref{test_null_channel()} @tab null のチャネルを返す
@item @ref{test_null_dict()} @tab null の辞書を返す
@item @ref{test_null_job()} @tab null の Job を返す
@item @ref{test_null_list()} @tab null のリストを返す
@item @ref{test_null_partial()} @tab null の部分適用を返す
@item @ref{test_null_string()} @tab null の文字列を返す
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	test_settime()		set the time Vim uses internally
	test_setmouse()		set the mouse position
	test_feedinput()	add key sequence to input buffer
	test_option_not_set()	reset flag indicating option was set
	test_scrollbar()	simulate scrollbar movement in the GUI
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{test_settime()} @tab Vim が内部的に用いる時間を設定する
@item @ref{test_setmouse()} @tab マウスの位置を設定する
@item @ref{test_feedinput()} @tab 入力バッファにキーシーケンスを追加する
@item @ref{test_option_not_set()} @tab オプションに設定されているフラグをリセットする
@item @ref{test_scrollbar()} @tab GUI でスクロールバーの移動をシミュレートする
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Inter-process communication:		    *channel-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{channel-functions}
@cindex channel-functions
@cindex Vim script プロセス間通信
@unnumberedsubsubsec プロセス間通信:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	ch_canread()		check if there is something to read
	ch_open()		open a channel
	ch_close()		close a channel
	ch_close_in()		close the in part of a channel
	ch_read()		read a message from a channel
	ch_readblob()		read a Blob from a channel
	ch_readraw()		read a raw message from a channel
	ch_sendexpr()		send a JSON message over a channel
	ch_sendraw()		send a raw message over a channel
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item @ref{ch_canread()} @tab 何か読むものがあるかチェックする
@item @ref{ch_open()} @tab チャネルを開く
@item @ref{ch_close()} @tab チャネルを閉じる
@item @ref{ch_close_in()} @tab チャネルの入力パートを閉じる
@item @ref{ch_read()} @tab チャネルからメッセージを読み取る
@item @ref{ch_readblob()} @tab チャネルから Blob を読み取る
@item @ref{ch_readraw()} @tab チャネルから raw メッセージを読み取る
@item @ref{ch_sendexpr()} @tab チャネルに JSON メッセージを送る
@item @ref{ch_sendraw()} @tab チャネルに raw メッセージを送る
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	ch_evalexpr()		evaluates an expression over channel
	ch_evalraw()		evaluates a raw string over channel
	ch_status()		get status of a channel
	ch_getbufnr()		get the buffer number of a channel
	ch_getjob()		get the job associated with a channel
	ch_info()		get channel information
	ch_log()		write a message in the channel log file
	ch_logfile()		set the channel log file
	ch_setoptions()		set the options for a channel
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{ch_evalexpr()} @tab チャネル経由で式を評価する
@item @ref{ch_evalraw()} @tab チャネル経由で raw 文字列を評価する
@item @ref{ch_status()} @tab チャネルの状態を取得する
@item @ref{ch_getbufnr()} @tab チャネルのバッファ番号を取得する
@item @ref{ch_getjob()} @tab チャネルが割り当てられている Job を取得する
@item @ref{ch_info()} @tab チャネルの情報を取得する
@item @ref{ch_log()} @tab チャネルのログファイルにメッセージを出力する
@item @ref{ch_logfile()} @tab チャネルのログファイルを設定する
@item @ref{ch_setoptions()} @tab チャネルのオプションを設定する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	json_encode()		encode an expression to a JSON string
	json_decode()		decode a JSON string to Vim types
	js_encode()		encode an expression to a JSON string
	js_decode()		decode a JSON string to Vim types
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{json_encode()} @tab 式を JSON の文字列にエンコードする
@item @ref{json_decode()} @tab JSON の文字列を Vim の型にデコードする
@item @ref{js_encode()} @tab 式を JSON の文字列にエンコードする
@item @ref{js_decode()} @tab JSON の文字列を Vim の型にデコードする
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Jobs:		    			        *job-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-functions}
@cindex job-functions
@cindex Vim script ジョブ
@unnumberedsubsubsec ジョブ:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	job_start()		start a job
	job_stop()		stop a job
	job_status()		get the status of a job
	job_getchannel()	get the channel used by a job
	job_info()		get information about a job
	job_setoptions()	set options for a job
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item @ref{job_start()} @tab Job を開始する
@item @ref{job_stop()} @tab Job を停止する
@item @ref{job_status()} @tab Job のステータスを取得する
@item @ref{job_getchannel()} @tab Job が使用する channel を取得する
@item @ref{job_info()} @tab Job の情報を取得する
@item @ref{job_setoptions()} @tab Job のオプションを設定する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Signs:						*sign-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sign-functions}
@cindex sign-functions
@cindex Vim script 目印
@unnumberedsubsubsec 目印:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	sign_define()		define or update a sign
	sign_getdefined()	get a list of defined signs
	sign_getplaced()	get a list of placed signs
	sign_jump()		jump to a sign
	sign_place()		place a sign
	sign_undefine()		undefine a sign
	sign_unplace()		unplace a sign
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item sign_define() @tab 目印を定義または更新する
@item sign_getdefined() @tab 定義されている目印のリストを取得する
@item sign_getplaced() @tab 配置されている目印のリストを取得する
@item sign_jump() @tab 目印へ移動する
@item sign_place() @tab 目印を配置する
@item sign_undefine() @tab 定義された目印を削除する
@item sign_unplace() @tab 設置された目印を解除する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Terminal window:				*terminal-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-functions}
@cindex terminal-functions
@cindex Vim script Terminal window
@unnumberedsubsubsec Terminal window:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	term_start()		open a terminal window and run a job
	term_list()		get the list of terminal buffers
	term_sendkeys()		send keystrokes to a terminal
	term_wait()		wait for screen to be updated
	term_getjob()		get the job associated with a terminal
	term_scrape()		get row of a terminal screen
	term_getline()		get a line of text from a terminal
	term_getattr()		get the value of attribute {what}
	term_getcursor()	get the cursor position of a terminal
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item @ref{term_start()} @tab ターミナルウィンドウを開いてジョブを開始する
@item @ref{term_list()} @tab ターミナルバッファのリストを取得する
@item @ref{term_sendkeys()} @tab ターミナルにキーストロークを送る
@item @ref{term_wait()} @tab スクリーンがアップデートされるのを待つ
@item @ref{term_getjob()} @tab ターミナルに関連するジョブを取得する
@item @ref{term_scrape()} @tab ターミナルスクリーンの列を取得する
@item @ref{term_getline()} @tab ターミナルからテキストの行を取得する
@item @ref{term_getattr()} @tab @{what@} の属性値を取得する
@item @ref{term_getcursor()} @tab ターミナルのカーソル位置を取得する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	term_getscrolled()	get the scroll count of a terminal
	term_getaltscreen()	get the alternate screen flag
	term_getsize()		get the size of a terminal
	term_getstatus()	get the status of a terminal
	term_gettitle()		get the title of a terminal
	term_gettty()		get the tty name of a terminal
	term_setansicolors()	set 16 ANSI colors, used for GUI
	term_getansicolors()	get 16 ANSI colors, used for GUI
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{term_getscrolled()} @tab ターミナルのスクロール数を取得する
@item @ref{term_getaltscreen()} @tab 代替のスクリーンフラグを取得する
@item @ref{term_getsize()} @tab ターミナルのサイズを取得する
@item @ref{term_getstatus()} @tab ターミナルのステータスを取得する
@item @ref{term_gettitle()} @tab ターミナルのタイトルを取得する
@item @ref{term_gettty()} @tab ターミナルの tty 名を取得する
@item @ref{term_setansicolors()} @tab GUI で使用される 16 色の ANSI カラーパレットを設定する
@item @ref{term_getansicolors()} @tab GUI で使用するた 16 色の ANSI カラーパレットを取得する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	term_dumpdiff()		display difference between two screen dumps
	term_dumpload()		load a terminal screen dump in a window
	term_dumpwrite()	dump contents of a terminal screen to a file
	term_setkill()		set signal to stop job in a terminal
	term_setrestore()	set command to restore a terminal
	term_setsize()		set the size of a terminal
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{term_dumpdiff()} @tab 2 つのスクリーンダンプ間の差異を表示する
@item @ref{term_dumpload()} @tab ウィンドウの端末スクリーンダンプを読み込む
@item @ref{term_dumpwrite()} @tab 端末スクリーンの内容をファイルにダンプする
@item @ref{term_setkill()} @tab 端末のジョブに停止シグナルを設定する
@item @ref{term_setrestore()} @tab 端末の復元コマンドを設定する
@item @ref{term_setsize()} @tab 端末のサイズを設定する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Timers:						*timer-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{timer-functions}
@cindex timer-functions
@cindex Vim script タイマー
@unnumberedsubsubsec タイマー:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	timer_start()		create a timer
	timer_pause()		pause or unpause a timer
	timer_stop()		stop a timer
	timer_stopall()		stop all timers
	timer_info()		get information about timers
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item @ref{timer_start()} @tab タイマーを作る
@item @ref{timer_pause()} @tab タイマーを一時停止もしくは再開する
@item @ref{timer_stop()} @tab タイマーを止める
@item @ref{timer_stopall()} @tab 全てのタイマーを止める
@item @ref{timer_info()} @tab タイマーの情報を得る
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Tags:						*tag-functions*
	taglist()		get list of matching tags
	tagfiles()		get a list of tags files
	gettagstack()		get the tag stack of a window
	settagstack()		modify the tag stack of a window
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tag-functions}
@cindex tag-functions
@unnumberedsubsubsec タグ:
@multitable @columnfractions .4 .6
@item @ref{taglist()} @tab マッチしているタグのリストを取得する
@item @ref{tagfiles()} @tab タグファイルのリストを取得する
@item @ref{gettagstack()} @tab ウィンドウのタグスタックを取得する
@item @ref{settagstack()} @tab ウィンドウのタグスタックを変更する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Prompt Buffer:					*promptbuffer-functions*
	prompt_setcallback()	set prompt callback for a buffer
	prompt_setinterrupt()	set interrupt callback for a buffer
	prompt_setprompt()	set the prompt text for a buffer
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{promptbuffer-functions}
@cindex promptbuffer-functions
@unnumberedsubsubsec プロンプトバッファ:
@multitable @columnfractions .4 .6
@item @ref{prompt_setcallback()} @tab バッファにプロンプトコールバックを設定する
@item @ref{prompt_setinterrupt()} @tab バッファに割り込みコールバックを設定する
@item @ref{prompt_setprompt()} @tab バッファにプロンプトテキストを設定する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Various:					*various-functions*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{various-functions}
@cindex various-functions
@cindex Vim script その他
@unnumberedsubsubsec その他:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	mode()			get current editing mode
	visualmode()		last visual mode used
	exists()		check if a variable, function, etc. exists
	has()			check if a feature is supported in Vim
	changenr()		return number of most recent change
	cscope_connection()	check if a cscope connection exists
	did_filetype()		check if a FileType autocommand was used
	eventhandler()		check if invoked by an event handler
	getpid()		get process ID of Vim

@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .35 .65
@item @ref{mode()} @tab 現在の編集モードを得る
@item @ref{visualmode()} @tab 最後に使われたビジュアルモードの種類
@item @ref{exists()} @tab 変数、関数の存在をチェック
@item @ref{has()} @tab 機能がサポートされているかをチェック
@item @ref{changenr()} @tab 最近の変更番号を返す
@item @ref{cscope_connection()} @tab cscope 接続をチェック
@item @ref{did_filetype()} @tab FileType オートコマンドが使用されたかどうか
@item @ref{eventhandler()} @tab イベントハンドラによって起動されたかどうか
@item @ref{getpid()} @tab Vim のプロセスIDを得る
@item
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	libcall()		call a function in an external library
	libcallnr()		idem, returning a number

	undofile()		get the name of the undo file
	undotree()		return the state of the undo tree

@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{libcall()} @tab 外部ライブラリの関数を呼ぶ
@item @ref{libcallnr()} @tab 同上、数値を返す
@item
@item @ref{undofile()} @tab アンドゥファイルの名前を得る
@item @ref{undotree()} @tab アンドゥツリーの状態を返す
@item
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	getreg()		get contents of a register
	getregtype()		get type of a register
	setreg()		set contents and type of a register
	reg_executing()		return the name of the register being executed
	reg_recording()		return the name of the register being recorded

	shiftwidth()		effective value of 'shiftwidth'

	wordcount()		get byte/word/char count of buffer

@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{getreg()} @tab レジスタの値を得る
@item @ref{getregtype()} @tab レジスタのタイプを得る
@item @ref{setreg()} @tab レジスタの値を設定する
@item @ref{reg_executing()} @tab 実行中のレジスタ名を返す
@item @ref{reg_recording()} @tab 記録中のレジスタ名を返す
@item
@item @ref{shiftwidth()} @tab '@option{shiftwidth}' の実際の値
@item
@item @ref{wordcount()} @tab バッファ内のバイト数/単語数/文字数などを得る
@item
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	luaeval()		evaluate Lua expression
	mzeval()		evaluate |MzScheme| expression
	perleval()		evaluate Perl expression (|+perl|)
	py3eval()		evaluate Python expression (|+python3|)
	pyeval()		evaluate Python expression (|+python|)
	pyxeval()		evaluate |python_x| expression
	debugbreak()		interrupt a program being debugged
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @ref{luaeval()} @tab |@ref{Lua}| の式を評価する
@item @ref{mzeval()} @tab |@ref{MzScheme}| の式を評価する
@item @ref{perleval()} @tab |@ref{Perl}| の式を評価する (|@ref{+perl}|)
@item @ref{py3eval()} @tab |@ref{Python}| の式を評価する (|@ref{+python3}|)
@item @ref{pyeval()} @tab |@ref{Python}| の式を評価する (|@ref{+python}|)
@item @ref{pyxeval()} @tab |@ref{python_x}| の式を評価する
@item @ref{debugbreak()} @tab デバッグされているプログラムを中断する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*41.7*	Defining a function
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{41.7}
@cindex 関数を定義する
@section 関数を定義する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim enables you to define your own functions.  The basic function declaration
begins as follows: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
自分で関数を定義することができます。基本的な関数定義は次のとおり:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function {name}({var1}, {var2}, ...)
	:  {body}
	:endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:function @{name@}(@{var1@}, @{var2@}, ...)
:  @{body@}
:endfunction
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<
	Note:
	Function names must begin with a capital letter.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
関数名は大文字で開始する必要があります。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Let's define a short function to return the smaller of two numbers.  It starts
with this line: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
小さな関数を定義してみましょう。2 つの数値のうち小さい方を返す関数を作ります。関数は次のような行で始まります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function Min(num1, num2)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:function Min(num1, num2)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This tells Vim that the function is named "Min" and it takes two arguments:
"num1" and "num2".
   The first thing you need to do is to check to see which number is smaller:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数の名前が "Min" であり、2 つの引数 ("num1" と "num2") を取る、ということを表しています。

最初にしなければならないのは、どちらの数値が小さいかをチェックすることです:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   >
	:  if a:num1 < a:num2
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:  if a:num1 < a:num2
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The special prefix "a:" tells Vim that the variable is a function argument.
Let's assign the variable "smaller" the value of the smallest number: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"a:" は特殊なプリフィックスで、この変数が関数の引数であることを示します。小さい方の値を変数 "smaller" に代入しましょう:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:  if a:num1 < a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:  if a:num1 < a:num2
:    let smaller = a:num1
:  else
:    let smaller = a:num2
:  endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The variable "smaller" is a local variable.  Variables used inside a function
are local unless prefixed by something like "g:", "a:", or "s:".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数 "smaller" はローカル変数です。関数の中で使われた変数はローカル変数になります。ただし、"g:"、"a:"、"s:" などのプリフィックスを付けた場合は別です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Note:
	To access a global variable from inside a function you must prepend
	"g:" to it.  Thus "g:today" inside a function is used for the global
	variable "today", and "today" is another variable, local to the
	function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
関数の内からグローバル変数にアクセスするには "g:" を付ける必要があります。つまり、関数内では "g:today" はグローバル変数 "today" を示し、"today" ならそれとは別の変数、すなわちローカル変数になります。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You now use the ":return" statement to return the smallest number to the user.
Finally, you end the function: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
":return" ステートメントを使って、小さい方の値を呼び出し元に返しましょう。そして、関数を閉じます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:  return smaller
	:endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:  return smaller
:endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The complete function definition is as follows: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数定義の全体は次のようになります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function Min(num1, num2)
	:  if a:num1 < a:num2
	:    let smaller = a:num1
	:  else
	:    let smaller = a:num2
	:  endif
	:  return smaller
	:endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:function Min(num1, num2)
:  if a:num1 < a:num2
:    let smaller = a:num1
:  else
:    let smaller = a:num2
:  endif
:  return smaller
:endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For people who like short functions, this does the same thing: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数を短く書きたい場合は、次のようにもできます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function Min(num1, num2)
	:  if a:num1 < a:num2
	:    return a:num1
	:  endif
	:  return a:num2
	:endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:function Min(num1, num2)
:  if a:num1 < a:num2
:    return a:num1
:  endif
:  return a:num2
:endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A user defined function is called in exactly the same way as a built-in
function.  Only the name is different.  The Min function can be used like
this: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザー定義関数は組み込み関数とまったく同じ方法で呼び出すことができます。違うのは名前だけです。Min 関数は次のように使用できます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:echo Min(5, 8)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:echo Min(5, 8)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Only now will the function be executed and the lines be interpreted by Vim.
If there are mistakes, like using an undefined variable or function, you will
now get an error message.  When defining the function these errors are not
detected.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数が実行され、関数の中身が Vim によって解釈されます。未定義の変数や関数を使うなどの間違いがあったときは、エラーメッセージが表示されます。関数定義の時点ではそれらのエラーは検出されません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When a function reaches ":endfunction" or ":return" is used without an
argument, the function returns zero.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数が ":endfunction" まで実行されたとき、あるいは引数無しで ":return" を使ったときは 0 が返ります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To redefine a function that already exists, use the ! for the ":function"
command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
既存の関数を再定義したい場合は ":function" コマンドに "!" を付けてください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function!  Min(num1, num2, num3)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:function!  Min(num1, num2, num3)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
USING A RANGE
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 範囲指定を使う
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The ":call" command can be given a line range.  This can have one of two
meanings.  When a function has been defined with the "range" keyword, it will
take care of the line range itself.
  The function will be passed the variables "a:firstline" and "a:lastline".
These will have the line numbers from the range the function was called with.
Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:call}" コマンドは行範囲を受け取ることができます。範囲指定の使用方法は 2 つあります。関数を定義するときに "range" キーワードを使った場合は、関数自身が範囲指定を処理します。

関数には "a:firstline" と "a:lastline" という 2 つの変数が暗黙的に渡されます。この 2 つの変数には範囲指定された行番号が代入されています。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function Count_words() range
	:  let lnum = a:firstline
	:  let n = 0
	:  while lnum <= a:lastline
	:    let n = n + len(split(getline(lnum)))
	:    let lnum = lnum + 1
	:  endwhile
	:  echo "found " . n . " words"
	:endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:function Count_words() range
:  let lnum = a:firstline
:  let n = 0
:  while lnum <= a:lastline
:    let n = n + len(split(getline(lnum)))
:    let lnum = lnum + 1
:  endwhile
:  echo "found " . n . " words"
:endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can call this function with: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この関数は次のように呼び出すことができます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:10,30call Count_words()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:10,30call Count_words()
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It will be executed once and echo the number of words.
   The other way to use a line range is by defining a function without the
"range" keyword.  The function will be called once for every line in the
range, with the cursor in that line.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数が一度だけ実行され、単語の数が表示されます。

関数を定義するときに "range" キーワードを使わなかった場合は、指定された範囲のそれぞれの行に対して関数が呼ばれます (カーソルはその行の上)。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function  Number()
	:  echo "line " . line(".") . " contains: " . getline(".")
	:endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:function  Number()
:  echo "line " . line(".") . " contains: " . getline(".")
:endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you call this function with: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のように実行すると:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:10,15call Number()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:10,15call Number()
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The function will be called six times.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数は 6 回実行されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
VARIABLE NUMBER OF ARGUMENTS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 可変長引数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim enables you to define functions that have a variable number of arguments.
The following command, for instance, defines a function that must have 1
argument (start) and can have up to 20 additional arguments: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
可変個の引数を取る関数を定義できます。例えば、次の関数は、必ず 1 つの引数 (start) を取り、最大で 20 個までの引数を取ることができます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function Show(start, ...)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:function Show(start, ...)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The variable "a:1" contains the first optional argument, "a:2" the second, and
so on.  The variable "a:0" contains the number of extra arguments.
   For example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数 "a:1" に 1 つ目のオプション引数が代入されます。2 つ目が "a:2" で、3 つ目が "a:3" です。"a:0" にはオプション引数の数が入ります。

例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function Show(start, ...)
	:  echohl Title
	:  echo "start is " . a:start
	:  echohl None
	:  let index = 1
	:  while index <= a:0
	:    echo "  Arg " . index . " is " . a:{index}
	:    let index = index + 1
	:  endwhile
	:  echo ""
	:endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:function Show(start, ...)
:  echohl Title
:  echo "start is " . a:start
:  echohl None
:  let index = 1
:  while index <= a:0
:    echo "  Arg " . index . " is " . a:{index}
:    let index = index + 1
:  endwhile
:  echo ""
:endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This uses the ":echohl" command to specify the highlighting used for the
following ":echo" command.  ":echohl None" stops it again.  The ":echon"
command works like ":echo", but doesn't output a line break.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この関数は "@command{:echohl}" を使って "@command{:echo}" の出力に色を付けています。"@command{:echohl None}" で色付けをやめます。"@command{:echon}" コマンドは "@command{:echo}" と同じ機能ですが、改行を出力しません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can also use the a:000 variable, it is a List of all the "..." arguments.
See |a:000|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数 a:000 を使うこともできます。これは "..." 引数がすべて入ったリストです。|@ref{a:000}|を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
LISTING FUNCTIONS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 関数の一覧
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The ":function" command lists the names and arguments of all user-defined
functions: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:function}" コマンドでユーザー定義関数の一覧を表示できます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:function
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	function Show(start, ...) ~
	function GetVimIndent() ~
	function SetSyn(name) ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
function Show(start, ...)
function GetVimIndent()
function SetSyn(name)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To see what a function does, use its name as an argument for ":function": >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数の中身を見たいときは関数名を指定してください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function SetSyn
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:function SetSyn
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	1     if &syntax == '' ~
	2       let &syntax = a:name ~
	3     endif ~
	   endfunction ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
1     if &syntax == ''
2       let &syntax = a:name
3     endif
   endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DEBUGGING
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec デバッグ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The line number is useful for when you get an error message or when debugging.
See |debug-scripts| about debugging mode.
   You can also set the 'verbose' option to 12 or higher to see all function
calls.  Set it to 15 or higher to see every executed line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
エラーメッセージが表示されたとき、あるいはデバッグ中に、行番号が表示されると便利です。デバッグモードについては |@ref{debug-scripts}| を参照してください。

'@option{verbose}' オプションに 12 以上の値を設定すると、すべての関数呼び出しが表示されます。15 以上にすると、実行されたすべての行が表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DELETING A FUNCTION
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数の削除
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To delete the Show() function: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば Show() 関数を削除するのは次のようにします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:delfunction Show
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:delfunction Show
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You get an error when the function doesn't exist.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数が存在しない場合はエラーになります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
FUNCTION REFERENCES
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 関数への参照
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Sometimes it can be useful to have a variable point to one function or
another.  You can do it with the function() function.  It turns the name of a
function into a reference: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数に関数を代入できると便利なことがあります。それには function() 関数を使います。function() は関数の名前を受け取り、関数への参照を返します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let result = 0		" or 1
	:function! Right()
	:  return 'Right!'
	:endfunc
	:function! Wrong()
	:  return 'Wrong!'
	:endfunc
	:
	:if result == 1
	:  let Afunc = function('Right')
	:else
	:  let Afunc = function('Wrong')
	:endif
	:echo call(Afunc, [])
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let result = 0        " or 1
:function! Right()
:  return 'Right!'
:endfunc
:function! Wrong()
:  return 'Wrong!'
:endfunc
:
:if result == 1
:  let Afunc = function('Right')
:else
:  let Afunc = function('Wrong')
:endif
:echo call(Afunc, [])
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	Wrong! ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
Wrong!
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that the name of a variable that holds a function reference must start
with a capital.  Otherwise it could be confused with the name of a builtin
function.
   The way to invoke a function that a variable refers to is with the call()
function.  Its first argument is the function reference, the second argument
is a List with arguments.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@strong{Note:} 関数への参照を保持する変数の名前は大文字で始めなければなりません。そうでないと組み込み関数の名前と紛らわしくなります。

変数が参照している関数を呼び出すには call() 関数を使います。call() 関数の最初の引数は関数への参照で、2 番目の引数は引数のリストです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Function references are most useful in combination with a Dictionary, as is
explained in the next section.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数への参照は、次節で説明される辞書と組み合わせたときもっとも役に立ちます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*41.8*	Lists and Dictionaries
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{41.8}
@cindex リストと辞書
@section リストと辞書
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
So far we have used the basic types String and Number.  Vim also supports two
composite types: List and Dictionary.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここまでは基本型(文字列と数値)を扱ってきました。Vim は 2 つの複合型、リストと辞書もサポートしています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A List is an ordered sequence of things.  The things can be any kind of value,
thus you can make a List of numbers, a List of Lists and even a List of mixed
items.  To create a List with three strings: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リストとは、要素を順番に並べたものです。要素はどのような型でも構いません。数値のリスト、リストのリスト、あるいは複数の型が混在したリストでも作れます。例えば、3 個の文字列からなるリストを作るには次のようにします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let alist = ['aap', 'mies', 'noot']
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let alist = ['aap', 'mies', 'noot']
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The List items are enclosed in square brackets and separated by commas.  To
create an empty List: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リストの要素は角括弧で囲み、コンマで区切ります。空のリストを作るには次のようにします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let alist = []
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let alist = []
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can add items to a List with the add() function: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数 add() を使うとリストに要素を追加することができます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let alist = []
	:call add(alist, 'foo')
	:call add(alist, 'bar')
	:echo alist
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let alist = []
:call add(alist, 'foo')
:call add(alist, 'bar')
:echo alist
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	['foo', 'bar'] ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
['foo', 'bar']
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
List concatenation is done with +: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リストの連結には + を使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:echo alist + ['foo', 'bar']
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:echo alist + ['foo', 'bar']
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	['foo', 'bar', 'foo', 'bar'] ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
['foo', 'bar', 'foo', 'bar']
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Or, if you want to extend a List directly: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
直接リストを拡張するには次のようにします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let alist = ['one']
	:call extend(alist, ['two', 'three'])
	:echo alist
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let alist = ['one']
:call extend(alist, ['two', 'three'])
:echo alist
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	['one', 'two', 'three'] ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
['one', 'two', 'three']
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Notice that using add() will have a different effect: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
add() とは効果が異なることに注意してください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let alist = ['one']
	:call add(alist, ['two', 'three'])
	:echo alist
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let alist = ['one']
:call add(alist, ['two', 'three'])
:echo alist
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	['one', ['two', 'three']] ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
['one', ['two', 'three']]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The second argument of add() is added as a single item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
add() の第二引数は1つの要素として追加されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
FOR LOOP
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec FOR ループ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
One of the nice things you can do with a List is iterate over it: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リストを使ってできる素晴らしいことの1つが、リストに対する繰り返しです:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let alist = ['one', 'two', 'three']
	:for n in alist
	:  echo n
	:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let alist = ['one', 'two', 'three']
:for n in alist
:  echo n
:endfor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	one ~
	two ~
	three ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
one
two
three
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This will loop over each element in List "alist", assigning the value to
variable "n".  The generic form of a for loop is: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上の例は、リスト "alist" の各要素に対して、その値を変数 "n" に代入しながらループを行います。for ループの書式は次の通りです:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:for {varname} in {listexpression}
	:  {commands}
	:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:for @{varname@} in @{listexpression@}
:  @{commands@}
:endfor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To loop a certain number of times you need a List of a specific length.  The
range() function creates one for you: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ある回数だけループするには、その長さのリストを使います。関数range() を使うと、そのようなリストを作成できます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:for a in range(3)
	:  echo a
	:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:for a in range(3)
:  echo a
:endfor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	0 ~
	1 ~
	2 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
0
1
2
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Notice that the first item of the List that range() produces is zero, thus the
last item is one less than the length of the list.
   You can also specify the maximum value, the stride and even go backwards: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
range() が生成するリストの最初の要素は0であることに注意してください。そのため、最後の要素はリストの長さより 1 小さい値になります。

最大値、ステップ幅を指定することもでき、逆方向に進むこともできます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:for a in range(8, 4, -2)
	:  echo a
	:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:for a in range(8, 4, -2)
:  echo a
:endfor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	8 ~
	6 ~
	4 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
8
6
4
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A more useful example, looping over lines in the buffer: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
より有用な例として、バッファ中の行に対するループ:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:for line in getline(1, 20)
	:  if line =~ "Date: "
	:    echo matchstr(line, 'Date: \zs.*')
	:  endif
	:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:for line in getline(1, 20)
:  if line =~ "Date: "
:    echo matchstr(line, 'Date: \zs.*')
:  endif
:endfor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This looks into lines 1 to 20 (inclusive) and echoes any date found in there.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
1 行目から 20 行目(両端を含む)を調べ、そこに含まれる日付を全て表示しています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DICTIONARIES
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 辞書
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A Dictionary stores key-value pairs.  You can quickly lookup a value if you
know the key.  A Dictionary is created with curly braces: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
辞書はキーと値のペアを保持します。キーを指定することで高速に値を検索できます。辞書は波括弧で作ります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now you can lookup words by putting the key in square brackets: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
そして角括弧の中にキーを書くことで単語を検索します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:echo uk2nl['two']
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:echo uk2nl['two']
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	twee ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
twee
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The generic form for defining a Dictionary is: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
辞書の定義の書式は次の通りです:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	{<key> : <value>, ...}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
{<key> : <value>, ...}
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An empty Dictionary is one without any keys: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
空の辞書とは、どんなキーも持たない辞書のことです:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	{}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
{}
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The possibilities with Dictionaries are numerous.  There are various functions
for them as well.  For example, you can obtain a list of the keys and loop
over them: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
辞書にはいろいろな使い道があります。辞書を扱う関数もたくさんあります。例えば、キーのリストを取得してそれに対してループするには次のようにします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:for key in keys(uk2nl)
	:  echo key
	:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:for key in keys(uk2nl)
:  echo key
:endfor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	three ~
	one ~
	two ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
three
one
two
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You will notice the keys are not ordered.  You can sort the list to get a
specific order: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
キーはソートされていません。特定の順序に並べるにはリストをソートします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:for key in sort(keys(uk2nl))
	:  echo key
	:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:for key in sort(keys(uk2nl))
:  echo key
:endfor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	one ~
	three ~
	two ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
one
three
two
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
But you can never get back the order in which items are defined.  For that you
need to use a List, it stores items in an ordered sequence.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
要素が定義された順序を得ることはできません。そのような目的にはリストを使ってください。リストは順序を保って要素を保持します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DICTIONARY FUNCTIONS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 辞書の関数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The items in a Dictionary can normally be obtained with an index in square
brackets: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
辞書の要素は角括弧でインデックスを指定して取得します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:echo uk2nl['one']
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:echo uk2nl['one']
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	een ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
een
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A method that does the same, but without so many punctuation characters: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
記号を使わない方法もあります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:echo uk2nl.one
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:echo uk2nl.one
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	een ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
een
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This only works for a key that is made of ASCII letters, digits and the
underscore.  You can also assign a new value this way: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この方法はキーがアルファベット、数字、アンダースコアなどの ASCII 文字だけで構成されている場合に使えます。この方法で値を代入することもできます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let uk2nl.four = 'vier'
	:echo uk2nl
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let uk2nl.four = 'vier'
:echo uk2nl
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'} ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'}
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
And now for something special: you can directly define a function and store a
reference to it in the dictionary: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数の定義と辞書への代入を同時に記述することができます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:function uk2nl.translate(line) dict
	:  return join(map(split(a:line), 'get(self, v:val, "???")'))
	:endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:function uk2nl.translate(line) dict
:  return join(map(split(a:line), 'get(self, v:val, "???")'))
:endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Let's first try it out: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これを実行してみましょう:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:echo uk2nl.translate('three two five one')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:echo uk2nl.translate('three two five one')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	drie twee ??? een ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
drie twee ??? een
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The first special thing you notice is the "dict" at the end of the ":function"
line.  This marks the function as being used from a Dictionary.  The "self"
local variable will then refer to that Dictionary.
   Now let's break up the complicated return command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:function}" の行の末尾に "dict" と書かれています。これは、その関数が辞書から使われることを示します。ローカル変数 "self" がその辞書を指すようになります。

次に、複雑な return コマンドを分解してみましょう:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	split(a:line)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
split(a:line)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The split() function takes a string, chops it into whitespace separated words
and returns a list with these words.  Thus in the example it returns: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数 split() は文字列を空白文字で区切り、リストにして返します。そのため、この例での戻り値は次のようになります: >
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:echo split('three two five one')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:echo split('three two five one')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	['three', 'two', 'five', 'one'] ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
['three', 'two', 'five', 'one']
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This list is the first argument to the map() function.  This will go through
the list, evaluating its second argument with "v:val" set to the value of each
item.  This is a shortcut to using a for loop.  This command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このリストが map() 関数の第一引数になります。map() はリストの各要素を "v:val" に代入した状態で第 2 引数を評価します。これにより for ループより短いコードが書けます。このコードは:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let alist = map(split(a:line), 'get(self, v:val, "???")')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let alist = map(split(a:line), 'get(self, v:val, "???")')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Is equivalent to: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のコードと同じです:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let alist = split(a:line)
	:for idx in range(len(alist))
	:  let alist[idx] = get(self, alist[idx], "???")
	:endfor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let alist = split(a:line)
:for idx in range(len(alist))
:  let alist[idx] = get(self, alist[idx], "???")
:endfor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The get() function checks if a key is present in a Dictionary.  If it is, then
the value is retrieved.  If it isn't, then the default value is returned, in
the example it's '???'.  This is a convenient way to handle situations where a
key may not be present and you don't want an error message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数 get() はそのキーが辞書に入っているかをチェックします。入っていればその値を返します。入っていなければデフォルト値(この例では '???')を返します。キーが入っていなくてもエラーを起こしたくないような場合に便利です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The join() function does the opposite of split(): it joins together a list of
words, putting a space in between.
  This combination of split(), map() and join() is a nice way to filter a line
of words in a very compact way.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数 join() は split() の逆の処理をします。つまり単語のリストをスペースでつなげます。

split()、map()、join() を組み合わせると、単語からなる行を簡潔に処理することができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
OBJECT ORIENTED PROGRAMMING
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec オブジェクト指向プログラミング
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now that you can put both values and functions in a Dictionary, you can
actually use a Dictionary like an object.
   Above we used a Dictionary for translating Dutch to English.  We might want
to do the same for other languages.  Let's first make an object (aka
Dictionary) that has the translate function, but no words to translate: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
辞書には値と関数を入れることができるので、辞書をオブジェクトとして使うことができます。

上述の例ではオランダ語から英語に翻訳するために辞書を使いました。同じことが他の言語でもできると面白いかもしれませんね。まず翻訳関数を持ったオブジェクト (つまり辞書) を作ります。翻訳する単語はまだ定義しません:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let transdict = {}
	:function transdict.translate(line) dict
	:  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
	:endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let transdict = {}
:function transdict.translate(line) dict
:  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
:endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It's slightly different from the function above, using 'self.words' to lookup
word translations.  But we don't have a self.words.  Thus you could call this
an abstract class.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
単語を翻訳するのに 'self.words' を使う点が上述の例と少し違います。しかし、self.words はまだありません。よって、これは抽象クラスと呼ぶことができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now we can instantiate a Dutch translation object: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オランダ語を翻訳するオブジェクトをインスタンス化してみましょう:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let uk2nl = copy(transdict)
	:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
	:echo uk2nl.translate('three one')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let uk2nl = copy(transdict)
:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
:echo uk2nl.translate('three one')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	drie een ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
drie een
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
And a German translator: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
さらにドイツ語の翻訳機を作ります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let uk2de = copy(transdict)
	:let uk2de.words = {'one': 'eins', 'two': 'zwei', 'three': 'drei'}
	:echo uk2de.translate('three one')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let uk2de = copy(transdict)
:let uk2de.words = {'one': 'eins', 'two': 'zwei', 'three': 'drei'}
:echo uk2de.translate('three one')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	drei eins ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
drei eins
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You see that the copy() function is used to make a copy of the "transdict"
Dictionary and then the copy is changed to add the words.  The original
remains the same, of course.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
copy() 関数を使って "transdict" 辞書をコピーし、そのコピーに対して単語を追加しています。元の辞書はもちろん変更されません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now you can go one step further, and use your preferred translator: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
さらに一歩進んで、適切な言語を選択できるようにしてみます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:if $LANG =~ "de"
	:  let trans = uk2de
	:else
	:  let trans = uk2nl
	:endif
	:echo trans.translate('one two three')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if $LANG =~ "de"
:  let trans = uk2de
:else
:  let trans = uk2nl
:endif
:echo trans.translate('one two three')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	een twee drie ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
een twee drie
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here "trans" refers to one of the two objects (Dictionaries).  No copy is
made.  More about List and Dictionary identity can be found at |list-identity|
and |dict-identity|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"trans" は 2 つのオブジェクト(辞書)のうちどちらか 1 つを参照します。コピーは作られていません。リストと辞書の同一性についてのより詳しい情報は |@ref{list-identity}| と |@ref{dict-identity}| にあります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now you might use a language that isn't supported.  You can overrule the
translate() function to do nothing: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
未対応の言語を使う場合は、translate() 関数を上書きして何もしないようにするといいかもしれません:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let uk2uk = copy(transdict)
	:function! uk2uk.translate(line)
	:  return a:line
	:endfunction
	:echo uk2uk.translate('three one wladiwostok')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let uk2uk = copy(transdict)
:function! uk2uk.translate(line)
:  return a:line
:endfunction
:echo uk2uk.translate('three one wladiwostok')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	three one wladiwostok ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
three one wladiwostok
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Notice that a ! was used to overwrite the existing function reference.  Now
use "uk2uk" when no recognized language is found: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
! を使って既に存在している関数への参照を上書きしています。続いて、未対応の言語に対して "uk2uk" を使うように変更します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:if $LANG =~ "de"
	:  let trans = uk2de
	:elseif $LANG =~ "nl"
	:  let trans = uk2nl
	:else
	:  let trans = uk2uk
	:endif
	:echo trans.translate('one two three')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if $LANG =~ "de"
:  let trans = uk2de
:elseif $LANG =~ "nl"
:  let trans = uk2nl
:else
:  let trans = uk2uk
:endif
:echo trans.translate('one two three')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	one two three ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
one two three
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For further reading see |Lists| and |Dictionaries|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
さらなる情報については |@ref{List}| と |@ref{Dictionaries}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*41.9*	Exceptions
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{41.9}
@cindex 例外
@section 例外
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Let's start with an example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
まずは例題を見てください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:try
	:   read ~/templates/pascal.tmpl
	:catch /E484:/
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:try
:   read ~/templates/pascal.tmpl
:catch /E484:/
:   echo "パスカル用のテンプレートファイルは見つかりませんでした。"
:endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The ":read" command will fail if the file does not exist.  Instead of
generating an error message, this code catches the error and gives the user a
nice message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:read}" コマンドはファイルがなければ失敗します。そのエラーをキャッチして、エラーメッセージの代わりにより親切なメッセージを表示しています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For the commands in between ":try" and ":endtry" errors are turned into
exceptions.  An exception is a string.  In the case of an error the string
contains the error message.  And every error message has a number.  In this
case, the error we catch contains "E484:".  This number is guaranteed to stay
the same (the text may change, e.g., it may be translated).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:try}" と "@command{:endtry}" の間で起きたエラーは例外に変わります。例外は文字列です。エラーが例外に変わったとき、文字列にはエラーメッセージが含まれます。また、全てのエラーメッセージは番号を持っています。例題では "E484:" を含んだエラーをキャッチしています。この番号は変わらないことが保証されています (テキストは翻訳されるなどして変わるかもしれません)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the ":read" command causes another error, the pattern "E484:" will not
match in it.  Thus this exception will not be caught and result in the usual
error message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:read}" コマンドが他のエラーを起こした場合、"E484:" というパターンはマッチしないでしょう。したがって、その例外はキャッチされず、通常のエラーメッセージが表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You might be tempted to do this: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のように書くこともできます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:try
	:   read ~/templates/pascal.tmpl
	:catch
	:   echo "Sorry, the Pascal template file cannot be found."
	:endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:try
:   read ~/templates/pascal.tmpl
:catch
:   echo "パスカル用のテンプレートファイルは見つかりませんでした。"
:endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This means all errors are caught.  But then you will not see errors that are
useful, such as "E21: Cannot make changes, 'modifiable' is off".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
全ての例外がキャッチされます。しかしこれでは "@samp{E21: Cannot make changes, 'modifiable' is off}" のような有効なエラーに気づくことができません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Another useful mechanism is the ":finally" command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:finally}" という便利なコマンドもあります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let tmp = tempname()
	:try
	:   exe ".,$write " . tmp
	:   exe "!filter " . tmp
	:   .,$delete
	:   exe "$read " . tmp
	:finally
	:   call delete(tmp)
	:endtry
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let tmp = tempname()
:try
:   exe ".,$write " . tmp
:   exe "!filter " . tmp
:   .,$delete
:   exe "$read " . tmp
:finally
:   call delete(tmp)
:endtry
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This filters the lines from the cursor until the end of the file through the
"filter" command, which takes a file name argument.  No matter if the
filtering works, something goes wrong in between ":try" and ":finally" or the
user cancels the filtering by pressing CTRL-C, the "call delete(tmp)" is
always executed.  This makes sure you don't leave the temporary file behind.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カーソル行からファイル末尾までを "filter" コマンド (ファイル名を引数に取るコマンド) でフィルタ処理しています。"@command{:try}" と "@command{:finally}" の間で問題が起きても、ユーザーが @kbd{CTRL-C} を押して操作をキャンセルしても、"@code{call delete(tmp)}" は必ず呼ばれます。一時ファイルが残ってしまう心配はありません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
More information about exception handling can be found in the reference
manual: |exception-handling|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例外についてさらに詳しい情報はリファレンスマニュアルの |@ref{exception-handling}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*41.10*	Various remarks
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{41.10}
@cindex Vim script 注意事項
@section 注意事項
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here is a summary of items that apply to Vim scripts.  They are also mentioned
elsewhere, but form a nice checklist.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim script において注意すべきことの概要を簡単に説明します。他の場所にも同じような説明はありますが、手頃なチェックリストに使えるでしょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The end-of-line character depends on the system.  For Unix a single <NL>
character is used.  For MS-DOS, Windows, OS/2 and the like, <CR><LF> is used.
This is important when using mappings that end in a <CR>.  See |:source_crnl|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
改行記号はシステムによって異なります。Unix では <NL> 文字が使われますが、MS-DOS, Windows, OS/2 などでは <CR><LF> が使われます。末尾が <CR> になっているマップを使うときは注意してください。|@ref{:source_crnl}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
WHITE SPACE
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 空白
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Blank lines are allowed and ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
空の行はあっても構いません。無視されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Leading whitespace characters (blanks and TABs) are always ignored.  The
whitespaces between parameters (e.g. between the "set" and the "cpoptions" in
the example below) are reduced to one blank character and plays the role of a
separator, the whitespaces after the last (visible) character may or may not
be ignored depending on the situation, see below.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
行頭の空白 (スペースとTAB) は常に無視されます。引数と引数の間には空白がいくつあっても構いません (例えば下記の "set" と "cpoptions" の間)。空白は 1 つのスペースにまとめられ、セパレータの役目をします。最後の文字より後ろにある空白文字は状況によって無視されたりされなかったりします。下記参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For a ":set" command involving the "=" (equal) sign, such as in: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
":set" コマンドで "=" 記号を使うとき:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set cpoptions    =aABceFst
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set cpoptions    =aABceFst
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
the whitespace immediately before the "=" sign is ignored.  But there can be
no whitespace after the "=" sign!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"=" の直前にある空白は無視されます。しかし、"=" の後ろに空白をはさむことはできません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To include a whitespace character in the value of an option, it must be
escaped by a "\" (backslash)  as in the following example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション値に空白を含めるときは、バックスラッシュ ("\") でエスケープする必要があります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set tags=my\ nice\ file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set tags=my\ nice\ file
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The same example written as: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のように書くと:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set tags=my nice file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set tags=my nice file
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
will issue an error, because it is interpreted as: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはエラーになります。このコマンドは次のように解釈されてしまいます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set tags=my
	:set nice
	:set file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set tags=my
:set nice
:set file
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
COMMENTS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec コメント
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The character " (the double quote mark) starts a comment.  Everything after
and including this character until the end-of-line is considered a comment and
is ignored, except for commands that don't consider comments, as shown in
examples below.  A comment can start on any character position on the line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コメントは " (ダブルクォート) 記号で開始します。行末までのすべての文字がコメントとして解釈され、無視されます。ただし、コメントを書くことができないコマンドもあります (以下に例を示します)。コメントは行のどこからでも開始できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There is a little "catch" with comments for some commands.  Examples: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コメントとして簡単な注釈を付けたとします。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:abbrev dev development		" shorthand
	:map <F3> o#include		" insert include
	:execute cmd			" do it
	:!ls *.c			" list C files
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:abbrev dev development         " shorthand
:map <F3> o#include             " insert include
:execute cmd                    " do it
:!ls *.c                        " list C files
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The abbreviation 'dev' will be expanded to 'development     " shorthand'.  The
mapping of <F3> will actually be the whole line after the 'o# ....' including
the '" insert include'.  The "execute" command will give an error.  The "!"
command will send everything after it to the shell, causing an error for an
unmatched '"' character.
   There can be no comment after ":map", ":abbreviate", ":execute" and "!"
commands (there are a few more commands with this restriction).  For the
":map", ":abbreviate" and ":execute" commands there is a trick: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
短縮形 'dev' は 'development     " shorthand' に展開されます。<F3> には 'o#....' から '" insert include' までの全部がマップされます。"execute" コマンドはエラーを起こします。"@command{!}" コマンドはすべての文字をシェルに渡すので、@samp{"} 記号が閉じられていないことでエラーが起こります。

":map"、":abbreviate"、":execute"、"!" などのコマンドはその後ろにコメントを書くことができません (そのようなコマンドは他にもあります)。ただし、無理やりコメントを書く方法もあります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:abbrev dev development|" shorthand
	:map <F3> o#include|" insert include
	:execute cmd			|" do it
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:abbrev dev development|" shorthand
:map <F3> o#include|" insert include
:execute cmd                    |" do it
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
With the '|' character the command is separated from the next one.  And that
next command is only a comment.  For the last command you need to do two
things: |:execute| and use '|': >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'|' 文字でコマンドを区切り、次のコマンドを書くことができます。この例では 2 つ目のコマンドはコメントのみです。"!" の場合は |@ref{:execute}| と '|' を使わなければなりません:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:exe '!ls *.c'			|" list C files
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:exe '!ls *.c'                  |" list C files
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Notice that there is no white space before the '|' in the abbreviation and
mapping.  For these commands, any character until the end-of-line or '|' is
included.  As a consequence of this behavior, you don't always see that
trailing whitespace is included: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:map}" と "@command{:abbreviate}" の場合は '|' の前に空白を置かないように注意してください。これらのコマンドは行末か '|' までのすべての文字を使います。そのため、意図せずに末尾に空白を入れてしまうかもしれません:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:map <F4> o#include  
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:map <F4> o#include
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To spot these problems, you can set the 'list' option when editing vimrc
files.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
vimrc を編集するときに '@option{list}' オプションをオンに設定しておくと、この問題が発見しやすくなります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For Unix there is one special way to comment a line, that allows making a Vim
script executable: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Unix では特別なコメント書式を使って Vim script を実行形式にすることができます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	#!/usr/bin/env vim -S
	echo "this is a Vim script"
	quit
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
#!/usr/bin/env vim -S
echo "this is a Vim script"
quit
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "#" command by itself lists a line with the line number.  Adding an
exclamation mark changes it into doing nothing, so that you can add the shell
command to execute the rest of the file. |:#!| |-S|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"#" コマンドは行を行番号付きで表示しますが、'!' をつけると何もしなくなります。よってファイルを実行するためのシェルコマンドを記述することができます。|@ref{:#!}| |@ref{-S}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
PITFALLS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 落とし穴
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Even bigger problem arises in the following example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次の例には大きな問題があります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:map ,ab o#include
	:unmap ,ab 
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:map ,ab o#include
:unmap ,ab
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here the unmap command will not work, because it tries to unmap ",ab ".  This
does not exist as a mapped sequence.  An error will be issued, which is very
hard to identify, because the ending whitespace character in ":unmap ,ab " is
not visible.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この unmap コマンドはうまく動きません。なぜなら ",ab " を unmap しようとしているからです。そのようなマップは存在しません。エラーが表示されますが、スペースは目に見えないので、エラーの原因を見つけるのは困難です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
And this is the same as what happens when one uses a comment after an 'unmap'
command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:unmap}" コマンドの後にコメントを書いた場合も同様です:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:unmap ,ab     " comment
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:unmap ,ab     " comment
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here the comment part will be ignored.  However, Vim will try to unmap
',ab     ', which does not exist.  Rewrite it as: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コメントは無視されますが、Vim は ',ab     ' を unmap しようとします。次のように書いてください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:unmap ,ab|    " comment
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:unmap ,ab|    " comment
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
RESTORING THE VIEW
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec ビューの復元
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Sometimes you want to make a change and go back to where the cursor was.
Restoring the relative position would also be nice, so that the same line
appears at the top of the window.
   This example yanks the current line, puts it above the first line in the
file and then restores the view: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
何らかの変更を加えてから、カーソルのあった場所に戻りたい時があります。そのときに、画面に表示されていた行範囲も復元されるとすてきです。

次の例は、現在行をヤンクしてファイルの先頭にプットし、ビューを復元します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	map ,p ma"aYHmbgg"aP`bzt`a
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
map ,p ma"aYHmbgg"aP`bzt`a
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
What this does: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは次のことをしています:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	ma"aYHmbgg"aP`bzt`a
<	ma			set mark a at cursor position
	  "aY			yank current line into register a
	     Hmb		go to top line in window and set mark b there
		gg		go to first line in file
		  "aP		put the yanked line above it
		     `b		go back to top line in display
		       zt	position the text in the window as before
			 `a	go back to saved cursor position
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
ma"aYHmbgg"aP`bzt`a
ma                      現在のカーソル位置にマーク a を設定
  "aY                   現在行をレジスタ a にヤンク
     Hmb                ウィンドウの 1 行目に移動してマーク b を設定
        gg              ファイルの 1 行目に移動
          "aP           ヤンクした行をその上にプット
             `b         ウィンドウの 1 行目に戻る
               zt       ウィンドウの表示範囲を以前と同じにする
                 `a     保存しておいたカーソル位置に移動
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
PACKAGING
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec パッケージング
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To avoid your function names to interfere with functions that you get from
others, use this scheme:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数の名前が他の人の関数とかぶらないように、次の方法を使ってください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Prepend a unique string before each function name.  I often use an
  abbreviation.  For example, "OW_" is used for the option window functions.
- Put the definition of your functions together in a file.  Set a global
  variable to indicate that the functions have been loaded.  When sourcing the
  file again, first unload the functions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item
ユニークな文字列を名前の前に付ける。私はよく略語を使います。例えば、オプションウィンドウ (option window) のための関数なら "OW_" などです。
@item
関数を 1 つのファイルにまとめて、関数がロードされているかどうかを示すグローバル変数を設定する。ファイルが 2 回目に読み込まれたとき、最初にそれらの関数をアンロードする。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	" This is the XXX package

	if exists("XXX_loaded")
	  delfun XXX_one
	  delfun XXX_two
	endif

	function XXX_one(a)
		... body of function ...
	endfun

	function XXX_two(b)
		... body of function ...
	endfun

	let XXX_loaded = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
" This is the XXX package

if exists("XXX_loaded")
  delfun XXX_one
  delfun XXX_two
endif

function XXX_one(a)
        ... body of function ...
endfun

function XXX_two(b)
        ... body of function ...
endfun

let XXX_loaded = 1
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*41.11*	Writing a plugin				*write-plugin*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{41.11}
@anchor{write-plugin}
@cindex write-plugin
@cindex プラグインを書く
@section プラグインを書く
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can write a Vim script in such a way that many people can use it.  This is
called a plugin.  Vim users can drop your script in their plugin directory and
use its features right away |add-plugin|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim script を書いて、それを多くの人に使ってもらうことができます。そのようなスクリプトはプラグインと呼ばれます。Vim ユーザーはあなたのスクリプトをプラグインディレクトリにコピーするだけで、すぐにその機能を使うことができます。|@ref{add-plugin}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are actually two types of plugins:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プラグインには 2 種類あります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  global plugins: For all types of files.
filetype plugins: Only for files of a specific type.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .5 .5
@item グローバルプラグイン: @tab すべてのファイルで共通
@item ファイルタイププラグイン: @tab ファイルの種類別
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In this section the first type is explained.  Most items are also relevant for
writing filetype plugins.  The specifics for filetype plugins are in the next
section |write-filetype-plugin|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この節ではグローバルプラグインについて説明します。ほとんどの説明はファイルタイププラグインに対してもあてはまります。ファイルタイププラグイン特有の説明は次節にあります |@ref{write-filetype-plugin}|。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
NAME
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 名前
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
First of all you must choose a name for your plugin.  The features provided
by the plugin should be clear from its name.  And it should be unlikely that
someone else writes a plugin with the same name but which does something
different.  And please limit the name to 8 characters, to avoid problems on
old Windows systems.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最初にプラグインの名前を決めなければなりません。プラグインが提供する機能が名前から分かるようにしてください。また、他の人が作ったプラグインと名前がかぶらないようにしてください。古い Windows システムでの問題を避けるため、名前は 8 文字以内にしてください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A script that corrects typing mistakes could be called "typecorr.vim".  We
will use it here as an example.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えばタイプミス (type mistake) を修正 (correct) するためのスクリプトなら "typecorr.vim" という名前を付けたりします。ここではこれを例題として使います。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For the plugin to work for everybody, it should follow a few guidelines.  This
will be explained step-by-step.  The complete example plugin is at the end.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プラグインが誰でも使えるようにするため、いくつかのガイドラインに従ってください。ガイドラインは段階的に説明していきます。例題プラグインの完全なソースは最後に示します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
BODY
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec ボディ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Let's start with the body of the plugin, the lines that do the actual work: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
まずはプラグインの本体部分を見てみましょう。行番号は実際の番号です:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
14 iabbrev teh the
15 iabbrev otehr other
16 iabbrev wnat want
17 iabbrev synchronisation
18     \ synchronization
19 let s:count = 4
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The actual list should be much longer, of course.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もちろん、実際のスクリプトはもっと巨大です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The line numbers have only been added to explain a few things, don't put them
in your plugin file!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
行番号は説明のために追加したものです。プラグインを書くときは行番号を付けないでください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
HEADER
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec ヘッダー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You will probably add new corrections to the plugin and soon have several
versions lying around.  And when distributing this file, people will want to
know who wrote this wonderful plugin and where they can send remarks.
Therefore, put a header at the top of your plugin: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しい単語を追加していくと、プラグインには複数のバージョンが存在することになります。ファイルを配布したとき、それを使った人は、誰がこの素晴らしいプラグインを書いたのかを知りたいと思うでしょうし、感想を伝えたいと思うかもしれません。
というわけで、次のようなヘッダーをプラグインに書いてください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar <Bram@vim.org>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
1 " Vim global plugin for correcting typing mistakes
2 " Last Change:  2000 Oct 15
3 " Maintainer:   Bram Moolenaar <Bram@vim.org>
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
About copyright and licensing: Since plugins are very useful and it's hardly
worth restricting their distribution, please consider making your plugin
either public domain or use the Vim |license|.  A short note about this near
the top of the plugin should be sufficient.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
著作権とライセンスについて: プラグインがとても便利で、そして再配布を制限するほどのものでない場合は、パブリックドメインか Vim ライセンス (|@ref{license}|) の適用を検討してみてください。次の短い宣言をプラグインの先頭付近に書いておくだけで十分です:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  4	" License:	This file is placed in the public domain.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
4     " License:      This file is placed in the public domain.
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
LINE CONTINUATION, AVOIDING SIDE EFFECTS		*use-cpo-save*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{use-cpo-save}
@cindex use-cpo-save
@cindex 行連結、副作用の回避
@unnumberedsubsec 行連結、副作用の回避
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In line 18 above, the line-continuation mechanism is used |line-continuation|.
Users with 'compatible' set will run into trouble here, they will get an error
message.  We can't just reset 'compatible', because that has a lot of side
effects.  To avoid this, we will set the 'cpoptions' option to its Vim default
value and restore it later.  That will allow the use of line-continuation and
make the script work for most people.  It is done like this: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上の例の 18 行目では行連結 (|@ref{line-continuation}|) が使われています。ユーザーの環境で '@option{compatible}' オプションがオンに設定されていると、この行でエラーが発生します。'@option{compatible}' オプションの設定には副作用があるので、勝手に設定をオフにすることはできません。問題を避けるには、一時的に '@option{cpoptions}' の値を Vim の初期値に設定し、後で元に戻します。そうすれば、行連結を使うことができ、スクリプトはほとんどの環境で動作するようになります。設定の変更は次のようにします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 11	let s:save_cpo = &cpo
 12	set cpo&vim
 ..
 42	let &cpo = s:save_cpo
 43	unlet s:save_cpo
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
11     let s:save_cpo = &cpo
12     set cpo&vim
..
42     let &cpo = s:save_cpo
43     unlet s:save_cpo
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
We first store the old value of 'cpoptions' in the s:save_cpo variable.  At
the end of the plugin this value is restored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最初に '@option{cpoptions}' の値を s:save_cpo 変数に保存します。プラグインの最後でオプションの値を元に戻します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Notice that a script-local variable is used |s:var|.  A global variable could
already be in use for something else.  Always use script-local variables for
things that are only used in the script.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
スクリプトローカル変数 (|@ref{s:var}|) を使っていることに注目してください。グローバル変数は他の場所で使われている可能性があります。スクリプトの中だけで使う場合はスクリプトローカル変数を使ってください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
NOT LOADING
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec ロードしない
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It's possible that a user doesn't always want to load this plugin.  Or the
system administrator has dropped it in the system-wide plugin directory, but a
user has his own plugin he wants to use.  Then the user must have a chance to
disable loading this specific plugin.  This will make it possible: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザーが常にプラグインをロードしたいと思うとは限りません。また、システム管理者がシステムのプラグインディレクトリにプラグインを入れたが、ユーザーは自分で入れたプラグインを使いたいということもあります。したがって、指定したプラグインだけを無効にできる必要があります。次のようにします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  6	if exists("g:loaded_typecorr")
  7	  finish
  8	endif
  9	let g:loaded_typecorr = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
6     if exists("g:loaded_typecorr")
7       finish
8     endif
9     let g:loaded_typecorr = 1
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This also avoids that when the script is loaded twice it would cause error
messages for redefining functions and cause trouble for autocommands that are
added twice.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはスクリプトの二重ロードを避ける効果もあります。スクリプトを二重にロードすると、関数の再定義エラーが発生したり、自動コマンドが二重に追加されることでトラブルが起きたりします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The name is recommended to start with "loaded_" and then the file name of the
plugin, literally.  The "g:" is prepended just to avoid mistakes when using
the variable in a function (without "g:" it would be a variable local to the
function).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数の名前は "loaded_" で始めてプラグインのファイル名をそのまま付けるようにしてください。"g:" を付けることで関数の中で変数を使用したときに発生するミスを防いでいます (関数の中では "g:" を付けない変数はローカル変数になります)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Using "finish" stops Vim from reading the rest of the file, it's much quicker
than using if-endif around the whole file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"finish" を使ってファイルの残りの部分の読み込みを停止しています。この方法はファイル全体を if-endif で囲むよりも速いです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MAPPING
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec マップ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now let's make the plugin more interesting: We will add a mapping that adds a
correction for the word under the cursor.  We could just pick a key sequence
for this mapping, but the user might already use it for something else.  To
allow the user to define which keys a mapping in a plugin uses, the <Leader>
item can be used: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
さて、プラグインをもっと魅力あるものに仕上げましょう。マップを追加して、カーソルの下の単語に対する修正を追加できるようにします。単純にキーを選んでマップを設定することもできますが、そのキーは既にユーザーが使っているかもしれません。マップに使用するキーをユーザーが選択できるようにするには、<Leader> を使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
22       map <unique> <Leader>a  <Plug>TypecorrAdd
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "<Plug>TypecorrAdd" thing will do the work, more about that further on.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"<Plug>TypecorrAdd" は目的の動作をします。詳しくは後で説明します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The user can set the "mapleader" variable to the key sequence that he wants
this mapping to start with.  Thus if the user has done: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
使用したいキーを "mapleader" 変数に設定することで、マップの最初のキーを設定できます。例えば、次のように設定すると: >
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	let mapleader = "_"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
let mapleader = "_"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
the mapping will define "_a".  If the user didn't do this, the default value
will be used, which is a backslash.  Then a map for "\a" will be defined.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マップは "_a" と定義されます。変数が設定されていない場合は初期設定 (バックスラッシュ) が使われます。つまり "\a" というマップが定義されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that <unique> is used, this will cause an error message if the mapping
already happened to exist. |:map-<unique>|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
上記のコマンドでは <unique> が使われています。これは、同じマップが既に定義されていた場合にエラーを表示します。|@ref{:map-<unique>}|
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
But what if the user wants to define his own key sequence?  We can allow that
with this mechanism: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マップするキーをユーザーが自分で定義できるようにするには、次のようにします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 21	if !hasmapto('<Plug>TypecorrAdd')
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd
 23	endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
21      if !hasmapto('<Plug>TypecorrAdd')
22        map <unique> <Leader>a  <Plug>TypecorrAdd
23      endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This checks if a mapping to "<Plug>TypecorrAdd" already exists, and only
defines the mapping from "<Leader>a" if it doesn't.  The user then has a
chance of putting this in his vimrc file: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"<Plug>TypecorrAdd" に対するマップが既にあるかどうかを調べ、無い場合のみ" <Leader>a" にマップを定義します。ユーザーは自分の vimrc ファイルの中でマップを定義することができます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	map ,c  <Plug>TypecorrAdd
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
map ,c  <Plug>TypecorrAdd
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Then the mapped key sequence will be ",c" instead of "_a" or "\a".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
すると、マップのキーとして ",c" が使われます。"_a" や "\a" は使われません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
PIECES
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec ピース
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If a script gets longer, you often want to break up the work in pieces.  You
can use functions or mappings for this.  But you don't want these functions
and mappings to interfere with the ones from other scripts.  For example, you
could define a function Add(), but another script could try to define the same
function.  To avoid this, we define the function local to the script by
prepending it with "s:".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
スクリプトが大きくなると、それを部品ごとに分けたくなります。それには関数やマップを使います。しかし、そうすると関数やマップが他のスクリプトのものと衝突する可能性があります。例えば、Add() という関数を追加したとき、他のスクリプトでも同じ名前の関数が定義されているかもしれません。そのような場合は、名前の前に "s:" を付けて、スクリプトの中だけで使える関数を定義します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
We will define a function that adds a new typing correction: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しい修正を追加するための関数を定義します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " . a:from . ": ")
 32	  exe ":iabbrev " . a:from . " " . to
 ..
 36	endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
30 function s:Add(from, correct)
31   let to = input("type the correction for " . a:from . ": ")
32   exe ":iabbrev " . a:from . " " . to
..
36 endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now we can call the function s:Add() from within this script.  If another
script also defines s:Add(), it will be local to that script and can only
be called from the script it was defined in.  There can also be a global Add()
function (without the "s:"), which is again another function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
s:Add() 関数は同じスクリプトの中から呼び出すことができます。他のスクリプトが s:Add() を定義していた場合、それはそのスクリプトにローカルであり、関数が定義されたスクリプトの中からのみ呼び出すことができます。さらにグローバルの Add() 関数 ("s:" 無し) を定義することもでき、それはまた別の関数になります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<SID> can be used with mappings.  It generates a script ID, which identifies
the current script.  In our typing correction plugin we use it like this: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マップ定義では <SID> が使えます。これは、現在のスクリプトを識別するためのスクリプト ID を生成します。私たちの入力修正プラグインでは <SID> を次のように使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 24	noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
 ..
 28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
24	noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
..
28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Thus when a user types "\a", this sequence is invoked: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザーが "\a" と入力すると、次の手順でキー入力が呼び出されます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	\a  ->  <Plug>TypecorrAdd  ->  <SID>Add  ->  :call <SID>Add()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
\a  ->  <Plug>TypecorrAdd  ->  <SID>Add  ->  :call <SID>Add()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If another script would also map <SID>Add, it would get another script ID and
thus define another mapping.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
他のスクリプトで <SID>Add をマップすると、別のスクリプト ID が使われ、別のマップが生成されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that instead of s:Add() we use <SID>Add() here.  That is because the
mapping is typed by the user, thus outside of the script.  The <SID> is
translated to the script ID, so that Vim knows in which script to look for
the Add() function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
s:Add() ではなく <SID>Add() と書いていることに注意してください。マップはスクリプトの外側でユーザーが入力するものだからです。<SID> はスクリプト ID に変換され、どのスクリプトの Add() 関数を呼べばいいのかわかるようになっています。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This is a bit complicated, but it's required for the plugin to work together
with other plugins.  The basic rule is that you use <SID>Add() in mappings and
s:Add() in other places (the script itself, autocommands, user commands).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは少し複雑ですが、複数のプラグインを同時に使用するためには必要なことです。基本的なルールとしては、マップの中では <SID>Add() を使い、他の場所 (スクリプトの中、自動コマンド、ユーザー定義コマンド) では s:Add() を使います。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
We can also add a menu entry to do the same as the mapping: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マップと同じ方法で、メニューを追加することもできます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 26	noremenu <script> Plugin.Add\ Correction      <SID>Add
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
26 noremenu <script> Plugin.Add\ Correction      <SID>Add
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "Plugin" menu is recommended for adding menu items for plugins.  In this
case only one item is used.  When adding more items, creating a submenu is
recommended.  For example, "Plugin.CVS" could be used for a plugin that offers
CVS operations "Plugin.CVS.checkin", "Plugin.CVS.checkout", etc.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プラグインのメニューを追加する場合は "Plugin" メニューの下に登録することが推奨されています。この例ではメニューが 1 つだけですが、複数のメニューを追加する場合は、サブメニューの使用が推奨されています。例えば、"Plugin.CVS" 以下に "Plugin.CVS.checkin" や "Plugin.CVS.checkout" などの CVS の操作を登録します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that in line 28 ":noremap" is used to avoid that any other mappings cause
trouble.  Someone may have remapped ":call", for example.  In line 24 we also
use ":noremap", but we do want "<SID>Add" to be remapped.  This is why
"<script>" is used here.  This only allows mappings which are local to the
script. |:map-<script>|  The same is done in line 26 for ":noremenu".
|:menu-<script>|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
28 行目では ":noremap" を使って、他のマップでトラブルが起きないようにしています。例えば、誰かが ":call" をマップしているかもしれないからです。24 行目でも ":noremap" を使っていますが、ここでは "<SID>Add" を再マップして欲しいので、"<script>" を使っています。これを使うとスクリプトローカルなマップだけが再マップされます |@ref{:map-<script>}|。26 行目でも ":noremenu" で同様のことをしています |@ref{:menu-<script>}|。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
<SID> AND <Plug>					*using-<Plug>*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{using-<Plug>}
@cindex using-<Plug>
@cindex <SID> と <Plug>
@unnumberedsubsec <SID> と <Plug>
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Both <SID> and <Plug> are used to avoid that mappings of typed keys interfere
with mappings that are only to be used from other mappings.  Note the
difference between using <SID> and <Plug>:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
<SID> と <Plug> は、入力したキーに対するマップと、他のマップの中だけで使われるマップが干渉しないようにするために使われます。<SID> と <Plug> の違いに注意してください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<Plug>	is visible outside of the script.  It is used for mappings which the
	user might want to map a key sequence to.  <Plug> is a special code
	that a typed key will never produce.
	To make it very unlikely that other plugins use the same sequence of
	characters, use this structure: <Plug> scriptname mapname
	In our example the scriptname is "Typecorr" and the mapname is "Add".
	This results in "<Plug>TypecorrAdd".  Only the first character of
	scriptname and mapname is uppercase, so that we can see where mapname
	starts.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item <Plug>
これはスクリプトの外側からも見えます。ユーザーが自分でプラグインの機能をマップできるようにするような場合に使います。<Plug> は特殊なコードで、キーボードから入力されることはありません。
キー列が他のプラグインとかぶらないように、<Plug> スクリプト名 マップ名、という形式で使ってください。
我々の例では、スクリプト名が "Typecorr"、マップ名が "Add" なので、"<Plug>TypecorrAdd" というキー列になります。スクリプト名とマップ名の最初の文字だけを大文字にして、どこがマップ名なのかわかるようにします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<SID>	is the script ID, a unique identifier for a script.
	Internally Vim translates <SID> to "<SNR>123_", where "123" can be any
	number.  Thus a function "<SID>Add()" will have a name "<SNR>11_Add()"
	in one script, and "<SNR>22_Add()" in another.  You can see this if
	you use the ":function" command to get a list of functions.  The
	translation of <SID> in mappings is exactly the same, that's how you
	can call a script-local function from a mapping.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item <SID>
これはスクリプト ID (スクリプト固有の識別子) です。
Vim は内部で <SID> を "<SNR>123_" に変換します ("123" の部分はいろいろな数字が入ります)。つまり、関数 "<SID>Add()" は、あるスクリプトでは "<SNR>11_Add()" という名前になり、別のスクリプトでは "<SNR>22_Add()" になります。これは "@command{:function}" コマンドで関数一覧を表示すると確認することができます。<SID> の変換はマップの中でも同様におこなわれるので、マップの中からスクリプトローカル関数を呼び出すことができます。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
USER COMMAND
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec ユーザー定義コマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now let's add a user command to add a correction: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
修正を追加するためのユーザー定義コマンドを追加します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40	endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
38    if !exists(":Correct")
39      command -nargs=1  Correct  :call s:Add(<q-args>, 0)
40    endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The user command is defined only if no command with the same name already
exists.  Otherwise we would get an error here.  Overriding the existing user
command with ":command!" is not a good idea, this would probably make the user
wonder why the command he defined himself doesn't work.  |:command|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザー定義コマンドは、同じ名前のコマンドがまだない場合のみ定義できます。既に定義されている場合はエラーになります。":command!" を使ってユーザー定義関数を上書きするのは良いアイデアとは言えません。ユーザーは、自分が定義したコマンドがなぜ動かないのか不思議に思うでしょう。|@ref{:command}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
SCRIPT VARIABLES
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec スクリプト変数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When a variable starts with "s:" it is a script variable.  It can only be used
inside a script.  Outside the script it's not visible.  This avoids trouble
with using the same variable name in different scripts.  The variables will be
kept as long as Vim is running.  And the same variables are used when sourcing
the same script again. |s:var|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
先頭に "s:" が付いた変数はスクリプト変数です。これはスクリプトの中だけで使えます。スクリプトの外からは見えません。同じ名前の変数を複数のスクリプトで使ってしまうようなトラブルを避けることができます。Vim が実行されている間、変数は保持されます。そして、同じスクリプトが再読み込みされると、再び同じ変数が使われます。|@ref{s:var}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The fun is that these variables can also be used in functions, autocommands
and user commands that are defined in the script.  In our example we can add
a few lines to count the number of corrections: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
スクリプト変数は、同じスクリプトの中で定義された関数、自動コマンド、ユーザー定義コマンドでも使えます。我々の例に、修正の数を数えるための数行のコードを追加します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 19	let s:count = 4
 ..
 30	function s:Add(from, correct)
 ..
 34	  let s:count = s:count + 1
 35	  echo s:count . " corrections now"
 36	endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
19  let s:count = 4
..
30  function s:Add(from, correct)
..
34    let s:count = s:count + 1
35    echo s:count . " corrections now"
36  endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
First s:count is initialized to 4 in the script itself.  When later the
s:Add() function is called, it increments s:count.  It doesn't matter from
where the function was called, since it has been defined in the script, it
will use the local variables from this script.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最初に s:count はスクリプトの中で 4 で初期化されます。その後、s:Add() 関数が呼び出されると、s:count が増加します。関数がどこから呼ばれたかにかかわらず、関数が定義されたスクリプトのローカル変数が使われます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
THE RESULT
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec まとめ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here is the resulting complete example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例題の完成形は以下のようになります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  1	" Vim global plugin for correcting typing mistakes
  2	" Last Change:	2000 Oct 15
  3	" Maintainer:	Bram Moolenaar <Bram@vim.org>
  4	" License:	This file is placed in the public domain.
  5
  6	if exists("g:loaded_typecorr")
  7	  finish
  8	endif
  9	let g:loaded_typecorr = 1
 10
 11	let s:save_cpo = &cpo
 12	set cpo&vim
 13
 14	iabbrev teh the
 15	iabbrev otehr other
 16	iabbrev wnat want
 17	iabbrev synchronisation
 18		\ synchronization
 19	let s:count = 4
 20
 21	if !hasmapto('<Plug>TypecorrAdd')
 22	  map <unique> <Leader>a  <Plug>TypecorrAdd
 23	endif
 24	noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
 25
 26	noremenu <script> Plugin.Add\ Correction      <SID>Add
 27
 28	noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
 29
 30	function s:Add(from, correct)
 31	  let to = input("type the correction for " . a:from . ": ")
 32	  exe ":iabbrev " . a:from . " " . to
 33	  if a:correct | exe "normal viws\<C-R>\" \b\e" | endif
 34	  let s:count = s:count + 1
 35	  echo s:count . " corrections now"
 36	endfunction
 37
 38	if !exists(":Correct")
 39	  command -nargs=1  Correct  :call s:Add(<q-args>, 0)
 40	endif
 41
 42	let &cpo = s:save_cpo
 43	unlet s:save_cpo
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
1 " Vim global plugin for correcting typing mistakes
2 " Last Change:  2000 Oct 15
3 " Maintainer:   Bram Moolenaar <Bram@@vim.org>
4 " License:  This file is placed in the public domain.
5
6 if exists("g:loaded_typecorr")
7   finish
8 endif
9 let g:loaded_typecorr = 1
10
11 let s:save_cpo = &cpo
12 set cpo&vim
13
14 iabbrev teh the
15 iabbrev otehr other
16 iabbrev wnat want
17 iabbrev synchronisation
18     \ synchronization
19 let s:count = 4
20
21 if !hasmapto('<Plug>TypecorrAdd')
22   map <unique> <Leader>a  <Plug>TypecorrAdd
23 endif
24 noremap <unique> <script> <Plug>TypecorrAdd  <SID>Add
25
26 noremenu <script> Plugin.Add\ Correction      <SID>Add
27
28 noremap <SID>Add  :call <SID>Add(expand("<cword>"), 1)<CR>
29
30 function s:Add(from, correct)
31   let to = input("type the correction for " . a:from . ": ")
32   exe ":iabbrev " . a:from . " " . to
33   if a:correct | exe "normal viws\<C-R>\" \b\e" | endif
34   let s:count = s:count + 1
35   echo s:count . " corrections now"
36 endfunction
37
38 if !exists(":Correct")
39   command -nargs=1  Correct  :call s:Add(<q-args>, 0)
40 endif
41
42 let &cpo = s:save_cpo
43 unlet s:save_cpo
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Line 33 wasn't explained yet.  It applies the new correction to the word under
the cursor.  The |:normal| command is used to use the new abbreviation.  Note
that mappings and abbreviations are expanded here, even though the function
was called from a mapping defined with ":noremap".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
33 行目は説明がまだでした。これは、新しい修正をカーソルの下の単語に適用します。|@ref{:normal}| コマンドを使って新しい略語を適用しています。
@quotation
@strong{Note:} マップと略語はその場で展開されます。":noremap" で定義されたマップから関数が呼び出されたとしても動作は同じです。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Using "unix" for the 'fileformat' option is recommended.  The Vim scripts will
then work everywhere.  Scripts with 'fileformat' set to "dos" do not work on
Unix.  Also see |:source_crnl|.  To be sure it is set right, do this before
writing the file: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{fileformat}' オプションを "unix" に設定することが推奨されています。そうすれば、Vim script はどこでも動作します。'@option{fileformat}' が "dos" に設定されたスクリプトは Unix では動作しません。|@ref{:source_crnl}| も参照。設定が正しいことを確実にするため、ファイルを保存する前に次のコマンドを実行してください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set fileformat=unix
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set fileformat=unix
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DOCUMENTATION						*write-local-help*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{write-local-help}
@cindex write-local-help
@cindex プラグインのドキュメント
ドキュメント
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It's a good idea to also write some documentation for your plugin.  Especially
when its behavior can be changed by the user.  See |add-local-help| for how
they are installed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プラグインのドキュメントを書くのは良いアイデアです。ユーザーが動作を変更できるような場合には特に重要です。|@ref{add-local-help}| ではどのようにしてドキュメントがインストールされるか説明されています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here is a simple example for a plugin help file, called "typecorr.txt": >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プラグインヘルプファイルの例を示します ("typecorr.txt"):
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  1	*typecorr.txt*	Plugin for correcting typing mistakes
  2
  3	If you make typing mistakes, this plugin will have them corrected
  4	automatically.
  5
  6	There are currently only a few corrections.  Add your own if you like.
  7
  8	Mappings:
  9	<Leader>a   or   <Plug>TypecorrAdd
 10		Add a correction for the word under the cursor.
 11
 12	Commands:
 13	:Correct {word}
 14		Add a correction for {word}.
 15
 16							*typecorr-settings*
 17	This plugin doesn't have any settings.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
1 *typecorr.txt*  Plugin for correcting typing mistakes
2
3 If you make typing mistakes, this plugin will have them corrected
4 automatically.
5
6 There are currently only a few corrections.  Add your own if you like.
7
8 Mappings:
9 <Leader>a   or   <Plug>TypecorrAdd
10     Add a correction for the word under the cursor.
11
12 Commands:
13 :Correct {word}
14     Add a correction for {word}.
15
16                         *typecorr-settings*
17 This plugin doesn't have any settings.
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The first line is actually the only one for which the format matters.  It will
be extracted from the help file to be put in the "LOCAL ADDITIONS:" section of
help.txt |local-additions|.  The first "*" must be in the first column of the
first line.  After adding your help file do ":help" and check that the entries
line up nicely.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
書式に気をつけなければならないのは一行目だけです。1 行目はコピーされ、help.txt の "LOCAL ADDITIONS:" の項に埋め込まれます |@ref{local-additions}|。最初の "*" は 1 行目の 1 桁目に書いてください。ヘルプを追加したら ":help" を実行して項目が追加されたことを確認してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can add more tags inside ** in your help file.  But be careful not to use
existing help tags.  You would probably use the name of your plugin in most of
them, like "typecorr-settings" in the example.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ヘルプの中で ** で文字を囲むとタグを追加することができます。ただし、既存のヘルプタグと同じものを使わないでください。"typecorr-settings" のように、プラグインの名前を使ってタグを作るといいかもしれません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Using references to other parts of the help in || is recommended.  This makes
it easy for the user to find associated help.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ヘルプの他の部分を参照するときは || で囲みます。そうすれば、ユーザーは簡単にヘルプの関連した部分を参照することができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
FILETYPE DETECTION					*plugin-filetype*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{plugin-filetype}
@cindex plugin-filetype
@cindex ファイルタイプの認識
ファイルタイプの認識
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If your filetype is not already detected by Vim, you should create a filetype
detection snippet in a separate file.  It is usually in the form of an
autocommand that sets the filetype when the file name matches a pattern.
Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルタイプが Vim によって認識されない場合は、別ファイルにファイルタイプを認識するためにコードを作成する必要があります。通常は、自動コマンドを使って、ファイル名がパターンにマッチしたときにファイルタイプを設定します。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	au BufNewFile,BufRead *.foo			set filetype=foofoo
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
au BufNewFile,BufRead *.foo         set filetype=foofoo
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Write this single-line file as "ftdetect/foofoo.vim" in the first directory
that appears in 'runtimepath'.  For Unix that would be
"~/.vim/ftdetect/foofoo.vim".  The convention is to use the name of the
filetype for the script name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この 1 行を '@option{runtimepath}' の最初のディレクトリの "ftdetect/foofoo.vim" に書き込みます。例えば、Unix なら "~/.vim/ftdetect/foofoo.vim" などです。ファイルタイプとスクリプトファイルの名前を同じにする決まりになっています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can make more complicated checks if you like, for example to inspect the
contents of the file to recognize the language.  Also see |new-filetype|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
必要ならより複雑な処理をすることもできます。例えば、ファイルの中身を見て言語を判定したりできます。|@ref{new-filetype}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
SUMMARY							*plugin-special*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{plugin-special}
@cindex plugin-special
@cindex プラグイン要約
要約
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Summary of special things to use in a plugin:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プラグインで使用する特有事項の要約を示します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
s:name			Variables local to the script.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item s:name
スクリプトローカル変数。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<SID>			Script-ID, used for mappings and functions local to
			the script.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item <SID>
スクリプトID。マップや関数をスクリプトローカルにするのに使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
hasmapto()		Function to test if the user already defined a mapping
			for functionality the script offers.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item hasmapto()
スクリプトが提供している機能に対して、ユーザーが既にマップを定義したかどうかをチェックする関数。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<Leader>		Value of "mapleader", which the user defines as the
			keys that plugin mappings start with.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item <Leader>
"mapleader" の値。ユーザーがその変数にキーを設定することで、プラグインのマップの開始キーを指定できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:map <unique>		Give a warning if a mapping already exists.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :map <unique>
マップが既に定義されているなら警告を発する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:noremap <script>	Use only mappings local to the script, not global
			mappings.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :noremap <script>
スクリプトローカルマップだけを使う。グローバルマップは使わない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
exists(":Cmd")		Check if a user command already exists.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item exists(":Cmd")
ユーザー定義コマンドが既にあるかどうかをチェックする。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*41.12*	Writing a filetype plugin	*write-filetype-plugin* *ftplugin*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{41.12}
@anchor{write-filetype-plugin}
@anchor{ftplugin}
@cindex write-filetype-plugin
@cindex ftplugin
@cindex ファイルタイププラグインを書く
@section ファイルタイププラグインを書く
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A filetype plugin is like a global plugin, except that it sets options and
defines mappings for the current buffer only.  See |add-filetype-plugin| for
how this type of plugin is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルタイププラグインはグローバルプラグインと似ていますが、カレントバッファのマップやオプションだけを設定します。ファイルタイププラグインの使用方法については |@ref{add-filetype-plugin}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
First read the section on global plugins above |41.11|.  All that is said there
also applies to filetype plugins.  There are a few extras, which are explained
here.  The essential thing is that a filetype plugin should only have an
effect on the current buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
先に |@ref{41.11}| 節のグローバルプラグインの項を読んでください。そこで説明されていることはすべてファイルタイププラグインにもあてはまります。この節ではファイルタイププラグイン特有の事項だけを説明します。ファイルタイププラグインはカレントバッファに対してのみ機能するということが最も大切です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DISABLING
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 無効化
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you are writing a filetype plugin to be used by many people, they need a
chance to disable loading it.  Put this at the top of the plugin: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルタイププラグインを書いて多くの人に使ってもらおうとするなら、プラグインを無効化できるようにしておく必要があります。プラグインの先頭に次のような記述を追加してください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	" Only do this when not done yet for this buffer
	if exists("b:did_ftplugin")
	  finish
	endif
	let b:did_ftplugin = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
" このバッファに対してまだ実行されていない場合のみ処理を実行する
if exists("b:did_ftplugin")
finish
endif
let b:did_ftplugin = 1
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This also needs to be used to avoid that the same plugin is executed twice for
the same buffer (happens when using an ":edit" command without arguments).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは同じプラグインが同じバッファで二重にロードされるのを防ぐためにも必要です (":edit" コマンドを引数なしで実行したときに発生します)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now users can disable loading the default plugin completely by making a
filetype plugin with only this line: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザーは、次の一行だけを書いたファイルタイププラグインを作成することで、標準プラグインのロードを無効化できます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	let b:did_ftplugin = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
let b:did_ftplugin = 1
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This does require that the filetype plugin directory comes before $VIMRUNTIME
in 'runtimepath'!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ただし、そのファイルを保存したファイルタイププラグインディレクトリが、'@option{runtimepath}' の中で @env{$VIMRUNTIME} よりも前にある必要があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you do want to use the default plugin, but overrule one of the settings,
you can write the different setting in a script: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
標準プラグインを使いつつ、その設定を 1 つだけ変更したいという場合は、スクリプトの中で設定を変更することができます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	setlocal textwidth=70
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
setlocal textwidth=70
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now write this in the "after" directory, so that it gets sourced after the
distributed "vim.vim" ftplugin |after-directory|.  For Unix this would be
"~/.vim/after/ftplugin/vim.vim".  Note that the default plugin will have set
"b:did_ftplugin", but it is ignored here.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このファイルを "after" ディレクトリに保存すると、(例えば filetype=vim なら) 標準配布の "vim.vim" が読み込まれた後に、保存したファイルが読み込まれるようになります |@ref{after-directory}|。Unix ならファイルのパスは "~/.vim/after/ftplugin/vim.vim" です。
@quotation
@strong{Note:} @*
標準プラグインは "b:did_ftplugin" を設定しますが、ここではそれを無視しています。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
OPTIONS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec オプション
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To make sure the filetype plugin only affects the current buffer use the >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルタイププラグインでは、カレントバッファの設定だけを変更するため、次のコマンドを使ってオプションを設定してください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:setlocal
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:setlocal
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
command to set options.  And only set options which are local to a buffer (see
the help for the option to check that).  When using |:setlocal| for global
options or options local to a window, the value will change for many buffers,
and that is not what a filetype plugin should do.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
そして、バッファローカルなオプションだけを設定してください (どのオプションがそうなのかはヘルプで確認してください)。|@ref{:setlocal}| コマンドでグローバルオプションやウィンドウローカルオプションを設定すると、たくさんのバッファの設定が変更されます。ファイルタイププラグインはそのような動作をすべきではありません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When an option has a value that is a list of flags or items, consider using
"+=" and "-=" to keep the existing value.  Be aware that the user may have
changed an option value already.  First resetting to the default value and
then changing it is often a good idea.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプションの値がフラグや設定項目のリストなら、"+=" や "-=" を使うことで既存の設定を維持することができます。ユーザーがそのオプションの設定を変更している可能性もあるので注意してください。最初に初期設定に戻してから設定を変更するといいかもしれません。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:setlocal formatoptions& formatoptions+=ro
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:setlocal formatoptions& formatoptions+=ro
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MAPPINGS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec マップ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To make sure mappings will only work in the current buffer use the >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カレントバッファの中だけで機能するマップを作るには次のコマンドを使います:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:map <buffer>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:map <buffer>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
command.  This needs to be combined with the two-step mapping explained above.
An example of how to define functionality in a filetype plugin: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上述したように、マップは二段階に分けて作る必要があります。ファイルタイププラグインで機能を定義する例を示します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	if !hasmapto('<Plug>JavaImport')
	  map <buffer> <unique> <LocalLeader>i <Plug>JavaImport
	endif
	noremap <buffer> <unique> <Plug>JavaImport oimport ""<Left><Esc>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
if !hasmapto('<Plug>JavaImport')
map <buffer> <unique> <LocalLeader>i <Plug>JavaImport
endif
noremap <buffer> <unique> <Plug>JavaImport oimport ""<Left><Esc>
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|hasmapto()| is used to check if the user has already defined a map to
<Plug>JavaImport.  If not, then the filetype plugin defines the default
mapping.  This starts with |<LocalLeader>|, which allows the user to select
the key(s) he wants filetype plugin mappings to start with.  The default is a
backslash.
"<unique>" is used to give an error message if the mapping already exists or
overlaps with an existing mapping.
|:noremap| is used to avoid that any other mappings that the user has defined
interferes.  You might want to use ":noremap <script>" to allow remapping
mappings defined in this script that start with <SID>.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{hasmapto()}| を使って、ユーザーが既に <Plug>JavaImport に対してマップを定義しているかどうかを調べます。未定義ならファイルタイププラグインの標準のマップを定義します。マップは <LocalLeader> で開始します。そうすることで、ファイルタイププラグインのマップを開始するキーをユーザーが選択できます。初期設定はバックスラッシュです。

"<unique>" を使って、マップが既に存在したとき、あるいは既存のマップと重複したときにエラーメッセージが表示されるようにします。

|@ref{:noremap}| を使って、ユーザーが定義した他のマップの影響を受けないようにします。":noremap <script>" を使うと、スクリプトの中で定義した <SID> で始まるマップだけが再マップされます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The user must have a chance to disable the mappings in a filetype plugin,
without disabling everything.  Here is an example of how this is done for a
plugin for the mail filetype: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザーがファイルタイププラグインのマップを無効化できる仕組みを提供しなければなりません。例えば、"mail" ファイルタイプのプラグインなら次のようにします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	" Add mappings, unless the user didn't want this.
	if !exists("no_plugin_maps") && !exists("no_mail_maps")
	  " Quote text by inserting "> "
	  if !hasmapto('<Plug>MailQuote')
	    vmap <buffer> <LocalLeader>q <Plug>MailQuote
	    nmap <buffer> <LocalLeader>q <Plug>MailQuote
	  endif
	  vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>
	  nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>
	endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
" マップを追加する。ユーザーが望まない場合は追加しない。
if !exists("no_plugin_maps") && !exists("no_mail_maps")
" "> " を挿入して引用する
if !hasmapto('<Plug>MailQuote')
vmap <buffer> <LocalLeader>q <Plug>MailQuote
nmap <buffer> <LocalLeader>q <Plug>MailQuote
endif
vnoremap <buffer> <Plug>MailQuote :s/^/> /<CR>
nnoremap <buffer> <Plug>MailQuote :.,$s/^/> /<CR>
endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Two global variables are used:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここでは 2 つのグローバル変数が使われています:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
|no_plugin_maps|	disables mappings for all filetype plugins
|no_mail_maps|		disables mappings for the "mail" filetype
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item |@ref{no_plugin_maps}| @tab すべてのファイルタイププラグインのマップを無効化
@item |@ref{no_mail_maps}| @tab "mail" ファイルタイプのマップを無効化
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
USER COMMANDS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec ユーザー定義コマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To add a user command for a specific file type, so that it can only be used in
one buffer, use the "-buffer" argument to |:command|.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルタイプ用のユーザー定義コマンドを追加して、それを 1 つのバッファの中だけで使えるようにするには、|@ref{:command}| の引数に "-buffer" を指定します。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:command -buffer  Make  make %:r.s
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:command -buffer  Make  make %:r.s
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
VARIABLES
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 変数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A filetype plugin will be sourced for each buffer of the type it's for.  Local
script variables |s:var| will be shared between all invocations.  Use local
buffer variables |b:var| if you want a variable specifically for one buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルタイププラグインは対応するすべてのバッファに対して実行されます。スクリプトローカル変数 |@ref{s:var}| はすべての実行で共有されます。バッファごとの変数を使いたい場合はバッファローカル変数 |@ref{b:var}| を使ってください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
FUNCTIONS
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 関数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When defining a function, this only needs to be done once.  But the filetype
plugin will be sourced every time a file with this filetype will be opened.
This construct makes sure the function is only defined once: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数は一度だけ定義すれば十分です。しかし、ファイルタイププラグインは対応するファイルが開かれるたびに読み込まれます。次のようにすると関数が一度だけ定義されるようになります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:if !exists("*s:Func")
	:  function s:Func(arg)
	:    ...
	:  endfunction
	:endif
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if !exists("*s:Func")
:  function s:Func(arg)
:    ...
:  endfunction
:endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
UNDO						*undo_indent* *undo_ftplugin*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{undo_indent}
@anchor{undo_ftplugin}
@cindex undo_indent
@cindex undo_ftplugin
@cindex プラグイン アンドゥ
アンドゥ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the user does ":setfiletype xyz" the effect of the previous filetype
should be undone.  Set the b:undo_ftplugin variable to the commands that will
undo the settings in your filetype plugin.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザーが ":setfiletype xyz" としたとき、それ以前のファイルタイプの効果は無効になるべきです。b:undo_ftplugin 変数にコマンドを設定し、ファイルタイププラグインの設定をアンドゥするようにしてください。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	let b:undo_ftplugin = "setlocal fo< com< tw< commentstring<"
		\ . "| unlet b:match_ignorecase b:match_words b:match_skip"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
let b:undo_ftplugin = "setlocal fo< com< tw< commentstring<"
    \ . "| unlet b:match_ignorecase b:match_words b:match_skip"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Using ":setlocal" with "<" after the option name resets the option to its
global value.  That is mostly the best way to reset the option value.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:setlocal}" でオプション名の後に "<" を付けると、そのオプションをグローバルな値でリセットします。オプションをリセットするにはこの方法が一番です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This does require removing the "C" flag from 'cpoptions' to allow line
continuation, as mentioned above |use-cpo-save|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このように行継続を使うには '@option{cpoptions}' から "C" フラグを取り除く必要があります。上述の |@ref{use-cpo-save}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For undoing the effect of an indent script, the b:undo_indent variable should
be set accordingly.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
インデントスクリプトの効果をアンドゥする為には、それに応じた b:undo_indent 変数を設定すべきです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
FILE NAME
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec ファイル名
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The filetype must be included in the file name |ftplugin-name|.  Use one of
these three forms:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルタイププラグインのファイル名にはファイルタイプ名が含まれていなければなりません |@ref{ftplugin-name}|。次の 3 つのうちのどれかにしてください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	.../ftplugin/stuff.vim
	.../ftplugin/stuff_foo.vim
	.../ftplugin/stuff/bar.vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
.../ftplugin/stuff.vim
.../ftplugin/stuff_foo.vim
.../ftplugin/stuff/bar.vim
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
"stuff" is the filetype, "foo" and "bar" are arbitrary names.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"stuff" はファイルタイプ名、"foo" と "bar" は任意の名前です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
SUMMARY							*ftplugin-special*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ftplugin-special}
@cindex ftplugin-special
@cindex プラグイン 要約
@unnumberedsubsec 要約
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Summary of special things to use in a filetype plugin:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルタイププラグインの特有事項を要約します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<LocalLeader>		Value of "maplocalleader", which the user defines as
			the keys that filetype plugin mappings start with.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item<LocalLeader>
"maplocalleader" の値。ユーザーがその変数にキーを設定することで、ファイルタイププラグインのマップの開始キーを指定できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:map <buffer>		Define a mapping local to the buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :map <buffer>
バッファローカルなマップを定義する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:noremap <script>	Only remap mappings defined in this script that start
			with <SID>.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :noremap <script>
同スクリプトで定義している <SID> で始まるマップだけを再マップする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:setlocal		Set an option for the current buffer only.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :setlocal
カレントバッファのオプションのみ設定する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:command -buffer	Define a user command local to the buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :command -buffer
バッファローカルなユーザー定義コマンドを定義する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
exists("*s:Func")	Check if a function was already defined.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item exists("*s:Func")
関数が定義済かどうかをチェックする。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Also see |plugin-special|, the special things used for all plugins.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プラグイン全般に関する事項は |@ref{plugin-special}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*41.13*	Writing a compiler plugin		*write-compiler-plugin*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{41.13}
@anchor{write-compiler-plugin}
@cindex write-compiler-plugin
@cindex コンパイラプラグインを書く
@section コンパイラプラグインを書く
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A compiler plugin sets options for use with a specific compiler.  The user can
load it with the |:compiler| command.  The main use is to set the
'errorformat' and 'makeprg' options.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コンパイラプラグインは特定のコンパイラを使うためのオプションを設定します。ユーザーは |@ref{:compiler}| コマンドでその設定を読み込むことができます。設定されるオプションは主に '@option{errorformat}' と '@option{makeprg}' です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Easiest is to have a look at examples.  This command will edit all the default
compiler plugins: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
百聞は一見に如かず。次のコマンドですべての標準コンパイラプラグインを開くことができます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:next $VIMRUNTIME/compiler/*.vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:next $VIMRUNTIME/compiler/*.vim
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Use |:next| to go to the next plugin file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:next}| を使って次のプラグインファイルに移動してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are two special items about these files.  First is a mechanism to allow
a user to overrule or add to the default file.  The default files start with: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのファイルには 2 つの特有事項があります。1 つは、標準ファイルに対して設定を追加したり上書きしたりできる仕組みです。標準ファイルの先頭は次のようになっています:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:if exists("current_compiler")
	:  finish
	:endif
	:let current_compiler = "mine"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if exists("current_compiler")
:  finish
:endif
:let current_compiler = "mine"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you write a compiler file and put it in your personal runtime directory
(e.g., ~/.vim/compiler for Unix), you set the "current_compiler" variable to
make the default file skip the settings.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コンパイラファイルを書いて、それを個人用のランタイムディレクトリ (例えば Unixなら ~/.vim/compiler) に置いたとき、"current_compiler" 変数を設定することで標準ファイルの設定をスキップすることができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:CompilerSet*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:CompilerSet}
@pindex :CompilerSet
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The second mechanism is to use ":set" for ":compiler!" and ":setlocal" for
":compiler".  Vim defines the ":CompilerSet" user command for this.  However,
older Vim versions don't, thus your plugin should define it then.  This is an
example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2 つ目は、":compiler!" が使われたときは ":set" を使い、":compiler" が使われたときは ":setlocal" を使う仕組みです。Vim はそのために ":CompilerSet" というユーザーコマンドを定義します。古い Vim はそれを定義しないので、プラグインの中で定義してください。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  if exists(":CompilerSet") != 2
    command -nargs=* CompilerSet setlocal <args>
  endif
  CompilerSet errorformat&		" use the default 'errorformat'
  CompilerSet makeprg=nmake
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
if exists(":CompilerSet") != 2
command -nargs=* CompilerSet setlocal <args>
endif
CompilerSet errorformat&                " use the default 'errorformat'
CompilerSet makeprg=nmake
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you write a compiler plugin for the Vim distribution or for a system-wide
runtime directory, use the mechanism mentioned above.  When
"current_compiler" was already set by a user plugin nothing will be done.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コンパイラプラグインを書いて、それを Vim の配布物に含めたり、システムのランタイムディレクトリに入れたりする場合は、上記の方法を使ってください。
"current_compiler" がユーザープラグインで設定された場合は何も実行しないようにします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you write a compiler plugin to overrule settings from a default plugin,
don't check "current_compiler".  This plugin is supposed to be loaded
last, thus it should be in a directory at the end of 'runtimepath'.  For Unix
that could be ~/.vim/after/compiler.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コンパイラプラグインを書いて標準プラグインの設定を上書きする場合は "current_compiler" をチェックしないようにします。そのプラグインは最後に読み込まれないといけないので、'@option{runtimepath}' の最後にあるディレクトリに置きます。例えば、Unix なら ~/.vim/after/compiler などです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*41.14*	Writing a plugin that loads quickly	*write-plugin-quickload*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{41.14}
@anchor{write-plugin-quickload}
@cindex write-plugin-quickload
@cindex プラグインを書く (高速ロード版)
@section プラグインを書く (高速ロード版)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A plugin may grow and become quite long.  The startup delay may become
noticeable, while you hardly ever use the plugin.  Then it's time for a
quickload plugin.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プラグインが成長し、とても大きくなることがあります。すると、起動速度は遅くなってきます。例えそのプラグインをたまにしか使わないとしても遅くなります。そういうときはクイックロードプラグインの出番です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The basic idea is that the plugin is loaded twice.  The first time user
commands and mappings are defined that offer the functionality.  The second
time the functions that implement the functionality are defined.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
基本的なアイデアはプラグインを 2 回に分けて読み込むということです。1 回目はユーザー定義コマンドやマップを定義して機能を提供します。2 回目は機能を実装する関数を定義します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It may sound surprising that quickload means loading a script twice.  What we
mean is that it loads quickly the first time, postponing the bulk of the
script to the second time, which only happens when you actually use it.  When
you always use the functionality it actually gets slower!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
スクリプトを 2回読み込むことがクイックロードだというと驚かれるかもしれません。この手法の意味は、1 回目は高速に読み込み、スクリプトの重い部分は 2 回目に後回しにするということです。2 回目の読み込みは、ユーザーが実際にその機能を使用したときに発生します。あなたがその機能を常に使うなら、これは逆に遅くなってしまいます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that since Vim 7 there is an alternative: use the |autoload|
functionality |41.15|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} Vim 7 以降では代わりの方法があります。|@ref{41.15}| で説明されている |@ref{autoload}| 機能を使う方法です。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The following example shows how it's done: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次に例を示します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	" Vim global plugin for demonstrating quick loading
	" Last Change:	2005 Feb 25
	" Maintainer:	Bram Moolenaar <Bram@vim.org>
	" License:	This file is placed in the public domain.

	if !exists("s:did_load")
		command -nargs=* BNRead  call BufNetRead(<f-args>)
		map <F19> :call BufNetWrite('something')<CR>

		let s:did_load = 1
		exe 'au FuncUndefined BufNet* source ' . expand('<sfile>')
		finish
	endif

	function BufNetRead(...)
		echo 'BufNetRead(' . string(a:000) . ')'
		" read functionality here
	endfunction

	function BufNetWrite(...)
		echo 'BufNetWrite(' . string(a:000) . ')'
		" write functionality here
	endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
" クイックロードのデモ用のグローバルプラグイン
" Last Change:  2005 Feb 25
" Maintainer:   Bram Moolenaar <Bram@vim.org>
" License:  This file is placed in the public domain.

if !exists("s:did_load")
command -nargs=* BNRead  call BufNetRead(<f-args>)
map <F19> :call BufNetWrite('something')<CR>

let s:did_load = 1
exe 'au FuncUndefined BufNet* source ' . expand('<sfile>')
finish
endif

function BufNetRead(...)
echo 'BufNetRead(' . string(a:000) . ')'
" read 機能をここに書く
endfunction

function BufNetWrite(...)
echo 'BufNetWrite(' . string(a:000) . ')'
" write 機能をここに書く
endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the script is first loaded "s:did_load" is not set.  The commands between
the "if" and "endif" will be executed.  This ends in a |:finish| command, thus
the rest of the script is not executed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このスクリプトが最初に読み込まれたとき、"s:did_load" は設定されていません。"if" と "endif" の間のコマンドが実行されます。|@ref{:finish}| コマンドによって終了し、スクリプトの残りの部分は実行されません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The second time the script is loaded "s:did_load" exists and the commands
after the "endif" are executed.  This defines the (possible long)
BufNetRead() and BufNetWrite() functions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2 回目に読み込まれたときは "s:did_load" が存在するので、"endif" 以降のコマンドが実行されます。この部分では (長くなる可能性のある) BufNetRead() 関数と BufNetWrite() 関数を定義します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you drop this script in your plugin directory Vim will execute it on
startup.  This is the sequence of events that happens:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このスクリプトをプラグインディレクトリに置くと、Vim の起動時に実行されます。処理の流れは次のようになります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. The "BNRead" command is defined and the <F19> key is mapped when the script
   is sourced at startup.  A |FuncUndefined| autocommand is defined.  The
   ":finish" command causes the script to terminate early.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item
起動時にスクリプトが読み込まれる。"BNRead" コマンドが定義され、@key{<F19>} キーにマップが設定される。自動コマンドの |@ref{FuncUndefined}| が定義される。"@command{:finish}" コマンドによってスクリプトが終了する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
2. The user types the BNRead command or presses the <F19> key.  The
   BufNetRead() or BufNetWrite() function will be called.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
ユーザーが BNRead コマンド実行する、または @key{<F19>} キーを押す。BufNetRead() 関数か BufNetWrite() 関数が呼び出される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
3. Vim can't find the function and triggers the |FuncUndefined| autocommand
   event.  Since the pattern "BufNet*" matches the invoked function, the
   command "source fname" will be executed.  "fname" will be equal to the name
   of the script, no matter where it is located, because it comes from
   expanding "<sfile>" (see |expand()|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
Vim はその関数を見つけることができず、自動コマンドの |@ref{FuncUndefined}| イベントを発行する。関数名が "BufNet*" というパターンにマッチするので、"source fname" コマンドが実行される。"fname" はスクリプトの名前になります。スクリプトがどこに保存されていても、"<sfile>" が展開されてファイル名になります (|@ref{expand()}|参照)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
4. The script is sourced again, the "s:did_load" variable exists and the
   functions are defined.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item
スクリプトが再び読み込まれる。"s:did_load" 変数が存在するので関数が定義される。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Notice that the functions that are loaded afterwards match the pattern in the
|FuncUndefined| autocommand.  You must make sure that no other plugin defines
functions that match this pattern.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
遅延ロードされる関数の名前が |@ref{FuncUndefined}| 自動コマンドのパターンにマッチしていることに注意してください。他のプラグインがこのパターンにマッチする関数を定義しているとうまく動きません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*41.15*	Writing library scripts			*write-library-script*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{41.15}
@anchor{write-library-script}
@cindex write-library-script
@cindex ライブラリスクリプトを書く
@section ライブラリスクリプトを書く
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Some functionality will be required in several places.  When this becomes more
than a few lines you will want to put it in one script and use it from many
scripts.  We will call that one script a library script.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
いろいろな場所で同じ機能が必要になることがあります。コードが 2、3 行以上になる場合は、それを 1 つのスクリプトに入れて、他のスクリプトから使えるようにしたくなると思います。そのようなスクリプトをライブラリスクリプトと呼びます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Manually loading a library script is possible, so long as you avoid loading it
when it's already done.  You can do this with the |exists()| function.
Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
自分でライブラリスクリプトを読み込むことは可能ですが、同じスクリプトを二重に読み込まないようにする必要があります。それには |@ref{exists()}| 関数を使います。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	if !exists('*MyLibFunction')
	   runtime library/mylibscript.vim
	endif
	call MyLibFunction(arg)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
if !exists('*MyLibFunction')
    runtime library/mylibscript.vim
endif
call MyLibFunction(arg)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here you need to know that MyLibFunction() is defined in a script
"library/mylibscript.vim" in one of the directories in 'runtimepath'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{runtimepath}' に設定されたディレクトリの中の "library/mylibscript.vim" の中で MyLibFunction() が定義されている必要があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To make this a bit simpler Vim offers the autoload mechanism.  Then the
example looks like this: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これをより簡単にするために、Vim には autoload という仕組みがあります。同じことを次のように書くことができます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	call mylib#myfunction(arg)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
call mylib#myfunction(arg)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
That's a lot simpler, isn't it?  Vim will recognize the function name and when
it's not defined search for the script "autoload/mylib.vim" in 'runtimepath'.
That script must define the "mylib#myfunction()" function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この方がずっと簡単でしょう？ Vim は関数の名前を見て、それが未定義なら、'@option{runtimepath}' の中から "autoload/mylib.vim" を探します。そのスクリプトは関数 "mylib#myfunction()" を定義していなければなりません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can put many other functions in the mylib.vim script, you are free to
organize your functions in library scripts.  But you must use function names
where the part before the '#' matches the script name.  Otherwise Vim would
not know what script to load.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
mylib.vim には他の関数も入れられます。ライブラリスクリプトの中では自由に関数を作ることができます。ただし、関数名の '#' より前の部分はスクリプトの名前と同じにする必要があります。そうしないと Vim はどのスクリプトを読み込めばいいのかわかりません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you get really enthusiastic and write lots of library scripts, you may
want to use subdirectories.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ライブラリスクリプトをたくさん書く場合は、サブディレクトリを使うといいかもしれません。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	call netlib#ftp#read('somefile')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
call netlib#ftp#read('somefile')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For Unix the library script used for this could be:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Unix では、このライブラリスクリプトは次のような場所に置かれます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	~/.vim/autoload/netlib/ftp.vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
~/.vim/autoload/netlib/ftp.vim
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Where the function is defined like this: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数は次のように定義します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	function netlib#ftp#read(fname)
		"  Read the file fname through ftp
	endfunction
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
function netlib#ftp#read(fname)
    "  ftp を使ってファイルを読み込む
endfunction
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Notice that the name the function is defined with is exactly the same as the
name used for calling the function.  And the part before the last '#'
exactly matches the subdirectory and script name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数定義と関数呼び出しではまったく同じ名前が使われます。最後の '#' より前の部分がサブディレクトリとスクリプトの名前に対応しています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use the same mechanism for variables: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
同じ方法で変数を扱うこともできます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	let weekdays = dutch#weekdays
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
let weekdays = dutch#weekdays
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This will load the script "autoload/dutch.vim", which should contain something
like: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これによって "autoload/dutch.vim" が読み込まれます。そのスクリプトには例えば次のようなコードが書かれています:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
		\ 'donderdag', 'vrijdag', 'zaterdag']
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
    \ 'donderdag', 'vrijdag', 'zaterdag']
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Further reading: |autoload|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
より詳しくは |@ref{autoload}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
*41.16*	Distributing Vim scripts			*distribute-script*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{41.16}
@anchor{distribute-script}
@cindex distribute-script
@cindex Vim script を配布する
@section Vim script を配布する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim users will look for scripts on the Vim website: http://www.vim.org.
If you made something that is useful for others, share it!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim ユーザーは Vim のウェブサイト @url{http://www.vim.org} でスクリプトを探します。便利なスクリプトを作ったら、ぜひ共有しましょう！
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim scripts can be used on any system.  There might not be a tar or gzip
command.  If you want to pack files together and/or compress them the "zip"
utility is recommended.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim script はどのシステムでも使えます。tar や gzip コマンドは存在しないことがあります。ファイルをまとめたり圧縮したりするには "zip" ユーティリティが推奨されています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For utmost portability use Vim itself to pack scripts together.  This can be
done with the Vimball utility.  See |vimball|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
可搬性を最大限に高めるには、Vim 自身を使ってスクリプトをパッケージ化します。それには Vimball ユーティリティを使います。|@ref{vimball}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It's good if you add a line to allow automatic updating.  See |glvs-plugins|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
自動更新するための行を書いておくと便利です。|@ref{glvs-plugins}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================

Next chapter: |usr_42.txt|  Add new menus

Copyright: see |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
@end ifset
