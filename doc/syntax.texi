@ifset JA  @c ----------- v -----------  JA  -*- tab-width: 8 -*-
@node syntax.txt, , , 目次
@unnumbered 構文強調
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*syntax.txt*	For Vim version 8.1.  Last change: 2018 Apr 30


		  VIM REFERENCE MANUAL	  by Bram Moolenaar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
*syntax.txt*	For Vim バージョン 8.1.  Last change: 2018 Apr 30


		  VIMリファレンスマニュアル    by Bram Moolenaar
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Syntax highlighting		*syntax* *syntax-highlighting* *coloring*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{syntax}
@anchor{syntax-highlighting}
@anchor{coloring}
@cindex syntax
@cindex syntax-highlighting
@cindex coloring
構文ハイライト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Syntax highlighting enables Vim to show parts of the text in another font or
color.	Those parts can be specific keywords or text matching a pattern.  Vim
doesn't parse the whole file (to keep it fast), so the highlighting has its
limitations.  Lexical highlighting might be a better name, but since everybody
calls it syntax highlighting we'll stick with that.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は構文ハイライトによってテキストの一部を別のフォントや色で表示することができる。ハイライトされるテキストは、特定のキーワードや正規表現パターンにマッチするテキストである。動作を速く保つため、ファイル全体を構文解析するわけではないから、このハイライト方法には限界が存在する。単語(レキシカル)ハイライトと呼ぶのがより正しいが、皆が構文ハイライトと呼ぶのでそう呼び続けている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim supports syntax highlighting on all terminals.  But since most ordinary
terminals have very limited highlighting possibilities, it works best in the
GUI version, gvim.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は全ての端末で構文ハイライトをサポートしている。しかし、多くの普通の端末にはごく限られたハイライト手段しか提供されていないので、GUI 版の gvim で動作させたときに見栄えが最もよくなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In the User Manual:
|usr_06.txt| introduces syntax highlighting.
|usr_44.txt| introduces writing a syntax file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザーマニュアルにおける記述:
@multitable @columnfractions .99
@item |@ref{usr_06.txt}| 構文ハイライトの紹介。
@item |@ref{usr_44.txt}| 構文ファイルの記述方法の紹介。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1.  Quick start			|:syn-qstart|
2.  Syntax files		|:syn-files|
3.  Syntax loading procedure	|syntax-loading|
4.  Syntax file remarks		|:syn-file-remarks|
5.  Defining a syntax		|:syn-define|
6.  :syntax arguments		|:syn-arguments|
7.  Syntax patterns		|:syn-pattern|
8.  Syntax clusters		|:syn-cluster|
9.  Including syntax files	|:syn-include|
10. Synchronizing		|:syn-sync|
11. Listing syntax items	|:syntax|
12. Highlight command		|:highlight|
13. Linking groups		|:highlight-link|
14. Cleaning up			|:syn-clear|
15. Highlighting tags		|tag-highlight|
16. Window-local syntax		|:ownsyntax|
17. Color xterms		|xterm-color|
18. When syntax is slow		|:syntime|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .5 .5
@item 1. クイックスタート @tab |@ref{:syn-qstart}|
@item 2. 構文ファイル @tab |@ref{:syn-files}|
@item 3. 構文ファイル読込の手順 @tab |@ref{syntax-loading}|
@item 4. 構文ファイルの覚書 @tab |@ref{:syn-file-remarks}|
@item 5. 構文を定義する @tab |@ref{:syn-define}|
@item 6. :syntax の引数 @tab |@ref{:syn-arguments}|
@item 7. syntax のパターン @tab |@ref{:syn-pattern}|
@item 8. クラスタ @tab |@ref{:syn-cluster}|
@item 9. 構文ファイルのインクルード @tab |@ref{:syn-include}|
@item 10. 表示のシンクロナイズ @tab |@ref{:syn-sync}|
@item 11. 構文アイテムのリストを表示する @tab |@ref{:syntax}|
@item 12. ハイライトコマンド @tab |@ref{:highlight}|
@item 13. グループのリンク @tab |@ref{:highlight-link}|
@item 14. 構文の消去 @tab |@ref{:syn-clear}|
@item 15. 関数名などのハイライト @tab |@ref{tag-highlight}|
@item 16. ウィンドウローカル構文 @tab |@ref{:ownsyntax}|
@item 17. カラー対応 xterm @tab |@ref{xterm-color}|
@item 18. シンタックスが遅い時には @tab |@ref{:syntime}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{Vi does not have any of these commands}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{Vi にはこれらのコマンドはない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Syntax highlighting is not available when the |+syntax| feature has been
disabled at compile time.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コンパイル時に |@ref{+syntax}| 機能を無効にした場合には構文ハイライトは利用することはできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
1. Quick start						*:syn-qstart*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-qstart}
@cindex :syn-qstart
@cindex クイックスタート
@section 1. クイックスタート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:syn-enable* *:syntax-enable*
This command switches on syntax highlighting: >

	:syntax enable
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-enable}
@anchor{:syntax-enable}
@cindex :syn-enable
@cindex :syntax-enable
次のコマンドで構文ハイライトが有効になる:
@example
:syntax enable
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
What this command actually does is to execute the command >
	:source $VIMRUNTIME/syntax/syntax.vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このコマンドにより実際には次のコマンドが実行される
@example
:source $VIMRUNTIME/syntax/syntax.vim
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the VIM environment variable is not set, Vim will try to find
the path in another way (see |$VIMRUNTIME|).  Usually this works just
fine.  If it doesn't, try setting the VIM environment variable to the
directory where the Vim stuff is located.  For example, if your syntax files
are in the "/usr/vim/vim50/syntax" directory, set $VIMRUNTIME to
"/usr/vim/vim50".  You must do this in the shell, before starting Vim.
This command also sources the |menu.vim| script when the GUI is running or
will start soon.  See |'go-M'| about avoiding that.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
環境変数 VIM が設定されていない場合は、Vim は別の方法 (|@ref{$VIMRUNTIME}| 参照) でパスの検索を試みる。通常はこれでうまくいく。うまく動作しない場合は、環境変数 VIM に Vim の構成ファイルが置いてあるディレクトリの設定を試みる。例えば、構文ファイルがディレクトリ "/usr/vim/vim50/syntax" にあるならば、@env{$VIMRUNTIME} に "@var{/usr/vim/vim50}" を設定する。これは Vim を起動する前に、シェルで設定しておかなければならない。

このコマンドは、GUI が実行されている、もしくは間もなく立ち上がる場合、スクリプト |@ref{menu.vim}| の読み込みも行う。これを避けるには |@ref{'go-M'}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:syn-on* *:syntax-on*
The `:syntax enable` command will keep your current color settings.  This
allows using `:highlight` commands to set your preferred colors before or
after using this command.  If you want Vim to overrule your settings with the
defaults, use: >
	:syntax on
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-on}
@anchor{:syntax-on}
@pindex :syn-on
@pindex :syntax-on
コマンド `@command{:syntax enable}` は現在の色設定を変更しない。そのため、このコマンドを使用する前後にコマンド `@command{:highlight}` で好みの色を設定することができる。現在の設定を破棄して、デフォルトの色を設定させたい場合は次のコマンドを使用する:
@example
:syntax on
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*:hi-normal* *:highlight-normal*
If you are running in the GUI, you can get white text on a black background
with: >
	:highlight Normal guibg=Black guifg=White
For a color terminal see |:hi-normal-cterm|.
For setting up your own colors syntax highlighting see |syncolor|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:hi-normal}
@anchor{:highlight-normal}
@pindex :hi-normal
@pindex :highlight-normal
GUI を使用している場合は、次のコマンドで黒地に白文字を設定できる:
@example
:highlight Normal guibg=Black guifg=White
@end example
カラー端末については |@ref{:hi-normal-cterm}| を参照。

自分自身で色を設定する方法については |@ref{syncolor}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
NOTE: The syntax files on MS-DOS and Windows have lines that end in <CR><NL>.
The files for Unix end in <NL>.  This means you should use the right type of
file for your system.  Although on MS-DOS and Windows the right format is
automatically selected if the 'fileformats' option is not empty.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
MS-DOS と Windows の構文ファイルは改行コードが <CR><NL> である。UNIX では <NL> である。自分のシステムに合った改行コードのファイルを使わなければならない。しかし、MS-DOS と Windows ではオプション '@option{fileformats}' が空でなければ正しい形式が自動的に選択される。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
NOTE: When using reverse video ("gvim -fg white -bg black"), the default value
of 'background' will not be set until the GUI window is opened, which is after
reading the |gvimrc|.  This will cause the wrong default highlighting to be
used.  To set the default value of 'background' before switching on
highlighting, include the ":gui" command in the |gvimrc|: >

   :gui		" open window and set default for 'background'
   :syntax on	" start highlighting, use 'background' to set colors
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
反転表示 ("gvim -fg white -bg black") を使用する場合、|@ref{gvimrc}| が読込まれた後、GUI ウィンドウが開かれるまでは '@option{background}' のデフォルト値が設定されない。そのせいで誤ったデフォルトのハイライトが使用されてしまう。ハイライト表示を有効化する前に '@option{background}' のデフォルト値を設定するには、|@ref{gvimrc}| にコマンド "@command{:gui}" を含めればよい:
@multitable @columnfractions .2 .8
@item :gui @tab ウィンドウを開き、'@option{background}' にデフォルト値を設定する
@item :syntax on @tab ハイライトを有効化し、'@option{background}' にもとづいて色を設定する
@end multitable
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
NOTE: Using ":gui" in the |gvimrc| means that "gvim -f" won't start in the
foreground!  Use ":gui -f" then.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
|@ref{.gvimrc}| の中で "@command{:gui}" を使用すると "@command{gvim -f}" によりフォアグラウンドで開始することができなくなる。その際は "@command{:gui -f}" を使用すること。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*g:syntax_on*
You can toggle the syntax on/off with this command: >
   :if exists("g:syntax_on") | syntax off | else | syntax enable | endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:syntax_on}
@vindex g:syntax_on
次のコマンドで構文ハイライトの有効・無効を切換えることができる:
@example
:if exists("g:syntax_on") | syntax off | else | syntax enable | endif
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To put this into a mapping, you can use: >
   :map <F7> :if exists("g:syntax_on") <Bar>
	\   syntax off <Bar>
	\ else <Bar>
	\   syntax enable <Bar>
	\ endif <CR>
[using the |<>| notation, type this literally]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これをキーマップに設定するには、以下のように書く:
@verbatim
:map <F7> :if exists("g:syntax_on") <Bar>
     \   syntax off <Bar>
     \ else <Bar>
     \   syntax enable <Bar>
     \ endif <CR>
@end verbatim
[|@ref{<>}| 記法を用いて全ての文字をそのまま入力すること]
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Details:
The ":syntax" commands are implemented by sourcing a file.  To see exactly how
this works, look in the file:
    command		file ~
    :syntax enable	$VIMRUNTIME/syntax/syntax.vim
    :syntax on		$VIMRUNTIME/syntax/syntax.vim
    :syntax manual	$VIMRUNTIME/syntax/manual.vim
    :syntax off		$VIMRUNTIME/syntax/nosyntax.vim
Also see |syntax-loading|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
詳細

コマンド "@command{:syntax}" はファイルを source することで実装されている。その際に source されるファイルの中身を見れば、このコマンドがどのように動作しているのか正確に知ることができる。
@multitable @columnfractions .4 .6
@headitem コマンド @tab ファイル
@item :syntax enable @tab $VIMRUNTIME/syntax/syntax.vim
@item :syntax on @tab $VIMRUNTIME/syntax/syntax.vim
@item :syntax manual @tab $VIMRUNTIME/syntax/manual.vim
@item :syntax off @tab $VIMRUNTIME/syntax/nosyntax.vim
@end multitable
|@ref{syntax-loading}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
NOTE: If displaying long lines is slow and switching off syntax highlighting
makes it fast, consider setting the 'synmaxcol' option to a lower value.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
長い行があって表示が遅く、構文ハイライトをオフにしたくなるような場合は、'@option{synmaxcol}' をもっと小さい値にすることも考えてみること。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
2. Syntax files						*:syn-files*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-files}
@cindex :syn-files
@cindex 構文ハイライトファイル
@section 2. 構文ハイライトファイル
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The syntax and highlighting commands for one language are normally stored in
a syntax file.	The name convention is: "{name}.vim".  Where {name} is the
name of the language, or an abbreviation (to fit the name in 8.3 characters,
a requirement in case the file is used on a DOS filesystem).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ある 1 つの言語用の構文とハイライト色定義コマンドは通常 1 つのファイル (以下構文ファイル) に格納される。名前は "@{name@}.vim" と付ける慣習になっている。@{name@} はその言語の名前か短縮名となる (DOS ファイルシステムで要求される、8.3 文字の形式にあわせることが望ましい)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Examples:
	c.vim		perl.vim	java.vim	html.vim
	cpp.vim		sh.vim		csh.vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:

c.vim, perl.vim, java.vim, html.vim, cpp.vim, sh.vim, csh.vim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The syntax file can contain any Ex commands, just like a vimrc file.  But
the idea is that only commands for a specific language are included.  When a
language is a superset of another language, it may include the other one,
for example, the cpp.vim file could include the c.vim file: >
   :so $VIMRUNTIME/syntax/c.vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
構文ファイルには、@file{vimrc} ファイルと同様に Ex コマンドを記述できる。しかし 1 つのファイルには、1 つの言語のためのコマンドだけを記述するよう取り決めている。ある言語が別の言語のスーパーセットである時には、他のファイルを内包していても良く、例えば、ファイル @file{cpp.vim} はファイル @file{c.vim} を取り込むようになっている:
@example
:so $VIMRUNTIME/syntax/c.vim
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The .vim files are normally loaded with an autocommand.  For example: >
   :au Syntax c	    runtime! syntax/c.vim
   :au Syntax cpp   runtime! syntax/cpp.vim
These commands are normally in the file $VIMRUNTIME/syntax/synload.vim.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
通常これらの構文ファイルはオートコマンドにより読込まれる。例:
@example
:au Syntax c     runtime! syntax/c.vim
:au Syntax cpp   runtime! syntax/cpp.vim
@end example
このようなコマンドはファイル $VIMRUNTIME/syntax/synload.vim に書かれている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MAKING YOUR OWN SYNTAX FILES				*mysyntaxfile*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{mysyntaxfile}
@cindex mysyntaxfile
@cindex 独自構文ファイルの作成
@unnumberedsubsec 独自構文ファイルの作成
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you create your own syntax files, and you want to have Vim use these
automatically with ":syntax enable", do this:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
独自の構文ファイルを作成し、"@option{:syntax enable}" をしたとき自動的にそのファイルが使われるようにするには、以下のようにする:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. Create your user runtime directory.	You would normally use the first item
   of the 'runtimepath' option.  Example for Unix: >
	mkdir ~/.vim

2. Create a directory in there called "syntax".  For Unix: >
	mkdir ~/.vim/syntax

3. Write the Vim syntax file.  Or download one from the internet.  Then write
   it in your syntax directory.  For example, for the "mine" syntax: >
	:w ~/.vim/syntax/mine.vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item ユーザーランタイムディレクトリを作成する。通常はオプション '@option{runtimepath}' に示される最初のディレクトリを使用する。UNIX の例では:
@example
mkdir ~/.vim
@end example
@item "syntax" という名のディレクトリを作成する。UNIX では:
@example
mkdir ~/.vim/syntax
@end example
@item Vim の構文ファイルを作成する。もしくはインターネットからダウンロードする。そのファイルはディレクトリ syntax に置く。構文 "mine" の例では:
@example
:w ~/.vim/syntax/mine.vim
@end example
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now you can start using your syntax file manually: >
	:set syntax=mine
You don't have to exit Vim to use this.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これで独自構文ファイルを手動で使うことはできるようになっている:
@example
:set syntax=mine
@end example
このコマンドを実行するためにVimを再起動する必要はない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you also want Vim to detect the type of file, see |new-filetype|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このファイルタイプが認識されるようにするには、|@ref{new-filetype}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you are setting up a system with many users and you don't want each user
to add the same syntax file, you can use another directory from 'runtimepath'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
システム管理者としてユーザー全てに独自構文ファイルを使わせるには、各ユーザーに同じ構文ファイルをインストールさせる必要はなく、全ユーザー共通の '@option{runtimepath}' ディレクトリにインストールすればよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ADDING TO AN EXISTING SYNTAX FILE		*mysyntaxfile-add*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{mysyntaxfile-add}
@cindex mysyntaxfile-add
@cindex 既存の構文ファイルに設定を追加する
@unnumberedsec 既存の構文ファイルに設定を追加する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you are mostly satisfied with an existing syntax file, but would like to
add a few items or change the highlighting, follow these steps:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
既存の構文ファイルでほぼ満足だが、いくつかの設定を追加したりハイライト手法を変更したい場合には、以下の手順に従う:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. Create your user directory from 'runtimepath', see above.

2. Create a directory in there called "after/syntax".  For Unix: >
	mkdir ~/.vim/after
	mkdir ~/.vim/after/syntax

3. Write a Vim script that contains the commands you want to use.  For
   example, to change the colors for the C syntax: >
	highlight cComment ctermfg=Green guifg=Green

4. Write that file in the "after/syntax" directory.  Use the name of the
   syntax, with ".vim" added.  For our C syntax: >
	:w ~/.vim/after/syntax/c.vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item 上同様、'@option{runtimepath}' に示されるユーザーディレクトリを作成する。
@item "after/syntax" というディレクトリを作成する。UNIX の例:
@example
mkdir ~/.vim/after
mkdir ~/.vim/after/syntax
@end example
@item 追加設定を行うコマンドを含む Vim script ファイルを作成する。例として、C 言語のコメントの色を変更するには:
@example
highlight cComment ctermfg=Green guifg=Green
@end example
@item その設定ファイルをディレクトリ "after/syntax" に置く。名前には構文名に ".vim" を追加して使用する。C の構文を拡張するならば:
@example
:w ~/.vim/after/syntax/c.vim
@end example
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
That's it.  The next time you edit a C file the Comment color will be
different.  You don't even have to restart Vim.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以上。次回Cのファイルを編集する時にはコメントが異なった色で表示される。Vim を再起動する必要はない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you have multiple files, you can use the filetype as the directory name.
All the "*.vim" files in this directory will be used, for example:
	~/.vim/after/syntax/c/one.vim
	~/.vim/after/syntax/c/two.vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
構文ファイルが複数になるときは、ファイルタイプの名前のディレクトリに置くとよい。そのディレクトリの中の全ての "*.vim" ファイルが読み込まれるようになる。例:
@example
~/.vim/after/syntax/c/one.vim
~/.vim/after/syntax/c/two.vim
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
REPLACING AN EXISTING SYNTAX FILE			*mysyntaxfile-replace*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{mysyntaxfile-replace}
@cindex mysyntaxfile-replace
@cindex 既存の構文ファイルを置き換える
@unnumberedsubsec 既存の構文ファイルを置き換える
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you don't like a distributed syntax file, or you have downloaded a new
version, follow the same steps as for |mysyntaxfile| above.  Just make sure
that you write the syntax file in a directory that is early in 'runtimepath'.
Vim will only load the first syntax file found, assuming that it sets
b:current_syntax.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
標準の構文ファイルが気に入らない場合や、新しいバージョンをダウンロードした際には、上で述べた |@ref{mysyntaxfile}| に従えば良い。ただ '@option{runtimepath}' で、前の方に記されたディレクトリに構文ファイルを置くように気をつければ良い。Vim は適合する構文ファイルのうち最初に見つけた 1 つだけを読込む (それが b:current_syntax を設定すると想定している)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
NAMING CONVENTIONS		    *group-name* *{group-name}* *E669* *W18*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{group-name}
@anchor{@{group-name@}}
@anchor{E669}
@anchor{W18}
@cindex group-name
@cindex @{group-name@}
@erindex E669
@erindex W18
@cindex 名前付けの慣習
@unnumberedsubsec 名前付けの慣習
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A syntax group name is to be used for syntax items that match the same kind of
thing.  These are then linked to a highlight group that specifies the color.
A syntax group name doesn't specify any color or attributes itself.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
構文グループとは、同じ種類の構文アイテムをグループ化したものである。構文グループから強調グループにリンクされ、強調グループに対して色が設定される。構文グループそれ自体は、色や属性を指定するものではない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The name for a highlight or syntax group must consist of ASCII letters, digits
and the underscore.  As a regexp: "[a-zA-Z0-9_]*".  However, Vim does not give
an error when using other characters.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ハイライトや構文グループの名前は ASCII 文字、数字、アンダースコアだけでつけなければならない。正規表現では: "[a-zA-Z0-9_]*"  しかしそれ以外の文字を使っても Vim はエラーを出力しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To be able to allow each user to pick his favorite set of colors, there must
be preferred names for highlight groups that are common for many languages.
These are the suggested group names (if syntax highlighting works properly
you can see the actual color, except for "Ignore"):
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
各ユーザーが好みの色セットを使用できるように、多くの言語に共通するハイライトグループには優先名が与えられている。推奨されているグループ名は以下のとおり (構文ハイライトがちゃんと機能していれば、"Ignore" 以外はそのグループに設定された色で表示されるだろう):
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	*Comment	any comment
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item *Comment @tab コメント
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	*Constant	any constant
	 String		a string constant: "this is a string"
	 Character	a character constant: 'c', '\n'
	 Number		a number constant: 234, 0xff
	 Boolean	a boolean constant: TRUE, false
	 Float		a floating point constant: 2.3e10
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item *Constant @tab 定数
@item String @tab 文字列定数: "これは文字列です"
@item Character @tab 文字定数: 'c', '\n'
@item Number @tab 数値定数: 234, 0xff
@item Boolean @tab ブール値の定数: TRUE, false
@item Float @tab 浮動小数点数の定数: 2.3e10
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	*Identifier	any variable name
	 Function	function name (also: methods for classes)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item *Identifier @tab 変数名
@item Function @tab 関数名(クラスメソッドを含む)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	*Statement	any statement
	 Conditional	if, then, else, endif, switch, etc.
	 Repeat		for, do, while, etc.
	 Label		case, default, etc.
	 Operator	"sizeof", "+", "*", etc.
	 Keyword	any other keyword
	 Exception	try, catch, throw
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item *Statement @tab 命令文
@item Conditional @tab if, then, else, endif, switch, その他
@item Repeat @tab for, do, while, その他
@item Label @tab case, default, その他
@item Operator @tab "sizeof", "+", "*", その他
@item Keyword @tab その他のキーワード
@item Exception @tab try, catch, throw
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	*PreProc	generic Preprocessor
	 Include	preprocessor #include
	 Define		preprocessor #define
	 Macro		same as Define
	 PreCondit	preprocessor #if, #else, #endif, etc.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item *PreProc @tab 一般的なプリプロセッサー命令
@item Include @tab #include プリプロセッサー
@item Define @tab #define プリプロセッサー
@item Macro @tab Defineと同値
@item PreCondit @tab プリプロセッサーの #if, #else, #endif, その他
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	*Type		int, long, char, etc.
	 StorageClass	static, register, volatile, etc.
	 Structure	struct, union, enum, etc.
	 Typedef	A typedef
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item *Type @tab int, long, char, その他
@item StorageClass @tab static, register, volatile, その他
@item Structure @tab struct, union, enum, その他
@item Typedef @tab typedef 宣言
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	*Special	any special symbol
	 SpecialChar	special character in a constant
	 Tag		you can use CTRL-] on this
	 Delimiter	character that needs attention
	 SpecialComment	special things inside a comment
	 Debug		debugging statements
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item *Special @tab 特殊なシンボル
@item SpecialChar @tab 特殊な文字定数
@item Tag @tab この上で @kbd{CTRL-]} を使うことができる
@item Delimiter @tab 注意が必要な文字
@item SpecialComment @tab コメント内の特記事項
@item Debug @tab デバッグ命令
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	*Underlined	text that stands out, HTML links
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item *Underlined @tab 目立つ文章, HTMLリンク
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	*Ignore		left blank, hidden  |hl-Ignore|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item *Ignore @tab (見た目上) 空白, 不可視 |@ref{hl-Ignore}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	*Error		any erroneous construct
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item *Error @tab エラーなど、なんらかの誤った構造
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	*Todo		anything that needs extra attention; mostly the
			keywords TODO FIXME and XXX
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @  @tab
@item *Todo @tab 特別な注意が必要なもの; 大抵は TODO FIXME XXX などのキーワード
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The names marked with * are the preferred groups; the others are minor groups.
For the preferred groups, the "syntax.vim" file contains default highlighting.
The minor groups are linked to the preferred groups, so they get the same
highlighting.  You can override these defaults by using ":highlight" commands
after sourcing the "syntax.vim" file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マーク (*) されている名前が優先グループ、その他はマイナーグループである。優先グループには、"syntax.vim" によりデフォルトのハイライト手法が定義されている。マイナーグループは優先グループにリンクされ、リンクした先と同じハイライト手法になる。ファイル "syntax.vim" が読込まれた後でコマンド "@command{:highlight}" を使えば、そのデフォルトを上書することができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that highlight group names are not case sensitive.  "String" and "string"
can be used for the same group.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ハイライトグループ名には大文字小文字の区別がないことに注意。"String" と "string" はどちらも同じグループを意味する。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The following names are reserved and cannot be used as a group name:
	NONE   ALL   ALLBUT   contains	 contained
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下の名前は予約されているのでグループ名として使用することはできない:
NONE, ALL, ALLBUT, contains, contained
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*hl-Ignore*
When using the Ignore group, you may also consider using the conceal
mechanism.  See |conceal|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-Ignore}
@cindex hl-Ignore
Ignore グループを使うときは、conceal 機能も使うと便利かもしれない。|@ref{conceal}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
3. Syntax loading procedure				*syntax-loading*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{syntax-loading}
@cindex syntax-loading
@cindex 構文ファイル読込の手順
@section 3. 構文ファイル読込の手順
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This explains the details that happen when the command ":syntax enable" is
issued.  When Vim initializes itself, it finds out where the runtime files are
located.  This is used here as the variable |$VIMRUNTIME|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここではコマンド "@command{:syntax enable}" を実行した時に何が起こるかの詳細を説明する。Vim は初期化の時に、ランタイムファイルの在り処を自動的に発見する。ここでは変数 |@ref{$VIMRUNTIME}| にその場所が格納されているとする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
":syntax enable" and ":syntax on" do the following:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex "@command{:syntax enable}" と "@command{:syntax on}" では以下のことが起こる
@unnumberedsubsec "@command{:syntax enable}" と "@command{:syntax on}" では以下のことが起こる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
    Source $VIMRUNTIME/syntax/syntax.vim
    |
    +-	Clear out any old syntax by sourcing $VIMRUNTIME/syntax/nosyntax.vim
    |
    +-	Source first syntax/synload.vim in 'runtimepath'
    |	|
    |	+-  Setup the colors for syntax highlighting.  If a color scheme is
    |	|   defined it is loaded again with ":colors {name}".  Otherwise
    |	|   ":runtime! syntax/syncolor.vim" is used.  ":syntax on" overrules
    |	|   existing colors, ":syntax enable" only sets groups that weren't
    |	|   set yet.
    |	|
    |	+-  Set up syntax autocmds to load the appropriate syntax file when
    |	|   the 'syntax' option is set. *synload-1*
    |	|
    |	+-  Source the user's optional file, from the |mysyntaxfile| variable.
    |	    This is for backwards compatibility with Vim 5.x only. *synload-2*
    |
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize @bullet
@item $VIMRUNTIME/syntax/@file{syntax.vim} を読込む
@itemize
@item $VIMRUNTIME/syntax/@file{nosyntax.vim} を読込んで古い構文を削除する
@item '@option{runtimepath}' から syntax/@file{synload.vim} を読込む
@itemize
@item 構文ハイライトの色を設定する。@* カラースキームが定義されている場合は "@command{:colors @{name@}}" で再度読込む。@* そうでない場合は "@command{:runtime! syntax/syncolor.vim}" が使用される。@* "@command{:syntax on}" は既存の色設定を上書設定し、"@command{:syntax enable}" はまだ設定されていないグループのみを設定する。
@item 適切な構文ファイルをオプション '@option{syntax}' が設定される時に読込む自動実行コマンドを設定する。
@anchor{synload-1}
@cindex synload-1
@item ユーザーによる追加ファイルを変数 |@ref{mysyntaxfile}| から読込む。これは Vim 5.x との互換性のためだけに存在する。
@anchor{synload-2}
@cindex synload-2
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    +-	Do ":filetype on", which does ":runtime! filetype.vim".  It loads any
    |	filetype.vim files found.  It should always Source
    |	$VIMRUNTIME/filetype.vim, which does the following.
    |	|
    |	+-  Install autocmds based on suffix to set the 'filetype' option
    |	|   This is where the connection between file name and file type is
    |	|   made for known file types. *synload-3*
    |	|
    |	+-  Source the user's optional file, from the *myfiletypefile*
    |	|   variable.  This is for backwards compatibility with Vim 5.x only.
    |	|   *synload-4*
    |	|
    |	+-  Install one autocommand which sources scripts.vim when no file
    |	|   type was detected yet. *synload-5*
    |	|
    |	+-  Source $VIMRUNTIME/menu.vim, to setup the Syntax menu. |menu.vim|
    |
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "@command{:filetype on}" を実行し "@command{:runtime! filetype.vim}" が実行される。これは見つけることのできる全ての @file{filetype.vim} を読込む。$VIMRUNTIME/@file{filetype.vim} は常に読込まれ、以下のことが実行される。
@itemize
@item 拡張子に基づいてオプション '@option{filetype}' を設定するオートコマンドをインストールする。これにより既知のファイル形式に付いて、ファイル名と当該形式との関連付けが成される。
@anchor{synload-3}
@cindex synload-3
@anchor{myfiletypefile}
@cindex myfiletypefile
@item ユーザーによる追加ファイルを変数 @env{myfiletypefile} から読込む。これは Vim 5.x との互換性のためだけに存在する。
@anchor{synload-4}
@cindex synload-4
@item ファイル形式が検出されなかった時に @file{scripts.vim} を読込むための自動実行コマンドをインストールする。
@anchor{synload-5}
@cindex synload-5
@item 構文メニュー設定のため $VIMRUNTIME/@file{menu.vim}を読込む。|@ref{menu.vim}|
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    +-	Install a FileType autocommand to set the 'syntax' option when a file
    |	type has been detected. *synload-6*
    |
    +-	Execute syntax autocommands to start syntax highlighting for each
	already loaded buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{synload-6}
@cindex synload-6
@item ファイル形式が検出された時にオプション '@option{syntax}' を設定するための FileType オートコマンドを設定する。
@item 既に読込まれているバッファに対して構文ハイライトを行うために、関連したオートコマンドを実行する。
@end itemize
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Upon loading a file, Vim finds the relevant syntax file as follows:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex ファイルを読込む時には、Vim は以下のように関連した構文ファイルを見つける
@unnumberedsubsec ファイルを読込む時には、Vim は以下のように関連した構文ファイルを見つける:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
    Loading the file triggers the BufReadPost autocommands.
    |
    +-	If there is a match with one of the autocommands from |synload-3|
    |	(known file types) or |synload-4| (user's file types), the 'filetype'
    |	option is set to the file type.
    |
    +-	The autocommand at |synload-5| is triggered.  If the file type was not
    |	found yet, then scripts.vim is searched for in 'runtimepath'.  This
    |	should always load $VIMRUNTIME/scripts.vim, which does the following.
    |	|
    |	+-  Source the user's optional file, from the *myscriptsfile*
    |	|   variable.  This is for backwards compatibility with Vim 5.x only.
    |	|
    |	+-  If the file type is still unknown, check the contents of the file,
    |	    again with checks like "getline(1) =~ pattern" as to whether the
    |	    file type can be recognized, and set 'filetype'.
    |
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize @bullet
@item ファイルを読込むと BufReadPost オートコマンドが起動する。
@itemize
@item |@ref{synload-3}| (既知ファイル形式) か |@ref{synload-4}| (ユーザー定義ファイル形式) の自動実行コマンドがヒットした場合、オプション '@option{filetype}' にそのファイル形式名が設定される。
@item |@ref{synload-5}| のオートコマンドが実行される。まだファイル形式が決定されていない場合は、'@option{runtimepath}' から @file{scripts.vim} が検索される。これは常に以下のことを行う $VIMRUNTIME/@file{scripts.vim} を読込む。
@itemize
@item ユーザーによる追加ファイルを変数 *myscriptsfile* から読込む。これは Vim 5.x との互換性のためだけに存在する。
@item 未だにファイル形式が決定できない場合、ファイルの内容を検査する。検査は "getline(1) =~ pattern" のように認識できるファイル形式かどうか行われ、認識できるならば '@option{filetype}' を設定する。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    +-	When the file type was determined and 'filetype' was set, this
    |	triggers the FileType autocommand |synload-6| above.  It sets
    |	'syntax' to the determined file type.
    |
    +-	When the 'syntax' option was set above, this triggers an autocommand
    |	from |synload-1| (and |synload-2|).  This find the main syntax file in
    |	'runtimepath', with this command:
    |		runtime! syntax/<name>.vim
    |
    +-	Any other user installed FileType or Syntax autocommands are
	triggered.  This can be used to change the highlighting for a specific
	syntax.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ファイル形式が決定されて '@option{filetype}' が設定された時に、上記 |@ref{synload-6}| の FileType オートコマンドが実行される。決定したファイル形式名がそれにより '@option{syntax}' へ設定される。
@item 上記でオプション '@option{syntax}' が設定されると、|@ref{synload-1}| (と |@ref{synload-2}|) の自動実行コマンドが実行される。これにより次のコマンドでメインとなる構文ファイルが '@option{runtimepath}' から読込まれる。
@example
runtime! syntax/<name>.vim
@end example
@item ユーザーがインストールしたその他の FileType および Syntax オートコマンドが実行される。これは特定の構文のハイライトを変更するのに使うことができる。
@end itemize
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
4. Syntax file remarks					*:syn-file-remarks*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-file-remarks}
@cindex :syn-file-remarks
@cindex 構文ファイルの覚書
@section 4. 構文ファイルの覚書
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*b:current_syntax-variable*
Vim stores the name of the syntax that has been loaded in the
"b:current_syntax" variable.  You can use this if you want to load other
settings, depending on which syntax is active.	Example: >
   :au BufReadPost * if b:current_syntax == "csh"
   :au BufReadPost *   do-some-things
   :au BufReadPost * endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{b:current_syntax-variable}
@cindex b:current_syntax-variable
Vim はロードした構文の名前を変数 "b:current_syntax" に記憶している。ある構文が有効な場合だけある設定を行うにはこの変数が利用できる。例:
@example
:au BufReadPost * if b:current_syntax == "csh"
:au BufReadPost *   do-some-things
:au BufReadPost * endif
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
2HTML						*2html.vim* *convert-to-HTML*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{2html.vim}
@anchor{convert-to-HTML}
@cindex 2html.vim
@cindex convert-to-HTML
@cindex 2HTML
@unnumberedsubsec 2HTML
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This is not a syntax file itself, but a script that converts the current
window into HTML. Vim opens a new window in which it builds the HTML file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは構文ファイルではなくて、現在のウィンドウの内容を HTML に変換するスクリプトである。Vim は新しいウィンドウを作成しそこに HTML ファイルを構築する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
After you save the resulting file, you can view it with any browser. The
colors should be exactly the same as you see them in Vim.  With
|g:html_line_ids| you can jump to specific lines by adding (for example) #L123
or #123 to the end of the URL in your browser's address bar. And with
|g:html_dynamic_folds| enabled, you can show or hide the text that is folded
in Vim.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変換結果を保存すればブラウザーでそれを表示できる。Vim での表示と同じ色で表示されるはずである。|@ref{g:html_line_ids}| を有効化すると、ブラウザーのアドレスバーで URL の末尾に (例えば) #L123 や #123 と付け加えることで、その行にジャンプできる。また、|@ref{g:html_dynamic_folds}| を有効化すると、Vim の折り畳みを表示したり隠したりできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You are not supposed to set the 'filetype' or 'syntax' option to "2html"!
Source the script to convert the current file: >

	:runtime! syntax/2html.vim
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
使う際にはオプション '@option{filetype}' や '@option{syntax}' に "@var{2html}" を設定してはならない！現在のファイルをコンバートするためにはこのスクリプトを読込む:
@example
:runtime! syntax/2html.vim
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Many variables affect the output of 2html.vim; see below. Any of the on/off
options listed below can be enabled or disabled by setting them explicitly to
the desired value, or restored to their default by removing the variable using
|:unlet|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2html.vim に影響する変数はたくさんある。下記参照。下記の on/off オプションは指定された値を明示的に設定することで有効化/無効化できる。また、|@ref{:unlet}| で変数を削除することで初期設定に戻すことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Remarks:
- Some truly ancient browsers may not show the background colors.
- From most browsers you can also print the file (in color)!
- The latest TOhtml may actually work with older versions of Vim, but some
  features such as conceal support will not function, and the colors may be
  incorrect for an old Vim without GUI support compiled in.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec 覚書き:
@itemize
@item いくつかの本当に古いブラウザーでは背景色が表示されないことがある。
@item 大半のブラウザーでは (なんとカラーで) 印刷することができる！
@item このバージョンの TOhtml はおそらく古い Vim でも動作するが、例えば conceal サポートのようないくつかの機能は動作しない。また、GUI サポート無しでコンパイルされた古い Vim では色がおかしくなるかもしれない。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here is an example how to run the script over all .c and .h files from a
Unix shell: >
   for f in *.[ch]; do gvim -f +"syn on" +"run! syntax/2html.vim" +"wq" +"q" $f; done
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば次の Unix シェルスクリプトですべての .c と .h ファイルを変換できる:
@example
for f in *.[ch]; do gvim -f +"syn on" +"run! syntax/2html.vim" +"wq" +"q" $f; done
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*g:html_start_line* *g:html_end_line*
To restrict the conversion to a range of lines, use a range with the |:TOhtml|
command below, or set "g:html_start_line" and "g:html_end_line" to the first
and last line to be converted.  Example, using the last set Visual area: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_start_line}
@anchor{g:html_end_line}
@vindex g:html_start_line
@vindex g:html_end_line
変換の範囲を指定するには、|@ref{:TOhtml}| コマンドに範囲を指定するか、"g:html_start_line" と "g:html_end_line" に変換したい範囲の最初と最後の行を設定する。例えば、最後に選択された範囲だけを変換するには:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let g:html_start_line = line("'<")
	:let g:html_end_line = line("'>")
	:runtime! syntax/2html.vim
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:let g:html_start_line = line("'<")
:let g:html_end_line = line("'>")
:runtime! syntax/2html.vim
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:TOhtml*
:[range]TOhtml		The ":TOhtml" command is defined in a standard plugin.
			This command will source |2html.vim| for you. When a
			range is given, this command sets |g:html_start_line|
			and |g:html_end_line| to the start and end of the
			range, respectively. Default range is the entire
			buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{:TOhtml}
@pindex :TOhtml
@item :[range]TOhtml
"@command{:TOhtml}" コマンドは標準プラグインで定義されている。このコマンドは |@ref{2html.vim}| を実行する。範囲が指定された場合は |@ref{g:html_start_line}| と |@ref{g:html_end_line}| をその範囲に設定する。範囲省略時はファイル全体が対象となる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			If the current window is part of a |diff|, unless
			|g:html_diff_one_file| is set, :TOhtml will convert
			all windows which are part of the diff in the current
			tab and place them side-by-side in a <table> element
			in the generated HTML. With |g:html_line_ids| you can
			jump to lines in specific windows with (for example)
			#W1L42 for line 42 in the first diffed window, or
			#W3L87 for line 87 in the third.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もしカレントウィンドウが |@ref{diff}| の一部で、|@ref{g:html_diff_one_file}| が設定されていない場合、:TOhtml はカレントタブ内の diff を表示しているすべてのウィンドウを変換して <table> 要素で並べた HTML を生成する。|@ref{g:html_line_ids}| が有効なら、(例えば) #W1L42 で 1 番目のウィンドウの 42 行目、#W3L87 で 3 番目の 87 行目にジャンプできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			Examples: >

	:10,40TOhtml " convert lines 10-40 to html
	:'<,'>TOhtml " convert current/last visual selection
	:TOhtml      " convert entire buffer
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@verbatim
:10,40TOhtml " convert lines 10-40 to html
:'<,'>TOhtml " convert current/last visual selection
:TOhtml      " convert entire buffer
@end verbatim
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*g:html_diff_one_file*
Default: 0.
When 0, and using |:TOhtml| all windows involved in a |diff| in the current tab
page are converted to HTML and placed side-by-side in a <table> element. When
1, only the current buffer is converted.
Example: >

	let g:html_diff_one_file = 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{g:html_diff_one_file}
@vindex g:html_diff_one_file
@item g:html_diff_one_file
初期設定: 0

0 なら、|@ref{:TOhtml}| を使うとカレントタブ内の |@ref{diff}| を表示しているすべてのウィンドウが変換され、<table> 要素で並べられた HTML が生成される。1 なら、カレントバッファのみが変換される。

例:
@example
let g:html_diff_one_file = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							 *g:html_whole_filler*
Default: 0.
When 0, if |g:html_diff_one_file| is 1, a sequence of more than 3 filler lines
is displayed as three lines with the middle line mentioning the total number
of inserted lines.
When 1, always display all inserted lines as if |g:html_diff_one_file| were
not set.
>
    :let g:html_whole_filler = 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_whole_filler}
@vindex g:html_whole_filler
@item g:html_whole_filler
初期設定: 0

0 なら、もし |@ref{g:html_diff_one_file}| が 1 なら、3 行以上の連続した詰め行は 3 行で表示され、真ん中の行に挿入された行数の合計が表示される。1 なら |@ref{g:html_diff_one_file}| が設定されていないときのように、常に挿入された行が表示される。
@example
:let g:html_whole_filler = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
				     *TOhtml-performance* *g:html_no_progress*
Default: 0.
When 0, display a progress bar in the statusline for each major step in the
2html.vim conversion process.
When 1, do not display the progress bar. This offers a minor speed improvement
but you won't have any idea how much longer the conversion might take; for big
files it can take a long time!
Example: >

	let g:html_no_progress = 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{TOhtml-performance}
@anchor{g:html_no_progress}
@cindex TOhtml-performance
@vindex g:html_no_progress
@item g:html_no_progress
初期設定: 0

0 なら、@file{2html.vim} の変換過程の各段階で進行状況のプログレスバーをステータスラインに表示する。1 なら、プログレスバーを表示しない。若干スピードは速くなるが、変換がいつごろ終わるかを知ることはできない。大きなファイルならとても時間がかかるのに！

例:
@example
let g:html_no_progress = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
You can obtain better performance improvements by also instructing Vim to not
run interactively, so that too much time is not taken to redraw as the script
moves through the buffer, switches windows, and the like: >

  vim -E -s -c "let g:html_no_progress=1" -c "syntax on" -c "set ft=c" -c "runtime syntax/2html.vim" -cwqa myfile.c
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim を非対話で実行すれば、スクリプトでバッファやウィンドウなどを走査するごとに表示を更新しなくてもよくなるので、速度はもっと速くなる:
@example
vim -E -s -c "let g:html_no_progress=1" -c "syntax on" -c "set ft=c" -c "runtime syntax/2html.vim" -cwqa myfile.c
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Note that the -s flag prevents loading your .vimrc and any plugins, so you
need to explicitly source/enable anything that will affect the HTML
conversion. See |-E| and |-s-ex| for details. It is probably best to create a
script to replace all the -c commands and use it with the -u flag instead of
specifying each command separately.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
-s フラグは @file{.vimrc} とプラグインの読み込みを抑制する。したがって、HTML 変換に必要な設定などは明示的に読み込まなければならない。詳細は |@ref{-E}| と |@ref{-s-ex}| を参照。このように各コマンドを指定して実行するよりは、上記の -c で設定しているようなことがらをすべてスクリプトファイルに書き込み、-u フラグで読み込んで実行するといいだろう。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							 *g:html_number_lines*
Default: current 'number' setting.
When 0, buffer text is displayed in the generated HTML without line numbering.
When 1, a column of line numbers is added to the generated HTML with the same
highlighting as the line number column in Vim (|hl-LineNr|).
Force line numbers even if 'number' is not set: >
   :let g:html_number_lines = 1
Force to omit the line numbers: >
   :let g:html_number_lines = 0
Go back to the default to use 'number' by deleting the variable: >
   :unlet g:html_number_lines
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_number_lines}
@vindex g:html_number_lines
@item g:html_number_lines
初期設定: 現在の '@option{number}' の設定

0 なら、バッファのテキストは行番号なしで HTML に表示される。1 なら、生成される HTML に行番号が付加される。色は Vim の行番号表示と同じ (|@ref{hl-LineNr}|)。

'@option{number}' がオフでも強制的に行番号を表示するなら:
@example
:let g:html_number_lines = 1
@end example
強制的に行番号を表示しないようにするなら:
@example
:let g:html_number_lines = 0
@end example
'@option{number}' の設定に従うように戻すには:
@example
:unlet g:html_number_lines
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
                                                             *g:html_line_ids*
Default: 1 if |g:html_number_lines| is set, 0 otherwise.
When 1, adds an HTML id attribute to each line number, or to an empty <span>
inserted for that purpose if no line numbers are shown. This ID attribute
takes the form of L123 for single-buffer HTML pages, or W2L123 for diff-view
pages, and is used to jump to a specific line (in a specific window of a diff
view). Javascript is inserted to open any closed dynamic folds
(|g:html_dynamic_folds|) containing the specified line before jumping. The
javascript also allows omitting the window ID in the url, and the leading L.
For example: >

	page.html#L123	jumps to line 123 in a single-buffer file
	page.html#123	does the same

	diff.html#W1L42	jumps to line 42 in the first window in a diff
	diff.html#42	does the same
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_line_ids}
@vindex g:html_line_ids
@item g:html_line_ids
初期設定: 1。|@ref{g:html_number_lines}| が設定されていないときは 0。

この設定が 1 なら、各行番号に HTML の id 属性を付ける。行番号が表示されていないときは空の <span> 要素を挿入して id を付ける。この ID 属性は、HTML が単一のバッファから生成されたときは L123 のような形になる。diff 表示から生成されたときは W2L123 のような形になる。これを使って (特定の diff ウィンドウの) 特定の行にジャンプできる。指定された行にジャンプする前にその行の折り畳みを開くための JavaScript が挿入される (|@ref{g:html_dynamic_folds}|)。JavaScript はウィンドウ ID や行番号前の L を省略できる機能も提供する。

例:
@verbatim
page.html#L123	単一バッファファイルの 123 行目にジャンプ
page.html#123	同上

diff.html#W1L42	diff の 1 番目のウィンドウの 42 行目にジャンプ
diff.html#42	同上
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							      *g:html_use_css*
Default: 1.
When 1, generate valid HTML 4.01 markup with CSS1 styling, supported in all
modern browsers and most old browsers.
When 0, generate <font> tags and similar outdated markup. This is not
recommended but it may work better in really old browsers, email clients,
forum posts, and similar situations where basic CSS support is unavailable.
Example: >
   :let g:html_use_css = 0
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_use_css}
@vindex g:html_use_css
@item g:html_use_css
初期設定: 1

1 なら、CSS1 で装飾された HTML 4.01 準拠の HTML が生成される。最新のブラウザーとほとんどの古いブラウザーでサポートされている。0 なら、<font> タグで装飾された時代遅れの HTML が生成される。これは推奨されていないが、古いブラウザー、あるいはメーラーや掲示板の投稿など、CSS が使えない場合には必要だろう。

例:
@example
:let g:html_use_css = 0
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						       *g:html_ignore_conceal*
Default: 0.
When 0, concealed text is removed from the HTML and replaced with a character
from |:syn-cchar| or 'listchars' as appropriate, depending on the current
value of 'conceallevel'.
When 1, include all text from the buffer in the generated HTML, even if it is
|conceal|ed.

Either of the following commands will ensure that all text in the buffer is
included in the generated HTML (unless it is folded): >
   :let g:html_ignore_conceal = 1
   :setl conceallevel=0
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_ignore_conceal}
@vindex g:html_ignore_conceal
@item g:html_ignore_conceal
初期設定: 0

0 なら、Conceal されたテキストは HTML には表示されず、'@option{conceallevel}' の現在の設定に応じて |@ref{:syn-cchar}| や '@option{listchars}' の文字が代わりに表示される。1 なら、Conceal されていてもされていなくても、すべてのテキストが HTML に表示される。

次のコマンドでバッファ内のすべてのテキストを HTML に表示することができる (折り畳まれて |@ref{conceal}| なければ):
@example
:let g:html_ignore_conceal = 1
:setl conceallevel=0
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						       *g:html_ignore_folding*
Default: 0.
When 0, text in a closed fold is replaced by the text shown for the fold in
Vim (|fold-foldtext|). See |g:html_dynamic_folds| if you also want to allow
the user to expand the fold as in Vim to see the text inside.
When 1, include all text from the buffer in the generated HTML; whether the
text is in a fold has no impact at all. |g:html_dynamic_folds| has no effect.

Either of these commands will ensure that all text in the buffer is included
in the generated HTML (unless it is concealed): >
   zR
   :let g:html_ignore_folding = 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_ignore_folding}
@vindex g:html_ignore_folding
@item g:html_ignore_folding
初期設定: 0

0 なら、折り畳みで閉じられたテキストは Vim で折り畳み表示されているテキストに置き換えられる (|@ref{fold-foldtext}|)。Vim で折り畳みを開けるのと同じように、HTML でも開けるようにしたい場合は |@ref{g:html_dynamic_folds}| を参照。1 なら、バッファのすべてのテキストを HTML に含める。テキストが折り畳まれているかどうかは無視される。|@ref{g:html_dynamic_folds}| は機能しない。

次のコマンドでバッファ内のすべてのテキストを HTML に表示することができる (Conceal されてなければ):
@example
zR
:let g:html_ignore_folding = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*g:html_dynamic_folds*
Default: 0.
When 0, text in a closed fold is not included at all in the generated HTML.
When 1, generate javascript to open a fold and show the text within, just like
in Vim.

Setting this variable to 1 causes 2html.vim to always use CSS for styling,
regardless of what |g:html_use_css| is set to.

This variable is ignored when |g:html_ignore_folding| is set.
>
   :let g:html_dynamic_folds = 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_dynamic_folds}
@vindex g:html_dynamic_folds
@item g:html_dynamic_folds
初期設定: 0

0 なら、折り畳まれたテキストは HTML に含まれない。1 なら、Vim の動作と同じように折り畳みを開いたり閉じたりするための、JavaScript が生成される。

この変数を 1 に設定すると、|@ref{g:html_use_css}| の設定にかかわらず、@file{2html.vim} は常に CSS を使うようになる。

この変数は |@ref{g:html_ignore_folding}| が設定されているときは無視される。
@example
:let g:html_dynamic_folds = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*g:html_no_foldcolumn*
Default: 0.
When 0, if |g:html_dynamic_folds| is 1, generate a column of text similar to
Vim's foldcolumn (|fold-foldcolumn|) the user can click on to toggle folds
open or closed. The minimum width of the generated text column is the current
'foldcolumn' setting.
When 1, do not generate this column; instead, hovering the mouse cursor over
folded text will open the fold as if |g:html_hover_unfold| were set.
>
   :let g:html_no_foldcolumn = 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_no_foldcolumn}
@vindex g:html_no_foldcolumn
@item g:html_no_foldcolumn
初期設定: 0

0 なら、もし |@ref{g:html_dynamic_folds}| が 1 なら、Vim の foldcolumn (|@ref{fold-foldcolumn}|) に似たテキストを生成する。ユーザーはそれをクリックすることで折り畳みを開いたり閉じたりできる。生成されるテキスト幅の最小値は現在の '@option{foldcolumn}' の設定で決まる。

1 なら、その列を生成しない。代わりに、マウスを折り畳みの上にもっていくことで折り畳みが開くようになる (|@ref{g:html_hover_unfold}| が設定されたときのように)。
@example
:let g:html_no_foldcolumn = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
				*TOhtml-uncopyable-text* *g:html_prevent_copy*
Default: empty string.
This option prevents certain regions of the generated HTML from being copied,
when you select all text in document rendered in a browser and copy it. Useful
for allowing users to copy-paste only the source text even if a fold column or
line numbers are shown in the generated content. Specify regions to be
affected in this way as follows:
	f:	fold column
	n:	line numbers (also within fold text)
	t:	fold text
	d:	diff filler
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{TOhtml-uncopyable-text}
@anchor{g:html_prevent_copy}
@cindex TOhtml-uncopyable-text
@vindex g:html_prevent_copy
@item g:html_prevent_copy
初期設定: 空文字列

このオプションは、例えば生成された HTML をブラウザーで開いて全体を選択してコピーしたときに、特定の範囲がコピーされないようにできる。これは foldcolumn や行番号が表示されていても、ソーステキストのみコピーできるようにしたい場合に便利である。範囲の指定は次のようにする:
@multitable @columnfractions .1 .9
@item f: @tab foldcolumn
@item n: @tab 行番号 (折り畳みテキスト内のも)
@item t: @tab 折り畳みテキスト
@item d: @tab 差分詰め文字
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Example, to make the fold column and line numbers uncopyable: >
	:let g:html_prevent_copy = "fn"
<
This feature is currently implemented by inserting read-only <input> elements
into the markup to contain the uncopyable areas. This does not work well in
all cases. When pasting to some applications which understand HTML, the
<input> elements also get pasted. But plain-text paste destinations should
always work.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば、foldcolumn と行番号をコピーできないようにするには:
@example
:let g:html_prevent_copy = "fn"
@end example
この機能は現在、コピー抑制エリアに読み込み専用の <input> 要素を挿入することで実装されている。これはすべての場合で機能するわけではない。他の、HTML を解釈するアプリケーションにペーストすると、<input> 要素もペーストされる。しかしプレーンテキストとしてのペーストなら常に機能するだろう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							   *g:html_no_invalid*
Default: 0.
When 0, if |g:html_prevent_copy| is non-empty, an invalid attribute is
intentionally inserted into the <input> element for the uncopyable areas. This
increases the number of applications you can paste to without also pasting the
<input> elements. Specifically, Microsoft Word will not paste the <input>
elements if they contain this invalid attribute.
When 1, no invalid markup is ever intentionally inserted, and the generated
page should validate. However, be careful pasting into Microsoft Word when
|g:html_prevent_copy| is non-empty; it can be hard to get rid of the <input>
elements which get pasted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_no_invalid}
@vindex g:html_no_invalid
@item g:html_no_invalid
初期設定: 0

0 なら、もし |@ref{g:html_prevent_copy}| が空でなければ、コピー抑制エリアのための <input> エレメントに不正な属性が意図的に挿入される。これによって、<input> 要素がペーストされてしまうような場合でもいくつかのアプリケーションは対応可能となる。特に、Microsoft Word は不正な属性を持つ <input> 要素をペーストしない。

1 なら、不正な属性は挿入されない。正しいページが生成される。ただし、|@ref{g:html_prevent_copy}| が空でないときに、Microsoft Word にペーストするには注意が必要である。<input> 要素がペーストされないようにするのは困難だ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							 *g:html_hover_unfold*
Default: 0.
When 0, the only way to open a fold generated by 2html.vim with
|g:html_dynamic_folds| set, is to click on the generated fold column.
When 1, use CSS 2.0 to allow the user to open a fold by moving the mouse
cursor over the displayed fold text. This is useful to allow users with
disabled javascript to view the folded text.

Note that old browsers (notably Internet Explorer 6) will not support this
feature.  Browser-specific markup for IE6 is included to fall back to the
normal CSS1 styling so that the folds show up correctly for this browser, but
they will not be openable without a foldcolumn.
>
   :let g:html_hover_unfold = 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_hover_unfold}
@vindex g:html_hover_unfold
@item g:html_hover_unfold
初期設定: 0

0 なら、@file{2html.vim} で |@ref{g:html_dynamic_folds}| 付きで生成された HTML の折り畳みを開く方法は、生成された折り畳み列をクリックする方法だけになる。

1 なら、CSS 2.0 を使って、マウスを折り畳みの上にもっていくことで折り畳みを開けるようにする。JavaScript を無効にしていても折り畳みを開けるようにしたい場合に便利である。
@quotation
@strong{Note:} @*
古いブラウザー (特に Internet Explorer 6) はこの機能をサポートしていない。通常の CSS1 を使った IE6 用のマークアップが挿入され、IE6 でも表示できるようにはなっているが、foldcolumn がないとそれを開くことはできない。
@example
:let g:html_hover_unfold = 1
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							      *g:html_id_expr*
Default: ""
Dynamic folding and jumping to line IDs rely on unique IDs within the document
to work. If generated HTML is copied into a larger document, these IDs are no
longer guaranteed to be unique. Set g:html_id_expr to an expression Vim can
evaluate to get a unique string to append to each ID used in a given document,
so that the full IDs will be unique even when combined with other content in a
larger HTML document. Example, to append _ and the buffer number to each ID: >

	:let g:html_id_expr = '"_".bufnr("%")'
<
To append a string "_mystring" to the end of each ID: >

	:let g:html_id_expr = '"_mystring"'
<
Note, when converting a diff view to HTML, the expression will only be
evaluated for the first window in the diff, and the result used for all the
windows.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_id_expr}
@vindex g:html_id_expr
@item g:html_id_expr
初期設定: ""

動的折り畳みや行 ID によるジャンプが機能するにはドキュメント内における一意の ID が必要である。例えば生成された HTML を他のドキュメント内にコピーしたりすると、その ID は一意性が保証されなくなる。g:html_id_expr に式が設定されていると、Vim は一意な文字列を得るためにその式を評価して、ドキュメント内で使用されるID に付加する。その完全な ID であれば、他のドキュメントにコピーされた場合でも一意に定めることができる。例えば、_ とバッファ番号を ID に付加するには:
@example
:let g:html_id_expr = '"_".bufnr("%")'
@end example
ID の末尾に "_mystring" を付加するには:
@example
:let g:html_id_expr = '"_mystring"'
@end example
@quotation
@strong{Note:} @*
diff ビューを HTML に変換するときは、この式は diff の 1 番目のウィンドウに対してのみ評価される。そしてその結果は他のすべてのウィンドウに対して使用される。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					  *TOhtml-wrap-text* *g:html_pre_wrap*
Default: current 'wrap' setting.
When 0, if |g:html_no_pre| is 0 or unset, the text in the generated HTML does
not wrap at the edge of the browser window.
When 1, if |g:html_use_css| is 1, the CSS 2.0 "white-space:pre-wrap" value is
used, causing the text to wrap at whitespace at the edge of the browser
window.
Explicitly enable text wrapping: >
   :let g:html_pre_wrap = 1
Explicitly disable wrapping: >
   :let g:html_pre_wrap = 0
Go back to default, determine wrapping from 'wrap' setting: >
   :unlet g:html_pre_wrap
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{TOhtml-wrap-text}
@anchor{g:html_pre_wrap}
@cindex TOhtml-wrap-text
@vindex g:html_pre_wrap
@item g:html_pre_wrap
初期設定: 現在の '@option{wrap}' の設定

0 なら、もし |@ref{g:html_no_pre}| が 0 または未設定なら、生成された HTML のテキストはブラウザーの端で折り返されない。

1 なら、もし |@ref{g:html_use_css}| が 1 なら、CSS 2.0 の "white-space:pre-wrap" が使われ、テキストはブラウザーの端で折り返される。

明示的に折り返しを有効にするには:
@example
:let g:html_pre_wrap = 1
@end example
明示的に折り返しを無効にするには:
@example
:let g:html_pre_wrap = 0
@end example
初期設定に戻し、'@option{wrap}' の設定が反映されるようにするには:
@example
:unlet g:html_pre_wrap
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							       *g:html_no_pre*
Default: 0.
When 0, buffer text in the generated HTML is surrounded by <pre>...</pre>
tags. Series of whitespace is shown as in Vim without special markup, and tab
characters can be included literally (see |g:html_expand_tabs|).
When 1 (not recommended), the <pre> tags are omitted, and a plain <div> is
used instead. Whitespace is replaced by a series of &nbsp; character
references, and <br> is used to end each line. This is another way to allow
text in the generated HTML is wrap (see |g:html_pre_wrap|) which also works in
old browsers, but may cause noticeable differences between Vim's display and
the rendered page generated by 2html.vim.
>
   :let g:html_no_pre = 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_no_pre}
@vindex g:html_no_pre
@item g:html_no_pre
初期設定: 0

0 なら、テキストは <pre>...</pre> タグで囲まれる。スペース文字の連続はそのまま Vim 内での表示と同じように表示され、タブ文字もそのまま含むことができる (|@ref{g:html_expand_tabs}| 参照)。

1 なら (非推奨)、<pre> タグは使われず、代わりに <div> タグが使われる。スペース文字は &nbsp; 文字参照に変換され、改行には <br> が使われる。これは HTML で折り返し (|@ref{g:html_pre_wrap}|) をするためのもう 1 つの方法で、古いブラウザーでも動作するが、Vim の表示とは違うページが生成されるかもしれない。
@example
:let g:html_no_pre = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							  *g:html_expand_tabs*
Default: 1 if 'tabstop' is 8, 'expandtab' is 0, and no fold column or line
		numbers occur in the generated HTML;
	 0 otherwise.
When 0, <Tab> characters in the buffer text are replaced with an appropriate
number of space characters, or &nbsp; references if |g:html_no_pre| is 1.
When 1, if |g:html_no_pre| is 0 or unset, <Tab> characters in the buffer text
are included as-is in the generated HTML. This is useful for when you want to
allow copy and paste from a browser without losing the actual whitespace in
the source document. Note that this can easily break text alignment and
indentation in the HTML, unless set by default.

Force |2html.vim| to keep <Tab> characters: >
   :let g:html_expand_tabs = 0
<
Force tabs to be expanded: >
   :let g:html_expand_tabs = 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_expand_tabs}
@vindex g:html_expand_tabs
@item g:html_expand_tabs
初期設定: '@option{tabstop}' が 8 で '@option{expandtab}' が 0 で foldcolumn と行番号がない場合は 1。

そうでない場合は 0。

0 なら、<Tab> 文字は同等のスペース文字、または &nbsp; (|@ref{g:html_no_pre}| が 1 の場合) に置換される。

1 なら、もし |@ref{g:html_no_pre}| が 0 または未設定なら、<Tab> 文字はそのまま HTML に出力される。これはブラウザーで表示したときに、もとのテキストのままコピー & ペーストできるようにしたい場合に便利である。
@quotation
@strong{Note:} @*
これはテキストの整列やインデントが崩れやすい (初期設定として設定された場合は別)。
@end quotation
強制的に |@ref{2html.vim}| で <Tab> 文字を維持したい場合は:
@example
:let g:html_expand_tabs = 0
@end example
強制的にタブ文字を展開したい場合は:
@example
:let g:html_expand_tabs = 1
@end example
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
				    *TOhtml-encoding-detect* *TOhtml-encoding*
It is highly recommended to set your desired encoding with
|g:html_use_encoding| for any content which will be placed on a web server.

If you do not specify an encoding, |2html.vim| uses the preferred IANA name
for the current value of 'fileencoding' if set, or 'encoding' if not.
'encoding' is always used for certain 'buftype' values. 'fileencoding' will be
set to match the chosen document encoding.

Automatic detection works for the encodings mentioned specifically by name in
|encoding-names|, but TOhtml will only automatically use those encodings with
wide browser support. However, you can override this to support specific
encodings that may not be automatically detected by default (see options
below). See http://www.iana.org/assignments/character-sets for the IANA names.

Note, by default all Unicode encodings are converted to UTF-8 with no BOM in
the generated HTML, as recommended by W3C:

	http://www.w3.org/International/questions/qa-choosing-encodings
	http://www.w3.org/International/questions/qa-byte-order-mark
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{TOhtml-encoding-detect}
@anchor{TOhtml-encoding}
@cindex TOhtml-encoding-detect
@cindex TOhtml-encoding
ウェブサーバーにコンテンツを置くような場合は、使用したいエンコーディング名を |@ref{g:html_use_encoding}| で指定することを強く推奨する。

エンコーディングが指定されていない場合は、|@ref{2html.vim}| は '@option{fileencoding}' が設定されていれば '@option{fileencoding}' の値から、設定されていなければ '@option{encoding}' の値から、適切な IANA 名が使用される。特定の '@option{buftype}' に対しては '@option{encoding}' が常に使用される。'@option{fileencoding}' は選択されたドキュメントエンコーディングに合うように設定される。

自動設定は |@ref{encoding-names}| に挙げられたエンコーディング名に対して機能するが、TOhtml は多くのブラウザーでサポートされているエンコーディングのみ自動設定する。自動設定の対象外のエンコーディングを使用したい場合は明示的にそれを設定することができる (下記オプション参照)。IANA 名については @url{http://www.iana.org/assignments/character-sets} を参照。

@quotation
@strong{Note:} @*
初期設定ではすべての Unicode エンコーディングは BOM なし UTF-8 として HTML 生成される (W3C 推奨):
@itemize
@item @url{http://www.w3.org/International/questions/qa-choosing-encodings}
@item @url{http://www.w3.org/International/questions/qa-byte-order-mark}
@end itemize
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							 *g:html_use_encoding*
Default: none, uses IANA name for current 'fileencoding' as above.
To overrule all automatic charset detection, set g:html_use_encoding to the
name of the charset to be used. It is recommended to set this variable to
something widely supported, like UTF-8, for anything you will be hosting on a
webserver: >
   :let g:html_use_encoding = "UTF-8"
You can also use this option to omit the line that specifies the charset
entirely, by setting g:html_use_encoding to an empty string (NOT recommended): >
   :let g:html_use_encoding = ""
To go back to the automatic mechanism, delete the |g:html_use_encoding|
variable: >
   :unlet g:html_use_encoding
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{g:html_use_encoding}
@vindex g:html_use_encoding
@item g:html_use_encoding
初期設定: なし。上述のとおり、'@option{fileencoding}' の値に応じて IANA 名が使われる。文字セットの自動設定を上書きするには、g:html_use_encoding に使用したい文字セットの名前を設定する。ウェブサーバーに上げるような場合には、UTF-8 のような広くサポートされている文字セットを設定することが推奨される:
@example
:let g:html_use_encoding = "UTF-8"
@end example
文字セット指定の行を含めたくない場合は g:html_use_encoding に空文字を設定する (非推奨):
@example
:let g:html_use_encoding = ""
@end example
自動的に判断する設定に戻すには変数 |@ref{g:html_use_encoding}| を削除する:
@example
:unlet g:html_use_encoding
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						    *g:html_encoding_override*
Default: none, autoload/tohtml.vim contains default conversions for encodings
		mentioned by name at |encoding-names|.
This option allows |2html.vim| to detect the correct 'fileencoding' when you
specify an encoding with |g:html_use_encoding| which is not in the default
list of conversions.

This is a dictionary of charset-encoding pairs that will replace existing
pairs automatically detected by TOhtml, or supplement with new pairs.

Detect the HTML charset "windows-1252" as the encoding "8bit-cp1252": >
   :let g:html_encoding_override = {'windows-1252': '8bit-cp1252'}
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_encoding_override}
@vindex g:html_encoding_override
@item g:html_encoding_override
初期設定: なし。|@ref{encoding-names}| で挙げられているエンコーディングに対しては autoload/@file{tohtml.vim} で既定の変換が定義されている。

自動設定されない文字セットを |@ref{g:html_use_encoding}| で明示的に設定したときに、それに対応する '@option{fileencoding}' を |@ref{2html.vim}| に指定することができる。

これは文字セット-エンコーディング組の辞書で、TOhtml が使用する組を置き換えたり追加したりできる。

例えば HTML 文字セットの "windows-1252" を "8bit-cp1252" エンコーディングに対応させるなら:
@example
:let g:html_encoding_override = @{'windows-1252': '8bit-cp1252'@}
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						     *g:html_charset_override*
Default: none, autoload/tohtml.vim contains default conversions for encodings
		mentioned by name at |encoding-names| and which have wide
		browser support.
This option allows |2html.vim| to detect the HTML charset for any
'fileencoding' or 'encoding' which is not detected automatically. You can also
use it to override specific existing encoding-charset pairs. For example,
TOhtml will by default use UTF-8 for all Unicode/UCS encodings. To use UTF-16
and UTF-32 instead, use: >
   :let g:html_charset_override = {'ucs-4': 'UTF-32', 'utf-16': 'UTF-16'}

Note that documents encoded in either UTF-32 or UTF-16 have known
compatibility problems with some major browsers.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_charset_override}
@vindex g:html_charset_override
@item g:html_charset_override
初期設定: なし。|@ref{encoding-names}| で挙げられているエンコーディングに対しては autoload/@file{tohtml.vim} で既定の変換が定義されている。それは多くのブラウザーでサポートされている。

|@ref{2html.vim}| が '@option{fileencoding}' や '@option{encoding}' から適切な HTML 文字セットを自動的に決定できない場合に設定する。既定のエンコーディング-文字セット組を上書きすることもできる。例えば、TOhtml はすべての Unicode/UCS エンコーディングに対しては UTF-8 を使用するが、代わりに UTF-16 や UTF-32 を使うようにするには次のように設定する:
@example
:let g:html_charset_override = @{'ucs-4': 'UTF-32', 'utf-16': 'UTF-16'@}
@end example
@quotation
@strong{Note:} @*
UTF-32 か UTF-16 でエンコードされたドキュメントはいくつかのメジャーブラウザーで互換性の問題があることが知られている。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
								 *g:html_font*
Default: "monospace"
You can specify the font or fonts used in the converted document using
g:html_font. If this option is set to a string, then the value will be
surrounded with single quotes. If this option is set to a list then each list
item is surrounded by single quotes and the list is joined with commas. Either
way, "monospace" is added as the fallback generic family name and the entire
result used as the font family (using CSS) or font face (if not using CSS).
Examples: >

   " font-family: 'Consolas', monospace;
   :let g:html_font = "Consolas"

   " font-family: 'DejaVu Sans Mono', 'Consolas', monospace;
   :let g:html_font = ["DejaVu Sans Mono", "Consolas"]
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:html_font}
@vindex g:html_font
@item g:html_font
初期設定: "monospace"

g:html_font を使って 1 つないしは複数のフォントを変換されたドキュメントに対して指定できる。このオプションに文字列を設定した場合はシングルクォートで囲まれる。またオプションにリストを設定した場合は全てのリストアイテムがシングルクォートで囲まれ、リストはコンマで結合される。どちらの場合でも、一般的なフォントファミリ名、(CSS を使っての)フォントファミリ名、(CSS を使わない場合の)フォントフェイス名を補う為に "monospace" が追加される。

例:

monospace の font-family: 'Consolas' を使う場合
@example
:let g:html_font = "Consolas"
@end example

monospace の font-family: 'DejaVu Sans Mono', 'Consolas' を使う場合
@example
:let g:html_font = ["DejaVu Sans Mono", "Consolas"]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			*convert-to-XML* *convert-to-XHTML* *g:html_use_xhtml*
Default: 0.
When 0, generate standard HTML 4.01 (strict when possible).
When 1, generate XHTML 1.0 instead (XML compliant HTML).
>
    :let g:html_use_xhtml = 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{convert-to-XML}
@anchor{convert-to-XHTML}
@anchor{g:html_use_xhtml}
@cindex convert-to-XML
@cindex convert-to-XHTML
@vindex g:html_use_xhtml
@item g:html_use_xhtml
初期設定: 0

0 なら、標準 HTML 4.01 を生成する (可能なら strict)。

1 なら、XHTML 1.0 を生成する (XML 準拠の HTML)。
@example
:let g:html_use_xhtml = 1
@end example
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ABEL						*abel.vim* *ft-abel-syntax*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{abel.vim}
@anchor{ft-abel-syntax}
@cindex abel.vim
@cindex ft-abel-syntax
@unnumberedsubsec ABEL
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ABEL highlighting provides some user-defined options.  To enable them, assign
any value to the respective variable.  Example: >
	:let abel_obsolete_ok=1
To disable them use ":unlet".  Example: >
	:unlet abel_obsolete_ok

Variable			Highlight ~
abel_obsolete_ok		obsolete keywords are statements, not errors
abel_cpp_comments_illegal	do not interpret '//' as inline comment leader
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ABEL のハイライトにはユーザーが定義できるオプションが幾つかある。それらを有効化するにはそれぞれの変数に何か値を設定すれば良い。例:
@example
:let abel_obsolete_ok=1
@end example
無効化するには ":unlet" を使用する。例:
@example
:unlet abel_obsolete_ok
@end example
@multitable @columnfractions .4 .6
@headitem 変数 @tab ハイライト
@item abel_obsolete_ok @tab 古いキーワードをエラーでなく命令文として扱う
@item abel_cpp_comments_illegal @tab '//' をインラインコメントリーダーとして扱わない
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ADA

See |ft-ada-syntax|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec ADA
|@ref{ft-ada-syntax}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ANT						*ant.vim* *ft-ant-syntax*

The ant syntax file provides syntax highlighting for javascript and python
by default.  Syntax highlighting for other script languages can be installed
by the function AntSyntaxScript(), which takes the tag name as first argument
and the script syntax file name as second argument.  Example: >

	:call AntSyntaxScript('perl', 'perl.vim')

will install syntax perl highlighting for the following ant code >

	<script language = 'perl'><![CDATA[
	    # everything inside is highlighted as perl
	]]></script>

See |mysyntaxfile-add| for installing script languages permanently.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ant.vim}
@anchor{ft-ant-syntax}
@cindex ant.vim
@cindex ft-ant-syntax
@unnumberedsubsec ANT
ANT の構文ファイルにはデフォルトで JavaScript と Python の構文ハイライトが含まれている。関数 AntSyntaxScript() の第 1 引数にタグ名を、第 2 引数にファイル名を指定することでその他のスクリプト言語用構文ハイライトをインストールすることができる。例:
@example
:call AntSyntaxScript('perl', 'perl.vim')
@end example
これは次のような ANT のコードに Perl の構文ハイライトをインストールするものである
@verbatim
<script language = 'perl'><![CDATA[
    # everything inside is highlighted as perl
]]></script>
@end verbatim
スクリプト言語を永続的にインストールするには |@ref{mysyntaxfile-add}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
APACHE						*apache.vim* *ft-apache-syntax*

The apache syntax file provides syntax highlighting for Apache HTTP server
version 2.2.3.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{apache.vim}
@anchor{ft-apache-syntax}
@cindex apache.vim
@cindex ft-apache-syntax
@unnumberedsubsec APACHE
apache の構文ファイルは Apache HTTP サーバーのバージョン 2.2.3 に基づいた構文ハイライトを提供する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
		*asm.vim* *asmh8300.vim* *nasm.vim* *masm.vim* *asm68k*
ASSEMBLY	*ft-asm-syntax* *ft-asmh8300-syntax* *ft-nasm-syntax*
		*ft-masm-syntax* *ft-asm68k-syntax* *fasm.vim*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{asm.vim}
@anchor{asmh8300.vim}
@anchor{nasm.vim}
@anchor{masm.vim}
@anchor{asm68k}
@anchor{ft-asm-syntax}
@anchor{ft-asmh8300-syntax}
@anchor{ft-nasm-syntax}
@anchor{ft-masm-syntax}
@anchor{ft-asm68k-syntax}
@anchor{fasm.vim}
@cindex asm.vim
@cindex asmh8300.vim
@cindex nasm.vim
@cindex masm.vim
@cindex asm68k
@cindex ft-asm-syntax
@cindex ft-asmh8300-syntax
@cindex ft-nasm-syntax
@cindex ft-masm-syntax
@cindex ft-asm68k-syntax
@cindex fasm.vim
@unnumberedsubsec ASSEMBLY
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Files matching "*.i" could be Progress or Assembly.  If the automatic detection
doesn't work for you, or you don't edit Progress at all, use this in your
startup vimrc: >
   :let filetype_i = "asm"
Replace "asm" with the type of assembly you use.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"*.i" にマッチする名前のファイルのタイプは Progress かアセンブリである。自動検出が動作しない場合や、Progress を編集しないことが判っている場合には、起動設定ファイル @file{vimrc} に次のコマンドを書くことができる:
@example
:let filetype_i = "asm"
@end example
"asm" には使用するアセンブリ言語の種類を指定する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are many types of assembly languages that all use the same file name
extensions.  Therefore you will have to select the type yourself, or add a
line in the assembly file that Vim will recognize.  Currently these syntax
files are included:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
同じ拡張子を使用しているアセンブリ言語はたくさんある。そのため、ユーザーは自分が使っている種類を選択するか、もしくはアセンブリファイルそのものに Vim がそれと判断できるような行を追加しなければならない。現在は以下の構文ファイルが利用可能:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	asm		GNU assembly (the default)
	asm68k		Motorola 680x0 assembly
	asmh8300	Hitachi H-8300 version of GNU assembly
	ia64		Intel Itanium 64
	fasm		Flat assembly (http://flatassembler.net)
	masm		Microsoft assembly (probably works for any 80x86)
	nasm		Netwide assembly
	tasm		Turbo Assembly (with opcodes 80x86 up to Pentium, and
			MMX)
	pic		PIC assembly (currently for PIC16F84)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item asm @tab GNU アセンブラ (デフォルト)
@item asm68k @tab モトローラ 680x0 アセンブラ
@item asmh8300 @tab 日立 H-8300 用 GNU アセンブラ
@item ia64 @tab インテル Itanium 64
@item fasm @tab Flat アセンブラ (@url{http://flatassembler.net})
@item masm @tab マイクロソフトアセンブラ (たぶん 80x86 汎用)
@item nasm @tab ネットワイドアセンブラ
@item tasm @tab ターボアセンブラ (80x86, Pentium, MMX の命令コードを含む)
@item pic @tab PIC アセンブラ (現在は PIC16F84 用)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The most flexible is to add a line in your assembly file containing: >
	asmsyntax=nasm
Replace "nasm" with the name of the real assembly syntax.  This line must be
one of the first five lines in the file.  No non-white text must be
immediately before or after this text.  Note that specifying asmsyntax=foo is
equivalent to setting ft=foo in a |modeline|, and that in case of a conflict
between the two settings the one from the modeline will take precedence (in
particular, if you have ft=asm in the modeline, you will get the GNU syntax
highlighting regardless of what is specified as asmsyntax).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
アセンブリファイルに次のような行を書き加えるのが一番柔軟である:
@example
asmsyntax=nasm
@end example
ここで、"nasm" は実際に使用するアセンブリ構文の名前に置き換えること。この記述はファイルの先頭 5 行以内に書いてなければならない。この文字列の前後に非空白文字があってはならない。Note asmsyntax=foo を指定するのはモードライン (|@ref{modeline}|) で ft=foo と設定するのと同じであり、設定がぶつかったときはモードラインの設定が先に処理される (特に、例えばモードラインで ft=asm と設定すると、asmsyntax があっても GNU 構文強調表示が使われることになる)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The syntax type can always be overruled for a specific buffer by setting the
b:asmsyntax variable: >
	:let b:asmsyntax = "nasm"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
構文の種類はバッファ変数 b:asmsyntax を設定することで常にそちらが優先される:
@example
:let b:asmsyntax = "nasm"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If b:asmsyntax is not set, either automatically or by hand, then the value of
the global variable asmsyntax is used.	This can be seen as a default assembly
language: >
	:let asmsyntax = "nasm"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
自動にしろ手動にしろ b:asmsyntax が設定されていないときには、グローバル変数 asmsyntax が使用される。これによりデフォルトのアセンブリ言語を設定することができる:
@example
:let asmsyntax = "nasm"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
As a last resort, if nothing is defined, the "asm" syntax is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最後の手段として、何も設定されていない場合には、"asm" 構文が使用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Netwide assembler (nasm.vim) optional highlighting ~

To enable a feature: >
	:let   {variable}=1|set syntax=nasm
To disable a feature: >
	:unlet {variable}  |set syntax=nasm
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec ネットワイドアセンブラ (nasm.vim) の補助ハイライト
機能を有効化するには:
@example
:let   @{variable@}=1|set syntax=nasm
@end example
無効化するには:
@example
:unlet @{variable@}  |set syntax=nasm
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Variable		Highlight ~
nasm_loose_syntax	unofficial parser allowed syntax not as Error
			  (parser dependent; not recommended)
nasm_ctx_outside_macro	contexts outside macro not as Error
nasm_no_warn		potentially risky syntax not as ToDo
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@headitem 変数 @tab ハイライト内容
@item nasm_loose_syntax @tab 非オフィシャルな拡張構文をエラーとしない (パーサー依存; 非推奨)
@item nasm_ctx_outside_macro @tab マクロ外のコンテキストをエラーとしない
@item nasm_no_warn @tab 潜在的に危険な構文をToDoとしてハイライトしない
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ASPPERL and ASPVBS			*ft-aspperl-syntax* *ft-aspvbs-syntax*

*.asp and *.asa files could be either Perl or Visual Basic script.  Since it's
hard to detect this you can set two global variables to tell Vim what you are
using.	For Perl script use: >
	:let g:filetype_asa = "aspperl"
	:let g:filetype_asp = "aspperl"
For Visual Basic use: >
	:let g:filetype_asa = "aspvbs"
	:let g:filetype_asp = "aspvbs"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ft-aspperl-syntax}
@anchor{ft-aspvbs-syntax}
@cindex ft-aspperl-syntax
@cindex ft-aspvbs-syntax
@unnumberedsubsec ASPPERL and ASPVBS
 *.asp と *.asa という名のファイルはどちらも Perl もしくは Visual Basic のスクリプトたりえる。Vim にとってこれを判別するのは難しいので、グローバル変数を設定することでどちらを使用するのか宣言することができる。どちらでも Perl スクリプトを使用するなら:
@example
:let g:filetype_asa = "aspperl"
:let g:filetype_asp = "aspperl"
@end example
Visual Basic を使用するなら次のように設定する:
@example
:let g:filetype_asa = "aspvbs"
:let g:filetype_asp = "aspvbs"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
BAAN						    *baan.vim* *baan-syntax*

The baan.vim gives syntax support for BaanC of release BaanIV upto SSA ERP LN
for both 3 GL and 4 GL programming. Large number of standard defines/constants
are supported.

Some special violation of coding standards will be signalled when one specify
in ones |.vimrc|: >
	let baan_code_stds=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{baan.vim}
@anchor{baan-syntax}
@cindex baan.vim
@cindex baan-syntax
@unnumberedsubsec BAAN

@file{baan.vim} は リリース BaanIV から SSA ERP LN まで、3 GL と 4 GL プログラミング両方に対応した構文を定義している。たくさんの標準的な定義/定数がサポートされている。

次を |@ref{.vimrc}| に書いておくと、ある種のコーディング標準違反を教えてくれる:
@example
let baan_code_stds=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
*baan-folding*

Syntax folding can be enabled at various levels through the variables
mentioned below (Set those in your |.vimrc|). The more complex folding on
source blocks and SQL can be CPU intensive.

To allow any folding and enable folding at function level use: >
	let baan_fold=1
Folding can be enabled at source block level as if, while, for ,... The
indentation preceding the begin/end keywords has to match (spaces are not
considered equal to a tab). >
	let baan_fold_block=1
Folding can be enabled for embedded SQL blocks as SELECT, SELECTDO,
SELECTEMPTY, ... The indentation preceding the begin/end keywords has to
match (spaces are not considered equal to a tab). >
	let baan_fold_sql=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{baan-folding}
@cindex baan-folding
以下の変数によって、様々なレベルで構文折り畳みを有効にできる (これらはユーザーの |@ref{.vimrc}| で設定すること)。ソースブロックと SQL についてより複雑な折り畳みを行うと CPU に負荷がかかる。

折り畳みを有効にし、関数レベルで折り畳みをするにはこうする:
@example
let baan_fold=1
@end example
次の設定を行うと、if, while, for ... のようなソースブロックレベルの折り畳みが有効になる。キーワード begin/end の前のインデントが等しくなければならない (スペースとタブは異なるとみなされる)。
@example
let baan_fold_block=1
@end example
次を設定すると SELECT, SELECTDO, SELECTEMPTY ... のような埋め込み SQL ブロックの折り畳みが有効になる。キーワード begin/end の前のインデントが等しくなければならない (スペースとタブは異なるとみなされる)。
@example
let baan_fold_sql=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Note: Block folding can result in many small folds. It is suggested to |:set|
the options 'foldminlines' and 'foldnestmax' in |.vimrc| or use |:setlocal| in
.../after/syntax/baan.vim (see |after-directory|). Eg: >
	set foldminlines=5
	set foldnestmax=6
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ブロック折り畳みを有効にすると、小さな折り畳みがたくさんできるかもしれない。|@ref{.vimrc}| でオプション '@option{foldminlines}' と '@option{foldnestmax}' を |@ref{:set}| するか、.../after/syntax/@file{baan.vim} 内で |@ref{:setlocal}| をする (|@ref{after-directory}| を参照) とよいかもしれない。例:
@example
set foldminlines=5
set foldnestmax=6
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
BASIC			*basic.vim* *vb.vim* *ft-basic-syntax* *ft-vb-syntax*

Both Visual Basic and "normal" basic use the extension ".bas".	To detect
which one should be used, Vim checks for the string "VB_Name" in the first
five lines of the file.  If it is not found, filetype will be "basic",
otherwise "vb".  Files with the ".frm" extension will always be seen as Visual
Basic.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{basic.vim}
@anchor{vb.vim}
@anchor{ft-basic-syntax}
@anchor{ft-vb-syntax}
@cindex basic.vim
@cindex vb.vim
@cindex ft-basic-syntax
@cindex ft-vb-syntax
@unnumberedsubsec BASIC
Visual Basicも「通常の」BASIC も、どちらも拡張子には ".bas" が使用される。どちらが使用されているか判別するのに、Vim はファイルの先頭5行以内に "VB_Name" という文字列が存在するかどうかを検査する。存在しなければ、ファイル形式は "basic" となり、そうでなければ "vb" となる。拡張子が ".frm" のファイルは常に Visual Basic として扱われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
C							*c.vim* *ft-c-syntax*

A few things in C highlighting are optional.  To enable them assign any value
to the respective variable.  Example: >
	:let c_comment_strings = 1
To disable them use ":unlet".  Example: >
	:unlet c_comment_strings
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c.vim}
@anchor{ft-c-syntax}
@cindex c.vim
@cindex ft-c-syntax
@unnumberedsubsec C
C には幾つかの補助的なハイライト方法がある。それらを有効化するには対応した変数に値を設定する。例:
@example
:let c_comment_strings = 1
@end example
これを無効化するには "@command{:unlet}" を使う。例:
@example
:unlet c_comment_strings
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Variable		Highlight ~
*c_gnu*			GNU gcc specific items
*c_comment_strings*	strings and numbers inside a comment
*c_space_errors*		trailing white space and spaces before a <Tab>
*c_no_trail_space_error*	 ... but no trailing spaces
*c_no_tab_space_error*	 ... but no spaces before a <Tab>
*c_no_bracket_error*	don't highlight {}; inside [] as errors
*c_no_curly_error*	don't highlight {}; inside [] and () as errors;
				except { and } in first column
				Default is to highlight them, otherwise you
				can't spot a missing ")".
*c_curly_error*		highlight a missing }; this forces syncing from the
			start of the file, can be slow
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@headitem 変数 @tab ハイライト内容
@anchor{c_gnu}
@vindex c_gnu
@item c_gnu @tab GNU gcc 固有の要素
@anchor{c_comment_strings}
@vindex c_comment_strings
@item c_comment_strings @tab コメント内の文字列と数値
@anchor{c_space_errors}
@vindex c_space_errors
@item c_space_errors @tab 行末の空白文字とタブ文字前のスペース文字
@anchor{c_no_trail_space_error}
@vindex c_no_trail_space_error
@item c_no_trail_space_error @tab ... 但し行末の空白文字は除外
@anchor{c_no_tab_space_error}
@vindex c_no_tab_space_error
@item c_no_tab_space_error @tab ... 但しタブ文字前のスペース文字は除外
@anchor{c_no_bracket_error}
@vindex c_no_bracket_error
@item c_no_bracket_error @tab [] の中の @{@} をエラーとして表示しない
@anchor{c_no_curly_error}
@vindex c_no_curly_error
@item c_no_curly_error @tab @{ と @} が第 1 桁にあるときを除き、[] と () の内側の @{@} をエラーとして表示しない。デフォルトでエラーとして表示される。欠落した ")" を見つけられないため。
@anchor{c_curly_error}
@vindex c_curly_error
@item c_curly_error @tab 対応する @{ がない @} をハイライトする。これを有効にすると、ファイルの先頭から同期が始まるため、遅くなる
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*c_no_ansi*		don't do standard ANSI types and constants
*c_ansi_typedefs*		 ... but do standard ANSI types
*c_ansi_constants*	 ... but do standard ANSI constants
*c_no_utf*		don't highlight \u and \U in strings
*c_syntax_for_h*		for *.h files use C syntax instead of C++ and use objc
			syntax instead of objcpp
*c_no_if0*		don't highlight "#if 0" blocks as comments
*c_no_cformat*		don't highlight %-formats in strings
*c_no_c99*		don't highlight C99 standard items
*c_no_c11*		don't highlight C11 standard items
*c_no_bsd*		don't highlight BSD specific types
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{c_no_ansi}
@vindex c_no_ansi
@item c_no_ansi @tab ANSI 標準の型と定数をハイライトしない
@anchor{c_ansi_typedefs}
@vindex c_ansi_typedefs
@item c_ansi_typedefs @tab ... 但し標準 ANSI 型はハイライトする
@anchor{c_ansi_constants}
@vindex c_ansi_constants
@item c_ansi_constants @tab ... 但し標準 ANSI 定数はハイライトする
@anchor{c_no_utf}
@vindex c_no_utf
@item c_no_utf @tab 文字列中の \u と \U をハイライトしない
@anchor{c_syntax_for_h}
@vindex c_syntax_for_h
@item c_syntax_for_h @tab ファイル *.h に C++ ではなく C の構文を適用し、objcpp ではなく objc の構文を適用する。
@anchor{c_no_if0}
@vindex c_no_if0
@item c_no_if0 @tab "#if 0" のブロックをコメントとしてハイライトしない
@anchor{c_no_cformat}
@vindex c_no_cformat
@item c_no_cformat @tab 文字列中の "%" によるフォーマットをハイライトしない
@anchor{c_no_c99}
@vindex c_no_c99
@item c_no_c99 @tab C99 の標準アイテムをハイライトしない
@anchor{c_no_c11}
@vindex c_no_c11
@item c_no_c11 @tab C11 の標準アイテムをハイライトしない
@anchor{c_no_bsd}
@vindex c_no_bsd
@item c_no_bsd @tab BSD 特有の型をハイライトしない
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When 'foldmethod' is set to "syntax" then /* */ comments and { } blocks will
become a fold.  If you don't want comments to become a fold use: >
	:let c_no_comment_fold = 1
"#if 0" blocks are also folded, unless: >
	:let c_no_if0_fold = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{foldmethod}' が "@var{syntax}" に設定されていると、/* */ のコメントと @{ @} のブロックが折り畳まれる。コメントを折り畳みたくなければこのようにする:
@example
:let c_no_comment_fold = 1
@end example
"#if 0" のブロックも同様に折り畳まれる。折り畳みたくなければこのようにする:
@example
:let c_no_if0_fold = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you notice highlighting errors while scrolling backwards, which are fixed
when redrawing with CTRL-L, try setting the "c_minlines" internal variable
to a larger number: >
	:let c_minlines = 100
This will make the syntax synchronization start 100 lines before the first
displayed line.  The default value is 50 (15 when c_no_if0 is set).  The
disadvantage of using a larger number is that redrawing can become slow.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上方向にスクロールしているときにハイライト表示がおかしくなり、それが @kbd{<CTRL-L>} で再描画すると直るようなら、内部変数 "c_minlines" にもっと大きな値を設定すれば解決できるかもしれない:
@example
:let c_minlines = 100
@end example
これにより構文判定のシンクロナイズ位置が表示開始行の 100 行手前に設定される。初期設定の値は 50 行 (c_no_if0 を使用した場合は 15 行) である。ただしこれには、大きな値を設定すると再描画が遅くなるという短所がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When using the "#if 0" / "#endif" comment highlighting, notice that this only
works when the "#if 0" is within "c_minlines" from the top of the window.  If
you have a long "#if 0" construct it will not be highlighted correctly.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"#if 0" / "#endif" のブロックをコメントとしてハイライトしている場合には、"#if 0" がウィンドウのトップから "c_minlines" 以内にある時にしか正しく動作しないことに注意する。長い "#if 0" のブロックを使用した場合には、それは正しくハイライトされない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To match extra items in comments, use the cCommentGroup cluster.
Example: >
   :au Syntax c call MyCadd()
   :function MyCadd()
   :  syn keyword cMyItem contained Ni
   :  syn cluster cCommentGroup add=cMyItem
   :  hi link cMyItem Title
   :endfun
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コメント内で追加要素にマッチを行うには、クラスタ cCommentGroup を使用する。

例:
@verbatim
:au Syntax c call MyCadd()
:function MyCadd()
:  syn keyword cMyItem contained Ni
:  syn cluster cCommentGroup add=cMyItem
:  hi link cMyItem Title
:endfun
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ANSI constants will be highlighted with the "cConstant" group.	This includes
"NULL", "SIG_IGN" and others.  But not "TRUE", for example, because this is
not in the ANSI standard.  If you find this confusing, remove the cConstant
highlighting: >
	:hi link cConstant NONE
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ANSI の定数はグループ "cConstant" でハイライトされる。これには "NULL", "SIG_IGN" やその他のものが含まれる。しかし ANSI 標準でないもの、例えば "TRUE" は含まれない。もしもこれが紛らわしいならば、cConstant 用のハイライトを削除する:
@example
:hi link cConstant NONE
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you see '{' and '}' highlighted as an error where they are OK, reset the
highlighting for cErrInParen and cErrInBracket.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文法上エラーではないはずの '@{' と '@}' がエラーとしてハイライトされてしまう場合には、cErrInParen 及び cErrInBracket のハイライトをリセットする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to use folding in your C files, you can add these lines in a file
in the "after" directory in 'runtimepath'.  For Unix this would be
~/.vim/after/syntax/c.vim. >
    syn sync fromstart
    set foldmethod=syntax
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
C ファイルで折り畳みをするには、以下の行を '@option{runtimepath}' 中の "after" ディレクトリ内のファイルに加えるとよい。Unix なら ~/.vim/after/syntax/@file{c.vim} に加えるとよいだろう:
@example
syn sync fromstart
set foldmethod=syntax
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CH						*ch.vim* *ft-ch-syntax*

C/C++ interpreter.  Ch has similar syntax highlighting to C and builds upon
the C syntax file.  See |c.vim| for all the settings that are available for C.

By setting a variable you can tell Vim to use Ch syntax for *.h files, instead
of C or C++: >
	:let ch_syntax_for_h = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch.vim}
@anchor{ft-ch-syntax}
@cindex ch.vim
@cindex ft-ch-syntax
@unnumberedsubsec CH
C/C++ インタープリター。Ch は C に似た構文ハイライトを持ち、C の構文ファイルに基づいている。C で利用できる設定については |@ref{c.vim}| を参照。

変数を設定すれば、*.h ファイルに対して C, C++ でなく Ch の構文を使うようにすることができる:
@example
:let ch_syntax_for_h = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
CHILL						*chill.vim* *ft-chill-syntax*

Chill syntax highlighting is similar to C.  See |c.vim| for all the settings
that are available.  Additionally there is:

chill_space_errors	like c_space_errors
chill_comment_string	like c_comment_strings
chill_minlines		like c_minlines
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{chill.vim}
@anchor{ft-chill-syntax}
@cindex chill.vim
@cindex ft-chill-syntax
@unnumberedsubsec CHILL
Chill の構文ハイライトはCに似ている。設定に関しては |@ref{c.vim}| を参照。それに加えて次のものがある:
@multitable @columnfractions .5 .5
@item chill_space_errors @tab c_space_errors と同様
@item chill_comment_string @tab c_comment_strings と同様
@item chill_minlines @tab c_minlines と同様
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
CHANGELOG				*changelog.vim* *ft-changelog-syntax*

ChangeLog supports highlighting spaces at the start of a line.
If you do not like this, add following line to your .vimrc: >
	let g:changelog_spacing_errors = 0
This works the next time you edit a changelog file.  You can also use
"b:changelog_spacing_errors" to set this per buffer (before loading the syntax
file).

You can change the highlighting used, e.g., to flag the spaces as an error: >
	:hi link ChangelogError Error
Or to avoid the highlighting: >
	:hi link ChangelogError NONE
This works immediately.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{changelog.vim}
@anchor{ft-changelog-syntax}
@cindex changelog.vim
@cindex ft-changelog-syntax
@unnumberedsubsec CHANGELOG
ChangeLog では行頭のスペースのハイライトできる。これをオフにしたいなら、次の行を .vimrc に加える:
@example
let g:changelog_spacing_errors = 0
@end example
これは次に ChangeLog ファイルを編集するときから有効になる。バッファごとに設定するには "b:changelog_spacing_errors" を使う (構文ファイルを読み込む前に設定すること)。

例えばスペースをエラーとするかどうかなどのハイライト方法を変えることができる:
@example
:hi link ChangelogError Error
@end example
ハイライトをやめるには:
@example
:hi link ChangelogError NONE
@end example
これは即座に有効になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
CLOJURE							*ft-clojure-syntax*

The default syntax groups can be augmented through the
*g:clojure_syntax_keywords* and *b:clojure_syntax_keywords* variables. The
value should be a |Dictionary| of syntax group names to a |List| of custom
identifiers:
>
	let g:clojure_syntax_keywords = {
	    \ 'clojureMacro': ["defproject", "defcustom"],
	    \ 'clojureFunc': ["string/join", "string/replace"]
	    \ }
<
Refer to the Clojure syntax script for valid syntax group names.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ft-clojure-syntax}
@cindex ft-clojure-syntax
@anchor{g:clojure_syntax_keywords}
@anchor{b:clojure_syntax_keywords}
@vindex g:clojure_syntax_keywords
@vindex b:clojure_syntax_keywords
@unnumberedsubsec CLOJURE
デフォルト構文グループは、変数 g:clojure_syntax_keywords や b:clojure_syntax_keywords を用いて追加できる。値には構文グループの名前をキーとし、値にカスタム識別子の |@ref{List}| を持つ |@ref{Dictionary}| を指定する:
@verbatim
let g:clojure_syntax_keywords = {
    \ 'clojureMacro': ["defproject", "defcustom"],
    \ 'clojureFunc': ["string/join", "string/replace"]
    \ }
@end verbatim
有効な構文グループについては、Clojure 構文スクリプトを参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the |buffer-variable| *b:clojure_syntax_without_core_keywords* is set, only
language constants and special forms are matched.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{b:clojure_syntax_without_core_keywords}
@vindex b:clojure_syntax_without_core_keywords
バッファ変数 (|@ref{buffer-variable}|) b:clojure_syntax_without_core_keywords がセットされると、言語定数と特定のフォームにのみマッチする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Setting *g:clojure_fold* enables folding Clojure code via the syntax engine.
Any list, vector, or map that extends over more than one line can be folded
using the standard Vim |fold-commands|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:clojure_fold}
@vindex g:clojure_fold
g:clojure_fold を設定するとシンタックスエンジンに基づいた Clojure コードの折り畳みが有効化される。複数行に渡るリスト、ベクタ、マップなどを標準の Vim を使って折り畳みできる |@ref{fold-commands}|。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Please note that this option does not work with scripts that redefine the
bracket syntax regions, such as rainbow-parentheses plugins.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このオプションは rainbow-parentheses プラグインのような、角カッコの構文範囲を変更するようなスクリプトを使っているときは機能しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This option is off by default.
>
	" Default
	let g:clojure_fold = 0
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このオプションは初期設定でオフになっている。

初期設定
@example
let g:clojure_fold = 0
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
COBOL						*cobol.vim* *ft-cobol-syntax*

COBOL highlighting has different needs for legacy code than it does for fresh
development.  This is due to differences in what is being done (maintenance
versus development) and other factors.	To enable legacy code highlighting,
add this line to your .vimrc: >
	:let cobol_legacy_code = 1
To disable it again, use this: >
	:unlet cobol_legacy_code
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cobol.vim}
@anchor{ft-cobol-syntax}
@cindex cobol.vim
@cindex ft-cobol-syntax
@unnumberedsubsec COBOL
既存の COBOL コードに要求されるハイライト方法と、新規に開発されるコードに要求されるそれには違いがある。この違いはコードのおかれている状況 (保守 vs 開発) やその他の要素によって決定する。既存コードのハイライトを行うには @file{.vimrc} に次の行を加える:
@example
:let cobol_legacy_code=1
@end example
これを再び無効にするには次のようにする:
@example
:unlet cobol_legacy_code
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
COLD FUSION			*coldfusion.vim* *ft-coldfusion-syntax*

The ColdFusion has its own version of HTML comments.  To turn on ColdFusion
comment highlighting, add the following line to your startup file: >

	:let html_wrong_comments = 1

The ColdFusion syntax file is based on the HTML syntax file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{coldfusion.vim}
@anchor{ft-coldfusion-syntax}
@cindex coldfusion.vim
@cindex ft-coldfusion-syntax
@unnumberedsubsec COLD FUSION
ColdFusion には独自版の HTML コメントが存在する。ColdFusion のコメントハイライトを有効化するには、次の行を起動設定ファイルに加える:
@example
:let html_wrong_comments=1
@end example
ColdFusionの 構文ファイルは HTML 用構文ファイルに基づいている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
CPP						*cpp.vim* *ft-cpp-syntax*

Most of things are same as |ft-c-syntax|.

Variable		Highlight ~
cpp_no_cpp11		don't highlight C++11 standard items
cpp_no_cpp14		don't highlight C++14 standard items
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cpp.vim}
@anchor{ft-cpp-syntax}
@cindex cpp.vim
@cindex ft-cpp-syntax
@unnumberedsubsec CPP
大部分は |@ref{ft-c-syntax}| と同じ。
@multitable @columnfractions .3 .7
@headitem 変数 @tab 強調表示
@item cpp_no_cpp11 @tab C++11 標準のアイテムを強調表示しない
@item cpp_no_cpp14 @tab C++14 標準のアイテムを強調表示しない
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
CSH						*csh.vim* *ft-csh-syntax*

This covers the shell named "csh".  Note that on some systems tcsh is actually
used.

Detecting whether a file is csh or tcsh is notoriously hard.  Some systems
symlink /bin/csh to /bin/tcsh, making it almost impossible to distinguish
between csh and tcsh.  In case VIM guesses wrong you can set the
"filetype_csh" variable.  For using csh:  *g:filetype_csh*
>
	:let g:filetype_csh = "csh"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{csh.vim}
@anchor{ft-csh-syntax}
@cindex csh.vim
@cindex ft-csh-syntax
@unnumberedsubsec CSH
これは "csh" という名前のシェルに対応している。システムによっては実際に使われているのがtcshである場合もあることに注意。

ファイルが csh か tcsh かを判定するのは難しいことがよく知られている。いくつかのシステムでは /bin/csh を /bin/tcsh にシンボリックリンクしていることが、この判別をほぼ不可能にしている。Vim が間違った判定をする場合には変数 "filetype_csh" を設定することができる。

csh を使うには:
@anchor{g:filetype_csh}
@vindex g:filetype_csh
@example
:let g:filetype_csh = "csh"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For using tcsh: >

	:let g:filetype_csh = "tcsh"

Any script with a tcsh extension or a standard tcsh filename (.tcshrc,
tcsh.tcshrc, tcsh.login) will have filetype tcsh.  All other tcsh/csh scripts
will be classified as tcsh, UNLESS the "filetype_csh" variable exists.  If the
"filetype_csh" variable exists, the filetype will be set to the value of the
variable.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
tcshを使うには:
@example
:let g:filetype_csh = "tcsh"
@end example
拡張子が tcsh であるか標準的な tcsh ファイル名 (.tcshrc, tcsh.tcshrc, tcsh.login) を持つスクリプトはすべて tcsh ファイル形式とされる。他の tcsh/csh スクリプトは、"filetype_csh" 変数が存在しない限り、すべて tcsh とみなされる。変数 "filetype_csh" が存在するならファイル形式はその値にセットされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
CYNLIB						*cynlib.vim* *ft-cynlib-syntax*

Cynlib files are C++ files that use the Cynlib class library to enable
hardware modelling and simulation using C++.  Typically Cynlib files have a .cc
or a .cpp extension, which makes it very difficult to distinguish them from a
normal C++ file.  Thus, to enable Cynlib highlighting for .cc files, add this
line to your .vimrc file: >

	:let cynlib_cyntax_for_cc=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cynlib.vim}
@anchor{ft-cynlib-syntax}
@cindex cynlib.vim
@cindex ft-cynlib-syntax
@unnumberedsubsec CYNLIB
Cynlib ファイルは、ハードウェアのモデリングとシミュレーションを行う Cynlib クラスライブラリを使用した C++ ファイルである。通常 Cynlib のファイルは .cc や .cpp という拡張子を持つので、Cynlib ではない C++ ファイルと区別するのは非常に困難である。だから .cc ファイルを Cynlib でハイライトする際には、ファイル @file{.vimrc} に次の行を加える:
@example
:let cynlib_cyntax_for_cc=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Similarly for cpp files (this extension is only usually used in Windows) >

	:let cynlib_cyntax_for_cpp=1

To disable these again, use this: >

	:unlet cynlib_cyntax_for_cc
	:unlet cynlib_cyntax_for_cpp
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
cpp ファイルについても同様 (この拡張子は通常 Windows だけで使用される)
@example
:let cynlib_cyntax_for_cpp=1
@end example
これらを再び無効にするには次のコマンドを使用する:
@example
:unlet cynlib_cyntax_for_cc
:unlet cynlib_cyntax_for_cpp
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
CWEB						*cweb.vim* *ft-cweb-syntax*

Files matching "*.w" could be Progress or cweb.  If the automatic detection
doesn't work for you, or you don't edit Progress at all, use this in your
startup vimrc: >
   :let filetype_w = "cweb"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cweb.vim}
@anchor{ft-cweb-syntax}
@cindex cweb.vim
@cindex ft-cweb-syntax
@unnumberedsubsec CWEB
"*.w" にマッチする名前のファイルのタイプは Progress か CWEB である。自動検出が動作しない場合や、Progress を編集しないことが判っている場合には、起動設定ファイル @file{vimrc} に次のコマンドを書くとよい:
@example
:let filetype_w = "cweb"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DESKTOP					   *desktop.vim* *ft-desktop-syntax*

Primary goal of this syntax file is to highlight .desktop and .directory files
according to freedesktop.org standard:
http://standards.freedesktop.org/desktop-entry-spec/latest/
But actually almost none implements this standard fully.  Thus it will
highlight all Unix ini files.  But you can force strict highlighting according
to standard by placing this in your vimrc file: >
	:let enforce_freedesktop_standard = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{desktop.vim}
@anchor{ft-desktop-syntax}
@cindex desktop.vim
@cindex ft-desktop-syntax
@unnumberedsubsec DESKTOP
この構文ファイルの本来の目的は、freedesktop.org 標準の .desktop と .directory を構文ハイライトすることである:

@url{http://standards.freedesktop.org/desktop-entry-spec/latest/}

しかし実際にはこの標準を完全に実装したものはほとんどない。なのでこれは全ての ini ファイルをハイライトする。ただし次を @file{vimrc} ファイルに書くことによって厳格に標準に準拠したハイライトをさせることもできる:
@example
:let enforce_freedesktop_standard = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DIFF							*diff.vim*

The diff highlighting normally finds translated headers.  This can be slow if
there are very long lines in the file.  To disable translations: >

	:let diff_translations = 0

Also see |diff-slow|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{diff.vim}
@cindex diff.vim
@unnumberedsubsec DIFF
diff 構文ハイライトは、通常ローカライズされた @{訳注: 英語以外の@} diff ヘッダも検出する。ファイルにとても長い行が含まれる場合、この機能は低速になる。ローカライズヘッダへの対応を無効化するには:
@example
:let diff_translations = 0
@end example
|@ref{diff-slow}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DIRCOLORS			       *dircolors.vim* *ft-dircolors-syntax*

The dircolors utility highlighting definition has one option.  It exists to
provide compatibility with the Slackware GNU/Linux distributions version of
the command.  It adds a few keywords that are generally ignored by most
versions.  On Slackware systems, however, the utility accepts the keywords and
uses them for processing.  To enable the Slackware keywords add the following
line to your startup file: >
	let dircolors_is_slackware = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{dircolors.vim}
@anchor{ft-dircolors-syntax}
@cindex dircolors.vim
@cindex ft-dircolors-syntax
@unnumberedsubsec DIRCOLORS
dircolors ユーティリティ用のハイライト定義には、Slackware GNU/Linux ディストリビューション版の dircolors に対応するためのオプションがある。このオプションはほとんどのバージョンでは無視されるいくつかのキーワードを付け加える。しかし Slackware システムでは dircolors はこれらのキーワードを認め、処理に用いる。Slackware キーワードを有効化するには次を起動設定ファイルに付け加えればよい:
@example
let dircolors_is_slackware = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DOCBOOK					*docbk.vim* *ft-docbk-syntax* *docbook*
DOCBOOK XML				*docbkxml.vim* *ft-docbkxml-syntax*
DOCBOOK SGML				*docbksgml.vim* *ft-docbksgml-syntax*

There are two types of DocBook files: SGML and XML.  To specify what type you
are using the "b:docbk_type" variable should be set.  Vim does this for you
automatically if it can recognize the type.  When Vim can't guess it the type
defaults to XML.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{docbk.vim}
@anchor{ft-docbk-syntax}
@anchor{docbook}
@anchor{docbkxml.vim}
@anchor{ft-docbkxml-syntax}
@anchor{docbksgml.vim}
@anchor{ft-docbksgml-syntax}
@cindex docbk.vim
@cindex ft-docbk-syntax
@cindex docbook
@cindex docbkxml.vim
@cindex ft-docbkxml-syntax
@cindex docbksgml.vim
@cindex ft-docbksgml-syntax
@unnumberedsubsec DOCBOOK または DOCBOOK XML または DOCBOOK SGML
DocBook ファイルには 2 つの種類: SGML と XML がある。どちらのタイプを使用するのかを指定するには変数 "b:docbk_type" をセットする。Vim がそのタイプを認識できた場合にはこれを自動的に行う。認識できなかった場合にはデフォルトは XML になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
You can set the type manually: >
	:let docbk_type = "sgml"
or: >
	:let docbk_type = "xml"
You need to do this before loading the syntax file, which is complicated.
Simpler is setting the filetype to "docbkxml" or "docbksgml": >
	:set filetype=docbksgml
or: >
	:set filetype=docbkxml

You can specify the DocBook version: >
	:let docbk_ver = 3
When not set 4 is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これを手動で設定するには:
@example
:let docbk_type = "sgml"
@end example
または:
@example
:let docbk_type = "xml"
@end example
これは構文ファイルを読み込む前に行う必要がある。しかし構文ファイルの読み込みは込み入っている。より単純な方法はファイル形式を "docbkxml" または "docbksgml" にセットすることである:
@example
:set filetype=docbksgml
@end example
または:
@example
:set filetype=docbkxml
@end example
DocBook のバージョンを指定できる:
@example
:let docbk_ver = 3
@end example
設定しない場合は 4 が使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DOSBATCH				*dosbatch.vim* *ft-dosbatch-syntax*

There is one option with highlighting DOS batch files.	This covers new
extensions to the Command Interpreter introduced with Windows 2000 and
is controlled by the variable dosbatch_cmdextversion.  For Windows NT
this should have the value 1, and for Windows 2000 it should be 2.
Select the version you want with the following line: >

   :let dosbatch_cmdextversion = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{dosbatch.vim}
@anchor{ft-dosbatch-syntax}
@cindex dosbatch.vim
@cindex ft-dosbatch-syntax
@unnumberedsubsec DOSBATCH
DOS バッチファイルのハイライトにはオプションが1つある。このオプションにより Windows 2000 で導入されたコマンドインタープリターの新しい拡張機能がサポートされ、変数 dosbatch_cmdextversion によりその有効/無効が制御される。Windows NT では値 1 を設定し、Windows 2000 では 2 を設定するのが良い。次のようにすれば使用するバージョンを選択できる:
@example
:let dosbatch_cmdextversion = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If this variable is not defined it defaults to a value of 2 to support
Windows 2000.

A second option covers whether *.btm files should be detected as type
"dosbatch" (MS-DOS batch files) or type "btm" (4DOS batch files).  The latter
is used by default.  You may select the former with the following line: >

   :let g:dosbatch_syntax_for_btm = 1

If this variable is undefined or zero, btm syntax is selected.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数が定義されていない際のデフォルトは Windows 2000 をサポートする 2 となる。

2 番目のオプションは、*.btm ファイルを "dosbatch" (MS-DOS バッチファイル) タイプか "btm" (4DOS バッチファイル) タイプのどちらと判定するかを指定する。デフォルトでは後者が使われる。前者を使うには、次のようにする:
@example
:let g:dosbatch_syntax_for_btm = 1
@end example
この変数が定義されていない、または 0 であると btm の構文が使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DOXYGEN						*doxygen.vim* *doxygen-syntax*

Doxygen generates code documentation using a special documentation format
(similar to Javadoc).  This syntax script adds doxygen highlighting to c, cpp,
idl and php files, and should also work with java.

There are a few of ways to turn on doxygen formatting. It can be done
explicitly or in a modeline by appending '.doxygen' to the syntax of the file.
Example: >
	:set syntax=c.doxygen
or >
	// vim:syntax=c.doxygen
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{doxygen.vim}
@anchor{doxygen-syntax}
@cindex doxygen.vim
@cindex doxygen-syntax
@unnumberedsubsec DOXYGEN
Doxygen は Javadoc に似た特殊なフォーマットからコードのドキュメントを生成する。この構文スクリプトは c, cpp, idl, php のファイルに対して Doxygen のハイライトを追加する。また、Java に対しても使える。

Doxygen のフォーマットを有効にするにはいくつかの方法がある。手動、またはモードラインでそのファイルの syntax に '.doxygen' を追加する。例:
@example
:set syntax=c.doxygen
@end example
または
@example
// vim:syntax=c.doxygen
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It can also be done automatically for C, C++, C#, IDL and PHP files by setting
the global or buffer-local variable load_doxygen_syntax.  This is done by
adding the following to your .vimrc. >
	:let g:load_doxygen_syntax=1

There are a couple of variables that have an effect on syntax highlighting, and
are to do with non-standard highlighting options.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
C, C++, C#, IDL, PHP のファイルに対しては、グローバルまたはバッファローカルな変数 load_doxygen_syntax を設定すれば自動的にこれが行われる。次の行を @file{.vimrc} に加える。
@example
:let g:load_doxygen_syntax=1
@end example
構文ハイライトに影響を与える変数がいくつかある。また、これらは標準でないハイライトオプションに関係している。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Variable			Default	Effect ~
g:doxygen_enhanced_color
g:doxygen_enhanced_colour	0	Use non-standard highlighting for
					doxygen comments.

doxygen_my_rendering		0	Disable rendering of HTML bold, italic
					and html_my_rendering underline.

doxygen_javadoc_autobrief	1	Set to 0 to disable javadoc autobrief
					colour highlighting.

doxygen_end_punctuation		'[.]'	Set to regexp match for the ending
					punctuation of brief
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .1 .5
@headitem 変数 @tab 既定値 @tab 効果
@item g:doxygen_enhanced_color @* g:doxygen_enhanced_colour @tab 0 @tab Doxygen コメントに対して標準でないハイライトを行う。
@item @ @tab @ @tab
@item doxygen_my_rendering @tab 0 @tab HTML の太字、斜体、html_my_rendering に対する下線の描画を無効にする。
@item @ @tab @ @tab
@item doxygen_javadoc_autobrief @tab 1 @tab 0 にすると JavaDoc の autobrief に対するハイライトを無効にする。
@item @ @tab @ @tab
@item doxygen_end_punctuation @tab '[.]' @tab brief の終わりを示す句読点にマッチする正規表現。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are also some hilight groups worth mentioning as they can be useful in
configuration.

Highlight			Effect ~
doxygenErrorComment		The colour of an end-comment when missing
				punctuation in a code, verbatim or dot section
doxygenLinkError		The colour of an end-comment when missing the
				\endlink from a \link section.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
また、次のハイライトグループを設定すると便利である。
@multitable @columnfractions .4 .6
@headitem ハイライト @tab 効果
@item doxygenErrorComment @tab code, verbatim, dot セクション中で句読点が抜けている終了コメントの色
@item doxygenLinkError @tab \link セクションで \endlink が抜けているときの終了コメントの色。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DTD						*dtd.vim* *ft-dtd-syntax*

The DTD syntax highlighting is case sensitive by default.  To disable
case-sensitive highlighting, add the following line to your startup file: >

	:let dtd_ignore_case=1

The DTD syntax file will highlight unknown tags as errors.  If
this is annoying, it can be turned off by setting: >

	:let dtd_no_tag_errors=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{dtd.vim}
@anchor{ft-dtd-syntax}
@cindex dtd.vim
@cindex ft-dtd-syntax
@unnumberedsubsec DTD
初期状態では DTD 構文ハイライトは大/小文字を区別する。区別しないようにするには、起動設定ファイルに次の行を書き足す:
@example
:let dtd_ignore_case=1
@end example
DTD 構文ファイルでは未知のタグをエラーとしてハイライトする。これが煩わしいならば、構文ファイル dtd.vim が読込まれる前に:
@example
:let dtd_no_tag_errors=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
before sourcing the dtd.vim syntax file.
Parameter entity names are highlighted in the definition using the
'Type' highlighting group and 'Comment' for punctuation and '%'.
Parameter entity instances are highlighted using the 'Constant'
highlighting group and the 'Type' highlighting group for the
delimiters % and ;.  This can be turned off by setting: >

	:let dtd_no_param_entities=1

The DTD syntax file is also included by xml.vim to highlight included dtd's.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
と設定することで無効化することができる。定義部内のパラメーターのエンティティ名はハイライトグループ 'Type'、句読点と '%' は 'Comment' を使用してハイライトされる。パラメーターエンティティの実体はハイライトグループ 'Constant' を、区切り文字の % と ; はハイライトグループ 'Type' を使用してハイライトされる。以下を設定するとこれを無効化できる:
@example
:let dtd_no_param_entities=1
@end example
XML内の埋め込み DTD をハイライト表示するために、DTD の構文ファイルは @file{xml.vim} からも参照される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
EIFFEL					*eiffel.vim* *ft-eiffel-syntax*

While Eiffel is not case-sensitive, its style guidelines are, and the
syntax highlighting file encourages their use.  This also allows to
highlight class names differently.  If you want to disable case-sensitive
highlighting, add the following line to your startup file: >

	:let eiffel_ignore_case=1

Case still matters for class names and TODO marks in comments.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{eiffel.vim}
@anchor{ft-eiffel-syntax}
@cindex eiffel.vim
@cindex ft-eiffel-syntax
@unnumberedsubsec EIFFEL
Eiffel は大小文字の区別をしないけれども、スタイルガイドラインが示すように、構文ハイライトではそれらが区別される。これにより大小文字が違えば違うクラス名としてハイライト表示することが可能になっている。大小文字の違いを無視してハイライトを行うならば、起動設定ファイルに次の行を書き足す:
@example
:let eiffel_ignore_case=1
@end example
これを行ってもコメント内のクラス名と TODO の印には大小文字の区別がなされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Conversely, for even stricter checks, add one of the following lines: >

	:let eiffel_strict=1
	:let eiffel_pedantic=1

Setting eiffel_strict will only catch improper capitalization for the
five predefined words "Current", "Void", "Result", "Precursor", and
"NONE", to warn against their accidental use as feature or class names.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
逆に、もっと厳密に検査するには、次の行のいずれかを書き足す:
@example
:let eiffel_strict=1
:let eiffel_pedantic=1
@end example
eiffel_strict を設定すると "Current", "Void", "Result", "Precursor" そして "NONE" の 5 つの既定単語について、不正な大小文字の使用を捕捉し、機能やクラス名としてそれらが使用されれば警告を与えるようになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Setting eiffel_pedantic will enforce adherence to the Eiffel style
guidelines fairly rigorously (like arbitrary mixes of upper- and
lowercase letters as well as outdated ways to capitalize keywords).

If you want to use the lower-case version of "Current", "Void",
"Result", and "Precursor", you can use >

	:let eiffel_lower_case_predef=1

instead of completely turning case-sensitive highlighting off.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
eiffel_pedantic を設定すると、Eiffel のスタイルガイドラインを相当に厳格に強制する。(キーワードを大文字で書く時代遅れの方法と同様に、大小文字を任意にミックスしたようなものが捕捉される)
"Current", "Void", "Result" そして "Precursor" の小文字版を使用するには、大小文字を区別するハイライト方法を無効化する代わりに:
@example
:let eiffel_lower_case_predef=1
@end example
という方法を使うことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Support for ISE's proposed new creation syntax that is already
experimentally handled by some compilers can be enabled by: >

	:let eiffel_ise=1

Finally, some vendors support hexadecimal constants.  To handle them, add >

	:let eiffel_hex_constants=1

to your startup file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ISE が提案し、実験的に幾つかのコンパイラでは取り扱うことのできる、新しい生成構文は次のコマンドで使用できるようになる:
@example
:let eiffel_ise=1
@end example
最後に幾つかのベンダーは16進数定数値をサポートしている。それを取り扱うには:
@example
:let eiffel_hex_constants=1
@end example
この行を起動設定ファイルに書き足す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
EUPHORIA	    *euphoria3.vim* *euphoria4.vim* *ft-euphoria-syntax*

Two syntax highlighting files exists for Euphoria. One for Euphoria 
version 3.1.1, which is the default syntax highlighting file, and one for 
Euphoria version 4.0.5 or later.

Euphoria version 3.1.1 (http://www.rapideuphoria.com/) is still necessary 
for developing applications for the DOS platform, which Euphoria version 4 
(http://www.openeuphoria.org/) does not support.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{euphoria3.vim}
@anchor{euphoria4.vim}
@anchor{ft-euphoria-syntax}
@cindex euphoria3.vim
@cindex euphoria4.vim
@cindex ft-euphoria-syntax
@unnumberedsubsec EUPHORIA
Euphoria には 2 つの構文強調表示ファイルがある。1 つは Euphoria バージョン 3.1.1 用で、初期設定ではこれが使われる。もう 1 つは Euphoria 4.0.5 以降用である。

Euphoria バージョン 3.1.1 (http://www.rapideuphoria.com/) は DOS プラットフォームのアプリケーションの開発にまだ必要とされている。Euphoria バージョン 4 (@url{http://www.openeuphoria.org/}) はそれをサポートしていない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The following file extensions are auto-detected as Euphoria file type: 
    
	*.e, *.eu, *.ew, *.ex, *.exu, *.exw
	*.E, *.EU, *.EW, *.EX, *.EXU, *.EXW

To select syntax highlighting file for Euphoria, as well as for 
auto-detecting the *.e and *.E file extensions as Euphoria file type,
add the following line to your startup file: >

	:let filetype_euphoria="euphoria3"

	or 

	:let filetype_euphoria="euphoria4"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下の拡張子のファイルは自動的に Euphoria ファイルタイプとして認識される:

 *.e, *.eu, *.ew, *.ex, *.exu, *.exw, *.E, *.EU, *.EW, *.EX, *.EXU, *.EXW

Euphoria の構文強調ファイルを選択するには (*.e や *.E 拡張子のファイルが自動的に Euphoria ファイルタイプとして認識された場合でも)、次の行を設定ファイルに加える:
@example
:let filetype_euphoria="euphoria3"
@end example
または
@example
:let filetype_euphoria="euphoria4"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ERLANG						*erlang.vim* *ft-erlang-syntax*

Erlang is a functional programming language developed by Ericsson.  Files with
the following extensions are recognized as Erlang files: erl, hrl, yaws.

The BIFs (built-in functions) are highlighted by default. To disable this,
put the following line in your vimrc: >

      :let g:erlang_highlight_bifs = 0

To enable highlighting some special atoms, put this in your vimrc: >

      :let g:erlang_highlight_special_atoms = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{erlang.vim}
@anchor{ft-erlang-syntax}
@cindex erlang.vim
@cindex ft-erlang-syntax
@unnumberedsubsec ERLANG
Erlang は Ericsson が開発した関数型プログラミング言語である。次の拡張子のファイルが Erlang ファイルとして認識される:

erl, hrl, yaws

組み込み関数 (BIFs: built-in functions) は初期設定で強調表示される。それを無効化するには vimrc で次のように設定する:
@example
:let g:erlang_highlight_bifs = 0
@end example
いくつかの特殊アトムを強調表示するには、vimrc で次のように設定する:
@example
:let g:erlang_highlight_special_atoms = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
FLEXWIKI				*flexwiki.vim* *ft-flexwiki-syntax*

FlexWiki is an ASP.NET-based wiki package available at http://www.flexwiki.com
NOTE: this site currently doesn't work, on Wikipedia is mentioned that
development stopped in 2009.

Syntax highlighting is available for the most common elements of FlexWiki
syntax. The associated ftplugin script sets some buffer-local options to make
editing FlexWiki pages more convenient. FlexWiki considers a newline as the
start of a new paragraph, so the ftplugin sets 'tw'=0 (unlimited line length),
'wrap' (wrap long lines instead of using horizontal scrolling), 'linebreak'
(to wrap at a character in 'breakat' instead of at the last char on screen),
and so on. It also includes some keymaps that are disabled by default.

If you want to enable the keymaps that make "j" and "k" and the cursor keys
move up and down by display lines, add this to your .vimrc: >
	:let flexwiki_maps = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{flexwiki.vim}
@anchor{ft-flexwiki-syntax}
@cindex flexwiki.vim
@cindex ft-flexwiki-syntax
@unnumberedsubsec FLEXWIKI
FlexWiki は @url{http://www.flexwiki.com} で入手できる ASP.NET ベースの wiki パッケージである。
@quotation
@strong{Note:} @*
このサイトは現在機能していない。Wikipedia によると 2009 年に開発がストップした。
@end quotation
FlexWiki の構文のほとんどの一般的な要素に対して構文ハイライトができる。FlexWiki の tplugin スクリプトはバッファローカルなオプションを設定し、FlexWiki ページの編集をより便利にする。FlexWiki は改行を新しい段落の開始とみなすので、この ftplugin は 'tw' を 0 に設定し (行の長さを制限しない)、'@option{wrap}' をオンにし (長い行を水平スクロールさせるのでなく、折り返す)、'@option{linebreak}' をオンにする (画面上の最後の文字でなく '@option{breakat}' の文字で折り返す)、などを行う。また、デフォルトでは無効にされているキーマップも含んでいる。

"j"、"k"、カーソルキーで表示行単位で移動するようにするキーマップを有効にするには次を @file{.vimrc} に追加する:
@example
:let flexwiki_maps = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
FORM						*form.vim* *ft-form-syntax*

The coloring scheme for syntax elements in the FORM file uses the default
modes Conditional, Number, Statement, Comment, PreProc, Type, and String,
following the language specifications in 'Symbolic Manipulation with FORM' by
J.A.M. Vermaseren, CAN, Netherlands, 1991.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{form.vim}
@anchor{ft-form-syntax}
@cindex form.vim
@cindex ft-form-syntax
@unnumberedsubsec FORM
FORM ファイルの構文要素に使用するカラースキームには、Conditional, Number, Statement, Comment, PreProc, Type, そして String が、次の文献で定義される言語仕様に沿って行われる。
文献: '@cite{Symbolic Manipulation with FORM' by J.A.M. Vermaseren, CAN, Netherlands, 1991.}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want include your own changes to the default colors, you have to
redefine the following syntax groups:

    - formConditional
    - formNumber
    - formStatement
    - formHeaderStatement
    - formComment
    - formPreProc
    - formDirective
    - formType
    - formString

Note that the form.vim syntax file implements FORM preprocessor commands and
directives per default in the same syntax group.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
初期設定の色に変更を加えるには、次の構文グループを再定義すれば良い:
@itemize
@item formConditional
@item formNumber
@item formStatement
@item formHeaderStatement
@item formComment
@item formPreProc
@item formDirective
@item formType
@item formString
@end itemize
@quotation
@strong{Note:} @*
構文ファイル @file{form.vim} では FORM プリプロセッサーコマンドとディレクティブをそれぞれ、デフォルトでは同じ構文グループにしていることに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A predefined enhanced color mode for FORM is available to distinguish between
header statements and statements in the body of a FORM program.  To activate
this mode define the following variable in your vimrc file >

	:let form_enhanced_color=1

The enhanced mode also takes advantage of additional color features for a dark
gvim display.  Here, statements are colored LightYellow instead of Yellow, and
conditionals are LightBlue for better distinction.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
FORM 用の既定の拡張カラーモードではヘッダー命令と FORM プログラム本体での命令を区別できるような色設定が利用可能である。拡張カラーモードを使用可能にするには、ファイル @file{vimrc} に次の設定を書き足す:
@example
:let form_enhanced_color=1
@end example
拡張モードを使うことは、gvim で暗いディスプレイを使用した場合にも利点がある。命令文は黄色ではなく明るい黄色で表示され、条件文は視認性のため明るい青で表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
FORTRAN					*fortran.vim* *ft-fortran-syntax*

Default highlighting and dialect ~
Highlighting appropriate for Fortran 2008 is used by default.  This choice
should be appropriate for most users most of the time because Fortran 2008 is
almost a superset of previous versions (Fortran 2003, 95, 90, and 77).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{fortran.vim}
@anchor{ft-fortran-syntax}
@cindex fortran.vim
@cindex ft-fortran-syntax
@unnumberedsubsec FORTRAN
@unnumberedsubsubsec デフォルトのハイライトと方言
初期設定では Fortran 2008 に適したハイライトが行われる。Fortran 2008 は以前のバージョン (Fortran 2003, 95, 90, 77) のほぼ上位互換であるため、この初期設定はほとんどのユーザーにとって適しているだろう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Fortran source code form ~
Fortran code can be in either fixed or free source form.  Note that the
syntax highlighting will not be correct if the form is incorrectly set.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec Fortranソースコードの形式
Fortran のソースコードには固定形式と自由形式が有る。形式が誤って設定されていると構文ハイライトが正しくされないことに注意。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you create a new fortran file, the syntax script assumes fixed source
form.  If you always use free source form, then >
    :let fortran_free_source=1
in your .vimrc prior to the :syntax on command.  If you always use fixed source
form, then >
    :let fortran_fixed_source=1
in your .vimrc prior to the :syntax on command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新規に Fortran のファイルを作成する場合には、構文ファイルは固定形式であると仮定する。常に自由形式を使う場合には
@example
:let fortran_free_source=1
@end example
これを @file{.vimrc} でコマンド @command{:syntax} を実行する前に行う必要がある。常に固定形式を使うには
@example
:let fortran_fixed_source=1
@end example
これも @file{.vimrc} でコマンド @command{:syntax} を実行する前に行う必要がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the form of the source code depends, in a non-standard way, upon the file
extension, then it is most convenient to set fortran_free_source in a ftplugin
file.  For more information on ftplugin files, see |ftplugin|. Note that this
will work only if the "filetype plugin indent on" command precedes the "syntax
on" command in your .vimrc file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ソースコードの形式もしくは標準的な方法ではないがファイルの拡張子に依存する場合、もっとも簡単な方法は ftplugin の中で fortran_free_source を設定する。ftplugin ファイルのより詳細な情報は |@ref{ftplugin}| を参照。
@quotation
@strong{Note:} @*
あなたの @file{.vimrc} ファイルで "filetype plugin indent on" コマンドを "syntax on" よりも前に実行した場合にのみ動作する事に注意する。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you edit an existing fortran file, the syntax script will assume free
source form if the fortran_free_source variable has been set, and assumes
fixed source form if the fortran_fixed_source variable has been set.  If
neither of these variables have been set, the syntax script attempts to
determine which source form has been used by examining the file extension
using conventions common to the ifort, gfortran, Cray, NAG, and PathScale
compilers (.f, .for, .f77 for fixed-source, .f90, .f95, .f03, .f08 for
free-source). If none of this works, then the script examines the first five
columns of the first 500 lines of your file.  If no signs of free source form
are detected, then the file is assumed to be in fixed source form.  The
algorithm should work in the vast majority of cases.  In some cases, such as a
file that begins with 500 or more full-line comments, the script may
incorrectly decide that the fortran code is in fixed form.  If that happens,
just add a non-comment statement beginning anywhere in the first five columns
of the first twenty-five lines, save (:w) and then reload (:e!) the file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
既存の Fortran ファイルを編集する時には、変数 fortran_free_source が設定されていれば構文ファイルは自由形式のソースであると仮定し、変数 fortran_fixed_source が設定されていれば固定形式のソースであると仮定する。

どちらも設定されていない場合は、ifort, gfortran Cray, NAG, PathScale コンパイラ (.f, .for, 固定形式の .f77, .f90, .f95, .f03, 自由形式の .f08) の共通的な拡張子の変換を試みてどのソースが使われているのかを判定する。

それでもうまく行かない場合はファイルの先頭 250 行の行頭5カラムを調べて、その形式が固定形式なのか自由形式なのかの判定を試みる。自由形式のコードの兆候が見られない場合には、固定形式であると見なされる。

このアルゴリズムはほとんどのケースにおいて有効に機能する。しかしいくつかのケース、例えば先頭 500 行以上が行コメントで占められているようなファイルでは、構文ファイルが固定形式の fortran のコードであると誤った判断をしてしまうかもしれない。

そのような場合には、ファイルの先頭 500 行 の行頭 5 桁のどこかに、コメント以外の命令文を追加し、ファイルの保存 (:w) そして再読込 (:e!) を行う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Tabs in fortran files ~
Tabs are not recognized by the Fortran standards.  Tabs are not a good idea in
fixed format fortran source code which requires fixed column boundaries.
Therefore, tabs are marked as errors.  Nevertheless, some programmers like
using tabs.  If your fortran files contain tabs, then you should set the
variable fortran_have_tabs in your .vimrc with a command such as >
    :let fortran_have_tabs=1
placed prior to the :syntax on command.  Unfortunately, the use of tabs will
mean that the syntax file will not be able to detect incorrect margins.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec Fortran ファイル内のタブ文字
標準の Fortran ではタブ文字は認識されない。固定桁位置での境界を必要とする固定形式の Fortran ソースコードでタブ文字を使用するのは良いアイデアではない。従ってタブ文字はエラーとしてハイライトされる。

しかしながらプログラマによってはタブ文字を使用することを望む場合があるだろう。Fortran ファイルにタブ文字が含まれている場合には、変数 fortran_have_tabs をコマンド @command{:syntax} が実行される前に
@example
:let fortran_have_tabs=1
@end example
このように @file{.vimrc} で設定すれば良い。タブ文字を使う場合には残念ながら、構文ファイルによって不正な余白を検出することができなくなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Syntax folding of fortran files ~
If you wish to use foldmethod=syntax, then you must first set the variable
fortran_fold with a command such as >
    :let fortran_fold=1
to instruct the syntax script to define fold regions for program units, that
is main programs starting with a program statement, subroutines, function
subprograms, block data subprograms, interface blocks, and modules.  If you
also set the variable fortran_fold_conditionals with a command such as >
    :let fortran_fold_conditionals=1
then fold regions will also be defined for do loops, if blocks, and select
case constructs.  If you also set the variable
fortran_fold_multilinecomments with a command such as >
    :let fortran_fold_multilinecomments=1
then fold regions will also be defined for three or more consecutive comment
lines.  Note that defining fold regions can be slow for large files.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec Fortran ファイルの構文による折り畳み
foldmethod=syntax を使用したいならば、まず変数 fortran_fold を
@example
:let fortran_fold=1
@end example
このようなコマンドで設定しなければならない。これにより構文ファイルはプログラム単位の領域、プログラム命令文で始まるメインプログラム、サブルーチン、関数、サブプログラム、ブロックデータサブプログラム、そしてモジュールといったプログラム単位の領域で折り畳みを定義する。同時に変数 fortran_fold_conditionals を
@example
:let fortran_fold_conditionals=1
@end example
このように設定すると、do ループ、if ブロック、そして select-case 構造の領域が折り畳まれる。さらに変数 fortran_fold_multilinecomments も
@example
:let fortran_fold_multilinecomments=1
@end example
このように設定すれば、3 行以上にわたって続くコメントの領域が折り畳まれる。大きなファイルに対してこのように構文による折り畳みを使用すると、非常に遅くなることに注意。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If fortran_fold, and possibly fortran_fold_conditionals and/or
fortran_fold_multilinecomments, have been set, then vim will fold your file if
you set foldmethod=syntax.  Comments or blank lines placed between two program
units are not folded because they are seen as not belonging to any program
unit.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
fortran_fold を設定し、fortran_fold_conditionals か fortran_fold_multilinecomments (どちらか片方でも両方でも) を設定した場合には、foldmethod=syntax を設定してある時に、Vim はファイルを折り畳む。2 つのプログラム単位の間にあるコメントや空行は折り畳まれない。なぜならそれらは構文によって定義されるプログラム単位に属していないからである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
More precise fortran syntax ~
If you set the variable fortran_more_precise with a command such as >
    :let fortran_more_precise=1
then the syntax coloring will be more precise but slower.  In particular,
statement labels used in do, goto and arithmetic if statements will be
recognized, as will construct names at the end of a do, if, select or forall
construct.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec より正確な Fortran の構文
変数 fortran_more_precise を
@example
:let fortran_more_precise=1
@end example
このようなコマンドで設定した場合には、構文ハイライトがより正確になるが動作は遅くなる。とりわけ、do, goto そして算術 if 命令文に使用される命令ラベルが、do, if, select もしくは forall 構造の終端で使用される名前として認識されるようになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Non-default fortran dialects ~
The syntax script supports two Fortran dialects: f08 and F. You will probably
find the default highlighting (f08) satisfactory.  A few legacy constructs
deleted or declared obsolescent in the 2008 standard are highlighted as todo
items.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec 非標準のFortran方言
構文ファイルは 2 つの Fortran 方言 (f08 と F) をサポートしている。ほとんどの人はデフォルトのハイライト (f08) で用が足りるだろう。2008 標準で削除または廃止予定となったいくつかの古い構造は todo アイテムとしてハイライトされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you use F, the advantage of setting the dialect appropriately is that
other legacy features excluded from F will be highlighted as todo items and
that free source form will be assumed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
F を使うなら、方言を適切に設定することで、F から除外された他の古い機能は todo アイテムとしてハイライトされ、そして自由形式のソースコードが仮定される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The dialect can be selected in various ways.  If all your fortran files use
the same dialect, set the global variable fortran_dialect in your .vimrc prior
to your syntax on statement.  The case-sensitive, permissible values of
fortran_dialect are "f08" or "F".  Invalid values of fortran_dialect are
ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
方言を設定する方法はいくつかある。もしあなたの fortran ファイルがすべて同じ方言なら、グローバル変数の fortran_dialect を @file{.vimrc} の syntax on より前で設定すればよい。値は大文字と小文字が区別される。fortran_dialect に設定できる値は "f08" か "F" である。fortran_dialect に無効な値を設定した場合は無視される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the dialect depends upon the file extension, then it is most convenient to
set a buffer-local variable in a ftplugin file.  For more information on
ftplugin files, see |ftplugin|.  For example, if all your fortran files with
an .f90 extension are written in the F subset, your ftplugin file should
contain the code >
    let s:extfname = expand("%:e")
    if s:extfname ==? "f90"
	let b:fortran_dialect="F"
    else
	unlet! b:fortran_dialect
    endif
Note that this will work only if the "filetype plugin indent on" command
precedes the "syntax on" command in your .vimrc file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
方言がファイルの拡張子に依存して決定される場合には、ftplugin ファイル内でバッファローカル変数を設定するのが最良の手段である。ftplugin ファイル付いての詳細な情報は |@ref{ftplugin}| を参照。例えば、.f90 という拡張子のすべてのファイルが F サブセットで書かれているなら、ftplugin ファイルには次のようなコードが含まれるだろう
@verbatim
let s:extfname = expand("%:e")
if s:extfname ==? "f90"
   let b:fortran_dialect="F"
else
   unlet! b:fortran_dialect
endif
@end verbatim
これは @file{.vimrc} で "@command{syntax on}" より前に "filetype plugin indent on" が書かれていないと機能しないことに注意。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Finer control is necessary if the file extension does not uniquely identify
the dialect.  You can override the default dialect, on a file-by-file basis,
by including a comment with the directive "fortran_dialect=xx" (where xx=F or
f08) in one of the first three lines in your file.  For example, your older .f
files may be legacy code but your newer ones may be F codes, and you would
identify the latter by including in the first three lines of those files a
Fortran comment of the form >
  ! fortran_dialect=F
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
拡張子によって方言を一意に決定できない場合にはもっと良い制御方法が必要になる。各ファイルの先頭 3 行以内にコメントで "fortran_dialect=xx" (xx は F or f8) という命令を書けば方言の設定を上書することができる。

例えば、古い .f ファイルは古い方言で書かれているが、新しい .f ファイルは F コードで書きたいような場合、後者を F ファイルとして認識させるには、そのファイルの先頭 3 行以内に Fortran のコメントとして次のように書く
@example
! fortran_dialect=F
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For previous versions of the syntax, you may have set fortran_dialect to the
now-obsolete values "f77", "f90", "f95", or "elf". Such settings will be
silently handled as "f08". Users of "elf" may wish to experiment with "F"
instead.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この構文ファイルの以前のバージョンでは fortran_dialect の値として "f77", "f90", "f95", "elf" が設定できた。これらの値が設定されているときは "f08" として扱われる。"elf" を設定していた人は "F" を試してみるといいかもしれない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The syntax/fortran.vim script contains embedded comments that tell you how to
comment and/or uncomment some lines to (a) activate recognition of some
non-standard, vendor-supplied intrinsics and (b) to prevent features deleted
or declared obsolescent in the 2008 standard from being highlighted as todo
items.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
syntax/@file{fortran.vim} スクリプトにはヒントとなるコメントが含まれている。行をコメントアウトしたりコメントを外したりすることで、(a) 非標準またはベンダー固有構文の認識を有効化したり、(b) 2008 標準で削除または廃止予定となった機能を todo アイテムとしてハイライトしないようにしたりできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Limitations ~
Parenthesis checking does not catch too few closing parentheses.  Hollerith
strings are not recognized.  Some keywords may be highlighted incorrectly
because Fortran90 has no reserved words.

For further information related to fortran, see |ft-fortran-indent| and
|ft-fortran-plugin|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec 制限事項
丸カッコチェックは、閉じカッコの不足については捕捉できない。ホレリス定数は認識されない。幾つかのキーワードはFortran90の予約語ではないので誤ってハイライトされる。

Fortran に関するその他の情報は |@ref{ft-fortran-indent}| や |@ref{ft-fortran-plugin}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
FVWM CONFIGURATION FILES			*fvwm.vim* *ft-fvwm-syntax*

In order for Vim to recognize Fvwm configuration files that do not match
the patterns *fvwmrc* or *fvwm2rc* , you must put additional patterns
appropriate to your system in your myfiletypes.vim file.  For these
patterns, you must set the variable "b:fvwm_version" to the major version
number of Fvwm, and the 'filetype' option to fvwm.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{fvwm.vim}
@anchor{ft-fvwm-syntax}
@cindex fvwm.vim
@cindex ft-fvwm-syntax
@anchor{fvwmrc}
@anchor{fvwm2rc}
@cindex fvwmrc
@cindex fvwm2rc
@unnumberedsubsec FVWM CONFIGURATION FILES
fvwmrc または fvwm2rc というパターンにマッチしない Fvwm 設定ファイルを認識させるには、ファイル @file{myfiletypefile.vim} で あなたのシステムに合ったパターンを設定しなければならない。具体的には、変数 "b:fvwm_version" に Fvwm のメジャーバージョンを指定し、オプション '@option{filetype}' に fvwm を設定する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For example, to make Vim identify all files in /etc/X11/fvwm2/
as Fvwm2 configuration files, add the following: >

  :au! BufNewFile,BufRead /etc/X11/fvwm2/*  let b:fvwm_version = 2 |
					 \ set filetype=fvwm
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば、/etc/X11/fvwm2/配下の全てのファイルをFvwm2の設定ファイルと認識させるには次のようにする:
@example
:au! BufNewFile,BufRead /etc/X11/fvwm2/*  let b:fvwm_version = 2 |
                                       \ set filetype=fvwm
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you'd like Vim to highlight all valid color names, tell it where to
find the color database (rgb.txt) on your system.  Do this by setting
"rgb_file" to its location.  Assuming your color database is located
in /usr/X11/lib/X11/, you should add the line >

	:let rgb_file = "/usr/X11/lib/X11/rgb.txt"

to your .vimrc file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
全ての有効な色の名前を Vim にハイライトさせるには、システムの色データベース (@file{rgb.txt}) の位置を知らせる必要がある。これには変数 "rgb_file" にその場所を設定する。色データベースが /usr/X11/lib/X11/ にあるとすれば:
@example
:let rgb_file = "/usr/X11/lib/X11/rgb.txt"
@end example
このような内容をファイル @file{.vimrc} に追加する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
GSP						*gsp.vim* *ft-gsp-syntax*

The default coloring style for GSP pages is defined by |html.vim|, and
the coloring for java code (within java tags or inline between backticks)
is defined by |java.vim|.  The following HTML groups defined in |html.vim|
are redefined to incorporate and highlight inline java code:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gsp.vim}
@anchor{ft-gsp-syntax}
@cindex gsp.vim
@cindex ft-gsp-syntax
@unnumberedsubsec GSP
GSP ページのデフォルトカラーは |@ref{html.vim}| にて定義され、Java コード (Java タグ内部やインラインのバッククォート内) のカラーは |@ref{java.vim}| にて定義される。インライン Java コードをハイライトするために、|@ref{html.vim}| で定義される以下の HTML グループは、再定義されている:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
    htmlString
    htmlValue
    htmlEndTag
    htmlTag
    htmlTagN
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .99
@item htmlString
@item htmlValue
@item htmlEndTag
@item htmlTag
@item htmlTagN
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Highlighting should look fine most of the places where you'd see inline
java code, but in some special cases it may not.  To add another HTML
group where you will have inline java code where it does not highlight
correctly, just copy the line you want from |html.vim| and add gspJava
to the contains clause.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
書かれた大抵の場所のインライン Java コードは適切にハイライトされるが、幾つかの特殊なケースではそうはならない。他の HTML グループ内にインライン Java コードを書いてそれが正しくハイライトされない場合には、必要な行を |@ref{html.vim}| からコピーして gspJava を constains 節に加えれば、正しくハイライトされるようになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The backticks for inline java are highlighted according to the htmlError
group to make them easier to see.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
インライン Java を示すバッククォートは、目立ちやすくするために htmlError グループでハイライトされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
GROFF						*groff.vim* *ft-groff-syntax*

The groff syntax file is a wrapper for |nroff.vim|, see the notes
under that heading for examples of use and configuration.  The purpose
of this wrapper is to set up groff syntax extensions by setting the
filetype from a |modeline| or in a personal filetype definitions file
(see |filetype.txt|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{groff.vim}
@anchor{ft-groff-syntax}
@cindex groff.vim
@cindex ft-groff-syntax
@unnumberedsubsec GROFF
groff 構文ファイルは |@ref{nroff.vim}| のラッパーであり、使用例と設定例についてはそこの下に書かれている注意を参照。このラッパーの目的は、モードライン (|@ref{modeline}|) か個人用のファイル定義ファイル (|@ref{filetype.txt}| 参照) からファイル形式をセットすることにより、groff 構文拡張を設定することである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
HASKELL			     *haskell.vim* *lhaskell.vim* *ft-haskell-syntax*

The Haskell syntax files support plain Haskell code as well as literate
Haskell code, the latter in both Bird style and TeX style.  The Haskell
syntax highlighting will also highlight C preprocessor directives.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{haskell.vim}
@anchor{lhaskell.vim}
@anchor{ft-haskell-syntax}
@cindex haskell.vim
@cindex lhaskell.vim
@cindex ft-haskell-syntax
@unnumberedsubsec HASKELL
Haskell 構文ファイルは、プレーン Haskell コードと literate Haskell コード両方をサポートしている。後者は Bird スタイルと TeX スタイル両方に対応している。Haskell 用の構文ハイライトは C プリプロセッサー命令もハイライトできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to highlight delimiter characters (useful if you have a
light-coloured background), add to your .vimrc: >
	:let hs_highlight_delimiters = 1
To treat True and False as keywords as opposed to ordinary identifiers,
add: >
	:let hs_highlight_boolean = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
区切り文字もハイライトさせるには (明るい背景色を使っているなら便利)、次を @file{.vimrc} に書き足す:
@example
:let hs_highlight_delimiters = 1
@end example
True と False を通常の識別子と区別してキーワードとして扱うにはこれを書き足す:
@example
:let hs_highlight_boolean = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
To also treat the names of primitive types as keywords: >
	:let hs_highlight_types = 1
And to treat the names of even more relatively common types as keywords: >
	:let hs_highlight_more_types = 1
If you want to highlight the names of debugging functions, put in
your .vimrc: >
	:let hs_highlight_debug = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プリミティブ型の名前をキーワードして扱うには:
@example
:let hs_highlight_types = 1
@end example
比較的一般的な型の名前をキーワードとして扱うには:
@example
:let hs_highlight_more_types = 1
@end example
デバッグ関数の名前をハイライトさせるには、これを.vimrcに書き足す:
@example
:let hs_highlight_debug = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The Haskell syntax highlighting also highlights C preprocessor
directives, and flags lines that start with # but are not valid
directives as erroneous.  This interferes with Haskell's syntax for
operators, as they may start with #.  If you want to highlight those
as operators as opposed to errors, put in your .vimrc: >
	:let hs_allow_hash_operator = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Haskell 用の構文ハイライトは C プリプロセッサー命令もハイライトし、# で始まるが命令として有効でない行をエラーとして警告する。Haskell の演算子の構文は#で始まることもあるため、これらが干渉する。これらをエラーでなく演算子としてハイライトしたいなら、次を @file{.vimrc} に書く:
@example
:let hs_allow_hash_operator = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The syntax highlighting for literate Haskell code will try to
automatically guess whether your literate Haskell code contains
TeX markup or not, and correspondingly highlight TeX constructs
or nothing at all.  You can override this globally by putting
in your .vimrc >
	:let lhs_markup = none
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
literate Haskell コード用の構文ハイライトはファイルが TeX マークアップを含んでいるかどうか、それに応じて TeX 要素をハイライトするかどうかを自動的に推測しようとする。@file{.vimrc} に次のような行を書くと、これをグローバルに上書きすることができる
@example
:let lhs_markup = none
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
for no highlighting at all, or >
	:let lhs_markup = tex
to force the highlighting to always try to highlight TeX markup.
For more flexibility, you may also use buffer local versions of
this variable, so e.g. >
	:let b:lhs_markup = tex
will force TeX highlighting for a particular buffer.  It has to be
set before turning syntax highlighting on for the buffer or
loading a file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
と書くとまったくハイライトしなくする。または
@example
:let lhs_markup = tex
@end example
と書くと常に TeX マークアップをハイライトするように強制する。より柔軟に、この変数のバッファローカル版を使うこともできる。例:
@example
:let b:lhs_markup = tex
@end example
と書くと特定のバッファに TeX ハイライトさせるようにする。これはそのバッファに構文ハイライトを有効化するかファイルを読み込む前に設定しなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
HTML						*html.vim* *ft-html-syntax*

The coloring scheme for tags in the HTML file works as follows.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{html.vim}
@anchor{ft-html-syntax}
@cindex html.vim
@cindex ft-html-syntax
@unnumberedsubsec HTML
HTML ファイルのタグ用の構文ファイルは以下のように動作する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The  <> of opening tags are colored differently than the </> of a closing tag.
This is on purpose! For opening tags the 'Function' color is used, while for
closing tags the 'Type' color is used (See syntax.vim to check how those are
defined for you)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
開きタグの <> は、閉じタグの </> とは異なった色でハイライトされる。これは意図的にそうしてある！開きタグにはハイライト 'Function' が使用され、閉じタグにはハイライト 'Type' が使用される (あなたの環境でこれらがどう定義されているかについては @file{syntax.vim} を参照すること)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Known tag names are colored the same way as statements in C.  Unknown tag
names are colored with the same color as the <> or </> respectively which
makes it easy to spot errors
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
既知のタグ名は C 命令文と同じようにハイライトされる。未知のタグ名は間違いを見分けやすくするために、<> や </> と同じようにハイライトされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that the same is true for argument (or attribute) names.  Known attribute
names are colored differently than unknown ones.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
引数 (もしくは属性) 名にも同じことが言える。既知の属性名と未知の属性名には異なるハイライトがなされる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Some HTML tags are used to change the rendering of text.  The following tags
are recognized by the html.vim syntax coloring file and change the way normal
text is shown: <B> <I> <U> <EM> <STRONG> (<EM> is used as an alias for <I>,
while <STRONG> as an alias for <B>), <H1> - <H6>, <HEAD>, <TITLE> and <A>, but
only if used as a link (that is, it must include a href as in
<A href="somefile.html">).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
幾つかの HTML タグは表示する文字種を変更するために使用される。以下のタグは構文ファイル @file{html.vim} によって認識され、その内容は通常の文字種とは異なる文字種で表示される: <B> <I> <U> <EM> <STRONG> (<EM> は <I> のエイリアスとして使われ、<STRONG> は <B> のエイリアス)、<H1> - <H6>, <HEAD>, <TITLE> そして <A> ただし href が含まれていてリンクとして使われている (例 <A href="somefile.html"> )場合。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to change how such text is rendered, you must redefine the
following syntax groups:

    - htmlBold
    - htmlBoldUnderline
    - htmlBoldUnderlineItalic
    - htmlUnderline
    - htmlUnderlineItalic
    - htmlItalic
    - htmlTitle for titles
    - htmlH1 - htmlH6 for headings
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
それらのテキストの文字種を変更するには、以下の構文グループを再定義する必要がある:
@itemize
@item htmlBold
@item htmlBoldUnderline
@item htmlBoldUnderlineItalic
@item htmlUnderline
@item htmlUnderlineItalic
@item htmlItalic
@item htmlTitle タイトル用
@item htmlH1 - htmlH6 見出し用
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To make this redefinition work you must redefine them all with the exception
of the last two (htmlTitle and htmlH[1-6], which are optional) and define the
following variable in your vimrc (this is due to the order in which the files
are read during initialization) >
	:let html_my_rendering=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この再定義が機能するためには最後の 2 つを除くすべてを再定義しなければならない。最後の 2 つ、htmlTitle と htmlH[1-6] は任意である。そして次の変数を vimrc で設定しなければならない (初期化の際に読み込まれるファイルの順序のせい)。
@example
:let html_my_rendering=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you'd like to see an example download mysyntax.vim at
http://www.fleiner.com/vim/download.html
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この例については以下から @file{mysyntax.vim} をダウンロードすること。

@url{http://www.fleiner.com/vim/download.html}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can also disable this rendering by adding the following line to your
vimrc file: >
	:let html_no_rendering=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次の行を vimrc に加えればこの描画を無効にできる:
@example
:let html_no_rendering=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
HTML comments are rather special (see an HTML reference document for the
details), and the syntax coloring scheme will highlight all errors.
However, if you prefer to use the wrong style (starts with <!-- and
ends with -->) you can define >
	:let html_wrong_comments=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
HTML コメントはむしろ特別で (詳細は HTML リファレンスドキュメントを参照)、すべてのエラーをハイライトする。しかしその間違ったスタイル (<!--で始まり--> で終わる) を使いたいならこれを定義する
@example
:let html_wrong_comments=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
JavaScript and Visual Basic embedded inside HTML documents are highlighted as
'Special' with statements, comments, strings and so on colored as in standard
programming languages.  Note that only JavaScript and Visual Basic are currently
supported, no other scripting language has been added yet.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
HTML ドキュメント中に埋め込まれた JavaScript や Visual Basic については、文は '@option{Special}' でハイライトされ、コメントや文字列などは標準のプログラミング言語と同じように色づけされる。現在のところサポートされているのは JavaScript と Visual Basic だけであり、他のスクリプト言語はまだ加えられていない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Embedded and inlined cascading style sheets (CSS) are highlighted too.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カスケードスタイルシート (CSS) の埋め込みとインラインもハイライトされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are several html preprocessor languages out there.  html.vim has been
written such that it should be trivial to include it.  To do so add the
following two lines to the syntax coloring file for that language
(the example comes from the asp.vim file):

    runtime! syntax/html.vim
    syn cluster htmlPreproc add=asp
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
html プロセッサー言語は複数ある。@file{html.vim} はインクルードしやすいように簡素に書かれている。@file{html.vim} をインクルードするには以下の 2 行をその言語用の構文ファイルに書き足すこと (この例は @file{asp.vim} からとった):
@example
runtime! syntax/html.vim
syn cluster htmlPreproc add=asp
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now you just need to make sure that you add all regions that contain
the preprocessor language to the cluster htmlPreproc.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
そしてプリプロセッサー言語を含むすべての領域をクラスタ htmlPreproc に加えればよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
HTML/OS (by Aestiva)				*htmlos.vim* *ft-htmlos-syntax*

The coloring scheme for HTML/OS works as follows:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{htmlos.vim}
@anchor{ft-htmlos-syntax}
@cindex htmlos.vim
@cindex ft-htmlos-syntax
@unnumberedsubsec HTML/OS (by Aestiva)
HTML/OS 用のカラースキームは以下のように機能する:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Functions and variable names are the same color by default, because VIM
doesn't specify different colors for Functions and Identifiers.  To change
this (which is recommended if you want function names to be recognizable in a
different color) you need to add the following line to either your ~/.vimrc: >
  :hi Function term=underline cterm=bold ctermfg=LightGray
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デフォルトでは関数名と変数名は同じである。これは、Vim は関数と識別子に異なる色を指定しないためである。これを変えるには (関数名を違う色にしたいならこうするとよい) 次の行を ~/@file{.vimrc} に書き加える:
@example
:hi Function term=underline cterm=bold ctermfg=LightGray
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Of course, the ctermfg can be a different color if you choose.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もちろん好みに応じて ctermfg は違う色にしてよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Another issues that HTML/OS runs into is that there is no special filetype to
signify that it is a file with HTML/OS coding.	You can change this by opening
a file and turning on HTML/OS syntax by doing the following: >
  :set syntax=htmlos
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
HTML/OS に関するもう1つの問題は、ファイルが HTML/OS コーディングであることを示す特別なファイル形式が存在しないことである。そのため、ファイルを開いた後に次のようにして HTML/OS 構文をオンにしなければならない:
@example
:set syntax=htmlos
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Lastly, it should be noted that the opening and closing characters to begin a
block of HTML/OS code can either be << or [[ and >> or ]], respectively.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
HTML/OS コードのブロックの開始と終了を示す文字は、それぞれ << または [[, >> または ]] のどちらであってもよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
IA64				*ia64.vim* *intel-itanium* *ft-ia64-syntax*

Highlighting for the Intel Itanium 64 assembly language.  See |asm.vim| for
how to recognize this filetype.

To have *.inc files be recognized as IA64, add this to your .vimrc file: >
	:let g:filetype_inc = "ia64"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ia64.vim}
@anchor{intel-itanium}
@anchor{ft-ia64-syntax}
@cindex ia64.vim
@cindex intel-itanium
@cindex ft-ia64-syntax
@unnumberedsubsec IA64
Intel Itanium 64 アセンブリ言語用のハイライト。このファイル形式を認識させる方法については |@ref{asm.vim}| を参照。

@file{*.inc} ファイルを IA64 と認識させるには次を @file{.vimrc} に書き足す:
@example
:let g:filetype_inc = "ia64"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
INFORM						*inform.vim* *ft-inform-syntax*

Inform highlighting includes symbols provided by the Inform Library, as
most programs make extensive use of it.  If do not wish Library symbols
to be highlighted add this to your vim startup: >
	:let inform_highlight_simple=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{inform.vim}
@anchor{ft-inform-syntax}
@cindex inform.vim
@cindex ft-inform-syntax
@unnumberedsubsec INFORM
Inform 構文ハイライトは Inform Library によって提供されるシンボルを含んでいる。ほとんどのプログラムがそれを利用しているためである。Library のシンボルをハイライ
トさせたくないなら、次を vim 初期化ファイルに加える:
@example
:let inform_highlight_simple=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
By default it is assumed that Inform programs are Z-machine targeted,
and highlights Z-machine assembly language symbols appropriately.  If
you intend your program to be targeted to a Glulx/Glk environment you
need to add this to your startup sequence: >
	:let inform_highlight_glulx=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デフォルトでは Inform プログラムは Z-machine ターゲットと仮定され、Z-machine アセンブリ言語シンボルが適切にハイライトされる。もしプログラムが Glulx/Glk 環境をターゲットとしたものなら、次を初期化ファイルに加える:
@example
:let inform_highlight_glulx=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This will highlight Glulx opcodes instead, and also adds glk() to the
set of highlighted system functions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
こうすると代わりに Glulx オペコードをハイライトし、glk() をシステム関数としてハイライトする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The Inform compiler will flag certain obsolete keywords as errors when
it encounters them.  These keywords are normally highlighted as errors
by Vim.  To prevent such error highlighting, you must add this to your
startup sequence: >
	:let inform_suppress_obsolete=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Inform コンパイラはある古いキーワードをエラーとみなす。普通、これらのキーワードはエラーとしてハイライトされる。これをエラーとしてハイライトするのをやめるには、次を初期化ファイルに加える:
@example
:let inform_suppress_obsolete=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
By default, the language features highlighted conform to Compiler
version 6.30 and Library version 6.11.  If you are using an older
Inform development environment, you may with to add this to your
startup sequence: >
	:let inform_highlight_old=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デフォルトではハイライトされる言語機能はコンパイラのバージョン 6.30 とライブラリのバージョン 6.11 に従う。これより古い Inform 開発環境を使っているなら、次の行を初期化ファイルに加えるとよいかもしれない:
@example
:let inform_highlight_old=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
IDL							*idl.vim* *idl-syntax*

IDL (Interface Definition Language) files are used to define RPC calls.  In
Microsoft land, this is also used for defining COM interfaces and calls.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{idl.vim}
@anchor{idl-syntax}
@cindex idl.vim
@cindex idl-syntax
@unnumberedsubsec IDL
IDL (Interface Definition Language) ファイルは RPC 呼び出しを定義するために使われる。Microsoft の世界では COM インターフェイスと呼び出しの定義にも使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
IDL's structure is simple enough to permit a full grammar based approach to
rather than using a few heuristics.  The result is large and somewhat
repetitive but seems to work.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
IDL の構造は単純であるため、ヒューリスティックな方法でなく、完全に文法にのっとったアプローチができる。その結果は巨大でいくぶん冗長であるが、一応は機能するようである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are some Microsoft extensions to idl files that are here.  Some of them
are disabled by defining idl_no_ms_extensions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
idl ファイルには Microsoft 拡張がある。それらのうちいくつかは idl_no_ms_extensions を定義すると無効になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The more complex of the extensions are disabled by defining idl_no_extensions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
より複雑な拡張は idl_no_extensions を定義すると無効になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Variable			Effect ~

idl_no_ms_extensions		Disable some of the Microsoft specific
				extensions
idl_no_extensions		Disable complex extensions
idlsyntax_showerror		Show IDL errors (can be rather intrusive, but
				quite helpful)
idlsyntax_showerror_soft	Use softer colours by default for errors
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@headitem 変数 @tab 効果
@item idl_no_ms_extensions @tab Microsoft 独自の拡張の一部を無効にする
@item idl_no_extensions @tab 複雑な拡張を無効にする
@item idlsyntax_showerror @tab IDL エラーを表示する (少々うるさいがとても助けになる)
@item idlsyntax_showerror_soft @tab エラーに対してデフォルトでよりソフトな色を使う
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
JAVA						*java.vim* *ft-java-syntax*

The java.vim syntax highlighting file offers several options:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{java.vim}
@anchor{ft-java-syntax}
@cindex java.vim
@cindex ft-java-syntax
@unnumberedsubsec JAVA
@file{java.vim} 構文ハイライトファイルはいくつかのオプションを提供している:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In Java 1.0.2 it was never possible to have braces inside parens, so this was
flagged as an error.  Since Java 1.1 this is possible (with anonymous
classes), and therefore is no longer marked as an error.  If you prefer the old
way, put the following line into your vim startup file: >
	:let java_mark_braces_in_parens_as_errors=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Java 1.0.2 では丸括弧の内側に波括弧が入ることは絶対になかったため、これはエラーと判断された。Java1.1 以降では (無名クラスとともに) これが可能になったため、エラーと判断されなくなった。もし以前のようにしたいなら、vim の初期化ファイルに次の行を加えること:
@example
:let java_mark_braces_in_parens_as_errors=1
@end example

@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
All identifiers in java.lang.* are always visible in all classes.  To
highlight them use: >
	:let java_highlight_java_lang_ids=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
java.lang.* 中の全ての識別子は常に全てのクラスから見える。これらをハイライトするには次を使う:
@example
:let java_highlight_java_lang_ids=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can also highlight identifiers of most standard Java packages if you
download the javaid.vim script at http://www.fleiner.com/vim/download.html.
If you prefer to only highlight identifiers of a certain package, say java.io
use the following: >
	:let java_highlight_java_io=1
Check the javaid.vim file for a list of all the packages that are supported.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@url{http://www.fleiner.com/vim/download.html} にあるスクリプト @file{javaid.vim} をダウンロードすれば、ほとんどの Java 標準パッケージの識別子をハイライトすることもできる。java.io など特定のパッケージの識別子だけをハイライトしたいならばこうする:
@example
:let java_highlight_java_io=1
@end example
対応している全パッケージのリストは @file{javaid.vim} を参照のこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Function names are not highlighted, as the way to find functions depends on
how you write Java code.  The syntax file knows two possible ways to highlight
functions:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数を認識する方法は Java コードの書き方に依存するため、関数名はハイライトされない。構文ファイルは関数をハイライトする方法を2つ備えている:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you write function declarations that are always indented by either
a tab, 8 spaces or 2 spaces you may want to set >
	:let java_highlight_functions="indent"
However, if you follow the Java guidelines about how functions and classes are
supposed to be named (with respect to upper and lowercase), use >
	:let java_highlight_functions="style"
If both options do not work for you, but you would still want function
declarations to be highlighted create your own definitions by changing the
definitions in java.vim or by creating your own java.vim which includes the
original one and then adds the code to highlight functions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数宣言が常にタブ、スペース 8 個、スペース 2 個のいずれかでインデントされているなら次のようにするとよいかもしれない。
@example
:let java_highlight_functions="indent"
@end example
しかし、関数とクラスの命名 (大文字・小文字についての) に関する Java ガイドラインにしたがっているなら次を使う。
@example
:let java_highlight_functions="style"
@end example
もしどちらのオプションもだめで、それでも関数宣言をハイライトしたいなら、@file{java.vim} 中の定義を変更するか、もとの @file{java.vim} に関数をハイライトするコードを加えて自分用の @file{java.vim} を作るかして独自の定義を作るしかない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In Java 1.1 the functions System.out.println() and System.err.println() should
only be used for debugging.  Therefore it is possible to highlight debugging
statements differently.  To do this you must add the following definition in
your startup file: >
	:let java_highlight_debug=1
The result will be that those statements are highlighted as 'Special'
characters.  If you prefer to have them highlighted differently you must define
new highlightings for the following groups.:
    Debug, DebugSpecial, DebugString, DebugBoolean, DebugType
which are used for the statement itself, special characters used in debug
strings, strings, boolean constants and types (this, super) respectively.  I
have opted to chose another background for those statements.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Java 1.1 では、System.out.println() と System.err.println() はデバッグのためだけに使われるものだった。そのためデバッグ用の文を区別してハイライトすることができる。それには次の定義を初期化ファイルに加える:
@example
:let java_highlight_debug=1
@end example
するとデバッグ用の文が 'Special' の文字としてハイライトされるだろう。これらを別の色でハイライトさせるには、以下のグループに対して新しいハイライトを定義すること:

Debug, DebugSpecial, DebugString, DebugBoolean, DebugType

これらはそれぞれ、文、デバッグ文字列に使われる特別な文字、文字列、ブール型定数、型 (this, super) に使われる。私はこれらの文に異なる背景色をつけることにしている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Javadoc is a program that takes special comments out of Java program files and
creates HTML pages.  The standard configuration will highlight this HTML code
similarly to HTML files (see |html.vim|).  You can even add Javascript
and CSS inside this code (see below).  There are four differences however:
  1. The title (all characters up to the first '.' which is followed by
     some white space or up to the first '@') is colored differently (to change
     the color change the group CommentTitle).
  2. The text is colored as 'Comment'.
  3. HTML comments are colored as 'Special'
  4. The special Javadoc tags (@see, @param, ...) are highlighted as specials
     and the argument (for @see, @param, @exception) as Function.
To turn this feature off add the following line to your startup file: >
	:let java_ignore_javadoc=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Javadoc は Java プログラム中から特別なコメントを抜き出して HTML ページを作成するプログラムである。標準の設定ではこれらの HTML コードを HTML ファイル (|@ref{html.vim}| を参照) と同様にハイライトする。さらにこのコードの中に JavaScript と CSS を書くこともできる (後述)。しかし 4 つの違いがある:
@enumerate
@item タイトル(その後にホワイトスペースが続く最初の '.' まで、または最初の '@@' までのすべての文字)は異なる色でハイライトされる(この色を変更するには CommentTitle を変えること)。
@item テキストは 'Comment' としてハイライトされる。
@item HTML コメントは 'Special' としてハイライトされる。
@item 特別な Javadoc タグ (@@see, @@param, ...) は Special として、(@@see, @@param, @@exception などの) 引数は Function としてハイライトされる。
@end enumerate
この機能をオフにするには初期化ファイルに次の行を加えること:
@example
:let java_ignore_javadoc=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you use the special Javadoc comment highlighting described above you
can also turn on special highlighting for Javascript, visual basic
scripts and embedded CSS (stylesheets).  This makes only sense if you
actually have Javadoc comments that include either Javascript or embedded
CSS.  The options to use are >
	:let java_javascript=1
	:let java_css=1
	:let java_vb=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以上の Javadoc コメントを使う場合、JavaScript, visual basic スクリプト、埋め込み CSS (スタイルシート) のハイライトをすることもできる。これは実際に JavaScript や埋め込み CSS を含む Javadoc コメントがあるときだけ意味がある。これらを有効化するためのオプションは次の通り
@example
:let java_javascript=1
:let java_css=1
:let java_vb=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In order to highlight nested parens with different colors define colors
for javaParen, javaParen1 and javaParen2, for example with >
	:hi link javaParen Comment
or >
	:hi javaParen ctermfg=blue guifg=#0000ff
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ネストした丸括弧に異なる色をつけるには、javaParen, javaParen1, javaParen2 に異なる色を定義する。例えば
@example
:hi link javaParen Comment
@end example
あるいは
@example
:hi javaParen ctermfg=blue guifg=#0000ff
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you notice highlighting errors while scrolling backwards, which are fixed
when redrawing with CTRL-L, try setting the "java_minlines" internal variable
to a larger number: >
	:let java_minlines = 50
This will make the syntax synchronization start 50 lines before the first
displayed line.  The default value is 10.  The disadvantage of using a larger
number is that redrawing can become slow.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上方向にスクロールしていてハイライトがおかしくなった場合 (@kbd{CTRL-L} で再描画すると直る)、内部変数 "java_minlines" を大きくしてみるとよい:
@example
:let java_minlines = 50
@end example
こうすると表示行の 50 行前から構文シンクロナイズが始まるようになる。デフォルト値は 10 である。大きな値にすることの不利点は、再描画が遅くなることである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
LACE						*lace.vim* *ft-lace-syntax*

Lace (Language for Assembly of Classes in Eiffel) is case insensitive, but the
style guide lines are not.  If you prefer case insensitive highlighting, just
define the vim variable 'lace_case_insensitive' in your startup file: >
	:let lace_case_insensitive=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{lace.vim}
@anchor{ft-lace-syntax}
@cindex lace.vim
@cindex ft-lace-syntax
@unnumberedsubsec LACE
Lace (Language for Assembly of Classes in Eiffel) は大文字・小文字を無視する。しかしスタイルガイドラインはそうでない。大文字・小文字を区別してハイライトさせるには、vim 変数 'lace_case_insensitive' を初期化ファイル中で定義すればよい:
@example
:let lace_case_insensitive=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
LEX						*lex.vim* *ft-lex-syntax*

Lex uses brute-force synchronizing as the "^%%$" section delimiter
gives no clue as to what section follows.  Consequently, the value for >
	:syn sync minlines=300
may be changed by the user if s/he is experiencing synchronization
difficulties (such as may happen with large lex files).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{lex.vim}
@anchor{ft-lex-syntax}
@cindex lex.vim
@cindex ft-lex-syntax
@unnumberedsubsec LEX
"^%%$" セクションデリミタが、その後にどんなセクションが続くかの手がかりを与えないため、Lex はブルートフォースなシンクロナイズを行う。それゆえ (巨大な lex ファイルなどで) 同期の問題が起こる場合には:
@example
:syn sync minlines=300
@end example
の値を変更するとよいかもしれない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
LIFELINES				*lifelines.vim* *ft-lifelines-syntax*

To highlight deprecated functions as errors, add in your .vimrc: >

	:let g:lifelines_deprecated = 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{lifelines.vim}
@anchor{ft-lifelines-syntax}
@cindex lifelines.vim
@cindex ft-lifelines-syntax
@unnumberedsubsec LIFELINES
廃止された関数をエラーとしてハイライトしたい場合は @file{.vimrc} で次のように設定すること:
@example
:let g:lifelines_deprecated = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
LISP						*lisp.vim* *ft-lisp-syntax*

The lisp syntax highlighting provides two options: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{lisp.vim}
@anchor{ft-lisp-syntax}
@cindex lisp.vim
@cindex ft-lisp-syntax
@unnumberedsubsec LISP
lisp の構文ハイライトには 2 つのオプションがある:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	g:lisp_instring : if it exists, then "(...)" strings are highlighted
			  as if the contents of the string were lisp.
			  Useful for AutoLisp.
	g:lisp_rainbow  : if it exists and is nonzero, then differing levels
			  of parenthesization will receive different
			  highlighting.
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .25 .75
@item g:lisp_instring @tab この変数が存在すると "(...)" 形式の文字列が、その中身が lisp であるかのようにハイライトされる。AutoLisp 用に便利である。
@item g:lisp_rainbow @tab この変数が存在し、0 以外であると段階の異なる括弧に対して異なるハイライトがつくようになる。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The g:lisp_rainbow option provides 10 levels of individual colorization for
the parentheses and backquoted parentheses.  Because of the quantity of
colorization levels, unlike non-rainbow highlighting, the rainbow mode
specifies its highlighting using ctermfg and guifg, thereby bypassing the
usual colorscheme control using standard highlighting groups.  The actual
highlighting used depends on the dark/bright setting  (see |'bg'|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション g:lisp_rainbow は括弧とバッククォートされた括弧に対して 10 段階の異なる色をつける。色づけ段階の多さのため、rainbow モード自身が ctermfg とguifg を使ってハイライトを指定する (rainbow モードでない場合はそうではない)。それゆえ、ハイライトグループを使う普通のカラースキームの影響を受けない。実際にどうハイライトされるかは dark/bright の設定 (|@ref{'bg'}| を参照) による。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
LITE						*lite.vim* *ft-lite-syntax*

There are two options for the lite syntax highlighting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{lite.vim}
@anchor{ft-lite-syntax}
@cindex lite.vim
@cindex ft-lite-syntax
@unnumberedsubsec LITE
lite 構文ハイライトには 2 つのオプションがある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you like SQL syntax highlighting inside Strings, use this: >

	:let lite_sql_query = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列中でSQL構文ハイライトを行ってほしいならこうする:
@example
:let lite_sql_query = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For syncing, minlines defaults to 100.	If you prefer another value, you can
set "lite_minlines" to the value you desire.  Example: >

	:let lite_minlines = 200
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シンクロナイズの最小行数はデフォルトで100になっている。他の値に変えたいなら "lite_minlines" をセットすればよい。例:
@example
:let lite_minlines = 200
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
LPC						*lpc.vim* *ft-lpc-syntax*

LPC stands for a simple, memory-efficient language: Lars Pensjö C.  The
file name of LPC is usually *.c.  Recognizing these files as LPC would bother
users writing only C programs.	If you want to use LPC syntax in Vim, you
should set a variable in your .vimrc file: >

	:let lpc_syntax_for_c = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{lpc.vim}
@anchor{ft-lpc-syntax}
@cindex lpc.vim
@cindex ft-lpc-syntax
@unnumberedsubsec LPC
LPC はシンプルでメモリ効率的な言語、Lars Pensjö C の略である。LPC のファイル名は通常 *.c である。これらのファイルを LPC と認識すると C プログラムのみを書くユーザーの迷惑になる。LPC 構文を使用したいなら、@file{.vimrc} でこの変数をセットすること:
@example
:let lpc_syntax_for_c = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If it doesn't work properly for some particular C or LPC files, use a
modeline.  For a LPC file:

	// vim:set ft=lpc:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これでも適切に動作しない C または LPC のファイルに対してはモードラインを使うこと。LPC ファイルには:
@example
// vim:set ft=lpc:
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For a C file that is recognized as LPC:

	// vim:set ft=c:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
LPC と認識されてしまう C ファイルには:
@example
// vim:set ft=c:
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you don't want to set the variable, use the modeline in EVERY LPC file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数をセットしたくないなら全てのLPCファイルでモードラインを使うこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are several implementations for LPC, we intend to support most widely
used ones.  Here the default LPC syntax is for MudOS series, for MudOS v22
and before, you should turn off the sensible modifiers, and this will also
assert the new efuns after v22 to be invalid, don't set this variable when
you are using the latest version of MudOS: >

	:let lpc_pre_v22 = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
LPC には複数の実装がある。我々はもっとも広く使われているものをサポートしたいと思っている。デフォルトの LPC 文法は MudOS シリーズ用である。MudOS v22 以前を使っているなら、次をセットすることにより sensible モディファイヤをオフにし、v22 以降の新しい efun を無効にするとよい。MudOS の最新版を使っているときはこの変数をセットしないこと:
@example
:let lpc_pre_v22 = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For LpMud 3.2 series of LPC: >

	:let lpc_compat_32 = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
LPC の LpMud 3.2 シリーズには:
@example
:let lpc_compat_32 = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For LPC4 series of LPC: >

	:let lpc_use_lpc4_syntax = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
LPC の LPC4 シリーズには:
@example
:let lpc_use_lpc4_syntax = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For uLPC series of LPC:
uLPC has been developed to Pike, so you should use Pike syntax
instead, and the name of your source file should be *.pike
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
LPC の uLPC シリーズには:

uLPC は Pike 用に開発されている。なので Pike 構文を代わりに使い、ソースファイルの名前を .pike とすること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
LUA						*lua.vim* *ft-lua-syntax*

The Lua syntax file can be used for versions 4.0, 5.0, 5.1 and 5.2 (5.2 is
the default). You can select one of these versions using the global variables
lua_version and lua_subversion. For example, to activate Lua
5.1 syntax highlighting, set the variables like this:

	:let lua_version = 5
	:let lua_subversion = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{lua.vim}
@anchor{ft-lua-syntax}
@cindex lua.vim
@cindex ft-lua-syntax
@unnumberedsubsec LUA
Lua 構文ファイルはバージョン 4.0, 5.0, 5.1, 5.2 に対して使える (5.2 がデフォルト) グローバル変数 lua_version と lua_subversion を設定することでバージョンを指定することができる。例えば、Lua 5.1 の構文ハイライトを有効にするには次のように変数を設定する:
@example
:let lua_version = 5
:let lua_subversion = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MAIL						*mail.vim* *ft-mail.vim*

Vim highlights all the standard elements of an email (headers, signatures,
quoted text and URLs / email addresses).  In keeping with standard conventions,
signatures begin in a line containing only "--" followed optionally by
whitespaces and end with a newline.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{mail.vim}
@anchor{ft-mail.vim}
@cindex mail.vim
@cindex ft-mail.vim
@unnumberedsubsec MAIL
Vim は email の標準的な要素 (ヘッダー、シグネチャ、引用文、URL / email アドレス)の全てをハイライトする。標準的な慣習に従い、シグネチャは、"@minus{}@minus{}" とそれに続く任意個の空白、そして改行のみからなる行で始まる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim treats lines beginning with ']', '}', '|', '>' or a word followed by '>'
as quoted text.  However Vim highlights headers and signatures in quoted text
only if the text is quoted with '>' (optionally followed by one space).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は ']', '@}', '|', '>' で始まる行または '>' が続く単語を引用文とみなす。引用文中のヘッダーとシグネチャについては、テキストが '>' (1 個のスペースが続いてもよい) で引用された場合のみハイライトする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
By default mail.vim synchronises syntax to 100 lines before the first
displayed line.  If you have a slow machine, and generally deal with emails
with short headers, you can change this to a smaller value: >

    :let mail_minlines = 30
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デフォルトでは @file{mail.vim} は先頭表示行の 100 行前までの構文をシンクロナイズさせる。遅いマシンを使っていて、一般的に短いヘッダーの email を扱っているなら、これをより小さい値に変えることができる:
@example
:let mail_minlines = 30
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MAKE						*make.vim* *ft-make-syntax*

In makefiles, commands are usually highlighted to make it easy for you to spot
errors.  However, this may be too much coloring for you.  You can turn this
feature off by using: >

	:let make_no_commands = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{make.vim}
@anchor{ft-make-syntax}
@cindex make.vim
@cindex ft-make-syntax
@unnumberedsubsec MAKE
Makefile ではエラーを見つけやすくするためにコマンドがハイライトされる。しかし、これは色が多すぎるかもしれない。この機能をオフにするにはこうする:
@example
:let make_no_commands = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MAPLE						*maple.vim* *ft-maple-syntax*

Maple V, by Waterloo Maple Inc, supports symbolic algebra.  The language
supports many packages of functions which are selectively loaded by the user.
The standard set of packages' functions as supplied in Maple V release 4 may be
highlighted at the user's discretion.  Users may place in their .vimrc file: >

	:let mvpkg_all= 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{maple.vim}
@anchor{ft-maple-syntax}
@cindex maple.vim
@cindex ft-maple-syntax
@unnumberedsubsec MAPLE
Waterloo Maple Inc による Maple V は記号代数をサポートしている。その言語はユーザーによって選択的にロードされる関数のパッケージをたくさんサポートしている。Maple V release 4 で供給される標準的なパッケージセットの関数がユーザーの判断によって強調される。ユーザーは @file{.vimrc} に以下を書くと、全てのパッケージ関数がハイライトされる:
@example
:let mvpkg_all= 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
to get all package functions highlighted, or users may select any subset by
choosing a variable/package from the table below and setting that variable to
1, also in their .vimrc file (prior to sourcing
$VIMRUNTIME/syntax/syntax.vim).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
あるいは以下の表から任意のサブセット変数／パッケージを選んで @file{.vimrc} ファイル中でその変数を 1 にセットしてもよい ($VIMRUNTIME/syntax/@file{syntax.vim} を読み込む前に行う必要がある)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Table of Maple V Package Function Selectors >
  mv_DEtools	 mv_genfunc	mv_networks	mv_process
  mv_Galois	 mv_geometry	mv_numapprox	mv_simplex
  mv_GaussInt	 mv_grobner	mv_numtheory	mv_stats
  mv_LREtools	 mv_group	mv_orthopoly	mv_student
  mv_combinat	 mv_inttrans	mv_padic	mv_sumtools
  mv_combstruct mv_liesymm	mv_plots	mv_tensor
  mv_difforms	 mv_linalg	mv_plottools	mv_totorder
  mv_finance	 mv_logic	mv_powseries
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Maple V パッケージ関数選択肢の表
@multitable @columnfractions .25 .25 .25 .25
@item mv_DEtools @tab mv_genfunc @tab mv_networks @tab mv_process
@item mv_Galois @tab mv_geometry @tab mv_numapprox @tab mv_simplex
@item mv_GaussInt @tab mv_grobner @tab mv_numtheory @tab mv_stats
@item mv_LREtools @tab mv_group @tab mv_orthopoly @tab mv_student
@item mv_combinat @tab mv_inttrans @tab mv_padic @tab mv_sumtools
@item mv_combstruct @tab mv_liesymm @tab mv_plots @tab mv_tensor
@item mv_difforms @tab mv_linalg @tab mv_plottools @tab mv_totorder
@item mv_finance @tab mv_logic @tab mv_powseries
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MATHEMATICA		*mma.vim* *ft-mma-syntax* *ft-mathematica-syntax*

Empty *.m files will automatically be presumed to be Matlab files unless you
have the following in your .vimrc: >

	let filetype_m = "mma"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{mma.vim}
@anchor{ft-mma-syntax}
@anchor{ft-mathematica-syntax}
@cindex mma.vim
@cindex ft-mma-syntax
@cindex ft-mathematica-syntax
@unnumberedsubsec MATHEMATICA
次を @file{.vimrc} に書いておかないかぎり、空の @file{*.m} ファイルは自動的に Matlab のファイルであるとみなされる:
@example
let filetype_m = "mma"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MOO						*moo.vim* *ft-moo-syntax*

If you use C-style comments inside expressions and find it mangles your
highlighting, you may want to use extended (slow!) matches for C-style
comments: >

	:let moo_extended_cstyle_comments = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{moo.vim}
@anchor{ft-moo-syntax}
@cindex moo.vim
@cindex ft-moo-syntax
@unnumberedsubsec MOO
式の中で C スタイルのコメントを使っていて、それがハイライトを乱している場合は、C スタイル用の拡張マッチ (これは遅い！) を使うことができる:
@example
:let moo_extended_cstyle_comments = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To disable highlighting of pronoun substitution patterns inside strings: >

	:let moo_no_pronoun_sub = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列中の代名詞置換パターンのハイライトを無効化させるには:
@example
:let moo_no_pronoun_sub = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To disable highlighting of the regular expression operator '%|', and matching
'%(' and '%)' inside strings: >

	:let moo_no_regexp = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
正規表現演算子 '%l' のハイライトと文字列中の '%(' と '%)' のマッチを無効化させるには:
@example
:let moo_no_regexp = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Unmatched double quotes can be recognized and highlighted as errors: >

	:let moo_unmatched_quotes = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
対応していないダブルクォートを認識してエラーとしてハイライトすることができる:
@example
:let moo_unmatched_quotes = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To highlight builtin properties (.name, .location, .programmer etc.): >

	:let moo_builtin_properties = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
組み込みプロパティ (.name, .location, .programmer など) をハイライトするには:
@example
:let moo_builtin_properties = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Unknown builtin functions can be recognized and highlighted as errors.  If you
use this option, add your own extensions to the mooKnownBuiltinFunction group.
To enable this option: >

	:let moo_unknown_builtin_functions = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
未知の組み込み関数を認識してエラーとしてハイライトすることができる。このオプションを使うなら、mooKnownBuiltinFunction グループに自分自身の拡張を加えること。このオプションを有効化するには:
@example
:let moo_unknown_builtin_functions = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An example of adding sprintf() to the list of known builtin functions: >

	:syn keyword mooKnownBuiltinFunction sprintf contained
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
既知の組み込み関数のリストに sprintf() を加える例:
@example
:syn keyword mooKnownBuiltinFunction sprintf contained
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MSQL						*msql.vim* *ft-msql-syntax*

There are two options for the msql syntax highlighting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{msql.vim}
@anchor{ft-msql-syntax}
@cindex msql.vim
@cindex ft-msql-syntax
@unnumberedsubsec MSQL
msql 構文ハイライトには2つのオプションがある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you like SQL syntax highlighting inside Strings, use this: >

	:let msql_sql_query = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列中で SQL 構文ハイライトをさせるにはこうする:
@example
:let msql_sql_query = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For syncing, minlines defaults to 100.	If you prefer another value, you can
set "msql_minlines" to the value you desire.  Example: >

	:let msql_minlines = 200
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シンクロナイズは、minlines はデフォルトで 100 になっている。この値を変えるには、"msql_minlines" の望む値にすればよい。例:
@example
:let msql_minlines = 200
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
N1QL						*n1ql.vim* *ft-n1ql-syntax*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{n1ql.vim}
@anchor{ft-n1ql-syntax}
@cindex n1ql.vim
@cindex ft-n1ql-syntax
@unnumberedsubsec N1QL
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
N1QL is a SQL-like declarative language for manipulating JSON documents in
Couchbase Server databases.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
N1QL は Couchbase Server データベースで JSON 文書を操作するための SQL ライクな宣言型言語である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim syntax highlights N1QL statements, keywords, operators, types, comments,
and special values.  Vim ignores syntactical elements specific to SQL or its
many dialects, like COLUMN or CHAR, that don't exist in N1QL.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は N1QL ステートメント, キーワード, オペレータ, 型, コメントおよび特殊な値を構文ハイライトする。COLUMN や CHAR のような、N1QL に存在しない SQL 特有な構文要素やその他たくさんある方言は無視される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
NCF						*ncf.vim* *ft-ncf-syntax*

There is one option for NCF syntax highlighting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ncf.vim}
@anchor{ft-ncf-syntax}
@cindex ncf.vim
@cindex ft-ncf-syntax
@unnumberedsubsec NCF
NCF 構文ハイライトには 1 つのオプションがある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to have unrecognized (by ncf.vim) statements highlighted as
errors, use this: >

	:let ncf_highlight_unknowns = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@file{ncf.vim} によって認識されない文をエラーとしてハイライトさせるにはこうする:
@example
:let ncf_highlight_unknowns = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you don't want to highlight these errors, leave it unset.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらをエラーとしてハイライトさせたくない場合は、この変数をセットしないでおく。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
NROFF						*nroff.vim* *ft-nroff-syntax*

The nroff syntax file works with AT&T n/troff out of the box.  You need to
activate the GNU groff extra features included in the syntax file before you
can use them.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{nroff.vim}
@anchor{ft-nroff-syntax}
@cindex nroff.vim
@cindex ft-nroff-syntax
@unnumberedsubsec NROFF
nroff 構文ファイルはそのままで AT&T n/troff に対応している。構文ファイルに含まれている GNU groff 拡張機能を使うには、それを有効化する必要がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For example, Linux and BSD distributions use groff as their default text
processing package.  In order to activate the extra syntax highlighting
features for groff, add the following option to your start-up files: >

  :let b:nroff_is_groff = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば、Linux と BSD ディストリビューションは、デフォルトではテキスト処理パッケージとして groff を使う。groff 用の拡張構文ハイライト機能を有効化するには、次のオプションを初期化ファイルに加える:
@example
:let b:nroff_is_groff = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Groff is different from the old AT&T n/troff that you may still find in
Solaris.  Groff macro and request names can be longer than 2 characters and
there are extensions to the language primitives.  For example, in AT&T troff
you access the year as a 2-digit number with the request \(yr.  In groff you
can use the same request, recognized for compatibility, or you can use groff's
native syntax, \[yr].  Furthermore, you can use a 4-digit year directly:
\[year].  Macro requests can be longer than 2 characters, for example, GNU mm
accepts the requests ".VERBON" and ".VERBOFF" for creating verbatim
environments.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
groff は、Solaris でまだ使われているかもしれない古い AT&T n/troff とは異なる。groff のマクロとリクエスト名は 2 文字以上の長さであってもよく、言語プリミティブに拡張がされている。

例えば、AT&T troff ではリクエスト \(yr を使い、2 桁の数で年にアクセスする。groff では互換性のために同じリクエストを使うこともできるし、または groff ネイティブの構文 ,\[yr] を使うこともできる。

さらに、\[year] として 4 桁の年を直接使うこともできる。マクロリクエストは 2 文字以上の長さであってもよい。例えば、GNU mm は verbatim 環境を作るのに ".VERBON" と ".VERBOFF" というリクエストを受けつける。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In order to obtain the best formatted output g/troff can give you, you should
follow a few simple rules about spacing and punctuation.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
g/troff によって得られる最良の整形された出力を得るには、スペースと句読点に関するいくつかの単純なルールに従うべきである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. Do not leave empty spaces at the end of lines.

2. Leave one space and one space only after an end-of-sentence period,
   exclamation mark, etc.

3. For reasons stated below, it is best to follow all period marks with a
   carriage return.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item 行の末尾に空のスペースを置かないこと
@item 文末のピリオド、エクスクラメーションマークなどの後にはちょうど 1 個のスペースを置くこと。
@item 後述の理由により、全てのピリオドの後に改行 (carriage return) を置くとよい。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The reason behind these unusual tips is that g/n/troff have a line breaking
algorithm that can be easily upset if you don't follow the rules given above.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらの妙な tips の理由は、g/n/troff が改行に、これらのルールに従わないとすぐに混乱してしまうアルゴリズムを使っているためである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Unlike TeX, troff fills text line-by-line, not paragraph-by-paragraph and,
furthermore, it does not have a concept of glue or stretch, all horizontal and
vertical space input will be output as is.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
troff は TeX と違い、段落ごとでなく行ごとにテキストを書き込む。さらに、glue や stretch の概念を持たず、入力に水平、垂直の空白があると全てそのまま出力される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Therefore, you should be careful about not using more space between sentences
than you intend to have in your final document.  For this reason, the common
practice is to insert a carriage return immediately after all punctuation
marks.  If you want to have "even" text in your final processed output, you
need to maintain regular spacing in the input text.  To mark both trailing
spaces and two or more spaces after a punctuation as an error, use: >

  :let nroff_space_errors = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
それゆえ、最終的なドキュメントで意図する以上の空白を文と文の間にはさまないように注意すること。この理由のため、全ての句読点記号の後すぐに改行を入れるという習慣がある。最終的に処理された出力が「一様な」テキストになってほしければ、入力のテキストで正しくスペースを置いておく必要がある。行末の空白と句読点の後の 2 個以上の空白をエラーとしてハイライトしたいならこうする:
@example
:let nroff_space_errors = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Another technique to detect extra spacing and other errors that will interfere
with the correct typesetting of your file, is to define an eye-catching
highlighting definition for the syntax groups "nroffDefinition" and
"nroffDefSpecial" in your configuration files.  For example: >

  hi def nroffDefinition term=italic cterm=italic gui=reverse
  hi def nroffDefSpecial term=italic,bold cterm=italic,bold
			 \ gui=reverse,bold
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
正しい活字組みと干渉するかもしれないが、余分な空白や他のエラーを検出するもう 1 つの方法は、設定ファイル中で構文グループ "nroffDefinition" と "nroffDefSpecial" に目立つハイライト定義を定義することである。例:
@example
hi def nroffDefinition term=italic cterm=italic gui=reverse
hi def nroffDefSpecial term=italic,bold cterm=italic,bold
                       \ gui=reverse,bold
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to navigate preprocessor entries in your source file as easily as
with section markers, you can activate the following option in your .vimrc
file: >

	let b:preprocs_as_sections = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ソースファイル中のプリプロセッサーのエントリをセクションマーカーと同じくらい容易に表示させたいなら、@file{.vimrc} 中で次のオプションを有効化する:
@example
let b:preprocs_as_sections = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
As well, the syntax file adds an extra paragraph marker for the extended
paragraph macro (.XP) in the ms package.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
同様に、構文ファイルは ms パッケージ中の拡張段落マクロ (.XP) 用の余分な段落マーカーも含んでいる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Finally, there is a |groff.vim| syntax file that can be used for enabling
groff syntax highlighting either on a file basis or globally by default.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最後に、構文ファイル |@ref{groff.vim}| が存在する。これはデフォルトで file basis とグローバルの両方で groff 構文ハイライトすることができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
OCAML						*ocaml.vim* *ft-ocaml-syntax*

The OCaml syntax file handles files having the following prefixes: .ml,
.mli, .mll and .mly.  By setting the following variable >

	:let ocaml_revised = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ocaml.vim}
@anchor{ft-ocaml-syntax}
@cindex ocaml.vim
@cindex ft-ocaml-syntax
@unnumberedsubsec OCAML
OCaml 構文ファイルは以下の拡張子を持つファイルに対応している: .ml, .mli, .mll と .mly。以下の変数をセットすると:
@example
:let ocaml_revised = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
you can switch from standard OCaml-syntax to revised syntax as supported
by the camlp4 preprocessor.  Setting the variable >

	:let ocaml_noend_error = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
標準的 OCaml 構文から camlp4 プリプロセッサーでサポートされている修正構文に切り替えることができる。以下の変数をセットすると:
@example
:let ocaml_noend_error = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
prevents highlighting of "end" as error, which is useful when sources
contain very long structures that Vim does not synchronize anymore.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"end" をエラーとしてハイライトするのをやめることができる。これは Vim がシンクロナイズできないほど長い構造を含むソースのとき便利である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
PAPP						*papp.vim* *ft-papp-syntax*

The PApp syntax file handles .papp files and, to a lesser extend, .pxml
and .pxsl files which are all a mixture of perl/xml/html/other using xml
as the top-level file format.  By default everything inside phtml or pxml
sections is treated as a string with embedded preprocessor commands.  If
you set the variable: >

	:let papp_include_html=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{papp.vim}
@anchor{ft-papp-syntax}
@cindex papp.vim
@cindex ft-papp-syntax
@unnumberedsubsec PAPP
PApp 構文ファイルは @file{.papp} ファイルと、その小さな拡張、トップレベルのファイルフォーマットとして xml を用いた perl/xml/html/その他 の混合である .pxml, .pxsl ファイルを扱う。デフォルトでは、phtml や pxml セクションの内側の全ては埋め込みプリプロセッサーコマンドつきの文字列として扱われる。次の変数を初期化ファイルで設定すると:
@example
:let papp_include_html=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
in your startup file it will try to syntax-hilight html code inside phtml
sections, but this is relatively slow and much too colourful to be able to
edit sensibly. ;)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
phtml セクションの内側の html コードを構文ハイライトしようとする。しかしこれは比較的遅く、実用的に編集するにはカラフルすぎる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The newest version of the papp.vim syntax file can usually be found at
http://papp.plan9.de.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
構文ファイル @file{papp.vim} の最新版は、通常以下で得られる。

@url{http://papp.plan9.de}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
PASCAL						*pascal.vim* *ft-pascal-syntax*

Files matching "*.p" could be Progress or Pascal.  If the automatic detection
doesn't work for you, or you don't edit Progress at all, use this in your
startup vimrc: >

   :let filetype_p = "pascal"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{pascal.vim}
@anchor{ft-pascal-syntax}
@cindex pascal.vim
@cindex ft-pascal-syntax
@unnumberedsubsec PASCAL
"*.p" にマッチするファイルのタイプは Progress か Pascal である。自動判別が機能しないなら、または Progress ファイルを一切編集しないとわかっているなら、これを @file{vimrc} ファイルに書くといい:
@example
:let filetype_p = "pascal"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The Pascal syntax file has been extended to take into account some extensions
provided by Turbo Pascal, Free Pascal Compiler and GNU Pascal Compiler.
Delphi keywords are also supported.  By default, Turbo Pascal 7.0 features are
enabled.  If you prefer to stick with the standard Pascal keywords, add the
following line to your startup file: >

   :let pascal_traditional=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Pascal 構文ファイルは Turbo Pascal, Free Pascal Compiler と GNU Pascal Compiler で提供される拡張に対応するための拡張が施されてきた。Delphi のキーワードもサポートされている。デフォルトでは Turbo Pascal 7.0 の機能が有効化されている。標準的な Pascal のキーワードだけを使いたいなら、次の行を初期化ファイルに加えること:
@example
:let pascal_traditional=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To switch on Delphi specific constructions (such as one-line comments,
keywords, etc): >

   :let pascal_delphi=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Delphi 固有の構文 (1 行コメント、キーワード等) を有効化したいなら:
@example
:let pascal_delphi=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
The option pascal_symbol_operator controls whether symbol operators such as +,
*, .., etc. are displayed using the Operator color or not.  To colorize symbol
operators, add the following line to your startup file: >

   :let pascal_symbol_operator=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション pascal_symbol_operator は、+, * などのような演算子記号を Operator の色を使って表示するどうかを制御する。演算子記号を色づけするには、次の行を初期化ファイルに加えること:
@example
:let pascal_symbol_operator=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Some functions are highlighted by default.  To switch it off: >

   :let pascal_no_functions=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
いくつかの関数はデフォルトでハイライトされる。これをオフにするには:
@example
:let pascal_no_functions=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Furthermore, there are specific variables for some compilers.  Besides
pascal_delphi, there are pascal_gpc and pascal_fpc.  Default extensions try to
match Turbo Pascal. >

   :let pascal_gpc=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
さらに、いくつかのコンパイラ用に個別の変数がある。pascal_delphi, pascal_gpc, pascal_fpc がある。デフォルトの拡張は Turbo Pascal に合うようになっている。
@example
:let pascal_gpc=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
or >

   :let pascal_fpc=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
または
@example
:let pascal_fpc=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To ensure that strings are defined on a single line, you can define the
pascal_one_line_string variable. >

   :let pascal_one_line_string=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列が 1 行で定義されるものとするなら、変数 pascal_one_line_string variable を定義するとよい。
@example
:let pascal_one_line_string=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you dislike <Tab> chars, you can set the pascal_no_tabs variable.  Tabs
will be highlighted as Error. >

   :let pascal_no_tabs=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
タブ文字が好きでないなら、変数 pascal_no_tabs をセットするとよい。するとタブがエラーとしてハイライトされる。
@example
:let pascal_no_tabs=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------



@ifset EN
PERL						*perl.vim* *ft-perl-syntax*

There are a number of possible options to the perl syntax highlighting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{perl.vim}
@anchor{ft-perl-syntax}
@cindex perl.vim
@cindex ft-perl-syntax
@unnumberedsubsec PERL
perl 用の構文ハイライトにはたくさんのオプションがある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Inline POD highlighting is now turned on by default.  If you don't wish
to have the added complexity of highlighting POD embedded within Perl
files, you may set the 'perl_include_pod' option to 0: >

	:let perl_include_pod = 0
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
インライン POD 強調表示は初期設定で有効化される。Perl ファイル内に埋め込まれた POD を強調表示して複雑にしたくない場合は、'@option{perl_include_pod}' オプションを 0 に設定する:
@example
:let perl_include_pod = 0
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To reduce the complexity of parsing (and increase performance) you can switch
off two elements in the parsing of variable names and contents. >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
パースの複雑さを軽減するために (そしてパフォーマンスを上げるために)、変数名と内容のパースにおける 2 つの要素をオフにすることができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To handle package references in variable and function names not differently
from the rest of the name (like 'PkgName::' in '$PkgName::VarName'): >

	:let perl_no_scope_in_variables = 1

(In Vim 6.x it was the other way around: "perl_want_scope_in_variables"
enabled it.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数名と関数名中のパッケージ参照 ('$PkgName::VarName' 中の 'PkgName::' のような) を他の名前と区別しないようにするには次のようにする:
@example
:let perl_no_scope_in_variables = 1
@end example
(Vim 6.x では違う方法だった: "perl_want_scope_in_variables" を設定するとこの機能が有効になった)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you do not want complex things like '@{${"foo"}}' to be parsed: >

	:let perl_no_extended_vars = 1

(In Vim 6.x it was the other way around: "perl_extended_vars" enabled it.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@@@{$@{"foo"@}@}' のように複雑なものをパースさせたくないなら次のようにする:
@example
:let perl_no_extended_vars = 1
@end example
(Vim 6.x では違う方法だった: "perl_extended_vars" を設定するとこの機能が有効になった)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The coloring strings can be changed.  By default strings and qq friends will be
highlighted like the first line.  If you set the variable
perl_string_as_statement, it will be highlighted as in the second line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列の色づけは変更できる。デフォルトでは文字列と qq friends は第 1 行と同じようにハイライトされる。変数 perl_string_as_statement をセットすると第2行のようにハイライトされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
   "hello world!"; qq|hello world|;
   ^^^^^^^^^^^^^^NN^^^^^^^^^^^^^^^N	  (unlet perl_string_as_statement)
   S^^^^^^^^^^^^SNNSSS^^^^^^^^^^^SN	  (let perl_string_as_statement)

(^ = perlString, S = perlStatement, N = None at all)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
   "hello world!"; qq|hello world|;
   ^^^^^^^^^^^^^^NN^^^^^^^^^^^^^^^N       (unlet perl_string_as_statement)
   S^^^^^^^^^^^^SNNSSS^^^^^^^^^^^SN       (let perl_string_as_statement)

(^ = perlString, S = perlStatement, N = None at all)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The syncing has 3 options.  The first two switch off some triggering of
synchronization and should only be needed in case it fails to work properly.
If while scrolling all of a sudden the whole screen changes color completely
then you should try and switch off one of those.  Let me know if you can figure
out the line that causes the mistake.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シンクロナイズには 3 つのオプションがある。最初の 2 つは、シンクロナイズのトリガーの一部をオフにするもので、ハイライトが適切に機能しないときのみ必要になる。スクロール中に突然スクリーン全体の色がすっかり変わってしまったらこれらのうち 1 つをオフにしてみること。その誤りを引き起こした行を特定できるなら、それを知らせてください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
One triggers on "^\s*sub\s*" and the other on "^[$@%]" more or less. >

	:let perl_no_sync_on_sub
	:let perl_no_sync_on_global_var
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
1 つのトリガーは "^\s*sub\s*" に関するもので、もう 1 つはほぼ "^[$@@%]" に関するものである。
@example
:let perl_no_sync_on_sub
:let perl_no_sync_on_global_var
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Below you can set the maximum distance VIM should look for starting points for
its attempts in syntax highlighting. >

	:let perl_sync_dist = 100
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下のようにして、どこから構文ハイライトを始めるかの最大距離を設定できる:
@example
:let perl_sync_dist = 100
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to use folding with perl, set perl_fold: >

	:let perl_fold = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
perl で折りたたみを使いたいなら perl_fold をセットすること:
@example
:let perl_fold = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to fold blocks in if statements, etc. as well set the following: >

	:let perl_fold_blocks = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
if 文などでも同様にブロックを折り畳みたければ、次のように設定する:
@example
:let perl_fold_blocks = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Subroutines are folded by default if 'perl_fold' is set.  If you do not want
this, you can set 'perl_nofold_subs': >

	:let perl_nofold_subs = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
初期設定では '@option{perl_fold}' が設定されていればサブルーチンの折り畳みは有効化される。無効化したい場合は '@option{perl_nofold_subs}' を設定する:
@example
:let perl_nofold_subs = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Anonymous subroutines are not folded by default; you may enable their folding
via 'perl_fold_anonymous_subs': >

	:let perl_fold_anonymous_subs = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
初期設定では無名サブルーチンは折り畳まれない。折り畳みを有効化するには '@option{perl_fold_anonymous_subs}' を設定する:
@example
:let perl_fold_anonymous_subs = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Packages are also folded by default if 'perl_fold' is set.  To disable this
behavior, set 'perl_nofold_packages': >

	:let perl_nofold_packages = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
初期設定では '@option{perl_fold}' が設定されていればパッケージは折り畳まれる。無効化したい場合は '@option{perl_nofold_packages}' を設定する:
@example
:let perl_nofold_packages = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
PHP3 and PHP4		*php.vim* *php3.vim* *ft-php-syntax* *ft-php3-syntax*

[note: previously this was called "php3", but since it now also supports php4
it has been renamed to "php"]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{php.vim}
@anchor{php3.vim}
@anchor{ft-php-syntax}
@anchor{ft-php3-syntax}
@cindex php.vim
@cindex php3.vim
@cindex ft-php-syntax
@cindex ft-php3-syntax
@unnumberedsubsec PHP3 and PHP4
@quotation
@strong{Note:} @*
これは以前は "php3" と呼ばれていた。しかし現在は php4 もサポートしているので "php" と名前が変更された。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are the following options for the php syntax highlighting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
php 用の構文ハイライトには以下のオプションがある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you like SQL syntax highlighting inside Strings: >

  let php_sql_query = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列中で SQL 構文ハイライトを行いたいなら:
@example
let php_sql_query = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For highlighting the Baselib methods: >

  let php_baselib = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Baselib メソッドのハイライトを行いたいなら:
@example
let php_baselib = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Enable HTML syntax highlighting inside strings: >

  let php_htmlInStrings = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列中で HTML 構文ハイライトを行いたいなら:
@example
let php_htmlInStrings = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Using the old colorstyle: >

  let php_oldStyle = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
古いカラースタイルを使いたいなら:
@example
let php_oldStyle = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Enable highlighting ASP-style short tags: >

  let php_asp_tags = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ASP スタイルのショートタグを有効化したいなら:
@example
let php_asp_tags = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Disable short tags: >

  let php_noShortTags = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ショートタグを無効化したいなら:
@example
let php_noShortTags = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For highlighting parent error ] or ): >

  let php_parent_error_close = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
] や ) の対応エラーをハイライトしたいなら:
@example
let php_parent_error_close = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For skipping a php end tag, if there exists an open ( or [ without a closing
one: >

  let php_parent_error_open = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
対応する閉じ括弧がない開き括弧 ( や [ が存在する場合、php 終了タグをスキップさせたいなら:
@example
let php_parent_error_open = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Enable folding for classes and functions: >

  let php_folding = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
クラスや関数の折り畳みを有効化するには:
@example
let php_folding = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Selecting syncing method: >

  let php_sync_method = x

x = -1 to sync by search (default),
x > 0 to sync at least x lines backwards,
x = 0 to sync from start.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シンクロナイズ方法を選ぶには:
@example
let php_sync_method = x
@end example
@multitable @columnfractions .1 .9
@item x = -1 @tab で検索によるシンクロナイズ(デフォルト)
@item x > 0 @tab 少なくともx行上までシンクロナイズ
@item x = 0 @tab 最初からシンクロナイズ
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
PLAINTEX				*plaintex.vim* *ft-plaintex-syntax*

TeX is a typesetting language, and plaintex is the file type for the "plain"
variant of TeX.  If you never want your *.tex files recognized as plain TeX,
see |ft-tex-plugin|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{plaintex.vim}
@anchor{ft-plaintex-syntax}
@cindex plaintex.vim
@cindex ft-plaintex-syntax
@unnumberedsubsec PLAINTEX
TeX とは組版言語であり、plaintex は「素の」TeX に対して使われるファイルタイプである。*.tex ファイルを決して素の TeX と認識してほしくないならば |@ref{ft-tex-plugin}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This syntax file has the option >

	let g:plaintex_delimiters = 1

if you want to highlight brackets "[]" and braces "{}".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この構文ファイルは次のオプションを持つ
@example
let g:plaintex_delimiters = 1
@end example
角括弧 "[]" と波括弧 "@{@}" をハイライトさせるには上の変数を設定する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
PPWIZARD					*ppwiz.vim* *ft-ppwiz-syntax*

PPWizard is a preprocessor for HTML and OS/2 INF files
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ppwiz.vim}
@anchor{ft-ppwiz-syntax}
@cindex ppwiz.vim
@cindex ft-ppwiz-syntax
@unnumberedsubsec PPWIZARD
PPWizard は HTML とOS/2 INF ファイル用のプリプロセッサーである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This syntax file has the options:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
構文ファイルは以下のオプションを持つ:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- ppwiz_highlight_defs : determines highlighting mode for PPWizard's
  definitions.  Possible values are

  ppwiz_highlight_defs = 1 : PPWizard #define statements retain the
    colors of their contents (e.g. PPWizard macros and variables)

  ppwiz_highlight_defs = 2 : preprocessor #define and #evaluate
    statements are shown in a single color with the exception of line
    continuation symbols

  The default setting for ppwiz_highlight_defs is 1.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item ppwiz_highlight_defs : PPWizard の定義についてのハイライトモードを決める。とりうる値は
@multitable @columnfractions .4 .6
@item ppwiz_highlight_defs = 1 @tab  #define 文においてその内容の色を保つ (例. PPWizard マクロと変数)
@item ppwiz_highlight_defs = 2 @tab 行継続記号を除き、#define と #evaluate 文が単一の色で表示される。
@end multitable
ppwiz_highlight_defs のデフォルトは 1 である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- ppwiz_with_html : If the value is 1 (the default), highlight literal
  HTML code; if 0, treat HTML code like ordinary text.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ppwiz_with_html : この値が 1 (デフォルト) なら、HTML コードをハイライトする。0 なら HTML コードを通常のテキストのように扱う。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
PHTML						*phtml.vim* *ft-phtml-syntax*

There are two options for the phtml syntax highlighting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{phtml.vim}
@anchor{ft-phtml-syntax}
@cindex phtml.vim
@cindex ft-phtml-syntax
@unnumberedsubsec PHTML
phtml 用の構文ハイライトには 2 つのオプションがある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you like SQL syntax highlighting inside Strings, use this: >

	:let phtml_sql_query = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列中で SQL 構文ハイライトをさせたいならこうする:
@example
:let phtml_sql_query = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For syncing, minlines defaults to 100.	If you prefer another value, you can
set "phtml_minlines" to the value you desire.  Example: >

	:let phtml_minlines = 200
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シンクロナイズについては、minlines のデフォルトは 100 になっている。他の値にしたいなら "phtml_minlines" を望む値にセットすればよい。例:
@example
:let phtml_minlines = 200
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
POSTSCRIPT				*postscr.vim* *ft-postscr-syntax*

There are several options when it comes to highlighting PostScript.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{postscr.vim}
@anchor{ft-postscr-syntax}
@cindex postscr.vim
@cindex ft-postscr-syntax
@unnumberedsubsec POSTSCRIPT
PostScript 用の構文ハイライトにはいくつかのオプションがある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
First which version of the PostScript language to highlight.  There are
currently three defined language versions, or levels.  Level 1 is the original
and base version, and includes all extensions prior to the release of level 2.
Level 2 is the most common version around, and includes its own set of
extensions prior to the release of level 3.  Level 3 is currently the highest
level supported.  You select which level of the PostScript language you want
highlighted by defining the postscr_level variable as follows: >

	:let postscr_level=2
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
まず、どのバージョンの PostScript 言語をハイライトするかである。現在のところ、言語の 3 つのバージョン、あるいはレベルが定義されている。レベル1はオリジナルの基本バージョンで、レベル 2 のリリース以前のすべての拡張を含んでいる。レベル 2 はもっとも一般的なバージョンで、レベル 3 リリース以前のすべての拡張を含んでいる。レベル 3 は現在のところサポートされている中でもっともレベルが高い。次のように変数 postscr_level を定義することによって、PostScript 言語のどのレベルをハイライトするか選ぶことができる:
@example
:let postscr_level=2
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If this variable is not defined it defaults to 2 (level 2) since this is
the most prevalent version currently.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この変数が定義されていないときはデフォルトの 2 (レベル 2)になる。これが現在のところもっとも普及しているためである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note, not all PS interpreters will support all language features for a
particular language level.  In particular the %!PS-Adobe-3.0 at the start of
PS files does NOT mean the PostScript present is level 3 PostScript!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong {Note:} @*
すべての PS インタープリターがその言語レベルのすべての言語機能をサポートしているわけではないことに注意。とくに、PS ファイルの先頭の %!PS-Adobe-3.0は 現在の PostScript がレベル 3 であることを示すわけではない！
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you are working with Display PostScript, you can include highlighting of
Display PS language features by defining the postscr_display variable as
follows: >

	:let postscr_display=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下のように変数 postscr_display を定義すると、Display PostScript の言語機能もハイライトさせることができる:
@example
:let postscr_display=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you are working with Ghostscript, you can include highlighting of
Ghostscript specific language features by defining the variable
postscr_ghostscript as follows: >

	:let postscr_ghostscript=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下のように変数 postscr_ghostscript を定義すると、Ghostscript 固有の言語機能もハイライトさせることができる:
@example
:let postscr_ghostscript=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
PostScript is a large language, with many predefined elements.	While it
useful to have all these elements highlighted, on slower machines this can
cause Vim to slow down.  In an attempt to be machine friendly font names and
character encodings are not highlighted by default.  Unless you are working
explicitly with either of these this should be ok.  If you want them to be
highlighted you should set one or both of the following variables: >

	:let postscr_fonts=1
	:let postscr_encodings=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
PostScript はたくさんの定義済み要素を持つ巨大な言語である。これらの要素すべてをハイライトすると便利であるが、そうすると遅いマシンでは Vim の動作が遅くなってしまう。マシンフレンドリーにするために、デフォルトではフォント名と文字エンコーディングはハイライトされない、これらをハイライトさせるには、以下の変数のどちらかまたは両方をセットすること:
@example
:let postscr_fonts=1
:let postscr_encodings=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There is a stylistic option to the highlighting of and, or, and not.  In
PostScript the function of these operators depends on the types of their
operands - if the operands are booleans then they are the logical operators,
if they are integers then they are binary operators.  As binary and logical
operators can be highlighted differently they have to be highlighted one way
or the other.  By default they are treated as logical operators.  They can be
highlighted as binary operators by defining the variable
postscr_andornot_binary as follows: >

	:let postscr_andornot_binary=1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
and, or, not のハイライトについて、スタイル上のオプションが存在する。PostScript では、これらの演算子の機能はオペランドの型に依存する。オペランドが両方ブール型なら論理演算子となり、両方整数型なら 2 項演算子となる。2 項演算子と論理演算子を区別してハイライトすることができるので、どちらにしてもこれらはハイライトされなければならない。デフォルトではどちらも論理演算子としてハイライトされる。変数 postscr_andornot_binary を定義すると、どちらも 2 項演算子としてハイライトされる:
@example
:let postscr_andornot_binary=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			*ptcap.vim* *ft-printcap-syntax*
PRINTCAP + TERMCAP	*ft-ptcap-syntax* *ft-termcap-syntax*

This syntax file applies to the printcap and termcap databases.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ptcap.vim}
@anchor{ft-printcap-syntax}
@anchor{ft-ptcap-syntax}
@anchor{ft-termcap-syntax}
@cindex ptcap.vim
@cindex ft-printcap-syntax
@cindex ft-ptcap-syntax
@cindex ft-termcap-syntax
@unnumberedsubsec PRINTCAP + TERMCAP
この構文ファイルは printcap と termcap データベースに適用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In order for Vim to recognize printcap/termcap files that do not match
the patterns *printcap*, or *termcap*, you must put additional patterns
appropriate to your system in your |myfiletypefile| file.  For these
patterns, you must set the variable "b:ptcap_type" to either "print" or
"term", and then the 'filetype' option to ptcap.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
 *printcap* または *termcap* というパターンにマッチしない printcap/termcap ファイルを認識させるためには、ファイル |@ref{myfiletypefile}| において、あなたのシステムに合ったパターンを追加しなければならない。これらのパターンには、変数 "b:ptcap_type" を "print" か "term" のどちらかにセットしなければならない。するとオプション '@option{filetype}' の値が @var{ptcap} になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For example, to make Vim identify all files in /etc/termcaps/ as termcap
files, add the following: >

   :au BufNewFile,BufRead /etc/termcaps/* let b:ptcap_type = "term" |
				       \ set filetype=ptcap
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば、/etc/termcaps/ 以下の全てのファイルを termcap ファイルと識別させるようにするには次を書き加える:
@example
:au BufNewFile,BufRead /etc/termcaps/* let b:ptcap_type = "term" |
                                    \ set filetype=ptcap
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you notice highlighting errors while scrolling backwards, which
are fixed when redrawing with CTRL-L, try setting the "ptcap_minlines"
internal variable to a larger number: >

   :let ptcap_minlines = 50

(The default is 20 lines.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上方向にスクロールしているときハイライトがおかしくなり、それが @kbd{CTRL-L} で再描画すると直るようなら、変数 "ptcap_minlines" の値を大きくしてみるとよい:
@example
:let ptcap_minlines = 50
@end example
(デフォルトは 20 行)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
PROGRESS				*progress.vim* *ft-progress-syntax*

Files matching "*.w" could be Progress or cweb.  If the automatic detection
doesn't work for you, or you don't edit cweb at all, use this in your
startup vimrc: >
   :let filetype_w = "progress"
The same happens for "*.i", which could be assembly, and "*.p", which could be
Pascal.  Use this if you don't use assembly and Pascal: >
   :let filetype_i = "progress"
   :let filetype_p = "progress"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{progress.vim}
@anchor{ft-progress-syntax}
@cindex progress.vim
@cindex ft-progress-syntax
@unnumberedsubsec PROGRESS
"*.w" にマッチするファイルのタイプは Progress か CWEB である。自動判別がうまく機能しないなら、または cweb ファイルを一切編集しないとわかっているなら、次を @file{vimrc} に加えるとよい:
@example
:let filetype_w = "progress"
@end example
同じことが "*.i" (アセンブリでもありうる) と "*.p" (Pascal でもありうる) にもいえる。アセンブリと Pascal を使わないとわかっているならこれを使うこと:
@example
:let filetype_i = "progress"
:let filetype_p = "progress"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
PYTHON						*python.vim* *ft-python-syntax*

There are six options to control Python syntax highlighting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{python.vim}
@anchor{ft-python-syntax}
@cindex python.vim
@cindex ft-python-syntax
@unnumberedsubsec PYTHON
Python 構文ハイライトをコントロールするオプションは 6 つある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For highlighted numbers: >
	:let python_no_number_highlight = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
数字のハイライト:
@example
:let python_no_number_highlight = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For highlighted builtin functions: >
	:let python_no_builtin_highlight = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
組み込み関数のハイライト:
@example
:let python_no_builtin_highlight = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For highlighted standard exceptions: >
	:let python_no_exception_highlight = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
標準例外のハイライト:
@example
:let python_no_exception_highlight = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For highlighted doctests and code inside: >
	:let python_no_doctest_highlight = 1
or >
	:let python_no_doctest_code_highlight = 1
(first option implies second one).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
doctest とその中のコードのハイライト:
@example
:let python_no_doctest_highlight = 1
@end example
または
@example
:let python_no_doctest_code_highlight = 1
@end example
(最初のオプションは 2 番目のオプションも含む)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For highlighted trailing whitespace and mix of spaces and tabs: >
	:let python_space_error_highlight = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
行末の空白と、スペースとタブの混在のハイライト:
@example
:let python_space_error_highlight = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want all possible Python highlighting (the same as setting the
preceding last option and unsetting all other ones): >
	:let python_highlight_all = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
全てのハイライトを有効化させるには (最後に挙げたオプションを有効化し、他のオプションを無効化するのと同じ):
@example
:let python_highlight_all = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: only existence of these options matter, not their value. You can replace
      1 above with anything.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
変数が定義されているかどうかが意味を持つ。値は関係ない。設定値は 1 以外でも構わない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
QUAKE						*quake.vim* *ft-quake-syntax*

The Quake syntax definition should work for most any FPS (First Person
Shooter) based on one of the Quake engines.  However, the command names vary
a bit between the three games (Quake, Quake 2, and Quake 3 Arena) so the
syntax definition checks for the existence of three global variables to allow
users to specify what commands are legal in their files.  The three variables
can be set for the following effects:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{quake.vim}
@anchor{ft-quake-syntax}
@cindex quake.vim
@cindex ft-quake-syntax
@unnumberedsubsec QUAKE
Quake 構文定義は Quake エンジンのどれかに基づくほとんど全ての FPS (First Person Shooter) 用に対応するはずである。しかし 3 つのゲーム (Quake, Quake 2, Quake 3 Arena) 間でコマンド名が少々異なる。そのため、3 つのグローバル変数により、どのコマンドが有効であるか指定できるようになっている。3 つの変数には次のような効果がある:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
set to highlight commands only available in Quake: >
	:let quake_is_quake1 = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Quake でのみ利用可能なコマンドをハイライトするように設定:
@example
:let quake_is_quake1 = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
set to highlight commands only available in Quake 2: >
	:let quake_is_quake2 = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Quake 2 でのみ利用可能なコマンドをハイライトするように設定:
@example
:let quake_is_quake2 = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
set to highlight commands only available in Quake 3 Arena: >
	:let quake_is_quake3 = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Quake 3 Arena でのみ利用可能なコマンドをハイライトするように設定:
@example
:let quake_is_quake3 = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Any combination of these three variables is legal, but might highlight more
commands than are actually available to you by the game.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これら 3 つのコマンドを自由に組み合わせることができる。しかしゲームで利用できないコマンドもハイライトしてしまうかもしれない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
READLINE				*readline.vim* *ft-readline-syntax*

The readline library is primarily used by the BASH shell, which adds quite a
few commands and options to the ones already available.  To highlight these
items as well you can add the following to your |vimrc| or just type it in the
command line before loading a file with the readline syntax: >
	let readline_has_bash = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{readline.vim}
@anchor{ft-readline-syntax}
@cindex readline.vim
@cindex ft-readline-syntax
@unnumberedsubsec READLINE
readline ライブラリは主として BASH シェルで使われ、BASH はかなりの数のコマンドとオプションを追加している。これらの項目を同様にハイライトするには次を |@ref{vimrc}| に加えるか、readline 構文ファイルを読み込む前にこれをタイプすればよい:
@example
let readline_has_bash = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This will add highlighting for the commands that BASH (version 2.05a and
later, and part earlier) adds.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
こうすると BASH (バージョン 2.05a 以降。一部それ以前) が追加するコマンドもハイライトするようになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
RESTRUCTURED TEXT			*rst.vim* *ft-rst-syntax*

You may set what syntax definitions should be used for code blocks via >
	let rst_syntax_code_list = ['vim', 'lisp', ...]
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{rst.vim}
@anchor{ft-rst-syntax}
@cindex rst.vim
@cindex ft-rst-syntax
@unnumberedsubsec RESTRUCTURED TEXT
コードブロックで有効にしたい構文定義を定義できる。
@example
let rst_syntax_code_list = ['vim', 'lisp', ...]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
REXX						*rexx.vim* *ft-rexx-syntax*

If you notice highlighting errors while scrolling backwards, which are fixed
when redrawing with CTRL-L, try setting the "rexx_minlines" internal variable
to a larger number: >
	:let rexx_minlines = 50
This will make the syntax synchronization start 50 lines before the first
displayed line.  The default value is 10.  The disadvantage of using a larger
number is that redrawing can become slow.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{rexx.vim}
@anchor{ft-rexx-syntax}
@cindex rexx.vim
@cindex ft-rexx-syntax
@unnumberedsubsec REXX
上方向にスクロールしているときにハイライトがおかしくなり、それが @kbd{CTRL-L} で再描画すると直るようなら、変数 "rexx_minlines" の値を大きくしてみるとよい:
@example
:let rexx_minlines = 50
@end example
こうすると構文シンクロナイズが画面最上行の 50 行前から始まるようになる。値を大きくすることの欠点は、再描画が遅くなることである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim tries to guess what type a ".r" file is.  If it can't be detected (from
comment lines), the default is "r".  To make the default rexx add this line to
your .vimrc:  *g:filetype_r*
>
	:let g:filetype_r = "r"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は ".r" ファイルのタイプを推測しようとする。(コメント行から) タイプを特定できなかった場合、デフォルトは "r" である。デフォルトを rexx にするには次の行を @file{.vimrc} に追加すること:
@anchor{g:filetype_r}
@vindex g:filetype_r
@example
:let g:filetype_r = "r"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
RUBY						*ruby.vim* *ft-ruby-syntax*

    Ruby: Operator highlighting		|ruby_operators|
    Ruby: Whitespace errors		|ruby_space_errors|
    Ruby: Folding			|ruby_fold| |ruby_foldable_groups|
    Ruby: Reducing expensive operations	|ruby_no_expensive| |ruby_minlines|
    Ruby: Spellchecking strings		|ruby_spellcheck_strings|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ruby.vim}
@anchor{ft-ruby-syntax}
@cindex ruby.vim
@cindex ft-ruby-syntax
@unnumberedsubsec RUBY
@multitable @columnfractions .5 .5
@item Ruby: 演算子のハイライト @tab |@ref{ruby_operators}|
@item Ruby: ホワイトスペース エラー @tab |@ref{ruby_space_errors}|
@item Ruby: 折り畳み @tab |@ref{ruby_fold}| |@ref{ruby_foldable_groups}|
@item Ruby: 負荷の高い処理の削減 @tab |@ref{ruby_no_expensive}| |@ref{ruby_minlines}|
@item Ruby: スペルチェック @tab |@ref{ruby_spellcheck_strings}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*ruby_operators*
 Ruby: Operator highlighting ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ruby_operators}
@vindex ruby_operators
@unnumberedsubsubsec  Ruby: 演算子のハイライト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Operators can be highlighted by defining "ruby_operators": >

	:let ruby_operators = 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"ruby_operators" を定義すると、演算子をハイライトできる:
@example
:let ruby_operators = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*ruby_space_errors*
 Ruby: Whitespace errors ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ruby_space_errors}
@vindex ruby_space_errors
@unnumberedsubsubsec Ruby: ホワイトスペース エラー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Whitespace errors can be highlighted by defining "ruby_space_errors": >

	:let ruby_space_errors = 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"ruby_space_errors" を定義すると、ホワイトスペースのエラーをハイライトできる:
@example
:let ruby_space_errors = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This will highlight trailing whitespace and tabs preceded by a space character
as errors.  This can be refined by defining "ruby_no_trail_space_error" and
"ruby_no_tab_space_error" which will ignore trailing whitespace and tabs after
spaces respectively.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは、行末のホワイトスペースとスペース文字に続くタブ文字をエラーとしてハイライトする。"ruby_no_trail_space_error" と "ruby_no_tab_space_error" の定義により、行末のホワイトスペースやスペース文字直後のタブ文字を無視するよう個別に制御できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*ruby_fold* *ruby_foldable_groups*
 Ruby: Folding ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ruby_fold}
@anchor{ruby_foldable_groups}
@vindex ruby_fold
@vindex ruby_foldable_groups
@unnumberedsubsubsec Ruby: 折り畳み
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Folding can be enabled by defining "ruby_fold": >

	:let ruby_fold = 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"ruby_fold" を定義すると、折り畳みを有効化できる:
@example
:let ruby_fold = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This will set the value of 'foldmethod' to "syntax" locally to the current
buffer or window, which will enable syntax-based folding when editing Ruby
filetypes.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは、'@option{foldmethod}' の値として "@var{syntax}" を現在のバッファまたはウィンドウに限定で設定し、Ruby ファイルの編集時に、構文に基づく折り畳みを有効にする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Default folding is rather detailed, i.e., small syntax units like "if", "do",
"%w[]" may create corresponding fold levels.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デフォルトの折り畳みはある程度、精密である。すなわち、"if", "do", "%w[]" などの小さな構文ユニットは、対応する折り畳みレベルを構成する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can set "ruby_foldable_groups" to restrict which groups are foldable: >

        :let ruby_foldable_groups = 'if case %'
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"ruby_foldable_groups" をセットすることで、折り畳み可能なグループを制限できる:
@example
:let ruby_foldable_groups = 'if case %'
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The value is a space-separated list of keywords:

    keyword       meaning ~
    --------  ------------------------------------- ~
    ALL        Most block syntax (default)
    NONE       Nothing
    if         "if" or "unless" block
    def        "def" block
    class      "class" block
    module     "module" block
    do         "do" block
    begin      "begin" block
    case       "case" block
    for        "for", "while", "until" loops
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
値は、キーワードのリストをスペース文字区切りで指定:
@multitable @columnfractions .2 .8
@headitem キーワード @tab 意味
@item ALL @tab 大部分のブロック構文 (デフォルト)
@item NONE @tab なし
@item if @tab "if" or "unless" ブロック
@item def @tab "def" ブロック
@item class @tab "class" ブロック
@item module @tab "module" ブロック
@item do @tab "do" ブロック
@item begin @tab "begin" ブロック
@item case @tab "case" ブロック
@item for @tab "for", "while", "until" ループ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    {          Curly bracket block or hash literal
    [          Array literal
    %          Literal with "%" notation, e.g.: %w(STRING), %!STRING!
    /          Regexp
    string     String and shell command output (surrounded by ', ", `)
    :          Symbol
    #          Multiline comment
    <<         Here documents
    __END__    Source code after "__END__" directive
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @{ @tab 波カッコ ブロック、またはハッシュ リテラル
@item [ @tab 配列リテラル
@item % @tab "%" 記法によるリテラル。 例: %w(STRING), %!STRING!
@item / @tab 正規表現
@item string @tab 文字列とシェルコマンドの出力 (', ", ` でくくられた)
@item : @tab シンボル
@item # @tab 複数行コメント
@item << @tab ヒアドキュメント
@item __END__ @tab "__END__" ディレクティブ以降のソースコード
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*ruby_no_expensive*
 Ruby: Reducing expensive operations ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ruby_no_expensive}
@vindex ruby_no_expensive
@unnumberedsubsubsec Ruby: 負荷の高い処理の削減
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
By default, the "end" keyword is colorized according to the opening statement
of the block it closes.  While useful, this feature can be expensive; if you
experience slow redrawing (or you are on a terminal with poor color support)
you may want to turn it off by defining the "ruby_no_expensive" variable: >

	:let ruby_no_expensive = 1
<
In this case the same color will be used for all control keywords.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デフォルトではキーワード "end" はそれに対応するブロック開始文にしたがって色づけされる。この機能は便利だが、コストがかかる。再描画が遅くなったら (または色機能の貧弱なターミナルを使っているなら) 変数 "ruby_no_expensive" を定義することによってこの機能をオフにできる:
@example
:let ruby_no_expensive = 1
@end example
この場合すべての制御キーワードに同じ色が使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*ruby_minlines*

If you do want this feature enabled, but notice highlighting errors while
scrolling backwards, which are fixed when redrawing with CTRL-L, try setting
the "ruby_minlines" variable to a value larger than 50: >

	:let ruby_minlines = 100
<
Ideally, this value should be a number of lines large enough to embrace your
largest class or module.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ruby_minlines}
@vindex ruby_minlines
この機能を有効化したいが、上にスクロールしているときにハイライトがおかしくなり、それが @kbd{CTRL-L} で再描画すると直るようなら、変数 "ruby_minlines" を 50 以上の値にセットしてみるとよい:
@example
:let ruby_minlines = 100
@end example
理想的には、ファイル中の最も行数の多いクラスやモジュールをカバーできるほどの十分な行数を値として設定するべき。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*ruby_spellcheck_strings*
 Ruby: Spellchecking strings ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ruby_spellcheck_strings}
@vindex ruby_spellcheck_strings
@unnumberedsubsubsec Ruby: スペルチェック
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Ruby syntax will perform spellchecking of strings if you define
"ruby_spellcheck_strings": >

	:let ruby_spellcheck_strings = 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"ruby_spellcheck_strings" を定義すると、Ruby シンタックスはスペルチェックを行う:
@example
:let ruby_spellcheck_strings = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
SCHEME						*scheme.vim* *ft-scheme-syntax*

By default only R7RS keywords are highlighted and properly indented.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{scheme.vim}
@anchor{ft-scheme-syntax}
@cindex scheme.vim
@cindex ft-scheme-syntax
@unnumberedsubsec SCHEME
デフォルトでは R7RS のキーワードだけをハイライトし、正しくインデントする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
scheme.vim also supports extensions of the CHICKEN Scheme->C compiler.
Define b:is_chicken or g:is_chicken, if you need them.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
scheme.vim は CHICKEN Scheme->C コンパイラの拡張子にも対応している。それを有効にするには b:is_chicken または g:is_chicken を定義する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
SDL						*sdl.vim* *ft-sdl-syntax*

The SDL highlighting probably misses a few keywords, but SDL has so many
of them it's almost impossibly to cope.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sdl.vim}
@anchor{ft-sdl-syntax}
@cindex sdl.vim
@cindex ft-sdl-syntax
@unnumberedsubsec SDL
SDL 用のハイライトにはいくつかのキーワードが抜けているかもしれない。しかし SDL にはたくさんのキーワードがあるので、すべてに対応することはほとんど不可能である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The new standard, SDL-2000, specifies that all identifiers are
case-sensitive (which was not so before), and that all keywords can be
used either completely lowercase or completely uppercase.  To have the
highlighting reflect this, you can set the following variable: >
	:let sdl_2000=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しい標準 SDL-2000 ではすべての識別子の大文字・小文字が区別される (以前はそうではなかった)。また、すべてのキーワードが全部大文字または全部小文字であってもよい。構文ハイライトにこれを反映させるには次の変数をセットすればよい:
@example
:let sdl_2000=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This also sets many new keywords.  If you want to disable the old
keywords, which is probably a good idea, use: >
	:let SDL_no_96=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはたくさんの新しいキーワードもセットする。古いキーワードを無効にするには (これはよい考えである)こうする:
@example
:let SDL_no_96=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
The indentation is probably also incomplete, but right now I am very
satisfied with it for my own projects.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
インデントもおそらく不完全であるが、今のところ私はこれでとても満足している。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
SED						*sed.vim* *ft-sed-syntax*

To make tabs stand out from regular blanks (accomplished by using Todo
highlighting on the tabs), define "highlight_sedtabs" by putting >

	:let highlight_sedtabs = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sed.vim}
@anchor{ft-sed-syntax}
@cindex sed.vim
@cindex ft-sed-syntax
@unnumberedsubsec SED
タブをハイライトして通常の空白と区別しやすくするには、次の行を @file{vimrc} に書いて "highlight_sedtabs" を定義する (TODO と同じ構文グループが使われる)
@example
:let highlight_sedtabs = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
in the vimrc file.  (This special highlighting only applies for tabs
inside search patterns, replacement texts, addresses or text included
by an Append/Change/Insert command.)  If you enable this option, it is
also a good idea to set the tab width to one character; by doing that,
you can easily count the number of tabs in a string.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
(タブのハイライトは、検索パターン、置換テキスト、アドレス、Append/Change/Insert コマンドに含まれるテキストいずれかの中のタブにだけ適用される)。このオプションを有効化するなら、タブ幅を 1 文字にするとよい。そうすると文字列中のタブの数を数えやすくなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Bugs:

  The transform command (y) is treated exactly like the substitute
  command.  This means that, as far as this syntax file is concerned,
  transform accepts the same flags as substitute, which is wrong.
  (Transform accepts no flags.)  I tolerate this bug because the
  involved commands need very complex treatment (95 patterns, one for
  each plausible pattern delimiter).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec バグ:
変換コマンド (y) は置換コマンドとまったく同様に扱われる。つまり、この構文ファイルにおいては、変換は置換と同じフラグを受け取ると判断される。これは間違いである (変換は一切フラグを受け取らない)。これに関係したコマンドは非常に複雑な処理を要求するため (95 パターン、もっともらしいパターンデリミタごとに 1 つ)、私はこのバグを容認している。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
SGML						*sgml.vim* *ft-sgml-syntax*

The coloring scheme for tags in the SGML file works as follows.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sgml.vim}
@anchor{ft-sgml-syntax}
@cindex sgml.vim
@cindex ft-sgml-syntax
@unnumberedsubsec SGML
SGML ファイル中のタグをハイライトする方法は以下のように動作する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The <> of opening tags are colored differently than the </> of a closing tag.
This is on purpose! For opening tags the 'Function' color is used, while for
closing tags the 'Type' color is used (See syntax.vim to check how those are
defined for you)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
開きタグ <> と閉じタグ </> は異なる色がつけられる。これは意図されたものである。開きタグには 'Function' の色が使われ、閉じタグには 'Type' の色が使われる (これらがどう定義されているかを確かめたいなら syntax.vim を見ること)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Known tag names are colored the same way as statements in C.  Unknown tag
names are not colored which makes it easy to spot errors.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
登録されているタグ名は C の文と同じ方法で色づけされる。エラーを見つけやすくするため、登録されていないタグ名は色づけされない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that the same is true for argument (or attribute) names.  Known attribute
names are colored differently than unknown ones.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
引数名 (や属性名) も同様である。登録されている属性名は登録されていない属性名と異なる色がつけられる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Some SGML tags are used to change the rendering of text.  The following tags
are recognized by the sgml.vim syntax coloring file and change the way normal
text is shown: <varname> <emphasis> <command> <function> <literal>
<replaceable> <ulink> and <link>.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
いくつかの SGML タグはテキストの外見を変更するのに使われる。以下のタグは構文ファイル @file{sgml.vim} によって認識され、通常のテキストの表示法を変更する:

<varname> <emphasis> <command> <function> <literal> <replaceable> <ulink> <link>。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to change how such text is rendered, you must redefine the
following syntax groups:

    - sgmlBold
    - sgmlBoldItalic
    - sgmlUnderline
    - sgmlItalic
    - sgmlLink for links
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
そのテキストの表示法を変えたいなら以下の構文グループを再定義しなければならない:
@itemize
@item sgmlBold
@item sgmlBoldItalic
@item sgmlUnderline
@item sgmlItalic
@item sgmlLink リンク用
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To make this redefinition work you must redefine them all and define the
following variable in your vimrc (this is due to the order in which the files
are read during initialization) >
   let sgml_my_rendering=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この再定義を機能させるにはこれらすべてを再定義し、以下の変数を vimrc 中で定義しなければならない (初期化の際にファイルが読み込まれる順序のため)
@example
let sgml_my_rendering=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can also disable this rendering by adding the following line to your
vimrc file: >
   let sgml_no_rendering=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この表示法を無効にしたければ次の行を vimrc に加える:
@example
let sgml_no_rendering=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
(Adapted from the html.vim help text by Claudio Fleiner <claudio@fleiner.com>)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
(Claudio Fleiner <claudio@@fleiner.com> による @file{html.vim} のヘルプテキストから一部借用した)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
		*ft-posix-synax* *ft-dash-syntax*
SH		*sh.vim*  *ft-sh-syntax*  *ft-bash-syntax*  *ft-ksh-syntax*

This covers syntax highlighting for the older Unix (Bourne) sh, and newer
shells such as bash, dash, posix, and the Korn shells.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ft-posix-synax}
@anchor{ft-dash-syntax}
@anchor{sh.vim}
@anchor{ft-sh-syntax}
@anchor{ft-bash-syntax}
@anchor{ft-ksh-syntax}
@cindex ft-posix-synax
@cindex ft-dash-syntax
@cindex sh.vim
@cindex ft-sh-syntax
@cindex ft-bash-syntax
@cindex ft-ksh-syntax
@unnumberedsubsec SH
これは、古い UNIX (Bourne) sh と bash や dash, POSIX, Korn シェルのような新しい UNIX シェルの構文ハイライトをカバーする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim attempts to determine which shell type is in use by specifying that
various filenames are of specific types: >

    ksh : .kshrc* *.ksh
    bash: .bashrc* bashrc bash.bashrc .bash_profile* *.bash
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は様々なファイル名がどのタイプであるかを指定することによって、どのシェルが使われているかを決定しようとする:
@multitable @columnfractions .1 .9
@item ksh: @tab .kshrc* *.ksh
@item bash: @tab .bashrc* bashrc bash.bashrc .bash_profile* *.bash
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
If none of these cases pertain, then the first line of the file is examined
(ex. looking for /bin/sh  /bin/ksh  /bin/bash).  If the first line specifies a
shelltype, then that shelltype is used.  However some files (ex. .profile) are
known to be shell files but the type is not apparent.  Furthermore, on many
systems sh is symbolically linked to "bash" (Linux, Windows+cygwin) or "ksh"
(Posix).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのうちどれにも当てはまらなければ、ファイルの第一行によって判断される (例.  /bin/sh /bin/ksh /bin/bash を探す)。第一行でシェルを指定されていれば、そのシェルが使用される。しかしいくつかのファイル (例. .profile) はシェルファイルであることはわかっていても、どのタイプか明らかではない。さらに、多くのシステムで sh は "bash" (Linux, Windows+cygwin) や "ksh" (Posix) へのシンボリックリンクになっている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
One may specify a global default by instantiating one of the following
variables in your <.vimrc>:

   ksh: >
	let g:is_kornshell = 1
<   posix:  (using this is the nearly the same as setting g:is_kornshell to 1) >
	let g:is_posix     = 1
<   bash: >
	let g:is_bash	   = 1
<   sh: (default) Bourne shell >
	let g:is_sh	   = 1

<   (dash users should use posix)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下の変数のどれかを @file{.vimrc} で定義することにより、デフォルトを設定することができる:

ksh:
@example
let g:is_kornshell = 1
@end example
posix: (これは g:is_kornshell に 1 を設定することとほぼ同じ)
@example
let g:is_posix = 1
@end example
bash:
@example
let g:is_bash = 1
@end example
sh: (デフォルト) Bourne shell
@example
let g:is_sh = 1
@end example
(dash 使用者は posix を使用するべき)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If there's no "#! ..." line, and the user hasn't availed himself/herself of a
default sh.vim syntax setting as just shown, then syntax/sh.vim will assume
the Bourne shell syntax.  No need to quote RFCs or market penetration
statistics in error reports, please -- just select the default version of the
sh your system uses and install the associated "let..." in your <.vimrc>.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"#! ..." という行がなく、かつユーザーが上の方法でデフォルトの @file{sh.vim} の構文を設定していない場合、@file{sh.vim} は Bourne シェルの構文であると仮定する。エラーレポートで RFC や市場浸透統計を引用する必要はありません。ただただ、デフォルトでシステムに使用されるバージョンのシェルを選択し、それに対応する "let..." をあなたの @file{.vimrc} に導入してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The syntax/sh.vim file provides several levels of syntax-based folding: >

	let g:sh_fold_enabled= 0     (default, no syntax folding)
	let g:sh_fold_enabled= 1     (enable function folding)
	let g:sh_fold_enabled= 2     (enable heredoc folding)
	let g:sh_fold_enabled= 4     (enable if/do/for folding)
>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
syntax/@file{sh.vim} は構文ベースの折り畳みを数種類用意している:
@multitable @columnfractions .5 .5
@item let g:sh_fold_enabled= 0 @tab (デフォルト。構文折り畳みなし)
@item let g:sh_fold_enabled= 1 @tab (関数の折り畳みを有効化)
@item let g:sh_fold_enabled= 2 @tab (ヒアドキュメントの折り畳みを有効化)
@item let g:sh_fold_enabled= 4 @tab (if/do/for の折り畳みを有効化)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
then various syntax items (ie. HereDocuments and function bodies) become
syntax-foldable (see |:syn-fold|).  You also may add these together
to get multiple types of folding: >

	let g:sh_fold_enabled= 3     (enables function and heredoc folding)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
様々な構文要素 (例: ヒアドキュメントと関数の中身) が syntax メソッドによって折り畳み可能になる (|@ref{:syn-fold}|)。これらのうち複数を組み合わせることもできる:
@example
let g:sh_fold_enabled= 3     (関数とヒアドキュメントの折畳を有効化)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you notice highlighting errors while scrolling backwards which are fixed
when one redraws with CTRL-L, try setting the "sh_minlines" internal variable
to a larger number.  Example: >

	let sh_minlines = 500
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上方向にスクロールしているときにハイライトがおかしくなり、それが @kbd{CTRL-L} で再描画すると直るようなら、変数 "sh_minlines" の値を大きくしてみるとよい。例:
@example
let sh_minlines = 500
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This will make syntax synchronization start 500 lines before the first
displayed line.  The default value is 200.  The disadvantage of using a larger
number is that redrawing can become slow.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
こうすると構文シンクロナイズが画面最上行の 500 行前から始まるようになる。デフォルトの値は 200 である。大きい値を設定することの欠点は、動作が遅くなるかもしれないことである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you don't have much to synchronize on, displaying can be very slow.	To
reduce this, the "sh_maxlines" internal variable can be set.  Example: >

	let sh_maxlines = 100
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シンクロナイズさせるものがあまりないときは表示がとても遅くなるかもしれない。これを減らすために、変数 "sh_maxlines" をセットすることができる。例:
@example
let sh_maxlines = 100
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The default is to use the twice sh_minlines.  Set it to a smaller number to
speed up displaying.  The disadvantage is that highlight errors may appear.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デフォルトは sh_minlines の 2 倍の値が使われる。表示を高速化するにはこれをもっと小さい値にすること。欠点はハイライト間違いが出るかもしれないことである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
syntax/sh.vim tries to flag certain problems as errors; usually things like
extra ']'s, 'done's, 'fi's, etc.  If you find the error handling problematic
for your purposes, you may suppress such error highlighting by putting
the following line in your .vimrc: >

	let g:sh_no_error= 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
syntax/@file{sh.vim} は特定のプログラムをエラーとして表示しようとする。通常は、余分な ']', 'done', 'fi' などがこれに当たる。もしもこのエラーの扱いがあなたの目的で問題を起こす場合は、@file{.vimrc} に以下を書くことでエラーの強調表示を抑制できる:
@example
let g:sh_no_error= 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*sh-embed*  *sh-awk*
 Sh: EMBEDDING LANGUAGES~

You may wish to embed languages into sh.  I'll give an example courtesy of
Lorance Stinson on how to do this with awk as an example. Put the following
file into $HOME/.vim/after/syntax/sh/awkembed.vim: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sh-embed}
@anchor{sh-awk}
@cindex sh-embed
@cindex sh-awk
@unnumberedsubsubsec Sh: 埋め込み言語
sh に言語を埋め込みたい場合。Lorance Stinson が awk を埋め込む例を出してくれたのでそれを載せる。以下のファイルを $HOME/.vim/after/syntax/sh/@file{awkembed.vim} に置くこと:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
    " AWK Embedding:
    " ==============
    " Shamelessly ripped from aspperl.vim by Aaron Hope.
    if exists("b:current_syntax")
      unlet b:current_syntax
    endif
    syn include @AWKScript syntax/awk.vim
    syn region AWKScriptCode matchgroup=AWKCommand start=+[=\\]\@<!'+ skip=+\\'+ end=+'+ contains=@AWKScript contained
    syn region AWKScriptEmbedded matchgroup=AWKCommand start=+\<awk\>+ skip=+\\$+ end=+[=\\]\@<!'+me=e-1 contains=@shIdList,@shExprList2 nextgroup=AWKScriptCode
    syn cluster shCommandSubList add=AWKScriptEmbedded
    hi def link AWKCommand Type
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
" AWK Embedding:
" ==============
" Shamelessly ripped from aspperl.vim by Aaron Hope.
if exists("b:current_syntax")
  unlet b:current_syntax
endif
syn include @AWKScript syntax/awk.vim
syn region AWKScriptCode matchgroup=AWKCommand start=+[=\\]\@<!'+ skip=+\\'+ end=+'+ contains=@AWKScript contained
syn region AWKScriptEmbedded matchgroup=AWKCommand start=+\<awk\>+ skip=+\\$+ end=+[=\\]\@<!'+me=e-1 contains=@shIdList,@shExprList2 nextgroup=AWKScriptCode
syn cluster shCommandSubList add=AWKScriptEmbedded
hi def link AWKCommand Type
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This code will then let the awk code in the single quotes: >
	awk '...awk code here...'
be highlighted using the awk highlighting syntax.  Clearly this may be
extended to other languages.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この例では次のようなシングルクォートで囲まれた awk コードが awk 言語として強調表示されるようになる:
@example
awk '...awk code here...'
@end example
これは他の言語にも応用できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
SPEEDUP						*spup.vim* *ft-spup-syntax*
(AspenTech plant simulator)

The Speedup syntax file has some options:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{spup.vim}
@anchor{ft-spup-syntax}
@cindex spup.vim
@cindex ft-spup-syntax
@unnumberedsubsec SPEEDUP
(AspenTech plant simulator)

Speedup 構文ファイルにはいくつかのオプションがある:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- strict_subsections : If this variable is defined, only keywords for
  sections and subsections will be highlighted as statements but not
  other keywords (like WITHIN in the OPERATION section).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item strict_subsections : この変数が定義されていると、セクションとサブセクション用のキーワードだけが文としてハイライトされ、他のキーワードにはされなくなる (OPERATION セクションの WITHIN と同様)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- highlight_types : Definition of this variable causes stream types
  like temperature or pressure to be highlighted as Type, not as a
  plain Identifier.  Included are the types that are usually found in
  the DECLARE section; if you defined own types, you have to include
  them in the syntax file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item highlight_types : この変数が定義されていると、温度や圧力のようなストリーム型が単純な識別子でなく Type としてハイライトされる。Included は通常 DECLARE セクション中に現れる型である; ユーザーが自分用の型を定義しているならそれらを構文ファイルに含めなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
- oneline_comments : this value ranges from 1 to 3 and determines the
  highlighting of # style comments.

  oneline_comments = 1 : allow normal Speedup code after an even
  number of #s.

  oneline_comments = 2 : show code starting with the second # as
  error.  This is the default setting.

  oneline_comments = 3 : show the whole line as error if it contains
  more than one #.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item oneline_comments : この値は 1 から 3 までの間になり、# スタイルのコメントのハイライトを決定する。
@multitable @columnfractions .4 .6
@item oneline_comments = 1 @tab  偶数個の # の後にも通常の Speedup コードが現れることを許す
@item oneline_comments = 2 @tab  2 番目の # で始まるコードをエラーとして表示する。これがデフォルトの設定である。
@item oneline_comments = 3 @tab 1 個以上の # を含む行全体をエラーとしてハイライトする。
@end multitable
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Since especially OPERATION sections tend to become very large due to
PRESETting variables, syncing may be critical.  If your computer is
fast enough, you can increase minlines and/or maxlines near the end of
the syntax file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変数の PRESET により、OPERATION セクションはとても大きくなりがちであり、そのためシンクロナイズが追いつかなくなるかもしれない。あなたのコンピュータが十分速いなら構文ファイルの最後近くで minlines と maxlines の値を大きくするとよいかもしれない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
SQL						*sql.vim* *ft-sql-syntax*
				*sqlinformix.vim* *ft-sqlinformix-syntax*
				*sqlanywhere.vim* *ft-sqlanywhere-syntax*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{sql.vim}
@anchor{ft-sql-syntax}
@anchor{sqlinformix.vim}
@anchor{ft-sqlinformix-syntax}
@anchor{sqlanywhere.vim}
@anchor{ft-sqlanywhere-syntax}
@cindex sql.vim
@cindex ft-sql-syntax
@cindex sqlinformix.vim
@cindex ft-sqlinformix-syntax
@cindex sqlanywhere.vim
@cindex ft-sqlanywhere-syntax
@unnumberedsubsec SQL
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
While there is an ANSI standard for SQL, most database engines add their own
custom extensions.  Vim currently supports the Oracle and Informix dialects of
SQL.  Vim assumes "*.sql" files are Oracle SQL by default.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
SQL には ANSI 標準があるのだが、ほとんどのデータベースエンジンは独自の拡張を追加している。現在のところ、Vim は Oracle と Informix の SQL 方言をサポートしている。デフォルトでは Vim は "*.sql" のファイルを Oracle SQL であると判断する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim currently has SQL support for a variety of different vendors via syntax
scripts.  You can change Vim's default from Oracle to any of the current SQL
supported types.  You can also easily alter the SQL dialect being used on a
buffer by buffer basis.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
現在のところ、Vim は構文スクリプトによって、様々なベンダーの SQL に対応している。デフォルト設定を Oracle から他の対応している SQL に変更することができる。また、バッファごとに使う SQL の方言を変えることも簡単にできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For more detailed instructions see |ft_sql.txt|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
より詳しい説明は |@ref{ft_sql.txt}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
TCSH						*tcsh.vim* *ft-tcsh-syntax*

This covers the shell named "tcsh".  It is a superset of csh.  See |csh.vim|
for how the filetype is detected.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tcsh.vim}
@anchor{ft-tcsh-syntax}
@cindex tcsh.vim
@cindex ft-tcsh-syntax
@unnumberedsubsec TCSH
これは "tcsh" という名前のシェルをカバーしている。これは csh のスーパーセットである。ファイル形式がどのように判定されるかは |@ref{csh.vim}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Tcsh does not allow \" in strings unless the "backslash_quote" shell variable
is set.  If you want VIM to assume that no backslash quote constructs exist add
this line to your .vimrc: >

	:let tcsh_backslash_quote = 0
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
tcsh はシェル変数 backslash_quote をセットしていない限り文字列中に \" が現れることを許さない。Vim にバックスラッシュクォート構文が存在しないと判断させたいなら、次の行を @file{.vimrc} に加えること:
@example
:let tcsh_backslash_quote = 0
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you notice highlighting errors while scrolling backwards, which are fixed
when redrawing with CTRL-L, try setting the "tcsh_minlines" internal variable
to a larger number: >

	:let tcsh_minlines = 1000
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上方向にスクロールしているときにハイライトがおかしくなり、それが @kbd{CTRL-L} で再描画すると直るようなら、変数 tcsh_minlines の値を大きくしてみるとよい:
@example
:let tcsh_minlines = 1000
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This will make the syntax synchronization start 1000 lines before the first
displayed line.  If you set "tcsh_minlines" to "fromstart", then
synchronization is done from the start of the file. The default value for
tcsh_minlines is 100.  The disadvantage of using a larger number is that
redrawing can become slow.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
こうすると構文シンクロナイズが画面最上行の 1000 行前から始まるようになる。tcsh_minlines に "fromstart" をセットすると、ファイルの先頭からシンクロナイズが行われるようになる。tcsh_minlines の既定値は 100。大きな値にすることの欠点は、再描画が遅くなることである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
TEX				*tex.vim* *ft-tex-syntax* *latex-syntax*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tex.vim}
@anchor{ft-tex-syntax}
@anchor{latex-syntax}
@cindex tex.vim
@cindex ft-tex-syntax
@cindex latex-syntax
@unnumberedsubsec TEX
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			Tex Contents~
	Tex: Want Syntax Folding?			|tex-folding|
	Tex: No Spell Checking Wanted			|g:tex_nospell|
	Tex: Don't Want Spell Checking In Comments?	|tex-nospell|
	Tex: Want Spell Checking in Verbatim Zones?	|tex-verb|
	Tex: Run-on Comments or MathZones		|tex-runon|
	Tex: Slow Syntax Highlighting?			|tex-slow|
	Tex: Want To Highlight More Commands?		|tex-morecommands|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec Tex 目次
@multitable @columnfractions .7 .3
@item Tex: 構文折り畳みをするには @tab |@ref{tex-folding}|
@item Tex: スペルチェックを行いたくない場合 @tab |@ref{g:tex_nospell}|
@item Tex: コメントの中ではスペルチェックを行いたくない場合 @tab |@ref{tex-nospell}|
@item Tex: Verbatim ゾーンをスペルチェックするには @tab |@ref{tex-verb}|
@item Tex: コメントや MathZone の区切り @tab |@ref{tex-runon}|
@item Tex: 構文ハイライトが遅いならば @tab |@ref{tex-slow}|
@item Tex: もっとコマンドをハイライトさせるには @tab |@ref{tex-morecommands}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	Tex: Excessive Error Highlighting?		|tex-error|
	Tex: Need a new Math Group?			|tex-math|
	Tex: Starting a New Style?			|tex-style|
	Tex: Taking Advantage of Conceal Mode		|tex-conceal|
	Tex: Selective Conceal Mode			|g:tex_conceal|
	Tex: Controlling iskeyword			|g:tex_isk|
	Tex: Fine Subscript and Superscript Control	|tex-supersub|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item Tex: エラーのハイライトが行き過ぎならば @tab |@ref{tex-error}|
@item Tex: 新しいMathグループが必要ならば @tab |@ref{tex-math}|
@item Tex: 新しいスタイルを始めるには @tab |@ref{tex-style}|
@item Tex: Conceal モードを活用する @tab |@ref{tex-conceal}|
@item Tex: Conceal モードの選択 @tab |@ref{g:tex_conceal}|
@item Tex: iskeyword を制御する @tab |@ref{g:tex_isk}|
@item Tex: 下付き記号と上付き記号を制御する @tab |@ref{tex-supersub}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*tex-folding* *g:tex_fold_enabled*
 Tex: Want Syntax Folding? ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tex-folding}
@anchor{g:tex_fold_enabled}
@cindex tex-folding
@vindex g:tex_fold_enabled
@unnumberedsubsubsec 構文折り畳みをするには
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
As of version 28 of <syntax/tex.vim>, syntax-based folding of parts, chapters,
sections, subsections, etc are supported.  Put >
	let g:tex_fold_enabled=1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
<syntax/tex.vim> のバージョン28以降では、構文による部分、章、節、小節などの折り畳みに対応している。それを有効にするには次の行を <.vimrc> に書き、
@example
let g:tex_fold_enabled=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
in your <.vimrc>, and :set fdm=syntax.  I suggest doing the latter via a
modeline at the end of your LaTeX file: >
	% vim: fdm=syntax
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@command{:set fdm=syntax} とする。後者を LaTeX ファイルの末尾にモードラインとして書いておくといいかもしれない:
@example
% vim: fdm=syntax
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
If your system becomes too slow, then you might wish to look into >
	https://vimhelp.appspot.com/vim_faq.txt.html#faq-29.7
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これによってシステムが遅くなり過ぎる場合は次のリンクを参照すること

@url{https://vimhelp.appspot.com/vim_faq.txt.html#faq-29.7}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*g:tex_nospell*
 Tex: No Spell Checking Wanted~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:tex_nospell}
@vindex g:tex_nospell
@unnumberedsubsubsec Tex: スペルチェックを行いたくない場合
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you don't want spell checking anywhere in your LaTeX document, put >
	let g:tex_nospell=1
into your .vimrc.  If you merely wish to suppress spell checking inside
comments only, see |g:tex_comment_nospell|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
LaTeX 文章でどこにもスペルチェックを行わせたくない場合は、
@example
let g:tex_nospell=1
@end example
を @file{.vimrc} に書けばよい。ただ単にコメント内だけでスペルチェックを抑制したい場合は、|@ref{g:tex_comment_nospell}| を参照せよ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*tex-nospell* *g:tex_comment_nospell*
 Tex: Don't Want Spell Checking In Comments? ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tex-nospell}
@anchor{g:tex_comment_nospell}
@cindex tex-nospell
@vindex g:tex_comment_nospell
@unnumberedsubsubsec Tex: コメントの中ではスペルチェックを行いたくない場合
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Some folks like to include things like source code in comments and so would
prefer that spell checking be disabled in comments in LaTeX files.  To do
this, put the following in your <.vimrc>: >
      let g:tex_comment_nospell= 1
If you want to suppress spell checking everywhere inside your LaTeX document,
see |g:tex_nospell|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
LaTeX ファイルのコメントの中にソースコードのようなものを含めることがあるので、コメントの中ではスペルチェックを無効にしたいという人もいる。そのようにするには次の行を @file{.vimrc} に加える:
@example
let g:tex_comment_nospell= 1
@end example
LaTeX 文章中のどこででもスペルチェックを抑制したい場合は、|@ref{g:tex_nospell}| を参照せよ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*tex-verb* *g:tex_verbspell*
 Tex: Want Spell Checking in Verbatim Zones?~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tex-verb}
@anchor{g:tex_verbspell}
@cindex tex-verb
@vindex g:tex_verbspell
@unnumberedsubsubsec Tex: Verbatim ゾーンをスペルチェックするには
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Often verbatim regions are used for things like source code; seldom does
one want source code spell-checked.  However, for those of you who do
want your verbatim zones spell-checked, put the following in your <.vimrc>: >
	let g:tex_verbspell= 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
たいてい verbatim リージョンはソースコードのようなものを書くのに使われる。ソースコードをスペルチェックしたいと思うことはほとんどないだろう。とはいえ、もし verbatim ゾーンの内容をスペルチェックしたいときは <.vimrc> で次のように設定すること:
@example
let g:tex_verbspell= 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*tex-runon* *tex-stopzone*
 Tex: Run-on Comments or MathZones ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tex-runon}
@anchor{tex-stopzone}
@cindex tex-runon
@cindex tex-stopzone
@unnumberedsubsubsec Tex: コメントや MathZone の区切り
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The <syntax/tex.vim> highlighting supports TeX, LaTeX, and some AmsTeX.  The
highlighting supports three primary zones/regions: normal, texZone, and
texMathZone.  Although considerable effort has been made to have these zones
terminate properly, zones delineated by $..$ and $$..$$ cannot be synchronized
as there's no difference between start and end patterns.  Consequently, a
special "TeX comment" has been provided >
	%stopzone
which will forcibly terminate the highlighting of either a texZone or a
texMathZone.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
<syntax/tex.vim> の構文ハイライトは TeX, LaTeX, AmsTeX をサポートしている。normal, texZone, texMathZone の 3 つの主な区間・範囲がサポートされている。これらの区間を適切に区切るようかなりの努力がされたが、$..$ と $$..$$ で線引きされる区間は開始・終了のパターンとまったく同じにシンクロナイズさせることはできない。その結果、特別な "TeX comment" が提供されている。
@example
%stopzone
@end example
このコメントがあると、ここで強制的に texZone または texMathZone のハイライトを終わらせる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*tex-slow* *tex-sync*
 Tex: Slow Syntax Highlighting? ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tex-slow}
@anchor{tex-sync}
@cindex tex-slow
@cindex tex-sync
@unnumberedsubsubsec Tex: 構文ハイライトが遅いならば
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you have a slow computer, you may wish to reduce the values for >
	:syn sync maxlines=200
	:syn sync minlines=50
(especially the latter).  If your computer is fast, you may wish to
increase them.	This primarily affects synchronizing (i.e. just what group,
if any, is the text at the top of the screen supposed to be in?).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
遅いコンピュータを使っているなら、これらの値を減らすとよいかもしれない
@example
:syn sync maxlines=200
:syn sync minlines=50
@end example
(特に後者を)。速いコンピュータを使っているならこれらの値を増やしてもよい。これらは第一にシンクロナイズ (つまり、画面最上行のテキストがどのグループに入るか) に影響を与える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Another cause of slow highlighting is due to syntax-driven folding; see
|tex-folding| for a way around this.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
構文による折り畳みによって遅くなる場合もある。回避方法については |@ref{tex-folding}| を参照のこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*g:tex_fast*

Finally, if syntax highlighting is still too slow, you may set >

	:let g:tex_fast= ""
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:tex_fast}
@vindex g:tex_fast
最後に、もし構文強調表示がまだ遅い場合は、@file{.vimrc} で次のように設定するとよい。
@example
:let g:tex_fast= ""
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
in your .vimrc.  Used this way, the g:tex_fast variable causes the syntax
highlighting script to avoid defining any regions and associated
synchronization.  The result will be much faster syntax highlighting; the
price: you will no longer have as much highlighting or any syntax-based
folding, and you will be missing syntax-based error checking.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
g:tex_fast 変数を設定すると、構文強調表示でリージョンや同期が定義されなくなる。それによって構文強調表示が速くなる。ただし、豊富な強調表示、構文ベースの折り畳み、構文ベースのエラーチェックはできなくなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You may decide that some syntax is acceptable; you may use the following table
selectively to enable just some syntax highlighting: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
特定の構文のみを有効化することもできる。次の一覧の中から有効化したい構文強調表示を選ぶことができる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
    b : allow bold and italic syntax
    c : allow texComment syntax
    m : allow texMatcher syntax (ie. {...} and [...])
    M : allow texMath syntax
    p : allow parts, chapter, section, etc syntax
    r : allow texRefZone syntax (nocite, bibliography, label, pageref, eqref)
    s : allow superscript/subscript regions
    S : allow texStyle syntax
    v : allow verbatim syntax
    V : allow texNewEnv and texNewCmd syntax
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item b @tab ボールド、イタリックを許可
@item c @tab texComment を許可
@item m @tab texMatcher を許可 (例: @{...@} と [...])
@item M @tab texMath を許可
@item p @tab 部 (parts)、章 (chapter)、節 (section) などを許可
@item r @tab texRefZone を許可 (nocite, bibliography, label, pageref, eqref)
@item s @tab superscript/subscript リージョンを許可
@item S @tab texStyle を許可
@item v @tab verbatim を許可
@item V @tab texNewEnv と texNewCmd を許可
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
As an example, let g:tex_fast= "M" will allow math-associated highlighting
but suppress all the other region-based syntax highlighting.
(also see: |g:tex_conceal| and |tex-supersub|)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば、@command{let g:tex_fast= "M"} は 数学関連の強調表示を有効化する。他のリージョンベースの構文強調表示は有効化されない。(|@ref{g:tex_conceal}| と |@ref{tex-supersub}| も参照)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*tex-morecommands* *tex-package*
 Tex: Want To Highlight More Commands? ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tex-morecommands}
@anchor{tex-package}
@cindex tex-morecommands
@cindex tex-package
@unnumberedsubsubsec Tex: もっとコマンドをハイライトさせるには
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
LaTeX is a programmable language, and so there are thousands of packages full
of specialized LaTeX commands, syntax, and fonts.  If you're using such a
package you'll often wish that the distributed syntax/tex.vim would support
it.  However, clearly this is impractical.  So please consider using the
techniques in |mysyntaxfile-add| to extend or modify the highlighting provided
by syntax/tex.vim.  Please consider uploading any extensions that you write,
which typically would go in $HOME/after/syntax/tex/[pkgname].vim, to
http://vim.sf.net/.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
LaTeX はプログラミング言語であり、特殊化された LaTeX のコマンド、構文、フォントがつまったパッケージがたくさんある。そのようなパッケージを使っている人は、標準の syntax/tex.vim にそのパッケージを対応させてほしいと思うだろう。しかしそれは明らかに非現実的である。そこで、|@ref{mysyntaxfile-add}| で使われているテクニックを使って、syntax/tex.vim で提供されているハイライトを拡張・修正してみてください。拡張 (典型的には $HOME/after/syntax/tex/[pkgname].vim に置いて使う) を書いたら、それを @url{http://vim.sf.net/} にアップロードすることを検討してみてください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*tex-error* *g:tex_no_error*
 Tex: Excessive Error Highlighting? ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tex-error}
@anchor{g:tex_no_error}
@cindex tex-error
@vindex g:tex_no_error
@unnumberedsubsubsec Tex: エラーのハイライトが行き過ぎならば
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The <tex.vim> supports lexical error checking of various sorts.  Thus,
although the error checking is ofttimes very useful, it can indicate
errors where none actually are.  If this proves to be a problem for you,
you may put in your <.vimrc> the following statement: >
	let g:tex_no_error=1
and all error checking by <syntax/tex.vim> will be suppressed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
<tex.vim> は様々な種類のレキシカルエラーチェックをサポートしている。すなわち、エラーチェックはとても便利だが、実際にはエラーでない箇所もエラーと示すかもしれない。それが嫌なら、次の行を <.vimrc> に置くとよい:
@example
let g:tex_no_error=1
@end example
すると <syntax/tex.vim> によるすべてのエラーチェックが行われなくなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
								*tex-math*
 Tex: Need a new Math Group? ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tex-math}
@cindex tex-math
@unnumberedsubsubsec Tex: 新しい Math グループが必要ならば
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to include a new math group in your LaTeX, the following
code shows you an example as to how you might do so: >
	call TexNewMathZone(sfx,mathzone,starform)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しい math グループを LaTeX に含めるには、以下のコードがその例となるだろう:
@example
call TexNewMathZone(sfx,mathzone,starform)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
You'll want to provide the new math group with a unique suffix
(currently, A-L and V-Z are taken by <syntax/tex.vim> itself).
As an example, consider how eqnarray is set up by <syntax/tex.vim>: >
	call TexNewMathZone("D","eqnarray",1)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しい math グループに一意な接尾辞をつけたいと思うだろう (現在のところ、A から L までと V から Z までは <syntax/tex.vim> 自身によって取得されている)。例として、<syntax/tex.vim> で eqnarray がどのように設定されているかを見てみよう:
@example
call TexNewMathZone("D","eqnarray",1)
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
You'll need to change "mathzone" to the name of your new math group,
and then to the call to it in .vim/after/syntax/tex.vim.
The "starform" variable, if true, implies that your new math group
has a starred form (ie. eqnarray*).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"mathzone" をあなたが作った math グループの名前に変える必要がある。また、それが呼ばれるようにするために .vim/after/syntax/tex.vim に書くこと。変数 "starform" が真ならば、あなたが作った math グループがアスタリスクつきの形をもつことを意味する (例. eqnarray*)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*tex-style* *b:tex_stylish*
 Tex: Starting a New Style? ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tex-style}
@anchor{b:tex_stylish}
@cindex tex-style
@vindex b:tex_stylish
@unnumberedsubsubsec Tex: 新しいスタイルを始めるには
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
One may use "\makeatletter" in *.tex files, thereby making the use of "@" in
commands available.  However, since the *.tex file doesn't have one of the
following suffices: sty cls clo dtx ltx, the syntax highlighting will flag
such use of @ as an error.  To solve this: >

	:let b:tex_stylish = 1
	:set ft=tex
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@file{*.tex} ファイルで "\makeatletter" を使う人がいるかもしれないので、コマンド中で "@@" が使えるようになっている。しかし @file{*.tex} ファイルは次の拡張子: sty cls clo dtx ltx を持たないので @@ をエラーと判断してハイライトする。これを解決するにはこうする:
@example
:let b:tex_stylish = 1
:set ft=tex
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Putting "let g:tex_stylish=1" into your <.vimrc> will make <syntax/tex.vim>
always accept such use of @.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@command{"let g:tex_stylish=1"} を <.vimrc> に書くと <syntax/tex.vim> は常にこのような @@ の使用法を受け入れるようになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*tex-cchar* *tex-cole* *tex-conceal*
 Tex: Taking Advantage of Conceal Mode~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tex-cchar}
@anchor{tex-cole}
@anchor{tex-conceal}
@cindex tex-cchar
@cindex tex-cole
@cindex tex-conceal
@unnumberedsubsubsec Tex: Conceal モードを活用する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you have |'conceallevel'| set to 2 and if your encoding is utf-8, then a
number of character sequences can be translated into appropriate utf-8 glyphs,
including various accented characters, Greek characters in MathZones, and
superscripts and subscripts in MathZones.  Not all characters can be made into
superscripts or subscripts; the constraint is due to what utf-8 supports.
In fact, only a few characters are supported as subscripts.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{'conceallevel'}| が 2 に設定され、エンコーディングとして utf-8 が使われているとき、さまざまな文字シーケンスがそれに対応した utf-8 グリフとして表示される。対応している文字としてはアクセント付き文字、Math ゾーンの中のギリシャ文字、Math ゾーンの中の上付き記号と下付き記号などがある。すべての上付き記号と下付き記号を表示できるわけではない。utf-8 がサポートしている範囲でのみ利用可能である。実際のところ、サポートされている下付き記号は少ししかない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
One way to use this is to have vertically split windows (see |CTRL-W_v|); one
with |'conceallevel'| at 0 and the other at 2; and both using |'scrollbind'|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
使用例としては、ウィンドウを垂直分割して (|@ref{CTRL-W_v}| 参照)、1 つのウィンドウは |@ref{'conceallevel'}| を 0 に設定してもう一方は 2 に設定し、両方で |@ref{'scrollbind'}| を設定するような使い方がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*g:tex_conceal*
 Tex: Selective Conceal Mode~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:tex_conceal}
@vindex g:tex_conceal
@unnumberedsubsubsec Tex: Conceal モードの選択
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You may selectively use conceal mode by setting g:tex_conceal in your
<.vimrc>.  By default, g:tex_conceal is set to "admgs" to enable concealment
for the following sets of characters: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
g:tex_conceal を <.vimrc> で設定することで Conceal モードの表示を変更できる。初期設定では、g:tex_conceal には "admgs" が設定されており、これによって次の文字セットが Conceal 表示される:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	a = accents/ligatures
	b = bold and italic
	d = delimiters
	m = math symbols
	g = Greek
	s = superscripts/subscripts
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .99
@item a = アクセント/合字 (accents/ligatures)
@item b = 太字と斜体 (bold and italic)
@item d = 区切り記号 (delimiters)
@item m = 数学記号 (math symbols)
@item g = ギリシャ文字 (Greek)
@item s = 上付き記号/下付き記号 (superscripts/subscripts)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
By leaving one or more of these out, the associated conceal-character
substitution will not be made.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらの文字を設定から外すことで、それに関連した文字が Conceal 表示されなくなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*g:tex_isk* *g:tex_stylish*
 Tex: Controlling iskeyword~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:tex_isk}
@anchor{g:tex_stylish}
@vindex g:tex_isk
@vindex g:tex_stylish
@unnumberedsubsubsec Tex: iskeyword を制御する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Normally, LaTeX keywords support 0-9, a-z, A-z, and 192-255 only. Latex
keywords don't support the underscore - except when in *.sty files.  The
syntax highlighting script handles this with the following logic:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
通常、LaTeX キーワードは 0-9, a-z, A-z, 192-255 のみがサポートされる。Latex キーワードはアンダースコアをサポートしない (*.sty ファイルを除く)。構文強調表示スクリプトは次の手順でそれを判断する:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	* If g:tex_stylish exists and is 1
		then the file will be treated as a "sty" file, so the "_"
		will be allowed as part of keywords
		(regardless of g:tex_isk)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize @bullet
@item g:tex_stylish が存在して値が 1 なら @*
ファイルは "sty" ファイルとして扱われる。"_" はキーワードの一部として認識される。(g:tex_isk に左右されない)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	* Else if the file's suffix is sty, cls, clo, dtx, or ltx,
		then the file will be treated as a "sty" file, so the "_"
		will be allowed as part of keywords
		(regardless of g:tex_isk)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item または、ファイル名の末尾は sty, cls, clo, dtx, ltx なら @*
ファイルは "sty" ファイルとして扱われる。"_" はキーワードの一部として認識される。(g:tex_isk に左右されない)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	* If g:tex_isk exists, then it will be used for the local 'iskeyword'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item g:tex_isk が存在するなら @*
'@option{iskeyword}' のローカル値として使用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	* Else the local 'iskeyword' will be set to 48-57,a-z,A-Z,192-255
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 存在しない場合、 @*
'@option{iskeyword}' のローカル値として 48-57, a-z, A-Z, 192-255 が設定される。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			*tex-supersub* *g:tex_superscripts* *g:tex_subscripts*
 Tex: Fine Subscript and Superscript Control~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tex-supersub}
@anchor{g:tex_superscripts}
@anchor{g:tex_subscripts}
@cindex tex-supersub
@vindex g:tex_superscripts
@vindex g:tex_subscripts
@unnumberedsubsubsec Tex: 下付き記号と上付き記号を制御する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	See |tex-conceal| for how to enable concealed character replacement.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Conceal による文字の代替表示を有効にするには |@ref{tex-conceal}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	See |g:tex_conceal| for selectively concealing accents, bold/italic,
	math, Greek, and superscripts/subscripts.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{g:tex_conceal}| を設定することでアクセント、太字/斜体、数学記号、ギリシャ文字、上付き記号/下付き記号のどれを Conceal 表示するかを選択できる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	One may exert fine control over which superscripts and subscripts one
	wants syntax-based concealment for (see |:syn-cchar|).  Since not all
	fonts support all characters, one may override the
	concealed-replacement lists; by default these lists are given by: >

	    let g:tex_superscripts= "[0-9a-zA-W.,:;+-<>/()=]"
	    let g:tex_subscripts= "[0-9aehijklmnoprstuvx,+-/().]"
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
どの上付き記号/下付き記号を構文に基づいて Conceal 表示 (|@ref{:syn-cchar}| 参照) するかを制御できる。すべてのフォントがすべての文字をサポートしているわけではないので、Conceal 表示する文字を変更できるようになっている。初期設定では次のように設定されている:
@example
let g:tex_superscripts= "[0-9a-zA-W.,:;+-<>/()=]"
let g:tex_subscripts= "[0-9aehijklmnoprstuvx,+-/().]"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	For example, I use Luxi Mono Bold; it doesn't support subscript
	characters for "hklmnpst", so I put >
		let g:tex_subscripts= "[0-9aeijoruvx,+-/().]"
<	in ~/.vim/ftplugin/tex/tex.vim in order to avoid having inscrutable
	utf-8 glyphs appear.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば、私は Luxi Mono Bold を使っているが、これは "hklmnpst" に対する下付き記号をサポートしていない。そこで私は
@example
let g:tex_subscripts= "[0-9aeijoruvx,+-/().]"
@end example
この設定を ~/.vim/ftplugin/tex/@file{tex.vim} に書いて、utf-8 の謎グリフが表示されないようにしている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
TF						*tf.vim* *ft-tf-syntax*

There is one option for the tf syntax highlighting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tf.vim}
@anchor{ft-tf-syntax}
@cindex tf.vim
@cindex ft-tf-syntax
@unnumberedsubsec TF
tf の構文ハイライトには 1 つのオプションがある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For syncing, minlines defaults to 100.	If you prefer another value, you can
set "tf_minlines" to the value you desire.  Example: >

	:let tf_minlines = your choice
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シンクロナイズについて、minlines のデフォルトは 100 になっている。この値を変えるには、"tf_minlines" に望みの値をセットする。例:
@example
:let tf_minlines = your choice
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
VIM			*vim.vim*		*ft-vim-syntax*
			*g:vimsyn_minlines*	*g:vimsyn_maxlines*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{vim.vim}
@anchor{ft-vim-syntax}
@anchor{g:vimsyn_minlines}
@anchor{g:vimsyn_maxlines}
@cindex vim.vim
@cindex ft-vim-syntax
@vindex g:vimsyn_minlines
@vindex g:vimsyn_maxlines
@unnumberedsubsec VIM
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
There is a trade-off between more accurate syntax highlighting versus screen
updating speed.  To improve accuracy, you may wish to increase the
g:vimsyn_minlines variable.  The g:vimsyn_maxlines variable may be used to
improve screen updating rates (see |:syn-sync| for more on this). >

	g:vimsyn_minlines : used to set synchronization minlines
	g:vimsyn_maxlines : used to set synchronization maxlines
<
	(g:vim_minlines and g:vim_maxlines are deprecated variants of
	these two options)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
正確な構文ハイライトと画面更新速度はトレードオフの問題である。正確さを向上させるには、変数 g:vimsyn_minlines の値を大きくすればよい。g:vimsyn_maxlines も画面更新頻度を高めるのに使える (これについては |@ref{:syn-sync}| を参照)。
@multitable @columnfractions .99
@item g:vimsyn_minlines : シンクロナイズの最小行数を指定する
@item g:vimsyn_maxlines : シンクロナイズの最大行数を指定する
@item (g:vim_minlines と g:vim_maxlines はこれらのオプションの以前の名前である)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*g:vimsyn_embed*
The g:vimsyn_embed option allows users to select what, if any, types of
embedded script highlighting they wish to have. >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:vimsyn_embed}
@vindex g:vimsyn_embed
@option{g:vimsyn_embed} オプションは、どの外部スクリプト言語の埋め込みに対応するかを指定する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
   g:vimsyn_embed == 0   : don't support any embedded scripts
   g:vimsyn_embed =~ 'l' : support embedded lua
   g:vimsyn_embed =~ 'm' : support embedded mzscheme
   g:vimsyn_embed =~ 'p' : support embedded perl
   g:vimsyn_embed =~ 'P' : support embedded python
   g:vimsyn_embed =~ 'r' : support embedded ruby
   g:vimsyn_embed =~ 't' : support embedded tcl
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item g:vimsyn_embed == 0   @tab どのスクリプトの埋め込みも対応しない
@item g:vimsyn_embed =~ 'l' @tab 埋め込み lua をサポート
@item g:vimsyn_embed =~ 'm' @tab 埋め込み mzscheme をサポート
@item g:vimsyn_embed =~ 'p' @tab 埋め込み perl をサポート
@item g:vimsyn_embed =~ 'P' @tab 埋め込み python をサポート
@item g:vimsyn_embed =~ 'r' @tab 埋め込み ruby をサポート
@item g:vimsyn_embed =~ 't' @tab 埋め込み tcl をサポート
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
By default, g:vimsyn_embed is a string supporting interpreters that your vim
itself supports.  Concatenate multiple characters to support multiple types
of embedded interpreters; ie. g:vimsyn_embed= "mp" supports embedded mzscheme
and embedded perl.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
初期設定では、@option{g:vimsyn_embed} には Vim がサポートしている言語が設定される。複数の埋め込み言語をサポートするには、それぞれの文字を組み合わせて設定する。例、@command{g:vimsyn_embed = "mp"} なら mzscheme と perl がサポートされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*g:vimsyn_folding*

Some folding is now supported with syntax/vim.vim: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:vimsyn_folding}
@vindex g:vimsyn_folding
syntax/@file{vim.vim} によって折り畳みが可能である:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
   g:vimsyn_folding == 0 or doesn't exist: no syntax-based folding
   g:vimsyn_folding =~ 'a' : augroups
   g:vimsyn_folding =~ 'f' : fold functions
   g:vimsyn_folding =~ 'l' : fold lua      script
   g:vimsyn_folding =~ 'm' : fold mzscheme script
   g:vimsyn_folding =~ 'p' : fold perl     script
   g:vimsyn_folding =~ 'P' : fold python   script
   g:vimsyn_folding =~ 'r' : fold ruby     script
   g:vimsyn_folding =~ 't' : fold tcl      script
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item g:vimsyn_folding == 0 または @* 変数が存在しない @tab 構文ベースの折り畳みはしない
@item g:vimsyn_folding =~ 'a' @tab augroups
@item g:vimsyn_folding =~ 'f' @tab 関数を折り畳む
@item g:vimsyn_folding =~ 'l' @tab lua      スクリプトを折り畳む
@item g:vimsyn_folding =~ 'm' @tab mzscheme スクリプトを折り畳む
@item g:vimsyn_folding =~ 'p' @tab perl     スクリプトを折り畳む
@item g:vimsyn_folding =~ 'P' @tab python   スクリプトを折り畳む
@item g:vimsyn_folding =~ 'r' @tab ruby     スクリプトを折り畳む
@item g:vimsyn_folding =~ 't' @tab tcl      スクリプトを折り畳む
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*g:vimsyn_noerror*
Not all error highlighting that syntax/vim.vim does may be correct; Vim script
is a difficult language to highlight correctly.  A way to suppress error
highlighting is to put the following line in your |vimrc|: >

	let g:vimsyn_noerror = 1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:vimsyn_noerror}
@vindex g:vimsyn_noerror
syntax/@file{vim.vim} によるエラーのハイライトは必ずしも正しいとは限らない。Vim script は正しくハイライトするのが難しい言語である。エラーのハイライトをやめるには次を |@ref{vimrc}| に書けばよい:
@example
let g:vimsyn_noerror = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
XF86CONFIG				*xf86conf.vim* *ft-xf86conf-syntax*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{xf86conf.vim}
@anchor{ft-xf86conf-syntax}
@cindex xf86conf.vim
@cindex ft-xf86conf-syntax
@unnumberedsubsec XF86CONFIG
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The syntax of XF86Config file differs in XFree86 v3.x and v4.x.  Both
variants are supported.  Automatic detection is used, but is far from perfect.
You may need to specify the version manually.  Set the variable
xf86conf_xfree86_version to 3 or 4 according to your XFree86 version in
your .vimrc.  Example: >
	:let xf86conf_xfree86_version=3
When using a mix of versions, set the b:xf86conf_xfree86_version variable.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
XF86Config ファイルの構文は XFree86 v3.x と v4.x で異なっている。両方のバージョンがサポートされている。自動的に判定がされるが、完全からはほど遠い。手動でバージョンを設定する必要があるかもしれない。使用している XFree86 に応じて、@file{.vimrc} 中で変数 xf86conf_xfree86_version を 3 または 4 にセットすること。例:
@example
:let xf86conf_xfree86_version=3
@end example
複数のバージョンが混在しているときには、変数 b:xf86conf_xfree86_version をセットすること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that spaces and underscores in option names are not supported.  Use
"SyncOnGreen" instead of "__s yn con gr_e_e_n" if you want the option name
highlighted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
オプション名の中のスペースとアンダースコアはハイライトされない。オプション名をハイライトさせるには "__s yn con gr_e_e_n" でなく "SyncOnGreen" と書くこと。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
XML						*xml.vim* *ft-xml-syntax*

Xml namespaces are highlighted by default.  This can be inhibited by
setting a global variable: >

	:let g:xml_namespace_transparent=1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{xml.vim}
@anchor{ft-xml-syntax}
@cindex xml.vim
@cindex ft-xml-syntax
@unnumberedsubsec XML
Xml 名前空間がデフォルトでハイライトされる。次のグローバル変数をセットするとそれが無効化される:
@example
:let g:xml_namespace_transparent=1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*xml-folding*
The xml syntax file provides syntax |folding| (see |:syn-fold|) between
start and end tags.  This can be turned on by >

	:let g:xml_syntax_folding = 1
	:set foldmethod=syntax
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{xml-folding}
@cindex xml-folding
xml 構文ファイルを使うと、開始タグと終了タグの間を折りたたむ |@ref{folding}| ことができる (|@ref{:syn-fold}| を参照)。これをオンにするには次のようにする。
@example
:let g:xml_syntax_folding = 1
:set foldmethod=syntax
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: syntax folding might slow down syntax highlighting significantly,
especially for large files.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
構文による折り畳みは、構文ハイライトを著しく遅くする可能性がある。特に巨大なファイルではそうである。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
X Pixmaps (XPM)					*xpm.vim* *ft-xpm-syntax*

xpm.vim creates its syntax items dynamically based upon the contents of the
XPM file.  Thus if you make changes e.g. in the color specification strings,
you have to source it again e.g. with ":set syn=xpm".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{xpm.vim}
@anchor{ft-xpm-syntax}
@cindex xpm.vim
@cindex ft-xpm-syntax
@unnumberedsubsec X Pixmaps (XPM)
@file{xpm.vim} は編集中の XPM ファイルの内容から、動的に構文要素を生成する。そのため、色設定文字列などを変更したときは "@command{:set syn=xpm}" などとして @file{xpm.vim} を読み直さなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To copy a pixel with one of the colors, yank a "pixel" with "yl" and insert it
somewhere else with "P".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
色つきのピクセルをコピーするには "yl" で "pixel" をヤンクし、どこかで "P" としてそれを挿入する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Do you want to draw with the mouse?  Try the following: >
   :function! GetPixel()
   :   let c = getline(".")[col(".") - 1]
   :   echo c
   :   exe "noremap <LeftMouse> <LeftMouse>r".c
   :   exe "noremap <LeftDrag>	<LeftMouse>r".c
   :endfunction
   :noremap <RightMouse> <LeftMouse>:call GetPixel()<CR>
   :set guicursor=n:hor20	   " to see the color beneath the cursor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マウスで図を描くには、次のようにしてみるとよい:
@verbatim
:function! GetPixel()
:   let c = getline(".")[col(".") - 1]
:   echo c
:   exe "noremap <LeftMouse> <LeftMouse>r".c
:   exe "noremap <LeftDrag>  <LeftMouse>r".c
:endfunction
:noremap <RightMouse> <LeftMouse>:call GetPixel()<CR>
:set guicursor=n:hor20          " to see the color beneath the cursor
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This turns the right button into a pipette and the left button into a pen.
It will work with XPM files that have one character per pixel only and you
must not click outside of the pixel strings, but feel free to improve it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これを行うと、右ボタンがピペットになり、左ボタンがペンになる。これは 1 ピクセルにつき 1 文字だけとなっている XPM ファイルでうまく機能する。ピクセル文字列の外をクリックしてはならない。これを自由に改良してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It will look much better with a font in a quadratic cell size, e.g. for X: >
	:set guifont=-*-clean-medium-r-*-*-8-*-*-*-*-80-*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
セルサイズが正方形のフォントを使うと見栄えがよくなる。X の場合の例:
@example
:set guifont=-*-clean-medium-r-*-*-8-*-*-*-*-80-*
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
YAML						*yaml.vim* *ft-yaml-syntax*

					*g:yaml_schema* *b:yaml_schema*
A YAML schema is a combination of a set of tags and a mechanism for resolving 
non-specific tags. For user this means that YAML parser may, depending on 
plain scalar contents, treat plain scalar (which can actually be only string 
and nothing else) as a value of the other type: null, boolean, floating-point, 
integer. `g:yaml_schema` option determines according to which schema values 
will be highlighted specially. Supported schemas are
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{yaml.vim}
@anchor{ft-yaml-syntax}
@anchor{g:yaml_schema}
@anchor{b:yaml_schema}
@cindex yaml.vim
@cindex ft-yaml-syntax
@vindex g:yaml_schema
@vindex b:yaml_schema
@unnumberedsubsec YAML
YAML スキーマとはタグのコンビネーションと、特定されないタグを解決する為のメカニズムである。ユーザーにとってはこれはプレーンなスカラーのコンテンツに依存してその簡素なスカラー (実際は文字列もしくはそれ以外の何か) をそれぞれ異なる値として扱う YAML パーサーを意味しているかもしれない: null, boolean, floating-point, integer.  `g:yaml_schema` オプションは特別にハイライトさせるスキーマの値を特定する為のオプション。サポートしているスキーマは
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Schema		Description ~
failsafe	No additional highlighting.
json		Supports JSON-style numbers, booleans and null.
core		Supports more number, boolean and null styles.
pyyaml		In addition to core schema supports highlighting timestamps, 
		but there are some differences in what is recognized as 
		numbers and many additional boolean values not present in core 
		schema.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item Schema @tab Description
@item failsafe @tab 追加されるハイライトはない。
@item json @tab JSON スタイルの number や boolean, null をサポートする。
@item core @tab number や boolean, null をよりサポートする。
@item pyyaml @tab timestamp のハイライトをサポートをコアスキーマに追加するが、number がどの様に認識されるか、boolean 型として認識する為に多くの値が追加されたという点で幾らか違いがある。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Default schema is `core`.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デフォルトのスキーマは `core`。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that schemas are not actually limited to plain scalars, but this is the 
only difference between schemas defined in YAML specification and the only 
difference defined in the syntax file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note} @*
@end quotation
実際にはスキーマは、プレーンなスカラーに限定されるものではない、これが YAML 仕様の定義に存在する唯一の違いであり、唯一異なるシンタックスが定義されているという点を注意しておく。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ZSH						    *zsh.vim* *ft-zsh-syntax*

The syntax script for zsh allows for syntax-based folding: >

	:let g:zsh_fold_enable = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{zsh.vim}
@anchor{ft-zsh-syntax}
@cindex zsh.vim
@cindex ft-zsh-syntax
@unnumberedsubsec ZSH
この zsh のための構文スクリプトは、構文に基づく折り畳みを可能にする:
@example
:let g:zsh_fold_enable = 1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
5. Defining a syntax					*:syn-define* *E410*

Vim understands three types of syntax items:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-define}
@anchor{E410}
@cindex :syn-define
@erindex E410
@cindex 構文を定義する
@section 5. 構文を定義する
構文アイテムには 3 つのタイプがある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. Keyword
   It can only contain keyword characters, according to the 'iskeyword'
   option.  It cannot contain other syntax items.  It will only match with a
   complete word (there are no keyword characters before or after the match).
   The keyword "if" would match in "if(a=b)", but not in "ifdef x", because
   "(" is not a keyword character and "d" is.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item キーワード (Keyword) @*
これはオプション '@option{iskeyword}' で定義されるキーワード文字だけからなる。他の構文要素を含むことはできない。完全な単語 (マッチの前後にキーワード文字が存在しない) にのみマッチする。キーワード "if" は "if(a=b)" にはマッチするが、"ifdef x" にはマッチしない。"(" はキーワード文字でなく、"d" はキーワード文字だから。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
2. Match
   This is a match with a single regexp pattern.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item マッチ (Match) @*
単一の正規表現パターンにマッチする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
3. Region
   This starts at a match of the "start" regexp pattern and ends with a match
   with the "end" regexp pattern.  Any other text can appear in between.  A
   "skip" regexp pattern can be used to avoid matching the "end" pattern.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item リージョン (Region) @*
正規表現パターン "start" のマッチ位置から始まり、正規表現パターン "end" のマッチ位置で終わる。その間にどんなテキストがあってもよい。正規表現パターン "skip" を使うとパターン "end" にマッチするのを避けることができる。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Several syntax ITEMs can be put into one syntax GROUP.	For a syntax group
you can give highlighting attributes.  For example, you could have an item
to define a "/* .. */" comment and another one that defines a "// .." comment,
and put them both in the "Comment" group.  You can then specify that a
"Comment" will be in bold font and have a blue color.  You are free to make
one highlight group for one syntax item, or put all items into one group.
This depends on how you want to specify your highlighting attributes.  Putting
each item in its own group results in having to specify the highlighting
for a lot of groups.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
複数の構文アイテムを1つの構文グループに入れることができる。構文グループにはハイライト属性を与えることができる。例えば、"/* .. */" のコメントを定義する要素と "// .." のコメントを定義する要素を作り、両方を "Comment" グループに入れる。そして "Comment" を青のボールドフォントで表示するように指定すると、両方のタイプのコメントに対して同じハイライトがされるようになる。

1 つの構文要素に対し 1 つの構文グループを作ってもよいし、すべての要素を 1 つのグループに入れてもよい。これはハイライト属性をどう指定したいかによる。各要素をそれ自身のグループに入れるとすると、たくさんのグループに対して色を指定しなければならなくなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that a syntax group and a highlight group are similar.  For a highlight
group you will have given highlight attributes.  These attributes will be used
for the syntax group with the same name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
構文グループとハイライトグループは似ているが異なることに注意。ハイライトグループに対してはハイライト属性を与えることになる。それらの属性が同名の構文グループに対して適用される。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In case more than one item matches at the same position, the one that was
defined LAST wins.  Thus you can override previously defined syntax items by
using an item that matches the same text.  But a keyword always goes before a
match or region.  And a keyword with matching case always goes before a
keyword with ignoring case.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
同じ箇所に対して複数のアイテムがマッチした場合には、最後に定義されたものが有効になる。よって同じテキストにマッチする要素を使って、以前に定義された構文アイテムを上書きすることができる。大文字・小文字の違いも含めてマッチするキーワードがある場合は、そうでないものより優先される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
PRIORITY						*:syn-priority*

When several syntax items may match, these rules are used:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-priority}
@cindex :syn-priority
@cindex 優先順位
@unnumberedsubsec 優先順位
複数の構文アイテムがマッチするときは、以下のルールが適用される:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. When multiple Match or Region items start in the same position, the item
   defined last has priority.
2. A Keyword has priority over Match and Region items.
3. An item that starts in an earlier position has priority over items that
   start in later positions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item 複数のマッチまたはリージョンアイテムが同じ場所で始まるときは、後に定義されたものが優先される。
@item マッチとリージョンよりキーワードが優先される。
@item より前の位置から始まる要素が優先される。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DEFINING CASE						*:syn-case* *E390*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-case}
@anchor{E390}
@cindex :syn-case
@erindex E390
@cindex 大文字・小文字の区別
@unnumberedsubsec 大文字・小文字の区別
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:sy[ntax] case [match | ignore]
	This defines if the following ":syntax" commands will work with
	matching case, when using "match", or with ignoring case, when using
	"ignore".  Note that any items before this are not affected, and all
	items until the next ":syntax case" command are affected.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item :sy[ntax] case [match | ignore]
これ以降の ":syntax" コマンドが大文字・小文字を区別するかどうかを定義する。"match" を使うと区別し、"ignore" を使うと区別しなくなる。これ以前の要素には影響せず、次の ":syntax case" コマンドまでのすべての要素に影響する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:sy[ntax] case
	Show either "syntax case match" or "syntax case ignore" (translated).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :sy[ntax] case
"syntax case match" または "syntax case ignore" (翻訳される)を表示する。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
SPELL CHECKING						*:syn-spell*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-spell}
@cindex :syn-spell
@cindex スペルチェック
@unnumberedsubsec スペルチェック
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:sy[ntax] spell [toplevel | notoplevel | default]
	This defines where spell checking is to be done for text that is not
	in a syntax item:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item :sy[ntax] spell [toplevel | notoplevel | default]
構文アイテムに入っていないテキストに対して、どこでスペルチェックを行うかを定義する:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	toplevel:	Text is spell checked.
	notoplevel:	Text is not spell checked.
	default:	When there is a @Spell cluster no spell checking.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item toplevel: @tab テキストのスペルチェックを行う。
@item notoplevel: @tab テキストのスペルチェックを行わない。
@item default: @tab クラスタ @@Spell があるときスペルチェックを行わない。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	For text in syntax items use the @Spell and @NoSpell clusters
	|spell-syntax|.  When there is no @Spell and no @NoSpell cluster then
	spell checking is done for "default" and "toplevel".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
構文アイテムに入っているテキストはクラスタ @@Spell と @@NoSpell を使う |@ref{spell-syntax}|。クラスタ @@Spell と@@NoSpell がないときは、スペルチェックは "default" と "toplevel" に対して行われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	To activate spell checking the 'spell' option must be set.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
スペルチェックを有効化するにはオプション '@option{spell}' をオンにしなければならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:sy[ntax] spell
	Show either "syntax spell toplevel", "syntax spell notoplevel" or
	"syntax spell default" (translated).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :sy[ntax] spell
"syntax spell toplevel", "syntax spell notoplevel" または "syntax spell default" (翻訳される) を表示する。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
SYNTAX ISKEYWORD SETTING				*:syn-iskeyword*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-iskeyword}
@cindex :syn-iskeyword
@unnumberedsubsec SYNTAX ISKEYWORD 設定
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:sy[ntax] iskeyword [clear | {option}]
	This defines the keyword characters.  It's like the 'iskeyword' option
	for but only applies to syntax highlighting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item :sy[ntax] iskeyword [clear | @{option@}]
キーワード文字を定義する。'@option{iskeyword}' オプションに似ているがシンタックスハイライトのみに適用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	clear:		Syntax specific iskeyword setting is disabled and the
			buffer-local 'iskeyword' setting is used.
	{option}        Set the syntax 'iskeyword' option to a new value. 
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item clear: @tab シンタックス固有の iskeyword の設定を無効にし、バッファローカルの '@option{iskeyword}' 設定を有効にする。
@item @{option@} @tab シンタックスの '@option{iskeyword}' オプション値を設定する。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Example: >
  :syntax iskeyword @,48-57,192-255,$,_
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
	例:
        @example
        :syntax iskeyword @@,48-57,192-255,$,_
        @end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	This would set the syntax specific iskeyword option to include all
	alphabetic characters, plus the numeric characters, all accented
	characters and also includes the "_" and the "$".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは全てのアルファベットと数字、アクセント付き文字、および "_" と "$" をシンタック固有の iskeyword オプションに設定する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	If no argument is given, the current value will be output.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数を指定しない場合は現在の値を表示する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Setting this option influences what |/\k| matches in syntax patterns
	and also determines where |:syn-keyword| will be checked for a new
	match.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このオプションを設定するとシンタックスパターン内での |@ref{/\k}| のマッチや |@ref{:syn-keyword}| が新しいマッチをチェックする際のデリミタに影響する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	It is recommended when writing syntax files, to use this command to
	set the correct value for the specific syntax language and not change
	the 'iskeyword' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シンタックスファイルを書く際はこのコマンドを使って言語固有の文法に対する正しい値を設定し '@option{iskeyword}' を変更しない事が推奨されている。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
DEFINING KEYWORDS					*:syn-keyword*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-keyword}
@cindex :syn-keyword
@cindex キーワードの定義
@unnumberedsubsec キーワードの定義
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:sy[ntax] keyword {group-name} [{options}] {keyword} .. [{options}]

	This defines a number of keywords.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item :sy[ntax] keyword @{group-name@} [@{options@}] @{keyword@} .. [@{options@}]
キーワードを定義する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	{group-name}	Is a syntax group name such as "Comment".
	[{options}]	See |:syn-arguments| below.
	{keyword} ..	Is a list of keywords which are part of this group.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item @{group-name@} @tab "Comment" のような構文グループ名。
@item [@{options@}] @tab 後述の |@ref{:syn-arguments}| を参照。
@item @{keyword@} .. @tab このグループに含めるキーワードのリスト。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Example: >
  :syntax keyword   Type   int long char
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:syntax keyword   Type   int long char
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	The {options} can be given anywhere in the line.  They will apply to
	all keywords given, also for options that come after a keyword.
	These examples do exactly the same: >
  :syntax keyword   Type   contained int long char
  :syntax keyword   Type   int long contained char
  :syntax keyword   Type   int long char contained
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{options@} は行のどこに置いてもよい。それらは与えられたキーワード全てに適用される。オプションがキーワードの後にあっても同じ。以下の例はまったく同じ意味になる:
@multitable @columnfractions .99
@item :syntax keyword   Type   contained int long char
@item :syntax keyword   Type   int long contained char
@item :syntax keyword   Type   int long char contained
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<								*E789* *E890*
	When you have a keyword with an optional tail, like Ex commands in
	Vim, you can put the optional characters inside [], to define all the
	variations at once: >
  :syntax keyword   vimCommand	 ab[breviate] n[ext]
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E789}
@anchor{E890}
@erindex E789
@erindex E890
Vim の ex コマンドのようにキーワードに短縮形があるとき、省略可能な部分を [] でくくることによって受け入れるキーワードをいっぺんに定義することができる:
@example
:syntax keyword   vimCommand     ab[breviate] n[ext]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	Don't forget that a keyword can only be recognized if all the
	characters are included in the 'iskeyword' option.  If one character
	isn't, the keyword will never be recognized.
	Multi-byte characters can also be used.  These do not have to be in
	'iskeyword'.
	See |:syn-iskeyword| for defining syntax specific iskeyword settings.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
キーワードは、その文字全てがオプション '@option{iskeyword}' に含まれていないと認識されないことに注意。1 文字でも含まれていないものがあると、そのキーワードは認識されない。マルチバイト文字を使うこともできる。マルチバイト文字は '@option{iskeyword}' に含まれている必要はない。シンタックス特有の iskeyword 設定については |@ref{:syn-iskeyword}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	A keyword always has higher priority than a match or region, the
	keyword is used if more than one item matches.	Keywords do not nest
	and a keyword can't contain anything else.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
キーワードは常にマッチやリージョンより優先される。キーワードは一要素以上マッチしたとき使われる。キーワードは入れ子にならなく、それ以外のものを含むこともできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Note that when you have a keyword that is the same as an option (even
	one that isn't allowed here), you can not use it.  Use a match
	instead.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
オプション名と同じ単語は、それがその位置で利用できないものであったとしても、キーワードとして定義することはできない。マッチで代用すること。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	The maximum length of a keyword is 80 characters.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
キーワードの長さは最大 80 文字である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	The same keyword can be defined multiple times, when its containment
	differs.  For example, you can define the keyword once not contained
	and use one highlight group, and once contained, and use a different
	highlight group.  Example: >
  :syn keyword vimCommand tag
  :syn keyword vimSetting contained tag
<	When finding "tag" outside of any syntax item, the "vimCommand"
	highlight group is used.  When finding "tag" in a syntax item that
	contains "vimSetting", the "vimSetting" group is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
containment が異なれば、同じキーワードを複数回定義することができる。例えば、まずキーワードを contained でなく定義して1つのハイライトグループを設定し、次に contained として定義して別のハイライトグループを設定することができる。例:
@example
:syn keyword vimCommand tag
:syn keyword vimSetting contained tag
@end example
構文要素の外側に "tag" があったときはハイライトグループ "vimCommand" が適用される。"vimSetting" を含む構文要素の中に "tag" があったときは "vimSetting" グループが適用される。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
DEFINING MATCHES					*:syn-match*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-match}
@cindex :syn-match
@cindex マッチの定義
@unnumberedsubsec マッチの定義
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:sy[ntax] match {group-name} [{options}]
		[excludenl]
		[keepend]
		{pattern}
		[{options}]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item :sy[ntax] match @{group-name@} [@{options@}]
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ [excludenl]
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ [keepend]
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @{pattern@}
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ [@{options@}]
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	This defines one match.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マッチを定義する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	{group-name}		A syntax group name such as "Comment".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item @{group-name@} @tab "Comment" のような構文グループ名。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	[{options}]		See |:syn-arguments| below.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item [@{options@}] @tab 後述の |@ref{:syn-arguments}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	[excludenl]		Don't make a pattern with the end-of-line "$"
				extend a containing match or region.  Must be
				given before the pattern. |:syn-excludenl|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item [excludenl] @tab 行末の "$" を含んでいるパターンに対して、行末以降までマッチやリージョンを拡張しないようにする。パターンの前に置かなければならない。|@ref{:syn-excludenl}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	keepend			Don't allow contained matches to go past a
				match with the end pattern.  See
				|:syn-keepend|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item keepend @tab 内包されたマッチが終了パターンを越えないようにする。|@ref{:syn-keepend}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	{pattern}		The search pattern that defines the match.
				See |:syn-pattern| below.
				Note that the pattern may match more than one
				line, which makes the match depend on where
				Vim starts searching for the pattern.  You
				need to make sure syncing takes care of this.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @{pattern@} @tab マッチを定義する検索パターン。後述の |@ref{:syn-pattern}| を参照。
@quotation
@strong{Note:} @*
パターンは複数行にもマッチする。よって検索を開始する場所によってマッチが変わってくる可能性がある。シンクロナイズが関係してくることに注意。
@end quotation
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Example (match a character constant): >
  :syntax match Character /'.'/hs=s+1,he=e-1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例 (文字定数にマッチする):
@example
:syntax match Character /'.'/hs=s+1,he=e-1
@end example
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
DEFINING REGIONS	*:syn-region* *:syn-start* *:syn-skip* *:syn-end*
							*E398* *E399*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-region}
@anchor{:syn-start}
@anchor{:syn-skip}
@anchor{:syn-end}
@anchor{E398}
@anchor{E399}
@cindex :syn-region
@cindex :syn-start
@cindex :syn-skip
@cindex :syn-end
@erindex E398
@erindex E399
@cindex リージョンの定義
@unnumberedsubsec リージョンの定義
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
:sy[ntax] region {group-name} [{options}]
		[matchgroup={group-name}]
		[keepend]
		[extend]
		[excludenl]
		start={start_pattern} ..
		[skip={skip_pattern}]
		end={end_pattern} ..
		[{options}]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item :sy[ntax] region @{group-name@} [@{options@}]
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ [matchgroup=@{group-name@}]
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ [keepend]
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ [extend]
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ [excludenl]
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ start=@{start_pattern@} ..
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ [skip=@{skip_pattern@}]
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ end=@{end_pattern@} ..
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ [@{options@}]
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	This defines one region.  It may span several lines.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リージョンを定義する。複数行にわたってもよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	{group-name}		A syntax group name such as "Comment".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item @{group-name@} @tab "Comment" のような構文グループ名。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	[{options}]		See |:syn-arguments| below.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item [@{options@}] @tab 後述の |@ref{:syn-arguments}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	[matchgroup={group-name}]  The syntax group to use for the following
				start or end pattern matches only.  Not used
				for the text in between the matched start and
				end patterns.  Use NONE to reset to not using
				a different group for the start or end match.
				See |:syn-matchgroup|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item [matchgroup=@{group-name@}] @tab 以下の開始パターンと終了パターンのマッチにのみ使われる構文グループ。マッチの開始パターンと終了パターンには使われない。開始パターンと終了パターン用に異なるグループを使わないようにリセットするには NONE を使う。|@ref{:syn-matchgroup}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	keepend			Don't allow contained matches to go past a
				match with the end pattern.  See
				|:syn-keepend|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item keepend @tab 内包されたマッチが終了パターンを越えないようにする。|@ref{:syn-keepend}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	extend			Override a "keepend" for an item this region
				is contained in.  See |:syn-extend|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item extend @tab このリージョンを含むアイテムの "keepend" を上書きする。|@ref{:syn-extend}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	excludenl		Don't make a pattern with the end-of-line "$"
				extend a containing match or item.  Only
				useful for end patterns.  Must be given before
				the patterns it applies to. |:syn-excludenl|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item excludenl @tab 行末の "$" を含んでいるパターンに対して、行末以降までマッチやアイテムを拡張しないようにする。終了パターンに対してのみ使い道がある。適用するパターンの前に置かねばならない。|@ref{:syn-excludenl}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	start={start_pattern}	The search pattern that defines the start of
				the region.  See |:syn-pattern| below.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item start=@{start_pattern@} @tab リージョンの開始を定義する検索パターン。後述の |@ref{:syn-pattern}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	skip={skip_pattern}	The search pattern that defines text inside
				the region where not to look for the end
				pattern.  See |:syn-pattern| below.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item skip=@{skip_pattern@} @tab その中ではリージョンの終了を探さないテキストを定義する検索パターン。|@ref{:syn-pattern}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	end={end_pattern}	The search pattern that defines the end of
				the region.  See |:syn-pattern| below.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item  end=@{end_pattern@} @tab リージョンの終了を定義する検索パターン。後述の |@ref{:syn-pattern}| を参照。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Example: >
  :syntax region String   start=+"+  skip=+\\"+  end=+"+
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:syntax region String   start=+"+  skip=+\\"+  end=+"+
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	The start/skip/end patterns and the options can be given in any order.
	There can be zero or one skip pattern.	There must be one or more
	start and end patterns.  This means that you can omit the skip
	pattern, but you must give at least one start and one end pattern.  It
	is allowed to have white space before and after the equal sign
	(although it mostly looks better without white space).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
start/skip/end パターンとオプションはどんな順序で書いてもよい。skip パターンは 0 個か 1 個許される。start と end パターンは 1 個以上なければならない。つまり skip パターンは省略できるが、少なくとも 1 つの start と end パターンを書かなければならない。等号記号の前後にはホワイトスペースがあってもよい (たいていはホワイトスペースがないほうが見やすいが)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	When more than one start pattern is given, a match with one of these
	is sufficient.	This means there is an OR relation between the start
	patterns.  The last one that matches is used.  The same is true for
	the end patterns.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
2 個以上の start パターンが与えられたときは、それらの 1 つがマッチすれば十分である。つまり start パターンらの間には OR 関係があることになる。最後にマッチしたものが使われる。end パターンについても同じである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	The search for the end pattern starts right after the start pattern.
	Offsets are not used for this.	This implies that the match for the
	end pattern will never overlap with the start pattern.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
end パターンの検索は start パターンの直後から行われる。これは end パターンのマッチと start パターンは決して重ならないことを意味する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	The skip and end pattern can match across line breaks, but since the
	search for the pattern can start in any line it often does not do what
	you want.  The skip pattern doesn't avoid a match of an end pattern in
	the next line.	Use single-line patterns to avoid trouble.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
skip と end パターンは改行をまたいでマッチしてもよい。しかしパターンの検索はどの行からも始まりうるので、望みどおりにならないこともある。skip パターンは次の行の end パターンのマッチを回避しない。問題を避けるには単一行のパターンを使うこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Note: The decision to start a region is only based on a matching start
	pattern.  There is no check for a matching end pattern.  This does NOT
	work: >
		:syn region First  start="("  end=":"
		:syn region Second start="("  end=";"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
リージョンの開始は、start パターンのマッチによってのみ決まる。end パターンの照合のチェックはされない。次のは機能しない:
@example
:syn region First  start="("  end=":"
:syn region Second start="("  end=";"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	The Second always matches before the First (last defined pattern has
	higher priority).  The Second region then continues until the next
	';', no matter if there is a ':' before it.  Using a match does work: >
		:syn match First  "(\_.\{-}:"
		:syn match Second "(\_.\{-};"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Second は常に First より前にマッチする (最後に定義されたパターンが優先される)。こうすると、その前に ':' があるかどうかにかかわらず、Second のリージョンが次の ';' まで続く。マッチを使うとうまくいく:
@example
:syn match First  "(\_.\@{-@}:"
:syn match Second "(\_.\@{-@};"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	This pattern matches any character or line break with "\_." and
	repeats that with "\{-}" (repeat as few as possible).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このパターンは "\_." によって任意の文字と改行にマッチし、"\@{-@}" によって繰り返しにマッチする (最小限の個数の繰り返し)。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:syn-keepend*
	By default, a contained match can obscure a match for the end pattern.
	This is useful for nesting.  For example, a region that starts with
	"{" and ends with "}", can contain another region.  An encountered "}"
	will then end the contained region, but not the outer region:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-keepend}
@cindex :syn-keepend
デフォルトでは内包されたマッチは end パターンのマッチを隠す。これはネスト用に便利である。例えば、"@{" で始まり "@}" で終わるリージョンがもう 1 つのリージョンを含むことができる。"@}" に出会うと内包されたリージョンが終わり、外側のリージョンは終了しない:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	    {		starts outer "{}" region
		{	starts contained "{}" region
		}	ends contained "{}" region
	    }		ends outer "{} region
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
{           外側の "{}" リージョンの開始
    {       内包された "{}" リージョンの開始
    }       内包された "{}" リージョンの終了
}           外側の "{}" リージョンの終了
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	If you don't want this, the "keepend" argument will make the matching
	of an end pattern of the outer region also end any contained item.
	This makes it impossible to nest the same region, but allows for
	contained items to highlight parts of the end pattern, without causing
	that to skip the match with the end pattern.  Example: >
  :syn match  vimComment +"[^"]\+$+
  :syn region vimCommand start="set" end="$" contains=vimComment keepend
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この挙動が望みでないなら、引数 "keepend" をつければ、外側のリージョンの end パターンのマッチによって内包されたアイテムも終了させることができる。そうすると同一リージョンのネストが不可能になるが、内包されたアイテムで end パターンをスキップさせることなく、end パターンの一部をハイライトすることができる。例:
@example
:syn match  vimComment +"[^"]\+$+
:syn region vimCommand start="set" end="$" contains=vimComment keepend
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	The "keepend" makes the vimCommand always end at the end of the line,
	even though the contained vimComment includes a match with the <EOL>.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"keepend" によって vimCommand が常に行末で終わるようにしている。たとえ内包された vimComment が <EOL> とのマッチを含んでいてもそのようになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	When "keepend" is not used, a match with an end pattern is retried
	after each contained match.  When "keepend" is included, the first
	encountered match with an end pattern is used, truncating any
	contained matches.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"keepend" が使われないときは、内包されたマッチの後で end パターンのマッチが検索される。"keepend" が含まれているときは最初に end パターンにマッチしたところで終了し、内包されたマッチもすべてそこで終了になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:syn-extend*
	The "keepend" behavior can be changed by using the "extend" argument.
	When an item with "extend" is contained in an item that uses
	"keepend", the "keepend" is ignored and the containing region will be
	extended.
	This can be used to have some contained items extend a region while
	others don't.  Example: >

   :syn region htmlRef start=+<a>+ end=+</a>+ keepend contains=htmlItem,htmlScript
   :syn match htmlItem +<[^>]*>+ contained
   :syn region htmlScript start=+<script+ end=+</script[^>]*>+ contained extend
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-extend}
@cindex :syn-extend
引数 "extend" を使うと "keepend" の挙動が変わる。"keepend" 付きのアイテム中に "extend" 付きのアイテムが内包されていると、"keepend" が無視され、外側のリージョンが拡張される。これによっていくつかのアイテムに対して例外的にリージョンを拡張させるようにできる。例:
@example
:syn region htmlRef start=+<a>+ end=+</a>+ keepend contains=htmlItem,htmlScript
:syn match htmlItem +<[^>]*>+ contained
:syn region htmlScript start=+<script+ end=+</script[^>]*>+ contained extend
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<	Here the htmlItem item does not make the htmlRef item continue
	further, it is only used to highlight the <> items.  The htmlScript
	item does extend the htmlRef item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この例では、htmlItem の位置で htmlRef が終了する。htmlItem は <> 要素をハイライトするためだけに使われる。htmlScript アイテムは htmlRef アイテムを拡張する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Another example: >
   :syn region xmlFold start="<a>" end="</a>" fold transparent keepend extend
<	This defines a region with "keepend", so that its end cannot be
	changed by contained items, like when the "</a>" is matched to
	highlight it differently.  But when the xmlFold region is nested (it
	includes itself), the "extend" applies, so that the "</a>" of a nested
	region only ends that region, and not the one it is contained in.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もう 1 つの例:
@example
:syn region xmlFold start="<a>" end="</a>" fold transparent keepend extend
@end example
"</a>" を別の色でハイライトしたいときなどのために、"keepend" つきでリージョンを定義し、内包するアイテムによって終端が変更されないようにしている。ただし xmlFold がネストしたとき(それ自身を含んだとき)、"extend" が適用され、内側の "</a>" はそのリージョン自身だけを終了させ、それを含んでいるリージョンは終了しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:syn-excludenl*
	When a pattern for a match or end pattern of a region includes a '$'
	to match the end-of-line, it will make a region item that it is
	contained in continue on the next line.  For example, a match with
	"\\$" (backslash at the end of the line) can make a region continue
	that would normally stop at the end of the line.  This is the default
	behavior.  If this is not wanted, there are two ways to avoid it:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-excludenl}
@cindex :syn-excludenl
マッチ用のパターンやリージョンの終了パターンが行末にマッチさせるために '$' を含んでいると、それを含むリージョンアイテムが次の行まで継続するようになる。例えば、"\\$" (行末のバックスラッシュ) とのマッチを使うと、通常は行末で終了するはずのリージョンを継続させることができる。これはデフォルトの挙動である。これが望みどおりでないなら、これをされる 2 つの方法がある:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	1. Use "keepend" for the containing item.  This will keep all
	   contained matches from extending the match or region.  It can be
	   used when all contained items must not extend the containing item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item 外側のアイテムに "keepend" を使う。こうすると含んでいるアイテム全てに対して拡張しないようにする。含んでいるアイテム全てが外側のアイテムを拡張してはならないときに使える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	2. Use "excludenl" in the contained item.  This will keep that match
	   from extending the containing match or region.  It can be used if
	   only some contained items must not extend the containing item.
	   "excludenl" must be given before the pattern it applies to.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 内側のアイテムに "excludenl" を使う。こうするとそのマッチに対して、それを含んでいるマッチやリージョンを拡張しないようにする。これはいくつかのアイテムだけが外側のアイテムを拡張してはならないときに使える。"excludenl" はそれを適用するパターンの前に置かねばならない。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:syn-matchgroup*
	"matchgroup" can be used to highlight the start and/or end pattern
	differently than the body of the region.  Example: >
  :syntax region String matchgroup=Quote start=+"+  skip=+\\"+	end=+"+
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-matchgroup}
@cindex :syn-matchgroup
"matchgroup" は、リージョンの本体とその開始・終了パターンに対して異なるハイライトをしたいときに使える。例:
@example
:syntax region String matchgroup=Quote start=+"+  skip=+\\"+	end=+"+
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	This will highlight the quotes with the "Quote" group, and the text in
	between with the "String" group.
	The "matchgroup" is used for all start and end patterns that follow,
	until the next "matchgroup".  Use "matchgroup=NONE" to go back to not
	using a matchgroup.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
こうすると引用符を "Quote" グループでハイライトし、その間にあるテキストを "String" グループでハイライトすることができる。"matchgroup" はそれが従うすべての開始・終了パターンに対して使われる。matchgroup を使わないように戻すには "matchgroup=NONE" を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	In a start or end pattern that is highlighted with "matchgroup" the
	contained items of the region are not used.  This can be used to avoid
	that a contained item matches in the start or end pattern match.  When
	using "transparent", this does not apply to a start or end pattern
	match that is highlighted with "matchgroup".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
開始・終了パターンが "matchgroup" でハイライトされるとき、そのリージョンに含まれているアイテムは無視される。これによって含まれているアイテムが開始・終了パターンにマッチするのを避けることができる。"transparent" を使っている場合、これは "matchgroup" でハイライトされる開始・終了パターンのマッチ部分には適用されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Here is an example, which highlights three levels of parentheses in
	different colors: >
   :sy region par1 matchgroup=par1 start=/(/ end=/)/ contains=par2
   :sy region par2 matchgroup=par2 start=/(/ end=/)/ contains=par3 contained
   :sy region par3 matchgroup=par3 start=/(/ end=/)/ contains=par1 contained
   :hi par1 ctermfg=red guifg=red
   :hi par2 ctermfg=blue guifg=blue
   :hi par3 ctermfg=darkgreen guifg=darkgreen
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次の例は、3 段階の括弧を異なる色でハイライトする例である:
@example
:sy region par1 matchgroup=par1 start=/(/ end=/)/ contains=par2
:sy region par2 matchgroup=par2 start=/(/ end=/)/ contains=par3 contained
:sy region par3 matchgroup=par3 start=/(/ end=/)/ contains=par1 contained
:hi par1 ctermfg=red guifg=red
:hi par2 ctermfg=blue guifg=blue
:hi par3 ctermfg=darkgreen guifg=darkgreen
@end example
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*E849*
The maximum number of syntax groups is 19999.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E849}
@erindex E849
構文グループの最大数は 19999 である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
6. :syntax arguments					*:syn-arguments*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-arguments}
@cindex :syn-arguments
@cindex :syntax の引数
@section 6. :syntax の引数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The :syntax commands that define syntax items take a number of arguments.
The common ones are explained here.  The arguments may be given in any order
and may be mixed with patterns.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
構文アイテムを定義する :syntax コマンドにはたくさんの引数がある。ここでは共通のものを説明する。引数はどんな順序でもよく、パターンと混ざっていてもよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Not all commands accept all arguments.	This table shows which arguments
can not be used for all commands:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
全てのコマンドが全ての引数を受けいれるわけではない。次の表はどの引数がどのコマンドに対して利用可能かを示している:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*E395*
		    contains  oneline	fold  display  extend concealends~
:syntax keyword		 -	 -	 -	 -	 -      -
:syntax match		yes	 -	yes	yes	yes     -
:syntax region		yes	yes	yes	yes	yes    yes
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E395}
@erindex E395
@multitable @columnfractions .3 .12 .12 .12 .12 .12 .12
@headitem @tab contains @tab oneline @tab fold @tab display @tab extend @tab concealends
@item :syntax keyword @tab - @tab - @tab - @tab - @tab - @tab -
@item :syntax match @tab yes @tab - @tab yes @tab yes @tab yes @tab -
@item :syntax region @tab yes @tab yes @tab yes @tab yes @tab yes @tab yes
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These arguments can be used for all three commands:
	conceal
	cchar
	contained
	containedin
	nextgroup
	transparent
	skipwhite
	skipnl
	skipempty
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下の引数は 3 つのコマンド全てに対して使える:
@multitable @columnfractions .99
@item conceal
@item cchar
@item contained
@item containedin
@item nextgroup
@item transparent
@item skipwhite
@item skipnl
@item skipempty
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
conceal						*conceal* *:syn-conceal*

When the "conceal" argument is given, the item is marked as concealable.
Whether or not it is actually concealed depends on the value of the
'conceallevel' option.  The 'concealcursor' option is used to decide whether
concealable items in the current line are displayed unconcealed to be able to
edit the line.
Another way to conceal text is with |matchadd()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{conceal}
@anchor{:syn-conceal}
@cindex conceal
@cindex :syn-conceal
@table @asis
@item conceal
@{訳注: conceal = 隠す、秘密にする@}

"conceal" 引数が指定されると、そのアイテムは Conceal 可能になる。アイテムが実際に Conceal 表示されるかどうかは '@option{conceallevel}' オプションの設定に依存する。現在行のアイテムを Conceal 表示するかどうかは '@option{concealcursor}' オプションで制御できる (行の編集を妨げないようにするため)。もう 1 つの方法として |@ref{matchadd()}| を用いても、テキストを隠すことができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
concealends						*:syn-concealends*

When the "concealends" argument is given, the start and end matches of
the region, but not the contents of the region, are marked as concealable.
Whether or not they are actually concealed depends on the setting on the
'conceallevel' option. The ends of a region can only be concealed separately
in this way when they have their own highlighting via "matchgroup"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-concealends}
@cindex :syn-concealends
@item concealends
"concealends" 引数が指定されると、リージョンの開始部分と終了部分が Conceal 可能になる (リージョンの中身はならない)。アイテムが実際に Conceal 表示されるかどうかは '@option{conceallevel}' の設定に依存する。"matchgroup" で別のハイライトを設定することでリージョンの終了部分だけを別に Conceal 表示するということもできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
cchar							*:syn-cchar*
							*E844*
The "cchar" argument defines the character shown in place of the item
when it is concealed (setting "cchar" only makes sense when the conceal
argument is given.) If "cchar" is not set then the default conceal
character defined in the 'listchars' option is used.  The character cannot be
a control character such as Tab.  Example: >
   :syntax match Entity "&amp;" conceal cchar=&
See |hl-Conceal| for highlighting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-cchar}
@cindex :syn-cchar
@item cchar
@anchor{E844}
@erindex E844
"cchar" 引数はアイテムが Conceal 表示されたときに実際に画面に表示される文字を定義する ("cchar" は conceal 引数が指定されたときのみ意味を持つ)。"cchar" が指定されていない場合はデフォルトの Conceal 文字として '@option{listchars}' オプションが使われる。Tab 文字のようなコントロール文字は使用できない。例:
@example
:syntax match Entity "&amp;" conceal cchar=&
@end example
ハイライトについては |@ref{hl-Conceal}| を参照のこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
contained						*:syn-contained*

When the "contained" argument is given, this item will not be recognized at
the top level, but only when it is mentioned in the "contains" field of
another match.	Example: >
   :syntax keyword Todo    TODO    contained
   :syntax match   Comment "//.*"  contains=Todo
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-contained}
@cindex :syn-contained
@item contained
引数 "contained" が与えられると、そのアイテムはトップレベルでは認識されず、他のマッチの "contains" フィールドで指定されたときのみ認識される。例:
@example
:syntax keyword Todo    TODO    contained
:syntax match   Comment "//.*"  contains=Todo
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
display							*:syn-display*

If the "display" argument is given, this item will be skipped when the
detected highlighting will not be displayed.  This will speed up highlighting,
by skipping this item when only finding the syntax state for the text that is
to be displayed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-display}
@cindex :syn-display
@item display
引数 "display" が与えられると、そのアイテムは検出されたハイライトが表示されない時にはスキップされる。こうすることで、表示されるべきテキストの構文状態だけを検索するときにはこのアイテムはスキップされ、ハイライトが高速になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Generally, you can use "display" for match and region items that meet these
conditions:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
通常は、以下の条件に合うときマッチとリージョンに "display" を使うとよい:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The item does not continue past the end of a line.  Example for C: A region
  for a "/*" comment can't contain "display", because it continues on the next
  line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item アイテムが行末を越えて継続しない。C の例: "/*" コメント用のリージョンは "display" を含んではならない。なぜなら次の行に継続するからである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The item does not contain items that continue past the end of the line or
  make it continue on the next line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item アイテムが、行を越えて継続したり、そのコンテナを次行まで継続させる効果を持つ子アイテムを含んでいない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The item does not change the size of any item it is contained in.  Example
  for C: A match with "\\$" in a preprocessor match can't have "display",
  because it may make that preprocessor match shorter.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item それを含むどんなアイテムのサイズも変更しない。C の例: プリプロセッサーマッチ中の "\\$" とのマッチは "display" を含んではならない。なぜならこれによってプリプロセッサーマッチが短くなるかもしれないからである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The item does not allow other items to match that didn't match otherwise,
  and that item may extend the match too far.  Example for C: A match for a
  "//" comment can't use "display", because a "/*" inside that comment would
  match then and start a comment which extends past the end of the line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 他のアイテムがマッチすることを許さず、そうでなければマッチせず、加えてマッチ自体が非常に長くなるようなアイテム。C の例: "//" コメント用のマッチは "display" を使ってはならない。なぜならそのコメントの内側の "/*" がマッチするかも知れず、そうなると行末をまたぐコメントが始まるからである。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples, for the C language, where "display" can be used:
- match with a number
- match with a label
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例として C 言語では次のとき "display" が使える:
@itemize
@item 数字とのマッチ
@item ラベルとのマッチ
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
transparent						*:syn-transparent*

If the "transparent" argument is given, this item will not be highlighted
itself, but will take the highlighting of the item it is contained in.	This
is useful for syntax items that don't need any highlighting but are used
only to skip over a part of the text.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-transparent}
@cindex :syn-transparent
@item transparent
引数 "transparent" が与えられると、そのアイテムはそれ自身ではハイライトされず、それを含むアイテムのハイライトを引き継ぐ。これはハイライトはせず、テキストの一部をスキップするためだけに使われる構文アイテムに対して有効である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "contains=" argument is also inherited from the item it is contained in,
unless a "contains" argument is given for the transparent item itself.	To
avoid that unwanted items are contained, use "contains=NONE".  Example, which
highlights words in strings, but makes an exception for "vim": >
	:syn match myString /'[^']*'/ contains=myWord,myVim
	:syn match myWord   /\<[a-z]*\>/ contained
	:syn match myVim    /\<vim\>/ transparent contained contains=NONE
	:hi link myString String
	:hi link myWord   Comment
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
transparent なアイテム自身に引数 "contains" が与えられていない場合、それを含むアイテムから引数 "contains=" も受け継がれる。望まないアイテムが含まれるのを避けるには "contains=NONE" とすること。文字列中の単語をハイライトするが、"vim" だけは例外とする例:
@example
:syn match myString /'[^']*'/ contains=myWord,myVim
:syn match myWord   /\<[a-z]*\>/ contained
:syn match myVim    /\<vim\>/ transparent contained contains=NONE
:hi link myString String
:hi link myWord   Comment
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Since the "myVim" match comes after "myWord" it is the preferred match (last
match in the same position overrules an earlier one).  The "transparent"
argument makes the "myVim" match use the same highlighting as "myString".  But
it does not contain anything.  If the "contains=NONE" argument would be left
out, then "myVim" would use the contains argument from myString and allow
"myWord" to be contained, which will be highlighted as a Constant.  This
happens because a contained match doesn't match inside itself in the same
position, thus the "myVim" match doesn't overrule the "myWord" match here.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"myVimが "myWord" の後に来ているので、"myVim" が優先される (同じ位置で複数のアイテムにマッチした場合、最後に定義されたものが前のものを上書きする)。"transparent" により、"myVim" にマッチしたテキストは "myString" と同じハイライトになる。しかし "myVim" は何も含まない。もし "contains=NONE" を取り除くと、"myVim" は "myString" から引数 contains を受け継いで "myWord" を含むようになり、テキスト "vim" は Constant としてハイライトされる。これは、内包されたマッチは同じ位置でそれ自身の内側でマッチしないためこうなる。つまり、ここではマッチ "myVim" は、マッチ "myWord" を上書きしない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you look at the colored text, it is like looking at layers of contained
items.	The contained item is on top of the item it is contained in, thus you
see the contained item.  When a contained item is transparent, you can look
through, thus you see the item it is contained in.  In a picture:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
色づけされたテキストは、内包されたアイテムの層のようにみなすことができる。内包されたアイテムは内包しているアイテムより上にあり、そのため内包されたアイテムを見ることができる。内包されたアイテムが transparent な場合、それを透過して見ることができ、よってそれを含んでいるアイテムが見える。図にすると:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		look from here

	    |	|   |	|   |	|
	    V	V   V	V   V	V

	       xxxx	  yyy		more contained items
	    ....................	contained item (transparent)
	=============================	first item
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
        ここから見る

    |   |   |   |   |   |
    V   V   V   V   V   V

       xxxx       yyy           さらに内包されたアイテム達
    ....................        内包されたアイテム (transparent)
=============================   最初のアイテム (最も外側のアイテム)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The 'x', 'y' and '=' represent a highlighted syntax item.  The '.' represent a
transparent group.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'x', 'y', '=' はハイライトされた構文アイテムを表す。'.' は transparent なグループを表している。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
What you see is:

	=======xxxx=======yyy========

Thus you look through the transparent "....".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
このとき次のように見える:

        =======xxxx=======yyy========

つまり transparent な "...." は透過して見える。
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
oneline							*:syn-oneline*

The "oneline" argument indicates that the region does not cross a line
boundary.  It must match completely in the current line.  However, when the
region has a contained item that does cross a line boundary, it continues on
the next line anyway.  A contained item can be used to recognize a line
continuation pattern.  But the "end" pattern must still match in the first
line, otherwise the region doesn't even start.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-oneline}
@cindex :syn-oneline
@item oneline
引数 "oneline" をつけると、そのリージョンは行をまたがないという意味になる。つまり、現在行の中で完全にマッチしなければならない。しかし、そのリージョンが行をまたぐアイテムを内包している場合は次の行に継続する。内包されたアイテムによって行継続パターンを認識することができる。しかしその場合でも "end" パターンは最初の行内でマッチしなければならない。そうでないとリージョンは開始すらしない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the start pattern includes a "\n" to match an end-of-line, the end
pattern must be found in the same line as where the start pattern ends.  The
end pattern may also include an end-of-line.  Thus the "oneline" argument
means that the end of the start pattern and the start of the end pattern must
be within one line.  This can't be changed by a skip pattern that matches a
line break.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
start パターンが行末にマッチする "\n" を含んでいるときは、start パターンの終了位置と同じ行に end パターンがなければならない。end パターンも行末を含んでもよい。つまり引数 "oneline" は、start パターンの終了位置と end パターンの開始位置が同一行にあることを意味する。改行にマッチする skip パターンを使ってもこの規則を変えることはできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
fold							*:syn-fold*

The "fold" argument makes the fold level increase by one for this item.
Example: >
   :syn region myFold start="{" end="}" transparent fold
   :syn sync fromstart
   :set foldmethod=syntax
This will make each {} block form one fold.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-fold}
@cindex :syn-fold
@item fold
引数 "fold" はこのアイテムに対して折り畳みレベルを1増加させる。例:
@example
:syn region myFold start="@{" end="@}" transparent fold
:syn sync fromstart
:set foldmethod=syntax
@end example
これは @{@} ブロックごとに 1 つの折り畳みを作らせる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The fold will start on the line where the item starts, and end where the item
ends.  If the start and end are within the same line, there is no fold.
The 'foldnestmax' option limits the nesting of syntax folds.
{not available when Vim was compiled without |+folding| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
折り畳みはそのアイテムの開始位置から始まり、アイテムの終了位置で終わる。開始位置と終了位置が同一行にある場合、折り畳みは作られない。オプション '@option{foldnestmax}' によって構文折り畳みのネストを制限できる。

@{|@ref{+folding}| 機能なしでコンパイルされた場合は利用できない@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
			*:syn-contains* *E405* *E406* *E407* *E408* *E409*
contains={group-name},..

The "contains" argument is followed by a list of syntax group names.  These
groups will be allowed to begin inside the item (they may extend past the
containing group's end).  This allows for recursive nesting of matches and
regions.  If there is no "contains" argument, no groups will be contained in
this item.  The group names do not need to be defined before they can be used
here.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-contains}
@anchor{E405}
@anchor{E406}
@anchor{E407}
@anchor{E408}
@anchor{E409}
@cindex :syn-contains
@erindex E405
@erindex E406
@erindex E407
@erindex E408
@erindex E409
@item contains=@{group-name@},..
引数 "contains" の後には構文グループ名のリストを続ける。"contains" で指定されたグループは、そのアイテムの内側で始まることを許可される (内包されるグループによっては、外側のアイテムの終端が拡張されることもある)。これを使うと、マッチとリージョンが再帰的にネストできるようになる。引数 "contains" がまったく指定されない場合は、そのアイテムはどんなグループも内包しない。ここで使うグループ名は、必ずしも以前に定義していなくてもよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
contains=ALL
		If the only item in the contains list is "ALL", then all
		groups will be accepted inside the item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item contains=ALL
contains リストが "ALL" だけのとき、全てのグループがこのアイテムの内側で許可される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
contains=ALLBUT,{group-name},..
		If the first item in the contains list is "ALLBUT", then all
		groups will be accepted inside the item, except the ones that
		are listed.  Example: >
  :syntax region Block start="{" end="}" ... contains=ALLBUT,Function
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item contains=ALLBUT,@{group-name@},..
contains リストの最初の要素が "ALLBUT" のとき、@{group-name@} で列挙したグループを除く全てのグループがこのアイテムの内側で許可される。例:
@example
:syntax region Block start="@{" end="@}" ... contains=ALLBUT,Function
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
contains=TOP
		If the first item in the contains list is "TOP", then all
		groups will be accepted that don't have the "contained"
		argument.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item contains=TOP
contains リストの最初の要素が "TOP" のとき、引数 "contained" を持たないグループ全てが許可される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
contains=TOP,{group-name},..
		Like "TOP", but excluding the groups that are listed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item contains=TOP,@{group-name@},..
"TOP" と同様だが、@{group-name@} に列挙したグループは除かれる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
contains=CONTAINED
		If the first item in the contains list is "CONTAINED", then
		all groups will be accepted that have the "contained"
		argument.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item contains=CONTAINED
contains リストの最初の要素が "CONTAINED" のとき、引数 "contained" を持つグループ全てが許可される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
contains=CONTAINED,{group-name},..
		Like "CONTAINED", but excluding the groups that are
		listed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item contains=CONTAINED,@{group-name@},..
"CONTAINED" と同様だが、@{group-name@} に列挙したグループは除かれる。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
The {group-name} in the "contains" list can be a pattern.  All group names
that match the pattern will be included (or excluded, if "ALLBUT" is used).
The pattern cannot contain white space or a ','.  Example: >
   ... contains=Comment.*,Keyw[0-3]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"contains" リスト内の @{group-name@} はパターンであってもよい。そのパターンにマッチするグループ名全てが含まれる ("ALLBUT" が使われたときはそれが除かれる)。パターンはホワイトスペースや ',' を含んではならない。例:
@example
... contains=Comment.*,Keyw[0-3]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The matching will be done at moment the syntax command is executed.  Groups
that are defined later will not be matched.  Also, if the current syntax
command defines a new group, it is not matched.  Be careful: When putting
syntax commands in a file you can't rely on groups NOT being defined, because
the file may have been sourced before, and ":syn clear" doesn't remove the
group names.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
パターンの照合はその syntax コマンドが実行されたときに行われる。それ以降に定義されたグループは照合されない。また、現在の syntax コマンドが新しいグループを定義している場合、そのグループは照合されない。ファイル内に syntax コマンドを書く場合、定義されていないグループを当てにすることはできないことに注意。これは、そのファイルは以前に読み込まれているかもしれず、":syn clear" はグループ名を削除しないためである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The contained groups will also match in the start and end patterns of a
region.  If this is not wanted, the "matchgroup" argument can be used
|:syn-matchgroup|.  The "ms=" and "me=" offsets can be used to change the
region where contained items do match.	Note that this may also limit the
area that is highlighted
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
内包されたグループはリージョンの start と end パターン内にもマッチする。これが望みの挙動でないなら、引数 "matchgroup" を使うとよい |@ref{:syn-matchgroup}|。オフセット "ms=" と "me=" によって内包されたアイテムがマッチする領域を変更することができる。これはハイライトされる範囲も制限することに注意。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
containedin={group-name}...				*:syn-containedin*

The "containedin" argument is followed by a list of syntax group names.  The
item will be allowed to begin inside these groups.  This works as if the
containing item has a "contains=" argument that includes this item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-containedin}
@cindex :syn-containedin
@item containedin=@{group-name@}...
引数 "containedin" の後には構文グループ名のリストを続ける。するとこのアイテムがそれらのグループの内側で始まることが許可される。これは外側のアイテムが引数 "contains=" でこのアイテムを指定したのと同じように動作する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The {group-name}... can be used just like for "contains", as explained above.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{group-name@}... の指定の仕方は前述の "contains" と同様である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This is useful when adding a syntax item afterwards.  An item can be told to
be included inside an already existing item, without changing the definition
of that item.  For example, to highlight a word in a C comment after loading
the C syntax: >
	:syn keyword myword HELP containedin=cComment contained
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは構文アイテムを後から追加するときに便利である。既に定義されているアイテムの定義を変更することなく、その内側にアイテムを含めることができる。例えば、C の構文を読み込んだ後で、C コメント中の単語をハイライトしたいときは:
@example
:syn keyword myword HELP containedin=cComment contained
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Note that "contained" is also used, to avoid that the item matches at the top
level.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
このアイテムがトップレベルではマッチしないように "contained" を使っている。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Matches for "containedin" are added to the other places where the item can
appear.  A "contains" argument may also be added as usual.  Don't forget that
keywords never contain another item, thus adding them to "containedin" won't
work.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"containedin" の照合は、このアイテムが現れる場所に追加される。引数 "contains" も通常通り追加される。注意: キーワードは他のアイテムを含むことができないため、"containedin" の先にキーワードを指定することは無意味である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
nextgroup={group-name},..				*:syn-nextgroup*

The "nextgroup" argument is followed by a list of syntax group names,
separated by commas (just like with "contains", so you can also use patterns).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-nextgroup}
@cindex :syn-nextgroup
@item nextgroup=@{group-name@},..
引数 "nextgroup" の後には構文グループ名のリストをコンマ区切りで続ける ("contains" と同様。パターンを使うこともできる)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the "nextgroup" argument is given, the mentioned syntax groups will be
tried for a match, after the match or region ends.  If none of the groups have
a match, highlighting continues normally.  If there is a match, this group
will be used, even when it is not mentioned in the "contains" field of the
current group.	This is like giving the mentioned group priority over all
other groups.  Example: >
   :syntax match  ccFoobar  "Foo.\{-}Bar"  contains=ccFoo
   :syntax match  ccFoo     "Foo"	    contained nextgroup=ccFiller
   :syntax region ccFiller  start="."  matchgroup=ccBar  end="Bar"  contained
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数 "nextgroup" が与えられると、マッチやリージョンの終了位置の後ろで、指定された構文グループにマッチする部分が探される。どのグループもマッチしなければ、ハイライトは通常通り続けられる。マッチが見つかった場合はそのグループが使われる。現在のグループの引数 "contains" でそのグループが指定されていなくてもそうなる。つまり、これは指定されたグループの優先度を最大にすることと同じである。例:
@example
:syntax match  ccFoobar  "Foo.\@{-@}Bar"  contains=ccFoo
:syntax match  ccFoo     "Foo"	    contained nextgroup=ccFiller
:syntax region ccFiller  start="."  matchgroup=ccBar  end="Bar"  contained
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This will highlight "Foo" and "Bar" differently, and only when there is a
"Bar" after "Foo".  In the text line below, "f" shows where ccFoo is used for
highlighting, and "bbb" where ccBar is used. >

   Foo asdfasd Bar asdf Foo asdf Bar asdf
   fff	       bbb	fff	 bbb
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは "Foo" の後に "Bar" が現れたときのみ、"Foo" と "Bar" に異なるハイライトをする。以下のテキストにおいて、"f" と書いたところは ccFoo でハイライトされ、"bbb" と書いたところは ccBar でハイライトされる。
@verbatim
Foo asdfasd Bar asdf Foo asdf Bar asdf
fff         bbb      fff      bbb
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note the use of ".\{-}" to skip as little as possible until the next Bar.
when ".*" would be used, the "asdf" in between "Bar" and "Foo" would be
highlighted according to the "ccFoobar" group, because the ccFooBar match
would include the first "Foo" and the last "Bar" in the line (see |pattern|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
".\@{-@}" を使い、次の Bar までのスキップが最小になるようにしている。もし ".*" を使うと、最初の "Foo" と最後の "Bar" が ccFooBar のマッチ部分に含まれるため、"Bar" と "Foo" の間の "asdf" が "ccFoobar" グループとしてハイライトされてしまう (|@ref{pattern}| を参照)。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
skipwhite						*:syn-skipwhite*
skipnl							*:syn-skipnl*
skipempty						*:syn-skipempty*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-skipwhite}
@anchor{:syn-skipnl}
@anchor{:syn-skipempty}
@cindex :syn-skipwhite
@cindex :syn-skipnl
@cindex :syn-skipempty
@item skipwhite または
@itemx skipnl または
@itemx skipempty
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These arguments are only used in combination with "nextgroup".	They can be
used to allow the next group to match after skipping some text:
	skipwhite	skip over space and tab characters
	skipnl		skip over the end of a line
	skipempty	skip over empty lines (implies a "skipnl")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これら 3 個の引数は "nextgroup" と組み合わせたときのみ意味を持つ。これらを指定すると、次のグループがマッチする前に、以下のテキストがあってもよくなる。
@multitable @columnfractions .2 .8
@item skipwhite @tab スペースとタブ文字をスキップする
@item skipnl @tab 行末をスキップする
@item skipempty @tab 空行をスキップする (自動的に "skipnl" も含むことになる)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When "skipwhite" is present, the white space is only skipped if there is no
next group that matches the white space.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば "skilwhite" を指定した場合、次のどのグループもホワイトスペースにマッチしないならば、ホワイトスペースをスキップする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When "skipnl" is present, the match with nextgroup may be found in the next
line.  This only happens when the current item ends at the end of the current
line!  When "skipnl" is not present, the nextgroup will only be found after
the current item in the same line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"skipnl" を指定すると、nextgroup の照合が次の行からも探される。これは現在のアイテムが行末で終わったときのみ有効である。"skipnl" を指定しない場合、nextgroup は同一行のそのアイテム以降から照合される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When skipping text while looking for a next group, the matches for other
groups are ignored.  Only when no next group matches, other items are tried
for a match again.  This means that matching a next group and skipping white
space and <EOL>s has a higher priority than other items.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のグループまでスキップされたテキストの中では他のグループの照合は無視される。次のグループの照合が見つからなかったとき、再び他のグループの照合が検索される。つまり、次のグループの照合と、ホワイトスペースと <EOL> のスキップは他のアイテムより優先される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Example: >
  :syn match ifstart "\<if.*"	  nextgroup=ifline skipwhite skipempty
  :syn match ifline  "[^ \t].*" nextgroup=ifline skipwhite skipempty contained
  :syn match ifline  "endif"	contained
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:syn match ifstart "\<if.*"     nextgroup=ifline skipwhite skipempty
:syn match ifline  "[^ \t].*" nextgroup=ifline skipwhite skipempty contained
:syn match ifline  "endif"    contained
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Note that the "[^ \t].*" match matches all non-white text.  Thus it would also
match "endif".	Therefore the "endif" match is put last, so that it takes
precedence.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
マッチ "[^ \t].*" はホワイトスペース以外の全てのテキストにマッチする。よって "endif" にもマッチする。そのためマッチ "endif" を最後に置き、最優先にしている。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Note that this example doesn't work for nested "if"s.  You need to add
"contains" arguments to make that work (omitted for simplicity of the
example).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
この例はネストした "if" には機能しないことに注意。ネストに対応するには引数 "contains" を指定する必要がある(この例では簡単のため省略した)。
@end quotation
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
IMPLICIT CONCEAL					*:syn-conceal-implicit*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-conceal-implicit}
@cindex :syn-conceal-implicit
@cindex 暗黙の Conceal
@unnumberedsubsec 暗黙 CONCEAL (IMPLICIT CONCEAL)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:sy[ntax] conceal [on|off]
	This defines if the following ":syntax" commands will define keywords,
	matches or regions with the "conceal" flag set. After ":syn conceal
	on", all subsequent ":syn keyword", ":syn match" or ":syn region"
	defined will have the "conceal" flag set implicitly. ":syn conceal
	off" returns to the normal state where the "conceal" flag must be
	given explicitly.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item :sy[ntax] conceal [on|off]
これ以降の ":syntax" コマンドでキーワード、マッチ、リージョンを定義したときに "conceal" フラグをセットするかどうかを定義する。":syn conceal on" を実行した後で ":syn keyword", ":syn match", ":syn region" を実行すると、暗黙的に "conceal" フラグがセットされる。":syn conceal off" を実行することで通常の状態、つまり "conceal" フラグを明示的に設定しなければならない状態に戻る。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:sy[ntax] conceal
	Show either "syntax conceal on" or "syntax conceal off" (translated).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :sy[ntax] conceal
"syntax conceal on" または "syntax conceal off" (翻訳される) を表示する。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
7. Syntax patterns				*:syn-pattern* *E401* *E402*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-pattern}
@anchor{E401}
@anchor{E402}
@cindex :syn-pattern
@erindex E401
@erindex E402
@cindex syntax のパターン
@section 7. syntax のパターン
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In the syntax commands, a pattern must be surrounded by two identical
characters.  This is like it works for the ":s" command.  The most common to
use is the double quote.  But if the pattern contains a double quote, you can
use another character that is not used in the pattern.	Examples: >
  :syntax region Comment  start="/\*"  end="\*/"
  :syntax region String   start=+"+    end=+"+	 skip=+\\"+
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
syntax コマンドでは、パターンの前後を同じ文字で囲まなければならない。これは ":s" コマンドと同様である。もっともよく使われるのはダブルクォートである。しかしパターンがダブルクォートを含んでいる場合は、そのパターンが含んでいない他の文字を使ったほうがよい。例:
@example
:syntax region Comment  start="/\*"  end="\*/"
:syntax region String   start=+"+    end=+"+   skip=+\\"+
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
See |pattern| for the explanation of what a pattern is.  Syntax patterns are
always interpreted like the 'magic' option is set, no matter what the actual
value of 'magic' is.  And the patterns are interpreted like the 'l' flag is
not included in 'cpoptions'.  This was done to make syntax files portable and
independent of 'compatible' and 'magic' settings.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
パターンの説明については |@ref{pattern}| を参照。構文パターンは常に '@option{magic}' オプションがセットされているのと同じように解釈される (実際の '@option{magic}' オプションの値とは無関係)。また、'@option{cpoptions}' に '@var{l}' フラグが含まれていない場合と同じように解釈される。これは構文ファイルの可搬性を高め、'@option{compatible}' と '@option{magic}' の設定と無関係にするためである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Try to avoid patterns that can match an empty string, such as "[a-z]*".
This slows down the highlighting a lot, because it matches everywhere.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"[a-z]*" など空文字列にマッチするパターンは避けること。これは全ての位置にマッチするため、ハイライトがとても遅くなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:syn-pattern-offset*
The pattern can be followed by a character offset.  This can be used to
change the highlighted part, and to change the text area included in the
match or region (which only matters when trying to match other items).	Both
are relative to the matched pattern.  The character offset for a skip
pattern can be used to tell where to continue looking for an end pattern.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-pattern-offset}
@cindex :syn-pattern-offset
パターンに文字数のオフセットを指定することができる。これによってハイライトされる部分を変更したり、マッチやリージョンに含まれるテキスト領域 (これは他のアイテムを照合するときにだけ関係する) を変更することができる。どちらもマッチしたパターンに相対的である。skip パターンに対して文字数のオフセットを指定すると、end パターンの検索が始まる位置を決めることができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The offset takes the form of "{what}={offset}"
The {what} can be one of seven strings:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オフセットは "@{what@}=@{offset@}" の形で指定する。

@{what@} は次の 7 個の文字列のどれかである:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ms	Match Start	offset for the start of the matched text
me	Match End	offset for the end of the matched text
hs	Highlight Start	offset for where the highlighting starts
he	Highlight End	offset for where the highlighting ends
rs	Region Start	offset for where the body of a region starts
re	Region End	offset for where the body of a region ends
lc	Leading Context	offset past "leading context" of pattern
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .3 .6
@item ms @tab Match Start @tab マッチしたテキストの開始位置のオフセット
@item me @tab Match End @tab マッチしたテキストの終了位置のオフセット
@item hs @tab Highlight Start @tab ハイライトが始まる位置のオフセット
@item he @tab Highlight End @tab ハイライトが終わる位置のオフセット
@item rs @tab Region Start @tab リージョンの本体が始まる位置のオフセット
@item re @tab Region End @tab リージョンが終わる位置のオフセット
@item lc @tab Leading Context @tab パターンの "leading context" を過ぎた後のオフセット
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The {offset} can be:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{offset@} は次のうちのどれか:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
s	start of the matched pattern
s+{nr}	start of the matched pattern plus {nr} chars to the right
s-{nr}	start of the matched pattern plus {nr} chars to the left
e	end of the matched pattern
e+{nr}	end of the matched pattern plus {nr} chars to the right
e-{nr}	end of the matched pattern plus {nr} chars to the left
{nr}	(for "lc" only): start matching {nr} chars right of the start
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item s @tab パターンのマッチ部分の先頭
@item s+@{nr@} @tab パターンのマッチ部分の先頭から右へ @{nr@} 文字目
@item s-@{nr@} @tab パターンのマッチ部分の先頭から左へ @{nr@} 文字目
@item e @tab パターンのマッチ部分の末尾
@item e+@{nr@} @tab パターンのマッチ部分の末尾から右へ @{nr@} 文字目
@item e-@{nr@} @tab パターンのマッチ部分の末尾から左へ @{nr@} 文字目
@item @{nr@} @tab ("lc" 専用): 右へ @{nr@} 文字目からマッチを開始する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples: "ms=s+1", "hs=e-2", "lc=3".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例: "ms=s+1", "hs=e-2", "lc=3"。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Although all offsets are accepted after any pattern, they are not always
meaningful.  This table shows which offsets are actually used:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
どのパターンの後にどのオフセットを指定してもよいが、それが意味を持たない場合もある。次の表はどのオフセットが実際に有効かを示している:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		    ms	 me   hs   he	rs   re	  lc ~
match item	    yes  yes  yes  yes	-    -	  yes
region item start   yes  -    yes  -	yes  -	  yes
region item skip    -	 yes  -    -	-    -	  yes
region item end     -	 yes  -    yes	-    yes  yes
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .1 .1 .1 .1 .1 .1 .1
@headitem @tab ms @tab me @tab hs @tab he @tab rs @tab re @tab lc
@item match item @tab yes @tab yes @tab yes @tab yes @tab - @tab - @tab yes
@item region item start @tab yes @tab - @tab yes @tab - @tab yes @tab - @tab yes
@item region item skip @tab - @tab yes @tab - @tab - @tab - @tab - @tab yes
@item region item end @tab - @tab yes @tab - @tab yes @tab - @tab yes @tab yes
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Offsets can be concatenated, with a ',' in between.  Example: >
  :syn match String  /"[^"]*"/hs=s+1,he=e-1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
複数のオフセットの間に ',' を入れて連結することができる。例:
@example
:syn match String  /"[^"]*"/hs=s+1,he=e-1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    some "string" text
	  ^^^^^^		highlighted
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
some "string" text
      ^^^^^^                highlighted
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Notes:
- There must be no white space between the pattern and the character
  offset(s).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
@itemize
@item パターンとオフセットの間にホワイトスペースを挟んではならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The highlighted area will never be outside of the matched text.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ハイライトされる領域がマッチしたテキストの外側にはみ出してはならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- A negative offset for an end pattern may not always work, because the end
  pattern may be detected when the highlighting should already have stopped.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item end パターンに対する負のオフセットは機能しない場合がある。これはハイライトが既に終わっているべきとき、end パターンは検出されない可能性があるからである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Before Vim 7.2 the offsets were counted in bytes instead of characters.
  This didn't work well for multi-byte characters, so it was changed with the
  Vim 7.2 release.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item Vim 7.2 以前では、オフセットは文字単位でなくバイト単位であった。それではマルチバイト文字ではうまく機能しないので、7.2 から変更された。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The start of a match cannot be in a line other than where the pattern
  matched.  This doesn't work: "a\nb"ms=e.  You can make the highlighting
  start in another line, this does work: "a\nb"hs=e.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item マッチの開始位置が、パターンがマッチした位置と別の行になってはならない。つまり "a\nb"ms=e というのは正常に機能しない。ハイライトの開始位置は別の行にあってもかまわない。"a\nb"hs=e というのは正常に機能する。
@end itemize
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Example (match a comment but don't highlight the /* and */): >
  :syntax region Comment start="/\*"hs=e+1 end="\*/"he=s-1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例 (コメントにマッチするが /* と */ はハイライトしない):
@example
:syntax region Comment start="/\*"hs=e+1 end="\*/"he=s-1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	/* this is a comment */
	  ^^^^^^^^^^^^^^^^^^^	  highlighted
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
/* this is a comment */
  ^^^^^^^^^^^^^^^^^^^     ここがハイライトされる
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A more complicated Example: >
  :syn region Exa matchgroup=Foo start="foo"hs=s+2,rs=e+2 matchgroup=Bar end="bar"me=e-1,he=e-1,re=s-1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
より複雑な例:
@example
:syn region Exa matchgroup=Foo start="foo"hs=s+2,rs=e+2 matchgroup=Bar end="bar"me=e-1,he=e-1,re=s-1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	 abcfoostringbarabc
	    mmmmmmmmmmm	    match
	      sssrrreee	    highlight start/region/end ("Foo", "Exa" and "Bar")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
abcfoostringbarabc
   mmmmmmmmmmm     マッチ部分
     sssrrreee     start/region/end としてハイライトされる部分
                   ("Foo", "Exa", "Bar")
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Leading context			*:syn-lc* *:syn-leading* *:syn-context*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-lc}
@anchor{:syn-leading}
@anchor{:syn-context}
@cindex :syn-lc
@cindex :syn-leading
@cindex :syn-context
@unnumberedsubsec Leading context
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: This is an obsolete feature, only included for backwards compatibility
with previous Vim versions.  It's now recommended to use the |/\@<=| construct
in the pattern.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
これは古い機能であり、以前のバージョンとの後方互換性のためだけに残されている。現在はパターン中の |@ref{/\@@<=}| コンストラクトを使うことが推奨されている。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "lc" offset specifies leading context -- a part of the pattern that must
be present, but is not considered part of the match.  An offset of "lc=n" will
cause Vim to step back n columns before attempting the pattern match, allowing
characters which have already been matched in previous patterns to also be
used as leading context for this match.  This can be used, for instance, to
specify that an "escaping" character must not precede the match: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"lc" オフセットはリーディングコンテキストを指定する。これはパターンの一部になければならないが、マッチ部分の一部とは見なされないものである。"lc=n" のオフセットを使うとパターンの照合を試みる前にn桁戻るようになる。リーディングコンテキスト内に他のパターンにマッチしている文字が現れてもよい。これはマッチの前方にあってはならない「エスケープ」文字を指定する場合などに使える:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  :syn match ZNoBackslash "[^\\]z"ms=s+1
  :syn match WNoBackslash "[^\\]w"lc=1
  :syn match Underline "_\+"
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:syn match ZNoBackslash "[^\\]z"ms=s+1
:syn match WNoBackslash "[^\\]w"lc=1
:syn match Underline "_\+"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	  ___zzzz ___wwww
	  ^^^	  ^^^	  matches Underline
	      ^ ^	  matches ZNoBackslash
		     ^^^^ matches WNoBackslash
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
___zzzz ___wwww
^^^     ^^^     Underline にマッチする
    ^ ^         ZNoBackslash にマッチする
           ^^^^ WNoBackslash にマッチする
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "ms" offset is automatically set to the same value as the "lc" offset,
unless you set "ms" explicitly.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"ms" を指定しないと自動的に "lc" と同じ値にセットされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Multi-line patterns					*:syn-multi-line*

The patterns can include "\n" to match an end-of-line.	Mostly this works as
expected, but there are a few exceptions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-multi-line}
@cindex :syn-multi-line
@cindex 複数行にわたるパターン
@unnumberedsubsec 複数行にわたるパターン
パターンが "\n" を含むと改行にマッチするようになる。たいていの場合これは期待通りに動作するが、少しだけ例外がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When using a start pattern with an offset, the start of the match is not
allowed to start in a following line.  The highlighting can start in a
following line though.  Using the "\zs" item also requires that the start of
the match doesn't move to another line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
start パターンにオフセットをつけるとき、マッチ部分の開始位置が次の行の先頭であってはならない。ハイライトは次の行で始まってもよい。"\zs" を使うときも、マッチ部分の開始位置が他の行になってはならない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The skip pattern can include the "\n", but the search for an end pattern will
continue in the first character of the next line, also when that character is
matched by the skip pattern.  This is because redrawing may start in any line
halfway a region and there is no check if the skip pattern started in a
previous line.	For example, if the skip pattern is "a\nb" and an end pattern
is "b", the end pattern does match in the second line of this: >
	 x x a
	 b x x
Generally this means that the skip pattern should not match any characters
after the "\n".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
skip パターンも "\n" を含んでよい。ただし次の行の最初の文字が skip パターンにマッチしていても、そこから end パターンの検索が続けられる。これは、再描画は領域内のどの行でも始まることができ、skip パターンが前の行から始まったかどうかはチェックされないからである。例えば、skip パターンが "a\nb" で、end パターンが "b" のとき、次のテキストの 2 行目で end パターンがマッチする。
@verbatim
x x a
b x x
@end verbatim
つまり、skip パターンは "\n" 以降の文字にはマッチしないことになる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
External matches					*:syn-ext-match*

These extra regular expression items are available in region patterns:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-ext-match}
@cindex :syn-ext-match
@cindex 外部マッチ
@unnumberedsubsec 外部マッチ
リージョンのパターンでは特別に以下の正規表現が使える:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*/\z(* */\z(\)* *E50* *E52* *E879*
    \z(\)	Marks the sub-expression as "external", meaning that it can be
		accessed from another pattern match.  Currently only usable in
		defining a syntax region start pattern.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{/\z(}
@anchor{/\z(\)}
@anchor{E50}
@anchor{E52}
@anchor{E879}
@cindex /\z(
@cindex /\z(\)
@erindex E50
@erindex E52
@erindex E879
@table @asis
@item \z(\)
一部を「external」としてマークする。これをつけると他のパターンからアクセスできるようになる。現在はリージョンの start パターン内でのみ使用可能。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*/\z1* */\z2* */\z3* */\z4* */\z5*
    \z1  ...  \z9			*/\z6* */\z7* */\z8* */\z9* *E66* *E67*
		Matches the same string that was matched by the corresponding
		sub-expression in a previous start pattern match.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{/\z1}
@anchor{/\z2}
@anchor{/\z3}
@anchor{/\z4}
@anchor{/\z5}
@anchor{/\z6}
@anchor{/\z7}
@anchor{/\z8}
@anchor{/\z9}
@anchor{E66}
@anchor{E67}
@cindex /\z1
@cindex /\z2
@cindex /\z3
@cindex /\z4
@cindex /\z5
@cindex /\z6
@cindex /\z7
@cindex /\z8
@cindex /\z9
@erindex E66
@erindex E67
@item \z1  ...  \z9
start パターンにマッチしたテキスト中からマークしておいた部分を参照する。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Sometimes the start and end patterns of a region need to share a common
sub-expression.  A common example is the "here" document in Perl and many Unix
shells.  This effect can be achieved with the "\z" special regular expression
items, which marks a sub-expression as "external", in the sense that it can be
referenced from outside the pattern in which it is defined.  The here-document
example, for instance, can be done like this: >
  :syn region hereDoc start="<<\z(\I\i*\)" end="^\z1$"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リージョンの start と end パターンで正規表現の一部を共有したい場合がある。一般的な例としては Perl や Unix シェルのヒアドキュメントがある。これは特別な正規表現アイテム "\z" を使えば達成できる。これは正規表現の一部を "external" としてマークしておく。するとその部分を他のパターンから参照できるようになる。例えば、ヒアドキュメントは次のようにすればよい:
@example
:syn region hereDoc start="<<\z(\I\i*\)" end="^\z1$"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
As can be seen here, the \z actually does double duty.	In the start pattern,
it marks the "\(\I\i*\)" sub-expression as external; in the end pattern, it
changes the \z1 back-reference into an external reference referring to the
first external sub-expression in the start pattern.  External references can
also be used in skip patterns: >
  :syn region foo start="start \(\I\i*\)" skip="not end \z1" end="end \z1"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このように、\z は 2 つの役割を果たす。start パターンにおいては正規表現の一部 "\(\I\i*\)" を external としてマークする。end パターンでは \z1 によって start パターン中の最初のマークされた部分への外部参照とする。外部参照は skip パターン中でも使える:
@example
:syn region foo start="start \(\I\i*\)" skip="not end \z1" end="end \z1"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that normal and external sub-expressions are completely orthogonal and
indexed separately; for instance, if the pattern "\z(..\)\(..\)" is applied
to the string "aabb", then \1 will refer to "bb" and \z1 will refer to "aa".
Note also that external sub-expressions cannot be accessed as back-references
within the same pattern like normal sub-expressions.  If you want to use one
sub-expression as both a normal and an external sub-expression, you can nest
the two, as in "\(\z(...\)\)".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
通常のマークと external なマークはまったく独立であり、別々に番号が振られる。例えば、文字列 "aabb" に対してパターン "\z(..\)\(..\)" を適用すると、\1は "bb" を参照し、\z1 は "aa" を参照するようになる。external なマークをした部分は、通常のマークと違って、同一パターン内で後方参照することはできない。ある部分に対して通常のマーク、external なマーク両方をつけたい場合は、"\(\z(...\)\)" のようにネストさせればよい。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that only matches within a single line can be used.  Multi-line matches
cannot be referred to.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
一行内でマッチした部分しか参照できないことに注意。複数行にわたってマッチした部分は参照できない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
8. Syntax clusters					*:syn-cluster* *E400*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-cluster}
@anchor{E400}
@cindex :syn-cluster
@erindex E400
@cindex クラスタ
@section 8. クラスタ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:sy[ntax] cluster {cluster-name} [contains={group-name}..]
				 [add={group-name}..]
				 [remove={group-name}..]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item :sy[ntax] cluster @{cluster-name@} [contains=@{group-name@}..] @*
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ [add=@{group-name@}..]
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ [remove=@{group-name@}..]
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This command allows you to cluster a list of syntax groups together under a
single name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このコマンドを使うと、複数の構文グループを1つの名前のもとにまとめることができる。このまとまりのことをクラスタと呼ぶ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	contains={group-name}..
		The cluster is set to the specified list of groups.
	add={group-name}..
		The specified groups are added to the cluster.
	remove={group-name}..
		The specified groups are removed from the cluster.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item contains=@{group-name@}..
クラスタに含まれるグループを指定する。
@item add=@{group-name@}..
指定したグループをクラスタに加える。
@item remove=@{group-name@}..
指定したグループをクラスタからとり除く。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A cluster so defined may be referred to in a contains=.., containedin=..,
nextgroup=.., add=..  or remove=.. list with a "@" prefix.  You can also use
this notation to implicitly declare a cluster before specifying its contents.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
定義したクラスタは contains=.. や containedin=.., nextgroup=.., add=.., remove=.. などの文脈で使うことができる。そのとき、クラスタ名の頭に "@@" をつける。クラスタを定義する前にそのクラスタ名を使用してもよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Example: >
   :syntax match Thing "# [^#]\+ #" contains=@ThingMembers
   :syntax cluster ThingMembers contains=ThingMember1,ThingMember2
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@example
:syntax match Thing "# [^#]\+ #" contains=@@ThingMembers
:syntax cluster ThingMembers contains=ThingMember1,ThingMember2
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
As the previous example suggests, modifications to a cluster are effectively
retroactive; the membership of the cluster is checked at the last minute, so
to speak: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この例からわかるように、クラスタに対する変更はさかのぼって効果がある。クラスタの定義は直前になってチェックされる。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   :syntax keyword A aaa
   :syntax keyword B bbb
   :syntax cluster AandB contains=A
   :syntax match Stuff "( aaa bbb )" contains=@AandB
   :syntax cluster AandB add=B	  " now both keywords are matched in Stuff
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:syntax keyword A aaa
:syntax keyword B bbb
:syntax cluster AandB contains=A
:syntax match Stuff "( aaa bbb )" contains=@@AandB
:syntax cluster AandB add=B    " これによって 2 つのキーワードが Stuff 内でマッチするようになる
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This also has implications for nested clusters: >
   :syntax keyword A aaa
   :syntax keyword B bbb
   :syntax cluster SmallGroup contains=B
   :syntax cluster BigGroup contains=A,@SmallGroup
   :syntax match Stuff "( aaa bbb )" contains=@BigGroup
   :syntax cluster BigGroup remove=B	" no effect, since B isn't in BigGroup
   :syntax cluster SmallGroup remove=B	" now bbb isn't matched within Stuff
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはクラスタのネスト度にも関係がある:
@example
:syntax keyword A aaa
:syntax keyword B bbb
:syntax cluster SmallGroup contains=B
:syntax cluster BigGroup contains=A,@@SmallGroup
:syntax match Stuff "( aaa bbb )" contains=@@BigGroup
:syntax cluster BigGroup remove=B    " B は BigGroup 内にないので無意味
:syntax cluster SmallGroup remove=B  " Stuff 内で bbb がマッチしなくなる
@end example
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*E848*
The maximum number of clusters is 9767.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E848}
@erindex E848
クラスタの最大数は 9767 である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
9. Including syntax files				*:syn-include* *E397*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-include}
@anchor{E397}
@cindex :syn-include
@erindex E397
@cindex 構文ファイルのインクルード
@section 9. 構文ファイルのインクルード
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It is often useful for one language's syntax file to include a syntax file for
a related language.  Depending on the exact relationship, this can be done in
two different ways:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
構文ファイルの中で、関係する構文ファイルをインクルードしたい場合がある。これには、構文ファイルの関係に応じて 2 種類の方法がある:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	- If top-level syntax items in the included syntax file are to be
	  allowed at the top level in the including syntax, you can simply use
	  the |:runtime| command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item インクルードされるファイル内のトップレベルのアイテムをそのままトップレベルとしたい場合は、単に |@ref{:runtime}| コマンドを使えばよい:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
  " In cpp.vim:
  :runtime! syntax/c.vim
  :unlet b:current_syntax
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
" In cpp.vim:
:runtime! syntax/c.vim
:unlet b:current_syntax
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<	- If top-level syntax items in the included syntax file are to be
	  contained within a region in the including syntax, you can use the
	  ":syntax include" command:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item インクルードされるファイル内のトップレベルのアイテムをリージョンに内包させるには、"@command{:syntax include}" コマンドを使うとよい:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:sy[ntax] include [@{grouplist-name}] {file-name}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:sy[ntax] include [@@@{grouplist-name@}] @{file-name@}
@end example
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	  All syntax items declared in the included file will have the
	  "contained" flag added.  In addition, if a group list is specified,
	  all top-level syntax items in the included file will be added to
	  that list. >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
インクルードされるファイル中で宣言された構文アイテム全てに "contained" フラグがつけられる。さらにグループのリストを指定すると、インクルードされるファイル中のトップレベルの構文アイテム全てに対してそのリストがつけられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
   " In perl.vim:
   :syntax include @Pod <sfile>:p:h/pod.vim
   :syntax region perlPOD start="^=head" end="^=cut" contains=@Pod
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
" In perl.vim:
:syntax include @@Pod <sfile>:p:h/pod.vim
:syntax region perlPOD start="^=head" end="^=cut" contains=@@Pod
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	  When {file-name} is an absolute path (starts with "/", "c:", "$VAR"
	  or "<sfile>") that file is sourced.  When it is a relative path
	  (e.g., "syntax/pod.vim") the file is searched for in 'runtimepath'.
	  All matching files are loaded.  Using a relative path is
	  recommended, because it allows a user to replace the included file
	  with his own version, without replacing the file that does the ":syn
	  include".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{file-name@} が絶対パスである場合 ("/", "c:", "$VAR", "<sfile>" のどれかで始まる場合) そのファイルが読み込まれる (sourceされる)。相対パスの場合 (例: "syntax/pod.vim")、そのファイルが '@option{runtimepath}' 中から探される。マッチしたファイル全てが読み込まれる。相対パスを使用することが推奨される。そうすればユーザーが ":syn include" を書き換えることなく、インクルードされるファイルを改変して別の場所に置けるからである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*E847*
The maximum number of includes is 999.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E847}
@erindex E847
インクルードの最大数は 999 である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
10. Synchronizing				*:syn-sync* *E403* *E404*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-sync}
@anchor{E403}
@anchor{E404}
@cindex :syn-sync
@erindex E403
@erindex E404
@cindex 表示のシンクロナイズ
@section 10. 表示のシンクロナイズ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim wants to be able to start redrawing in any position in the document.  To
make this possible it needs to know the syntax state at the position where
redrawing starts.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ドキュメント中のどの位置からでも再描画を開始できると望ましい。これを実現するには、再描画を開始する位置における構文の状態を知る必要がある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:sy[ntax] sync [ccomment [group-name] | minlines={N} | ...]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:sy[ntax] sync [ccomment [group-name] | minlines=@{N@} | ...]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are four ways to synchronize:
1. Always parse from the start of the file.
   |:syn-sync-first|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シンクロナイズには4つのやり方がある:
@enumerate
@item 常にファイルの最初からパースする。|@ref{:syn-sync-first}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
2. Based on C-style comments.  Vim understands how C-comments work and can
   figure out if the current line starts inside or outside a comment.
   |:syn-sync-second|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item C スタイルのコメントに基づく。Vim は C コメントの仕様を理解し、現在行がコメントの内側から始まっているか外側から始まっているかを判定することができる。|@ref{:syn-sync-second}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
3. Jumping back a certain number of lines and start parsing there.
   |:syn-sync-third|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 一定行さかのぼり、そこからパースを開始する。|@ref{:syn-sync-third}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
4. Searching backwards in the text for a pattern to sync on.
   |:syn-sync-fourth|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item テキストをさかのぼり、シンクロナイズを始める目印の正規表現を検索する。|@ref{:syn-sync-fourth}|
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*:syn-sync-maxlines* *:syn-sync-minlines*
For the last three methods, the line range where the parsing can start is
limited by "minlines" and "maxlines".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-sync-maxlines}
@anchor{:syn-sync-minlines}
@cindex :syn-sync-maxlines
@cindex :syn-sync-minlines
最後の3つの方法に関して、さかのぼる行数は "minlines" と "maxlines" で制限される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the "minlines={N}" argument is given, the parsing always starts at least
that many lines backwards.  This can be used if the parsing may take a few
lines before it's correct, or when it's not possible to use syncing.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数 "minlines=@{N@}" が指定されると、常に少なくともその行数さかのぼってパースが開始される。パースする行数が少なすぎて正しくハイライトできないかもしれないとき、またはシンクロナイズを使うのが不可能であるとき、この引数を使うとよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the "maxlines={N}" argument is given, the number of lines that are searched
for a comment or syncing pattern is restricted to N lines backwards (after
adding "minlines").  This is useful if you have few things to sync on and a
slow machine.  Example: >
   :syntax sync maxlines=500 ccomment
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数 "maxlines=@{N@}" が指定されると、コメントや正規表現を検索するためにさかのぼる行数が最大 N 行になる。これは遅いマシンを使っていて、シンクロナイズする行数が少ないとわかっているときに便利である。例:
@example
:syntax sync maxlines=500 ccomment
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*:syn-sync-linebreaks*
When using a pattern that matches multiple lines, a change in one line may
cause a pattern to no longer match in a previous line.	This means has to
start above where the change was made.	How many lines can be specified with
the "linebreaks" argument.  For example, when a pattern may include one line
break use this: >
   :syntax sync linebreaks=1
The result is that redrawing always starts at least one line before where a
change was made.  The default value for "linebreaks" is zero.  Usually the
value for "minlines" is bigger than "linebreaks".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-sync-linebreaks}
@cindex :syn-sync-linebreaks
複数行にマッチする正規表現を使っているとき、ある行に変更を施すと、前の行でマッチしていた正規表現がマッチしなくなってしまうことがある。この場合、変更を施した位置より上からシンクロナイズを行わなければならない。その行数を引数 "linebreaks" で指定する。例えば、正規表現が改行を1個含んでいる場合はこのようにする:
@example
:syntax sync linebreaks=1
@end example
こうすると、常に変更が施された行の少なくとも1行前から再描画が開始される。"linebreaks" のデフォルト値は 0。通常 "minlines" の値は "linebreaks" の値より大きい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
First syncing method:			*:syn-sync-first*
>
   :syntax sync fromstart
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-sync-first}
@cindex :syn-sync-first
@unnumberedsubsec 第一の方法:
@example
:syntax sync fromstart
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The file will be parsed from the start.  This makes syntax highlighting
accurate, but can be slow for long files.  Vim caches previously parsed text,
so that it's only slow when parsing the text for the first time.  However,
when making changes some part of the text needs to be parsed again (worst
case: to the end of the file).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルの最初からパースする。この方法を使うと構文ハイライトが正確になるが、大きいファイルに対しては遅くなる。Vim は以前にパースしたテキストをキャッシュしておく。そのため、遅くなるのはファイルを最初にパースするときだけである。しかし、変更を施すと、それ以降の一部をパースし直さなければならなくなる (最悪の場合はファイルの最後まで)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Using "fromstart" is equivalent to using "minlines" with a very large number.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"fromstart" を使うことは "minlines" を非常に大きな値にすることと同じ効果を持つ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Second syncing method:			*:syn-sync-second* *:syn-sync-ccomment*

For the second method, only the "ccomment" argument needs to be given.
Example: >
   :syntax sync ccomment
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-sync-second}
@anchor{:syn-sync-ccomment}
@cindex :syn-sync-second
@cindex :syn-sync-ccomment
@unnumberedsubsec 第二の方法:
第二の方法を使うには、単に引数 "ccomment" をつければよい。

例:
@example
:syntax sync ccomment
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When Vim finds that the line where displaying starts is inside a C-style
comment, the last region syntax item with the group-name "Comment" will be
used.  This requires that there is a region with the group-name "Comment"!
An alternate group name can be specified, for example: >
   :syntax sync ccomment javaComment
This means that the last item specified with "syn region javaComment" will be
used for the detected C comment region.  This only works properly if that
region does have a start pattern "\/*" and an end pattern "*\/".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
画面最上行が C スタイルコメントの内側にあると判断される場合、グループ名が "Comment" のリージョン構文アイテムが使われる。この方法を使うには "Comment" というグループ名のリージョンがなければならないことに注意。他のグループ名を指定することもできる。例:
@example
:syntax sync ccomment javaComment
@end example
こうすると、検出された C コメントのリージョンに対して "syn region javaComment" で指定されたアイテムのうち最後のものが使われる。ここで指定するリージョンの start パターンが "\/*"、end パターンが "*\/" となっていないと適切に機能しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "maxlines" argument can be used to restrict the search to a number of
lines.	The "minlines" argument can be used to at least start a number of
lines back (e.g., for when there is some construct that only takes a few
lines, but it hard to sync on).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数 "maxlines" を使うと検索の行数を制限できる。引数 "minlines" を使うと少なくともその行数だけさかのぼって開始させることができる (例: 2,3 行だけを受け取るコンストラクトがある場合。ただしその場合シンクロナイズするのが困難)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: Syncing on a C comment doesn't work properly when strings are used
that cross a line and contain a "*/".  Since letting strings cross a line
is a bad programming habit (many compilers give a warning message), and the
chance of a "*/" appearing inside a comment is very small, this restriction
is hardly ever noticed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"*/" を含む文字列で行をまたぐものがあると、C コメントによるシンクロナイズは適切に機能しない。行をまたいで文字列を書くのは悪いプログラミング習慣である (多くのコンパイラが警告を出す)。また、コメント中に "*/" が現れる機会はまれなので、この制限は注意するほどのものではない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Third syncing method:				*:syn-sync-third*

For the third method, only the "minlines={N}" argument needs to be given.
Vim will subtract {N} from the line number and start parsing there.  This
means {N} extra lines need to be parsed, which makes this method a bit slower.
Example: >
   :syntax sync minlines=50
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-sync-third}
@cindex :syn-sync-third
@unnumberedsubsec 第三の方法:
第三の方法を使うには引数 "minlines=@{N@}" を加えればよい。この方法を指定すると、@{N@} 行前からパースを開始する。これは @{N@} 行余分にパースされることを意味する。そのためこの方法は少し遅くなる。

例:
@example
:syntax sync minlines=50
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
"lines" is equivalent to "minlines" (used by older versions).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"lines" は "minlines" と同じ意味である (古いバージョンで使われている)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Fourth syncing method:				*:syn-sync-fourth*

The idea is to synchronize on the end of a few specific regions, called a
sync pattern.  Only regions can cross lines, so when we find the end of some
region, we might be able to know in which syntax item we are.  The search
starts in the line just above the one where redrawing starts.  From there
the search continues backwards in the file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-sync-fourth}
@cindex :syn-sync-fourth
@unnumberedsubsec 第四の方法:
第四の方法は、シンクロナイズパターンと呼ばれる特定のリージョンの末尾でシンクロナイズするものである。行をまたげるのはリージョンだけなので、リージョンの末尾に出会ったら、どの構文アイテムの中にいるのかを知ることができる。再描画が始まる行のすぐ上から検索を開始し、ファイルの上方に向かって検索する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This works just like the non-syncing syntax items.  You can use contained
matches, nextgroup, etc.  But there are a few differences:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはシンクロナイズしない構文アイテムとちょうど同じように機能する。内包されたマッチ、nextgroup などを使うことができる。ただし少しだけ違いがある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Keywords cannot be used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item キーワードを使うことはできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The syntax items with the "sync" keyword form a completely separated group
  of syntax items.  You can't mix syncing groups and non-syncing groups.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "sync" キーワード付きの構文アイテムは、完全に別の構文アイテムのグループを形成する。シンクロナイズするグループとしないグループを混ぜることはできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The matching works backwards in the buffer (line by line), instead of
  forwards.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 照合はバッファ内で 1 行ごとに逆向きに行われる (前向きではない)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- A line continuation pattern can be given.  It is used to decide which group
  of lines need to be searched like they were one line.  This means that the
  search for a match with the specified items starts in the first of the
  consecutive that contain the continuation pattern.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 行継続パターンをつけることができる。これを使うと、あたかも 1 行であるかのように検索する一連の行を指定することができる。これは、指定したアイテムとの照合が継続パターンを含む一連の行の最初から始まることを意味する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- When using "nextgroup" or "contains", this only works within one line (or
  group of continued lines).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "nextgroup" や "contains" は 1 行 (または継続された一連の行) 内でだけ有効。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- When using a region, it must start and end in the same line (or group of
  continued lines).  Otherwise the end is assumed to be at the end of the
  line (or group of continued lines).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item リージョンは同一行 (または継続された一連の行) 内で開始・終了しなければならない。そうでないと行末 (または継続された一連の行) 内で終わるものとされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- When a match with a sync pattern is found, the rest of the line (or group of
  continued lines) is searched for another match.  The last match is used.
  This is used when a line can contain both the start end the end of a region
  (e.g., in a C-comment like /* this */, the last "*/" is used).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item シンクロナイズパターンとのマッチが見つかると、その行 (または継続された一連の行) の残りから再びマッチが探される。最後のマッチが使われる。これはリージョンの開始と終了が同一行内にあるとき使われる (例: /* this */のようなCコメントでは、最後の "*/" が使われる)。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are two ways how a match with a sync pattern can be used:
1. Parsing for highlighting starts where redrawing starts (and where the
   search for the sync pattern started).  The syntax group that is expected
   to be valid there must be specified.  This works well when the regions
   that cross lines cannot contain other regions.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シンクロナイズパターンとのマッチは2通りの使い方がある。
@enumerate
@item 再描画を始める場所 (シンクロナイズパターンの検索が始まる場所でもある) から強調のためのパースを始める。そこで有効であると期待される構文グループを指定しなければならない。行をまたぐリージョンが他のリージョンを含んではならない場合にこれはうまく機能する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
2. Parsing for highlighting continues just after the match.  The syntax group
   that is expected to be present just after the match must be specified.
   This can be used when the previous method doesn't work well.  It's much
   slower, because more text needs to be parsed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ハイライトのためのパースはマッチの直後から継続される。マッチの直後に現れると期待される構文グループを指定しなければならない。これは前の方法がうまくいかないときに使われる。より多くのテキストをパースする必要があるため、とても遅い。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Both types of sync patterns can be used at the same time.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
両方のタイプを同時に使うこともできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Besides the sync patterns, other matches and regions can be specified, to
avoid finding unwanted matches.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シンクロナイズパターンだけでなく、他のマッチとリージョンを指定して望まないマッチが見つかるのを避けることができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
[The reason that the sync patterns are given separately, is that mostly the
search for the sync point can be much simpler than figuring out the
highlighting.  The reduced number of patterns means it will go (much)
faster.]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[シンクロナイズパターンが別々に与えられる理由は、シンクロナイズポイントの検索はたいていの場合、ハイライトするところを判別するよりずっと単純だからである。パターンの数が減るとそれだけ速くなる。]
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					    *syn-sync-grouphere* *E393* *E394*
    :syntax sync match {sync-group-name} grouphere {group-name} "pattern" ..
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{syn-sync-grouphere}
@anchor{E393}
@anchor{E394}
@cindex syn-sync-grouphere
@erindex E393
@erindex E394
@table @asis
@item :syntax sync match @{sync-group-name@} grouphere @{group-name@} "pattern" ..
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Define a match that is used for syncing.  {group-name} is the
	name of a syntax group that follows just after the match.  Parsing
	of the text for highlighting starts just after the match.  A region
	must exist for this {group-name}.  The first one defined will be used.
	"NONE" can be used for when there is no syntax group after the match.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シンクロナイズ用に使うマッチを定義する。@{group-name@} はマッチのすぐ後に続く構文グループの名前である。ハイライトのためのテキストのパースはマッチの直後から始まる。この @{group-name@} がついたリージョンが存在しなければならない。最初に定義されたリージョンが使われる。マッチの後に構文グループが続かない場合は "NONE" を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*syn-sync-groupthere*
    :syntax sync match {sync-group-name} groupthere {group-name} "pattern" ..
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{syn-sync-groupthere}
@cindex syn-sync-groupthere
@item :syntax sync match @{sync-group-name@} groupthere @{group-name@} "pattern" ..
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Like "grouphere", but {group-name} is the name of a syntax group that
	is to be used at the start of the line where searching for the sync
	point started.	The text between the match and the start of the sync
	pattern searching is assumed not to change the syntax highlighting.
	For example, in C you could search backwards for "/*" and "*/".  If
	"/*" is found first, you know that you are inside a comment, so the
	"groupthere" is "cComment".  If "*/" is found first, you know that you
	are not in a comment, so the "groupthere" is "NONE".  (in practice
	it's a bit more complicated, because the "/*" and "*/" could appear
	inside a string.  That's left as an exercise to the reader...).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"grouphere" と同様。ただし @{group-name@} はシンクロナイズポイントの検索が始まる行の行頭で使われる構文グループの名前である。マッチとシンクロナイズパターンの検索が始まる位置との間のテキストは構文ハイライトを変えてはならない。例えば C において "/*" と "*/" を後方検索することができる。"/*" が先に見つかったら、今はコメントの内側にいるとわかる。なので "groupthere" は "cComment" となる。"*/" が先に見つかったら今はコメントの中ではないとわかる。なので "groupthere" は "NONE" となる。(実際は、文字列の中に "/*" と "*/" があるかもしれないので、もう少し込み入っている。これは読者の練習問題としておく...)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
    :syntax sync match ..
    :syntax sync region ..
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :syntax sync match .. または
@itemx :syntax sync region ..
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Without a "groupthere" argument.  Define a region or match that is
	skipped while searching for a sync point.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数 "groupthere" なしの場合。シンクロナイズポイントの検索の際にスキップされるリージョンやマッチを定義する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*syn-sync-linecont*
    :syntax sync linecont {pattern}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{syn-sync-linecont}
@cindex syn-sync-linecont
@item :syntax sync linecont @{pattern@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	When {pattern} matches in a line, it is considered to continue in
	the next line.	This means that the search for a sync point will
	consider the lines to be concatenated.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{pattern@} とのマッチが次の行にも継続されるとみなされる。つまりシンクロナイズポイントの検索の際、行は連結されているものと見なされる。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the "maxlines={N}" argument is given too, the number of lines that are
searched for a match is restricted to N.  This is useful if you have very
few things to sync on and a slow machine.  Example: >
   :syntax sync maxlines=100
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数 "maxlines=@{N@}" が同時に与えられると、マッチを検索する行がN行に制限される。これは遅いマシンを使っていて、シンクロナイズするものが少ないとわかっているときに便利。例:
@example
:syntax sync maxlines=100
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can clear all sync settings with: >
   :syntax sync clear
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
全てのシンクロナイズの設定をクリアするには:
@example
:syntax sync clear
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can clear specific sync patterns with: >
   :syntax sync clear {sync-group-name} ..
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
あるシンクロナイズパターンをクリアするには:
@example
:syntax sync clear @{sync-group-name@} ..  
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
11. Listing syntax items		*:syntax* *:sy* *:syn* *:syn-list*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syntax}
@anchor{:sy}
@anchor{:syn}
@anchor{:syn-list}
@pindex :syntax
@pindex :sy
@pindex :syn
@cindex :syn-list
@cindex 構文アイテムのリストを表示する
@section 11. 構文アイテムのリストを表示する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This command lists all the syntax items: >

    :sy[ntax] [list]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のコマンドは全ての構文アイテムのリストを表示する:
@example
:sy[ntax] [list]
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To show the syntax items for one syntax group: >

    :sy[ntax] list {group-name}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ある構文グループに属する構文アイテムを表示するには:
@example
:sy[ntax] list @{group-name@}
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To list the syntax groups in one cluster:			*E392*	 >

    :sy[ntax] list @{cluster-name}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E392}
@erindex E392
あるクラスタに属する構文グループを表示するには:
@example
:sy[ntax] list @@@{cluster-name@}
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
See above for other arguments for the ":syntax" command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:syntax}" コマンドに対する他の引数については上を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that the ":syntax" command can be abbreviated to ":sy", although ":syn"
is mostly used, because it looks better.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"@command{:syntax}" コマンドは "@command{:sy}" とも略記できる。しかし "@command{:syn}" の方が見栄えがよいため、普通はこちらが使われる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
12. Highlight command			*:highlight* *:hi* *E28* *E411* *E415*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:highlight}
@anchor{:hi}
@anchor{E28}
@anchor{E411}
@anchor{E415}
@pindex :highlight
@pindex :hi
@erindex E28
@erindex E411
@erindex E415
@cindex ハイライトコマンド
@section 12. ハイライトコマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are three types of highlight groups:
- The ones used for specific languages.  For these the name starts with the
  name of the language.  Many of these don't have any attributes, but are
  linked to a group of the second type.
- The ones used for all syntax languages.
- The ones used for the 'highlight' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ハイライトグループには 3 つのタイプがある:
@itemize
@item 特定の構文言語用のもの。名前がその言語の名前で始まる。このタイプのほとんどは属性を持たず、2 番目のタイプのグループにリンクされる。
@item 全ての構文言語に対して使われるもの。
@item '@option{highlight}' オプションに使われるもの。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hitest.vim*
You can see all the groups currently active with this command: >
    :so $VIMRUNTIME/syntax/hitest.vim
This will open a new window containing all highlight group names, displayed
in their own color.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hitest.vim}
@cindex hitest.vim
現在有効な全てのグループを知るにはこのコマンドを使う:
@example
:so $VIMRUNTIME/syntax/hitest.vim
@end example
このコマンドは新しいウィンドウを開き、そこに全てのハイライトグループ名を、それ自身の色を使って表示する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:colo* *:colorscheme* *E185*
:colo[rscheme]		Output the name of the currently active color scheme.
			This is basically the same as >
				:echo g:colors_name
<			In case g:colors_name has not been defined :colo will
			output "default".  When compiled without the |+eval|
			feature it will output "unknown".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:colo}
@anchor{:colorscheme}
@anchor{E185}
@pindex :colo
@pindex :colorscheme
@erindex E185
@table @asis
@item :colo[rscheme]
現在のカラースキームの名前を表示する。基本的には次のコマンドと同じである
@example
:echo g:colors_name
@end example
g:colors_name が定義されていない場合は "default" と表示される。|@ref{+eval}| 機能付きでコンパイルされていない場合は "unknown" と表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:colo[rscheme] {name}	Load color scheme {name}.  This searches 'runtimepath'
			for the file "colors/{name}.vim".  The first one that
			is found is loaded.
			Also searches all plugins in 'packpath', first below
			"start" and then under "opt".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :colo[rscheme] @{name@}
カラースキーム @{name@} を読み込む。これは '@option{runtimepath}' の中から "colors/@{name@}.vim" というファイルを検索する。最初に見つかったものが読み込まれる。同様に、'@option{packpath}' 内の全てのプラグインを検索し、それぞれについて "start" 内、"opt" 内の順で検索する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			Doesn't work recursively, thus you can't use
			":colorscheme" in a color scheme script.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
再帰的な読み込みはされない。つまりカラースキームスクリプト中で ":colorscheme" を使うことはできない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			To customize a colorscheme use another name, e.g.
			"~/.vim/colors/mine.vim", and use `:runtime` to load
			the original colorscheme: >
				runtime colors/evening.vim
				hi Statement ctermfg=Blue guifg=Blue
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カラースキームをカスタマイズするには異なる名前を使い、例えば "~/.vim/colors/mine.vim"、`:runtime` を用いてオリジナルのカラースキームを読み込む:
@example
runtime colors/evening.vim
hi Statement ctermfg=Blue guifg=Blue
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
<			Before the color scheme will be loaded the
			|ColorSchemePre| autocommand event is triggered.
			After the color scheme has been loaded the
			|ColorScheme| autocommand event is triggered.
			For info about writing a colorscheme file: >
				:edit $VIMRUNTIME/colors/README.txt
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カラースキームが読み込まれる前に、自動コマンドイベント |@ref{ColorSchemePre}| が発生する。

カラースキームが読み込まれた後、自動コマンドイベント |@ref{ColorScheme}| が発生する。カラースキームファイルを書くための情報については次を参照:
@example
:edit $VIMRUNTIME/colors/README.txt
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:hi[ghlight]		List all the current highlight groups that have
			attributes set.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :hi[ghlight]
属性がセットされたハイライトグループを全て表示する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:hi[ghlight] {group-name}
			List one highlight group.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :hi[ghlight] @{group-name@}
1 つのハイライトグループを表示する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:hi[ghlight] clear	Reset all highlighting to the defaults.  Removes all
			highlighting for groups added by the user!
			Uses the current value of 'background' to decide which
			default colors to use.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :hi[ghlight] clear
全てのハイライトをデフォルトに戻す。ユーザーによって加えられたグループに対するハイライトが全て消去される。現在の '@option{background}' の値によってデフォルトの色が決まる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:hi[ghlight] clear {group-name}
:hi[ghlight] {group-name} NONE
			Disable the highlighting for one highlight group.  It
			is _not_ set back to the default colors.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :hi[ghlight] clear @{group-name@}
@itemx :hi[ghlight] @{group-name@} NONE
1 つのハイライトグループに対するハイライトを無効にする。デフォルトの色に戻すわけではない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:hi[ghlight] [default] {group-name} {key}={arg} ..
			Add a highlight group, or change the highlighting for
			an existing group.
			See |highlight-args| for the {key}={arg} arguments.
			See |:highlight-default| for the optional [default]
			argument.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :hi[ghlight] [default] @{group-name@} @{key@}=@{arg@} ..
ハイライトグループを追加する、または既存のグループに対する強調を変更する。引数 @{key@}=@{arg@} については |@ref{highlight-args}| を参照。オプショナルな引数 [default] については |@ref{:highlight-default}| を参照。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Normally a highlight group is added once when starting up.  This sets the
default values for the highlighting.  After that, you can use additional
highlight commands to change the arguments that you want to set to non-default
values.  The value "NONE" can be used to switch the value off or go back to
the default value.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
通常、ハイライトグループは起動時に一度だけ追加される。そこでハイライトのデフォルト値をセットする。その後、ハイライトコマンドを使うことによってデフォルトでない値に変えることができる。値 "NONE" を使うとその値をオフにしたりデフォルト値に戻したりできる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A simple way to change colors is with the |:colorscheme| command.  This loads
a file with ":highlight" commands such as this: >

   :hi Comment	gui=bold
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
色を変える簡単な方法は |@ref{:colorscheme}| コマンドを使うことである。すると、次のような "@command{:highlight}" コマンドが書かれたファイルが読み込まれる:
@example
:hi Comment     gui=bold
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that all settings that are not included remain the same, only the
specified field is used, and settings are merged with previous ones.  So, the
result is like this single command has been used: >
   :hi Comment	term=bold ctermfg=Cyan guifg=#80a0ff gui=bold
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
このファイルに含まれない設定は変更されないままである。指定されたフィールドだけが更新され、それ以前の設定とマージされる。なのでその結果は次のコマンド 1 つを実行するのと同じである:
@example
:hi Comment     term=bold ctermfg=Cyan guifg=#80a0ff gui=bold
@end example
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:highlight-verbose*
When listing a highlight group and 'verbose' is non-zero, the listing will
also tell where it was last set.  Example: >
	:verbose hi Comment
<	Comment        xxx term=bold ctermfg=4 guifg=Blue ~
	   Last set from /home/mool/vim/vim7/runtime/syntax/syncolor.vim ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:highlight-verbose}
@cindex :highlight-verbose
'@option{verbose}' を 0 でない値にしてハイライトグループの一覧を表示すると、最後に設定された場所も表示される。例:
@example
:verbose hi Comment
@end example
@verbatim
Comment        xxx term=bold ctermfg=4 guifg=Blue
   Last set from /home/mool/vim/vim7/runtime/syntax/syncolor.vim
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When ":hi clear" is used then the script where this command is used will be
mentioned for the default values. See |:verbose-cmd| for more information.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:hi clear}" が実行されると、このコマンドを実行したスクリプトがデフォルト値として言及される。より詳しくは |@ref{:verbose-cmd}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*highlight-args* *E416* *E417* *E423*
There are three types of terminals for highlighting:
term	a normal terminal (vt100, xterm)
cterm	a color terminal (MS-DOS console, color-xterm, these have the "Co"
	termcap entry)
gui	the GUI
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{highlight-args}
@anchor{E416}
@anchor{E417}
@anchor{E423}
@cindex highlight-args
@erindex E416
@erindex E417
@erindex E423
ハイライトに関して、ターミナルは3種類に分類される:
@multitable @columnfractions .15 .85
@item term @tab 通常のターミナル(vt100, xterm)
@item cterm @tab カラーターミナル (MS-DOS console, color-xterm。これらは termcap エントリ "Co" をもつ)
@item gui @tab GUI
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For each type the highlighting can be given.  This makes it possible to use
the same syntax file on all terminals, and use the optimal highlighting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ハイライトはこれらのタイプごとに指定できる。そうすることによって、同じ構文ファイルを全てのターミナルに対して使用でき、ターミナルごとに最善のハイライトを利用できるようになっている。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. highlight arguments for normal terminals
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex highlight コマンドの引数 (通常のターミナル用)
@unnumberedsubsec 1. highlight コマンドの引数 (通常のターミナル用)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*bold* *underline* *undercurl*
					*inverse* *italic* *standout*
					*nocombine* *strikethrough*
term={attr-list}			*attr-list* *highlight-term* *E418*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{bold}
@anchor{underline}
@anchor{undercurl}
@anchor{inverse}
@anchor{italic}
@anchor{standout}
@anchor{nocombine}
@anchor{strikethrough}
@anchor{attr-list}
@anchor{highlight-term}
@anchor{E418}
@cindex bold
@cindex underline
@cindex undercurl
@cindex inverse
@cindex italic
@cindex standout
@cindex nocombine
@cindex strikethrough
@cindex attr-list
@cindex highlight-term
@erindex E418
@table @asis
@item term=@{attr-list@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	attr-list is a comma separated list (without spaces) of the
	following items (in any order):
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
attr-list はコンマ区切りのリスト (スペースは入れない) で、要素は以下の通り (順序はどうでもよい):
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		bold
		underline
		undercurl	not always available
		strikethrough	not always available
		reverse
		inverse		same as reverse
		italic
		standout
		nocombine	override attributes instead of combining them
		NONE		no attributes used (used to reset it)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item bold @tab
@item underline @tab
@item undercurl @tab 必ずしも使用できるとは限らない
@item strikethrough @tab 必ずしも使用できるとは限らない
@item reverse @tab
@item inverse @tab reverse と同じ
@item italic @tab
@item standout @tab
@item nocombine @tab 属性をまとめる代わりに、オーバーライドする
@item NONE @tab 属性を使用しない (属性をリセットするために使う)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Note that "bold" can be used here and by using a bold font.  They
	have the same effect.
	"undercurl" is a curly underline.  When "undercurl" is not possible
	then "underline" is used.  In general "undercurl" and "strikethrough"
	is only available in the GUI.  The color is set with |highlight-guisp|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
この引数で "bold" を指定してもよいし、太文字のフォントを指定してもよい。どちらも表示は同じになる。

"undercurl" は波線のこと。"undercurl" が使用できないときは "underline" が使われる。一般的には "undercurl" および "strikethrough" は GUI でのみ使用できる。その色は |@ref{highlight-guisp}| で設定できる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
start={term-list}				*highlight-start* *E422*
stop={term-list}				*term-list* *highlight-stop*
	These lists of terminal codes can be used to get
	non-standard attributes on a terminal.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{highlight-start}
@anchor{E422}
@anchor{term-list}
@anchor{highlight-stop}
@cindex highlight-start
@erindex E422
@cindex term-list
@cindex highlight-stop
@item start=@{term-list@} または
@itemx stop=@{term-list@}
これらのターミナルコードのリストを使ってターミナルについての標準的でない属性を得ることができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	The escape sequence specified with the "start" argument
	is written before the characters in the highlighted
	area.  It can be anything that you want to send to the
	terminal to highlight this area.  The escape sequence
	specified with the "stop" argument is written after the
	highlighted area.  This should undo the "start" argument.
	Otherwise the screen will look messed up.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数 "start" でエスケープシーケンスを指定すると、ハイライトするテキストの前にそれが書き込まれる。そのテキストをハイライトする際にターミナルに送りたいものをなんでも指定できる。引数 "stop" でエスケープシーケンスを指定すると、強調されるテキストの後にそれが書き込まれる。"start" で行ったことを "stop" で元に戻すべきである。そうしないとスクリーンがごちゃごちゃになってしまうだろう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	The {term-list} can have two forms:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{term-list@} は 2 つの形を持つ:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	1. A string with escape sequences.
	   This is any string of characters, except that it can't start with
	   "t_" and blanks are not allowed.  The <> notation is recognized
	   here, so you can use things like "<Esc>" and "<Space>".  Example:
		start=<Esc>[27h;<Esc>[<Space>r;
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item エスケープシーケンス付きの文字列。これは "t_" で始まるものと空文字列を除く任意の文字列である。"<Esc>" や "<Space>" のような <> 記法が利用できる。例:
@example
start=<Esc>[27h;<Esc>[<Space>r;
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	2. A list of terminal codes.
	   Each terminal code has the form "t_xx", where "xx" is the name of
	   the termcap entry.  The codes have to be separated with commas.
	   White space is not allowed.	Example:
		start=t_C1,t_BL
	   The terminal codes must exist for this to work.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ターミナルコードのリスト。ターミナルコードは "t_xx" の形を持つ。"xx" は termcap エントリ名である。ターミナルコードはコンマで区切る。ホワイトスペースは使えない。例:
@example
start=t_C1,t_BL
@end example
対応するターミナルコードが存在しなければならない。
@end enumerate
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
2. highlight arguments for color terminals
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex highlight コマンドの引数 (カラーターミナル用)
@unnumberedsubsec 2. highlight コマンドの引数 (カラーターミナル用)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
cterm={attr-list}					*highlight-cterm*
	See above for the description of {attr-list} |attr-list|.
	The "cterm" argument is likely to be different from "term", when
	colors are used.  For example, in a normal terminal comments could
	be underlined, in a color terminal they can be made Blue.
	Note: Many terminals (e.g., DOS console) can't mix these attributes
	with coloring.	Use only one of "cterm=" OR "ctermfg=" OR "ctermbg=".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{highlight-cterm}
@cindex highlight-cterm
@item cterm=@{attr-list@}
@{attr-list@} の説明は上を参照 |@ref{attr-list}|。色を使う場合、引数 "cterm" は "term" と異なる結果になる。例えば、通常のターミナルではコメントにアンダーラインを引き、カラーターミナルではコメントを青色で表示することができる。
@quotation
@strong{Note:} @*
DOS コンソールなど多くのターミナルでは色づけの際にこれらの属性を混在させることはできない。"cterm=" か "ctermfg=" が "ctermbg=" のどれか 1 つだけを使うこと。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ctermfg={color-nr}				*highlight-ctermfg* *E421*
ctermbg={color-nr}				*highlight-ctermbg*
	The {color-nr} argument is a color number.  Its range is zero to
	(not including) the number given by the termcap entry "Co".
	The actual color with this number depends on the type of terminal
	and its settings.  Sometimes the color also depends on the settings of
	"cterm".  For example, on some systems "cterm=bold ctermfg=3" gives
	another color, on others you just get color 3.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{highlight-ctermfg}
@anchor{E421}
@anchor{highlight-ctermbg}
@cindex highlight-ctermfg
@erindex E421
@cindex highlight-ctermbg
@item ctermfg=@{color-nr@} または
@itemx ctermbg=@{color-nr@}
引数 @{color-nr@} で色番号を指定する。色番号の範囲は 0 から termcap エントリ "Co" の値 - 1 までである。

この色番号で実際に表示される色はターミナルの種類とその設定に依存する。"cterm" の設定によって色が変わる場合もある。例えば、あるシステムでは "cterm=bold ctermfg=3" でそのまま 3 番の色を表示し、他のシステムでは異なる色を表示することがある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	For an xterm this depends on your resources, and is a bit
	unpredictable.	See your xterm documentation for the defaults.	The
	colors for a color-xterm can be changed from the .Xdefaults file.
	Unfortunately this means that it's not possible to get the same colors
	for each user.	See |xterm-color| for info about color xterms.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
xterm においてはこれはユーザーのリソースに依存し、やや予測ができない。デフォルトについては xterm のドキュメントを参照のこと。カラー xterm 用の色は @file{.Xdefaults} ファイルで変更することができる。このため、ユーザーごとに表示される色が異なるかもしれない。カラー xterm については |@ref{xterm-color}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	The MSDOS standard colors are fixed (in a console window), so these
	have been used for the names.  But the meaning of color names in X11
	are fixed, so these color settings have been used, to make the
	highlighting settings portable (complicated, isn't it?).  The
	following names are recognized, with the color number used:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コンソールウィンドウ内の MSDOS 標準色は固定されている。そのため、これらの色を名前に使っている。一方、X11 の色名の意味は固定されている。そこでハイライトの設定に可搬性を持たせるため、X11 の色設定が使われている (複雑であるが)。以下の色名を、色番号の代わりに使うことができる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*cterm-colors*
	    NR-16   NR-8    COLOR NAME ~
	    0	    0	    Black
	    1	    4	    DarkBlue
	    2	    2	    DarkGreen
	    3	    6	    DarkCyan
	    4	    1	    DarkRed
	    5	    5	    DarkMagenta
	    6	    3	    Brown, DarkYellow
	    7	    7	    LightGray, LightGrey, Gray, Grey
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{cterm-colors}
@cindex cterm-colors
@multitable @columnfractions .2 .2 .6
@headitem NR-16 @tab NR-8 @tab COLOR NAME
@item 0 @tab 0 @tab Black
@item 1 @tab 4 @tab DarkBlue
@item 2 @tab 2 @tab DarkGreen
@item 3 @tab 6 @tab DarkCyan
@item 4 @tab 1 @tab DarkRed
@item 5 @tab 5 @tab DarkMagenta
@item 6 @tab 3 @tab Brown, DarkYellow
@item 7 @tab 7 @tab LightGray, LightGrey, Gray, Grey
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	    8	    0*	    DarkGray, DarkGrey
	    9	    4*	    Blue, LightBlue
	    10	    2*	    Green, LightGreen
	    11	    6*	    Cyan, LightCyan
	    12	    1*	    Red, LightRed
	    13	    5*	    Magenta, LightMagenta
	    14	    3*	    Yellow, LightYellow
	    15	    7*	    White
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 8 @tab 0* @tab DarkGray, DarkGrey
@item 9 @tab 4* @tab Blue, LightBlue
@item 10 @tab 2* @tab Green, LightGreen
@item 11 @tab 6* @tab Cyan, LightCyan
@item 12 @tab 1* @tab Red, LightRed
@item 13 @tab 5* @tab Magenta, LightMagenta
@item 14 @tab 3* @tab Yellow, LightYellow
@item 15 @tab 7* @tab White
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	The number under "NR-16" is used for 16-color terminals ('t_Co'
	greater than or equal to 16).  The number under "NR-8" is used for
	8-color terminals ('t_Co' less than 16).  The '*' indicates that the
	bold attribute is set for ctermfg.  In many 8-color terminals (e.g.,
	"linux"), this causes the bright colors to appear.  This doesn't work
	for background colors!	Without the '*' the bold attribute is removed.
	If you want to set the bold attribute in a different way, put a
	"cterm=" argument AFTER the "ctermfg=" or "ctermbg=" argument.	Or use
	a number instead of a color name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"NR-16" の下の番号は 16 色ターミナル ('t_Co' が 16 以上のもの) 用である。"NR-8" の下の番号は 8 色ターミナル ('t_Co' が 16 未満のもの) 用である。'*' は ctermfg に bold 属性がセットされることを意味している。"linux" など多くの8色ターミナルでは明るい色になる。ただし背景色には適用されない。'*' がないものは bold 属性なしになる。他の方法で bold 属性をつけたいなら引数 "cterm=" を "ctermfg=" や "ctermbg=" の後に書くこと。または色名の代わりに番号を使うこと。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	The case of the color names is ignored.
	Note that for 16 color ansi style terminals (including xterms), the
	numbers in the NR-8 column is used.  Here '*' means 'add 8' so that Blue
	is 12, DarkGray is 8 etc.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
色名の大文字・小文字は無視される。16 色 ansi スタイルターミナル (xterm を含む) では NR-8 の列の番号が使われることに注意。ここで '*' は 'add 8' という意味になる。つまり Blue が 12 に、DarkGray が 8 になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Note that for some color terminals these names may result in the wrong
	colors!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
カラーターミナルによっては、色名を使うと間違った色で表示される場合もあることに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	You can also use "NONE" to remove the color.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
色をなしにするのに "NONE" も使える。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:hi-normal-cterm*
	When setting the "ctermfg" or "ctermbg" colors for the Normal group,
	these will become the colors used for the non-highlighted text.
	Example: >
		:highlight Normal ctermfg=grey ctermbg=darkblue
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:hi-normal-cterm}
@cindex :hi-normal-cterm
Normal グループに対して "ctermfg" や "ctermbg" を設定すると、これらはハイライトされないテキストに対する色になる。例:
@example
:highlight Normal ctermfg=grey ctermbg=darkblue
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	When setting the "ctermbg" color for the Normal group, the
	'background' option will be adjusted automatically, under the
	condition that the color is recognized and 'background' was not set
	explicitly.  This causes the highlight groups that depend on
	'background' to change!  This means you should set the colors for
	Normal first, before setting other colors.
	When a colorscheme is being used, changing 'background' causes it to
	be reloaded, which may reset all colors (including Normal).  First
	delete the "g:colors_name" variable when you don't want this.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Normal グループに対して "ctermbg" を設定すると、その色が認識されてかつ '@option{background}' が明示的に設定されていないという条件の下で、オプション '@option{background}' が自動的に調整される。これによって '@option{background}' に依存するハイライトグループが変更される！そのため、まず Normal に対する色を設定し、それから他の色を設定するべきである。

カラースキーム使用時に '@option{background}' を変更するとカラースキームが再読み込みされる。そして Normal を含む全ての色がリセットされる。これが嫌なら最初に変数 "g:colors_name" を削除すること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	When you have set "ctermfg" or "ctermbg" for the Normal group, Vim
	needs to reset the color when exiting.	This is done with the "op"
	termcap entry |t_op|.  If this doesn't work correctly, try setting the
	't_op' option in your .vimrc.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Normal グループの "ctermfg" や "ctermbg" を変更した場合、Vim 終了時にその色をリセットする必要がある。これは termcap エントリ "op" |@ref{t_op}| を使ってなされる。リセットがうまくいかない場合は @file{.vimrc} 中で 't_op' を設定してみること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*E419* *E420*
	When Vim knows the normal foreground and background colors, "fg" and
	"bg" can be used as color names.  This only works after setting the
	colors for the Normal group and for the MS-DOS console.  Example, for
	reverse video: >
	    :highlight Visual ctermfg=bg ctermbg=fg
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E419}
@anchor{E420}
@erindex E419
@erindex E420
Vim が通常の文字色と背景色を知っている場合、色名として "fg" と "bg" を使用できる。これは Normal グループの色と MS-DOS コンソールの色を設定しないと使えない。例えば反転表示をするには:
@example
:highlight Visual ctermfg=bg ctermbg=fg
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	Note that the colors are used that are valid at the moment this
	command are given.  If the Normal group colors are changed later, the
	"fg" and "bg" colors will not be adjusted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
このコマンドを実行した時点で有効な色が使われることに注意。この後で Normal グループを変更しても "fg" と "bg" は調整されない。
@end quotation
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
3. highlight arguments for the GUI
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex highlight コマンドの引数 (GUI 用)
@unnumberedsubsec 3. highlight コマンドの引数 (GUI 用)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
gui={attr-list}						*highlight-gui*
	These give the attributes to use in the GUI mode.
	See |attr-list| for a description.
	Note that "bold" can be used here and by using a bold font.  They
	have the same effect.
	Note that the attributes are ignored for the "Normal" group.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{highlight-gui}
@cindex highlight-gui
@item gui=@{attr-list@}
これらは GUI モードで使われる属性を設定する。説明は |@ref{attr-list}| を参照。
@quotation
ここで "bold" を設定しても太字のフォントを使ってもよい。どちらも同じ効果を持つ。
@end quotation
@quotation
"Normal" グループに対する属性は無視される。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
font={font-name}					*highlight-font*
	font-name is the name of a font, as it is used on the system Vim
	runs on.  For X11 this is a complicated name, for example: >
   font=-misc-fixed-bold-r-normal--14-130-75-75-c-70-iso8859-1
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{highlight-font}
@cindex highlight-font
@item font=@{font-name@}
font-name は Vim を実行しているシステム上で使われるフォント名である。X11 ではこれは複雑な名前になる。例えば:
@example
font=-misc-fixed-bold-r-normal--14-130-75-75-c-70-iso8859-1
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	The font-name "NONE" can be used to revert to the default font.
	When setting the font for the "Normal" group, this becomes the default
	font (until the 'guifont' option is changed; the last one set is
	used).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
フォント名 "NONE" を使うとデフォルトのフォントに戻る。"Normal" グループに対してフォントを設定すると、これがデフォルトフォントになる (オプション '@option{guifont}' が変更されるまでは; 最後に設定したものが使われる)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	The following only works with Motif and Athena, not with other GUIs:
	When setting the font for the "Menu" group, the menus will be changed.
	When setting the font for the "Tooltip" group, the tooltips will be
	changed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下のものは Motif と Athena 上でのみ動作し、他の GUI 上では利用できない: "Menu" グループに対してフォントを設定すると、メニューが変更される。"Tooltip" グループに対してフォントを設定すると、ツールチップが変更される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	All fonts used, except for Menu and Tooltip, should be of the same
	character size as the default font!  Otherwise redrawing problems will
	occur.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Menu 用と Tooltip 用を除く全てのフォントのサイズがデフォルトフォントのサイズと同じでなければならない。そうでないと再描画の際に問題が発生する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	To use a font name with an embedded space or other special character,
	put it in single quotes.  The single quote cannot be used then.
	Example: >
	    :hi comment font='Monospace 10'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
名前にスペースや特殊文字を含むフォントを使う場合、名前をシングルクォートでくくる。このためシングルクォートを名前に含めることはできない。

例:
@example
:hi comment font='Monospace 10'
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
guifg={color-name}					*highlight-guifg*
guibg={color-name}					*highlight-guibg*
guisp={color-name}					*highlight-guisp*
	These give the foreground (guifg), background (guibg) and special
	(guisp) color to use in the GUI.  "guisp" is used for undercurl and
	strikethrough.
	There are a few special names:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{highlight-guifg}
@anchor{highlight-guibg}
@anchor{highlight-guisp}
@cindex highlight-guifg
@cindex highlight-guibg
@cindex highlight-guisp
@item guifg=@{color-name@} または
@itemx guibg=@{color-name@} または
@itemx guisp=@{color-name@}
guifg は文字色、guibg は背景色、guisp は波線および取り消し線の色を指定する。これらは GUI で使用される。

いくつか特別な名前がある:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		NONE		no color (transparent)
		bg		use normal background color
		background	use normal background color
		fg		use normal foreground color
		foreground	use normal foreground color
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item NONE @tab no color (透明)
@item bg @tab 通常の背景色を使う
@item background @tab 通常の背景色を使う
@item fg @tab 通常の文字色を使う
@item foreground @tab 通常の文字色を使う
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	To use a color name with an embedded space or other special character,
	put it in single quotes.  The single quote cannot be used then.
	Example: >
	    :hi comment guifg='salmon pink'
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
名前にスペースや特殊文字を含む色を使う場合、名前をシングルクォートでくくる。このためシングルクォートを名前に含めることはできない。

例:
@example
:hi comment guifg='salmon pink'
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*gui-colors*
	Suggested color names (these are available on most systems):
	    Red		LightRed	DarkRed
	    Green	LightGreen	DarkGreen	SeaGreen
	    Blue	LightBlue	DarkBlue	SlateBlue
	    Cyan	LightCyan	DarkCyan
	    Magenta	LightMagenta	DarkMagenta
	    Yellow	LightYellow	Brown		DarkYellow
	    Gray	LightGray	DarkGray
	    Black	White
	    Orange	Purple		Violet
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gui-colors}
@cindex gui-colors
推奨されている色名 (これらはほとんどのシステムで利用可能である)
@multitable @columnfractions .25 .25 .25 .25
@item Red @tab LightRed @tab DarkRed @tab
@item Green @tab LightGreen @tab DarkGreen @tab SeaGreen
@item Blue @tab LightBlue @tab DarkBlue @tab SlateBlue
@item Cyan @tab LightCyan @tab DarkCyan @tab
@item Magenta @tab LightMagenta	DarkMagenta @tab
@item Yellow @tab LightYellow @tab Brown @tab DarkYellow
@item Gray @tab LightGray @tab DarkGray @tab
@item Black @tab White @tab @tab
@item Orange @tab Purple @tab Violet
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	In the Win32 and MacVim GUI versions, additional system colors are
	available.  See |win32-colors| and |macvim-colors|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Win32 と MacVim GUI バージョンでは他にもシステムカラーが利用できる。|@ref{win32-colors}| と |@ref{macvim-colors}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	You can also specify a color by its Red, Green and Blue values.
	The format is "#rrggbb", where
		"rr"	is the Red value
		"gg"	is the Green value
		"bb"	is the Blue value
	All values are hexadecimal, range from "00" to "ff".  Examples: >
  :highlight Comment guifg=#11f0c3 guibg=#ff00ff
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
RGB値によって色を指定することもできる。

フォーマットは "#rrggbb"、ここで
@multitable @columnfractions .5 .5
@item "rr" @tab Red 値
@item "gg" @tab Green 値
@item "bb" @tab Blue 値
@end multitable
これらの値は 16 進であり、範囲は "00" から "ff"。例:
@example
:highlight Comment guifg=#11f0c3 guibg=#ff00ff
@end example
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*highlight-groups* *highlight-default*
These are the default highlighting groups.  These groups are used by the
'highlight' option default.  Note that the highlighting depends on the value
of 'background'.  You can see the current settings with the ":highlight"
command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{highlight-groups}
@anchor{highlight-default}
@cindex highlight-groups
@cindex highlight-default
以下はデフォルトのハイライトグループである。これらのグループはデフォルトでオプション '@option{highlight}' によって使われる。ただしハイライトは '@option{background}' の値に依存することに注意。"@command{:highlight}" コマンドで現在の設定を知ることができる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-ColorColumn*
ColorColumn	used for the columns set with 'colorcolumn'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{hl-ColorColumn}
@cindex hl-ColorColumn
@item ColorColumn
'@option{colorcolumn}' で設定された列の表示に使われる
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-Conceal*
Conceal		placeholder characters substituted for concealed
		text (see 'conceallevel')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-Conceal}
@cindex hl-Conceal
@item Conceal
Conceal されたテキストの代わりに表示される代替文字の表示に使われる ('@option{conceallevel}' 参照)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-Cursor*
Cursor		the character under the cursor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-Cursor}
@cindex hl-Cursor
@item Cursor
カーソル下の文字
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-CursorIM*
CursorIM	like Cursor, but used when in IME mode |CursorIM|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-CursorIM}
@cindex hl-CursorIM
@item CursorIM
Cursor と同じだが、IME モードにいるとき使われる |@ref{CursorIM}|。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-CursorColumn*
CursorColumn	the screen column that the cursor is in when 'cursorcolumn' is
		set
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-CursorColumn}
@cindex hl-CursorColumn
@item CursorColumn
'@option{cursorcolumn}' がオンになっているときのカーソルがある画面上の桁
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-CursorLine*
CursorLine	the screen line that the cursor is in when 'cursorline' is
		set
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-CursorLine}
@cindex hl-CursorLine
@item CursorLine
'@option{cursorline}' がオンになっているときのカーソルがある画面上の行
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-Directory*
Directory	directory names (and other special names in listings)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-Directory}
@cindex hl-Directory
@item Directory
ディレクトリ名 (とリストにある特別な名前)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-DiffAdd*
DiffAdd		diff mode: Added line |diff.txt|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-DiffAdd}
@cindex hl-DiffAdd
@item DiffAdd
差分モード: 追加された行 |@ref{diff.txt}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-DiffChange*
DiffChange	diff mode: Changed line |diff.txt|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-DiffChange}
@cindex hl-DiffChange
@item DiffChange
差分モード: 変更された行 |@ref{diff.txt}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-DiffDelete*
DiffDelete	diff mode: Deleted line |diff.txt|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-DiffDelete}
@cindex hl-DiffDelete
@item DiffDelete
差分モード: 削除された行 |@ref{diff.txt}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-DiffText*
DiffText	diff mode: Changed text within a changed line |diff.txt|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-DiffText}
@cindex hl-DiffText
@item DiffText
差分モード: 変更された行中の変更されたテキスト |@ref{diff.txt}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-EndOfBuffer*
EndOfBuffer	filler lines (~) after the last line in the buffer.
		By default, this is highlighted like |hl-NonText|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-EndOfBuffer}
@cindex hl-EndOfBuffer
@item EndOfBuffer
バッファ中で最終行以降の領域を埋めるための行 (~)。標準では、|@ref{hl-NonText}| のようにハイライトされる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-ErrorMsg*
ErrorMsg	error messages on the command line
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-ErrorMsg}
@cindex hl-ErrorMsg
@item ErrorMsg
コマンドラインに現れるエラーメッセージ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-VertSplit*
VertSplit	the column separating vertically split windows
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-VertSplit}
@cindex hl-VertSplit
@item VertSplit
垂直分割したウィンドウの区切りとなる桁
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-Folded*
Folded		line used for closed folds
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-Folded}
@cindex hl-Folded
@item Folded
閉じた折り畳みの行
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-FoldColumn*
FoldColumn	'foldcolumn'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-FoldColumn}
@cindex hl-FoldColumn
@item FoldColumn
'@option{foldcolumn}'
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-SignColumn*
SignColumn	column where |signs| are displayed
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-SignColumn}
@cindex hl-SignColumn
@item SignColumn
目印 |@ref{signs}| が表示される行。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-IncSearch*
IncSearch	'incsearch' highlighting; also used for the text replaced with
		":s///c"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-IncSearch}
@cindex hl-IncSearch
@item IncSearch
'@option{incsearch}' のハイライト; ":s///c" で置換されたテキストにも使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-LineNr*
LineNr		Line number for ":number" and ":#" commands, and when 'number'
		or 'relativenumber' option is set.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-LineNr}
@cindex hl-LineNr
@item LineNr
"@command{:number}" と "@command{:#}" コマンドの行番号。'@option{number}' オプションか '@option{relativenumber}' オプションが設定されているときにはその表示にも使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-CursorLineNr*
CursorLineNr	Like LineNr when 'cursorline' or 'relativenumber' is set for
		the cursor line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-CursorLineNr}
@cindex hl-CursorLineNr
@item CursorLineNr
LineNr と同じだが '@option{cursorline}' か '@option{relativenumber}' が設定されているときに現在行に使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-MatchParen*
MatchParen	The character under the cursor or just before it, if it
		is a paired bracket, and its match. |pi_paren.txt|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-MatchParen}
@cindex hl-MatchParen
@item MatchParen
カーソル下の文字、または直後の文字が括弧であるとき、その文字と対応する括弧に使われる。|@ref{pi_paren.txt}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*hl-ModeMsg*
ModeMsg		'showmode' message (e.g., "-- INSERT --")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-ModeMsg}
@cindex hl-ModeMsg
@item ModeMsg
'@option{showmode}' のメッセージ (例. "@samp{-- INSERT --}")
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-MoreMsg*
MoreMsg		|more-prompt|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-MoreMsg}
@cindex hl-MoreMsg
@item MoreMsg
|@ref{more-prompt}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-NonText*
NonText		'@' at the end of the window, characters from 'showbreak'
		and other characters that do not really exist in the text
		(e.g., ">" displayed when a double-wide character doesn't
		fit at the end of the line).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-NonText}
@cindex hl-NonText
@item NonText
ウィンドウの端の '@@' と '@option{showbreak}' で設定された文字など、実際のテキストには存在しない文字 (例. 全角文字が行末に収まらないとき ">" が表示される)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-Normal*
Normal		normal text
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-Normal}
@cindex hl-Normal
@item Normal
通常のテキスト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-Pmenu*
Pmenu		Popup menu: normal item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-Pmenu}
@cindex hl-Pmenu
@item Pmenu
ポップアップメニュー: 通常の項目。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-PmenuSel*
PmenuSel	Popup menu: selected item.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-PmenuSel}
@cindex hl-PmenuSel
@item PmenuSel
ポップアップメニュー: 選択されている項目。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-PmenuSbar*
PmenuSbar	Popup menu: scrollbar.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-PmenuSbar}
@cindex hl-PmenuSbar
@item PmenuSbar
ポップアップメニュー: スクロールバー。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-PmenuThumb*
PmenuThumb	Popup menu: Thumb of the scrollbar.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-PmenuThumb}
@cindex hl-PmenuThumb
@item PmenuThumb
ポップアップメニュー: スクロールバーのつまみ部分。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-Question*
Question	|hit-enter| prompt and yes/no questions
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-Question}
@cindex hl-Question
@item Question
ヒットエンタープロンプト |@ref{hit-enter}| と yes/no クエスチョン
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-QuickFixLine*
QuickFixLine	Current |quickfix| item in the quickfix window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-QuickFixLine}
@cindex hl-QuickFixLine
@item QuickFixLine
quickfix ウィンドウ内の現在の |@ref{quickfix}| 項目
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-Search*
Search		Last search pattern highlighting (see 'hlsearch').
		Also used for similar items that need to stand out.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-Search}
@cindex hl-Search
@item Search
最後に検索した語のハイライト ('@option{hlsearch}') を参照。強調されるべき同様の項目にも使用される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-SpecialKey*
SpecialKey	Meta and special keys listed with ":map", also for text used
		to show unprintable characters in the text, 'listchars'.
		Generally: text that is displayed differently from what it
		really is.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-SpecialKey}
@cindex hl-SpecialKey
@item SpecialKey
":map" でリストされるメタキーと特別なキー。テキスト中の unprintable な文字を表示するのにも使われる。一般に: 実際とは異なる文字で表示されるテキスト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-SpellBad*
SpellBad	Word that is not recognized by the spellchecker. |spell|
		This will be combined with the highlighting used otherwise.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-SpellBad}
@cindex hl-SpellBad
@item SpellBad
スペルチェッカに認識されない単語。|@ref{spell}| これは他のハイライトと同時に組み合わせられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-SpellCap*
SpellCap	Word that should start with a capital. |spell|
		This will be combined with the highlighting used otherwise.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-SpellCap}
@cindex hl-SpellCap
@item SpellCap
大文字で始まるべき単語。|@ref{spell}| これは他のハイライトと同時に組み合わせられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-SpellLocal*
SpellLocal	Word that is recognized by the spellchecker as one that is
		used in another region. |spell|
		This will be combined with the highlighting used otherwise.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-SpellLocal}
@cindex hl-SpellLocal
@item SpellLocal
スペルチェッカによって他の地域で使われると判断される単語。|@ref{spell}| これは他のハイライトと同時に組み合わせられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-SpellRare*
SpellRare	Word that is recognized by the spellchecker as one that is
		hardly ever used. |spell|
		This will be combined with the highlighting used otherwise.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-SpellRare}
@cindex hl-SpellRare
@item SpellRare
スペルチェッカによってまず使わないと判断される単語。|@ref{spell}| これは他のハイライトと同時に組み合わせられる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-StatusLine*
StatusLine	status line of current window
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-StatusLine}
@cindex hl-StatusLine
@item StatusLine
ウィンドウのカレントウィンドウのステータスライン
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-StatusLineNC*
StatusLineNC	status lines of not-current windows
		Note: if this is equal to "StatusLine" Vim will use "^^^" in
		the status line of the current window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-StatusLineNC}
@cindex hl-StatusLineNC
@item StatusLineNC
ウィンドウの非カレントウィンドウのステータスライン
@quotation
@strong{Note:} @*
これが "StatusLine" に等しい場合、カレントウィンドウのステータスラインに "^^^" が使われる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-StatusLineTerm*
StatusLineTerm	status line of current window, if it is a |terminal| window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-StatusLineTerm}
@cindex hl-StatusLineTerm
@item StatusLineTerm
もしもそれが |@ref{terminal}| ウィンドウの場合、カレントウィンドウのステータスライン。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-StatusLineTermNC*
StatusLineTermNC   status lines of not-current windows that is a |terminal|
		window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-StatusLineTermNC}
@cindex hl-StatusLineTermNC
@item StatusLineTermNC
|@ref{terminal}| の非カレントウィンドウのステータスライン。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-TabLine*
TabLine		tab pages line, not active tab page label
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-TabLine}
@cindex hl-TabLine
@item TabLine
タブページの行の、アクティブでないタブページのラベル
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-TabLineFill*
TabLineFill	tab pages line, where there are no labels
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-TabLineFill}
@cindex hl-TabLineFill
@item TabLineFill
タブページの行の、ラベルがない部分
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-TabLineSel*
TabLineSel	tab pages line, active tab page label
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-TabLineSel}
@cindex hl-TabLineSel
@item TabLineSel
タブページの行の、アクティブなタブページのラベル
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-Terminal*
Terminal	|terminal| window (see |terminal-size-color|)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-Terminal}
@cindex hl-Terminal
@item Terminal
|@ref{terminal}| ウィンドウ (|@ref{terminal-size-color}| を参照)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-Title*
Title		titles for output from ":set all", ":autocmd" etc.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-Title}
@cindex hl-Title
@item Title
"@command{:set all}"、"@command{:autocmd}" などによる出力のタイトル。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-Visual*
Visual		Visual mode selection
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-Visual}
@cindex hl-Visual
@item Visual
ビジュアルモード選択
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-VisualNOS*
VisualNOS	Visual mode selection when vim is "Not Owning the Selection".
		Only X11 Gui's |gui-x11| and |xterm-clipboard| supports this.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-VisualNOS}
@cindex hl-VisualNOS
@item VisualNOS
vim が "Not Owning the Selection" のときのビジュアルモード選択。これをサポートしているのは X11 GUI |@ref{gui-x11}| と |@ref{xterm-clipboard}| のみ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-WarningMsg*
WarningMsg	warning messages
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-WarningMsg}
@cindex hl-WarningMsg
@item WarningMsg
警告メッセージ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*hl-WildMenu*
WildMenu	current match in 'wildmenu' completion
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-WildMenu}
@cindex hl-WildMenu
@item WildMenu
'@option{wildmenu}' 補完における現在の候補
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*hl-User1* *hl-User1..9* *hl-User9*
The 'statusline' syntax allows the use of 9 different highlights in the
statusline and ruler (via 'rulerformat').  The names are User1 to User9.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-User1}
@anchor{hl-User1..9}
@anchor{hl-User9}
@cindex hl-User1
@cindex hl-User1..9
@cindex hl-User9
'@option{statusline}' 構文によってステータスラインとルーラー ('@option{rulerformat}' によって) 中で 9 個のハイライトが使えるようになっている。その名前は User1 から User9 である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For the GUI you can use the following groups to set the colors for the menu,
scrollbars and tooltips.  They don't have defaults.  This doesn't work for the
Win32 GUI.  Only three highlight arguments have any effect here: font, guibg,
and guifg.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
GUI 使用時には、これらのグループを使ってメニューやスクロールバー、ツールチップの色を設定することができる。これらにデフォルト値はない。これは Win32 では利用できない。ここでは highlight の引数のうち font, guibg, guifg の 3 つだけが効果を持つ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*hl-Menu*
Menu		Current font, background and foreground colors of the menus.
		Also used for the toolbar.
		Applicable highlight arguments: font, guibg, guifg.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{hl-Menu}
@cindex hl-Menu
@item Menu
メニューのフォント、文字、背景。ツールバーにも使われる。使用可能な highlight の引数: font, guibg, guifg.
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		NOTE: For Motif and Athena the font argument actually
		specifies a fontset at all times, no matter if 'guifontset' is
		empty, and as such it is tied to the current |:language| when
		set.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
Motif と Athena では '@option{guifontset}' が空かどうかにかかわらず、常に引数 font で実際のフォントセットを指定する。そしてそれが現在の |@ref{:language}| に結び付けられる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*hl-Scrollbar*
Scrollbar	Current background and foreground of the main window's
		scrollbars.
		Applicable highlight arguments: guibg, guifg.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-Scrollbar}
@cindex hl-Scrollbar
@item Scrollbar
メインウィンドウのスクロールバーの文字と背景。使用可能な highlight の引数: guibg, guifg.
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*hl-Tooltip*
Tooltip		Current font, background and foreground of the tooltips.
		Applicable highlight arguments: font, guibg, guifg.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-Tooltip}
@cindex hl-Tooltip
@item Tooltip
ツールチップのフォント、文字、背景。使用可能な highlight の引数: font, guibg, guifg.
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		NOTE: For Motif and Athena the font argument actually
		specifies a fontset at all times, no matter if 'guifontset' is
		empty, and as such it is tied to the current |:language| when
		set.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
Motif と Athena では '@option{guifontset}' が空かどうかにかかわらず、常に引数 font で実際のフォントセットを指定する。そしてそれが現在の |@ref{:language}| に結び付けられる。
@end quotation
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
13. Linking groups		*:hi-link* *:highlight-link* *E412* *E413*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:hi-link}
@anchor{:highlight-link}
@anchor{E412}
@anchor{E413}
@cindex :hi-link
@cindex :highlight-link
@erindex E412
@erindex E413
@cindex グループのリンク
@section 13. グループのリンク
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you want to use the same highlighting for several syntax groups, you
can do this more easily by linking the groups into one common highlight
group, and give the color attributes only for that group.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
複数の構文グループに対して同じハイライトを適用させるには、両方のグループから 1 つの強調グループにリンクを作り、リンク先に対して色属性を与えると簡単である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To set a link:

    :hi[ghlight][!] [default] link {from-group} {to-group}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リンクを作るには:
@example
:hi[ghlight][!] [default] link @{from-group@} @{to-group@}
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To remove a link:

    :hi[ghlight][!] [default] link {from-group} NONE
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リンクを削除するには:
@example
:hi[ghlight][!] [default] link @{from-group@} NONE
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Notes:							*E414*
- If the {from-group} and/or {to-group} doesn't exist, it is created.  You
  don't get an error message for a non-existing group.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E414}
@erindex E414
@quotation
@strong{Note:}
@itemize
@item @{from-group@} か @{to-group@} のどちらかが存在しない場合、リンクは作成されない。この場合エラーメッセージは表示されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- As soon as you use a ":highlight" command for a linked group, the link is
  removed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item リンクされたグループに対して "@command{:highlight}" を使うと、即座にリンクが削除される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- If there are already highlight settings for the {from-group}, the link is
  not made, unless the '!' is given.  For a ":highlight link" command in a
  sourced file, you don't get an error message.  This can be used to skip
  links for groups that already have settings.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 既に @{from-group@} にハイライト設定がされている場合、'!' をつけないとリンクは作成されない。source されたファイル中の "@command{:highlight link}" コマンドに関して、エラーメッセージは表示されない。そのため既に設定を持つグループに対するリンクがスキップされる。
@end itemize
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*:hi-default* *:highlight-default*
The [default] argument is used for setting the default highlighting for a
group.	If highlighting has already been specified for the group the command
will be ignored.  Also when there is an existing link.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:hi-default}
@anchor{:highlight-default}
@cindex :hi-default
@cindex :highlight-default
引数 [default] によってグループに対するデフォルトのハイライトを設定することができる。そのグループに対して既にハイライトが指定されている場合、このコマンドは無視される。既にリンクが存在する場合も同様。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Using [default] is especially useful to overrule the highlighting of a
specific syntax file.  For example, the C syntax file contains: >
	:highlight default link cComment Comment
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[default] は、そのハイライト設定をあとから上書きさせるために使われる。例えば C 構文ファイルは次の行を含んでいる:
@example
:highlight default link cComment Comment
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
If you like Question highlighting for C comments, put this in your vimrc file: >
	:highlight link cComment Question
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この設定を変更し、C コメントに対して Question のハイライトをつけたい場合、次の行を @file{.vimrc} に加える:
@example
:highlight link cComment Question
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Without the "default" in the C syntax file, the highlighting would be
overruled when the syntax file is loaded.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"default" をつけないと、@file{.vimrc} より C 構文ファイルの方があとに読み込まれるため、@file{.vimrc} の設定を上書きしてしまう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
14. Cleaning up						*:syn-clear* *E391*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syn-clear}
@anchor{E391}
@cindex :syn-clear
@erindex E391
@cindex 構文の消去
@section 14. 構文の消去
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to clear the syntax stuff for the current buffer, you can use this
command: >
  :syntax clear
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カレントバッファに対する構文設定を消去したいときはこのコマンドを使う:
@example
:syntax clear
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This command should be used when you want to switch off syntax highlighting,
or when you want to switch to using another syntax.  It's normally not needed
in a syntax file itself, because syntax is cleared by the autocommands that
load the syntax file.
The command also deletes the "b:current_syntax" variable, since no syntax is
loaded after this command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このコマンドは、構文ハイライトをオフにしたいときや他の構文を適用したいときに使う。通常、これを構文ファイル内で行う必要はない。なぜなら、構文ファイルを読み込む自動コマンドによって構文がクリアされる。
また、このコマンドは変数 "b:current_syntax" を削除する。このコマンドの実行後にはすべての構文がなくなるからである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to disable syntax highlighting for all buffers, you need to remove
the autocommands that load the syntax files: >
  :syntax off
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
全てのバッファに対して構文ハイライトを無効にしたいときは、構文ファイルを読み込む自動コマンドを削除する必要がある:
@example
:syntax off
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
What this command actually does, is executing the command >
  :source $VIMRUNTIME/syntax/nosyntax.vim
See the "nosyntax.vim" file for details.  Note that for this to work
$VIMRUNTIME must be valid.  See |$VIMRUNTIME|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このコマンドが実際に行うことは次のコマンドを実行するのと同じである:
@example
:source $VIMRUNTIME/syntax/nosyntax.vim
@end example
詳細は "@file{nosyntax.vim}" を参照。これが正常に機能するためには @env{$VIMRUNTIME} が正しく設定されている必要がある。|@ref{$VIMRUNTIME}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To clean up specific syntax groups for the current buffer: >
  :syntax clear {group-name} ..
This removes all patterns and keywords for {group-name}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カレントバッファに対する特定の構文グループを消去するには:
@example
:syntax clear @{group-name@} ..
@end example
これは @{group-name@} に対する全てのパターンとキーワードを消去する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To clean up specific syntax group lists for the current buffer: >
  :syntax clear @{grouplist-name} ..
This sets {grouplist-name}'s contents to an empty list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カレントバッファに対する特定の構文グループリストを消去するには:
@example
:syntax clear @@@{grouplist-name@} ..
@end example
これは @{grouplist-name@} の中身を空リストにセットする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:syntax-reset* *:syn-reset*
If you have changed the colors and messed them up, use this command to get the
defaults back: >

  :syntax reset
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syntax-reset}
@anchor{:syn-reset}
@cindex :syntax-reset
@cindex :syn-reset
色を変えたため、色がごちゃごちゃになってしまったときは、次のコマンドを使うとデフォルトに戻る:
@example
:syntax reset
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It is a bit of a wrong name, since it does not reset any syntax items, it only
affects the highlighting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
少々正しくない名前だが、どんなシンタックス項目もリセットせず、ただハイライトのみに影響する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This doesn't change the colors for the 'highlight' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはオプション '@option{highlight}' に対する色は変更しない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that the syntax colors that you set in your vimrc file will also be reset
back to their Vim default.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ユーザーのvimrcファイル中で設定した構文色もVimのデフォルト値に戻ることに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Note that if you are using a color scheme, the colors defined by the color
scheme for syntax highlighting will be lost.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
カラースキームを使っている場合、カラースキームによって定義された色は失われることに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
What this actually does is: >

	let g:syntax_cmd = "reset"
	runtime! syntax/syncolor.vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このコマンドが実際に行うことは次と同じ:
@example
let g:syntax_cmd = "reset"
runtime! syntax/syncolor.vim
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that this uses the 'runtimepath' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ここでオプション '@option{runtimepath}' が使われていることに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*syncolor*
If you want to use different colors for syntax highlighting, you can add a Vim
script file to set these colors.  Put this file in a directory in
'runtimepath' which comes after $VIMRUNTIME, so that your settings overrule
the default colors.  This way these colors will be used after the ":syntax
reset" command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{syncolor}
@cindex syncolor
構文ハイライトに別の色を使うには、色を設定する Vim script を作ればよい。そのファイルを '@option{runtimepath}' 中 ('@option{runtimepath}' は @env{$VIMRUNTIME} を含む) のディレクトリに置くと、その設定がデフォルトの色設定を上書きする。こうして "@command{:syntax reset}" コマンドを実行すると、それらの色が有効になる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For Unix you can use the file ~/.vim/after/syntax/syncolor.vim.  Example: >

	if &background == "light"
	  highlight comment ctermfg=darkgreen guifg=darkgreen
	else
	  highlight comment ctermfg=green guifg=green
	endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Unix では ~/.vim/after/syntax/@file{syncolor.vim} ファイルを使うとよい。例:
@verbatim
if &background == "light"
  highlight comment ctermfg=darkgreen guifg=darkgreen
else
  highlight comment ctermfg=green guifg=green
endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
								*E679*
Do make sure this syncolor.vim script does not use a "syntax on", set the
'background' option or uses a "colorscheme" command, because it results in an
endless loop.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E679}
@erindex E679
この @file{syncolor.vim} が "@command{syntax on}" を実行しないこと、また、オプション '@option{background}' を設定したりコマンド "@command{colorscheme}" を実行しないように確認すること。もしこれらを実行すると無限ループに陥ってしまう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that when a color scheme is used, there might be some confusion whether
your defined colors are to be used or the colors from the scheme.  This
depends on the color scheme file.  See |:colorscheme|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
カラースキームを使用すると、ユーザー定義の色が使われるのか、それともカラースキームで定義された色が使われるのかわからなくなる場合があることに注意。これはカラースキームファイルに依存する。|@ref{:colorscheme}| を参照。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*syntax_cmd*
The "syntax_cmd" variable is set to one of these values when the
syntax/syncolor.vim files are loaded:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{syntax_cmd}
@cindex syntax_cmd
syntax/@file{syncolor.vim} ファイルが読み込まれると、変数 "syntax_cmd" に次の 3 つの値のどれかがセットされる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   "on"		":syntax on" command.  Highlight colors are overruled but
		links are kept
   "enable"	":syntax enable" command.  Only define colors for groups that
		don't have highlighting yet.  Use ":syntax default".
   "reset"	":syntax reset" command or loading a color scheme.  Define all
		the colors.
   "skip"	Don't define colors.  Used to skip the default settings when a
		syncolor.vim file earlier in 'runtimepath' has already set
		them.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item "on" @tab "@command{:syntax on}" コマンド。ハイライト色が上書きされるがリンクはそのまま。
@item "enable" @tab "@command{:syntax enable}" コマンド。まだハイライトが定義されていないグループに対して色を定義するだけ。"@command{:syntax default}" を使うこと。
@item "reset" @tab "@command{:syntax reset}" コマンドまたはカラースキームを読み込む。全ての色を定義する。
@item "skip" @tab 色を定義しない。'@option{runtimepath}' で前にある @file{syncolor.vim} ファイルが既にデフォルト設定をセットしているとき、そのデフォルト設定をスキップするために使われる。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
15. Highlighting tags					*tag-highlight*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tag-highlight}
@cindex tag-highlight
@cindex 関数名などのハイライト
@section 15. 関数名などのハイライト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to highlight all the tags in your file, you can use the following
mappings.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイル中の全てのタグ (関数名など) をハイライトするには、次のマッピングを使うとよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	<F11>	-- Generate tags.vim file, and highlight tags.
	<F12>	-- Just highlight tags based on existing tags.vim file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .99
@item <F11> @samp{--} @file{tags.vim} ファイルを生成し、タグをハイライトする。
@item <F12> @samp{--} 既存の @file{tags.vim} ファイルをもとにハイライトする。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
>
  :map <F11>  :sp tags<CR>:%s/^\([^	:]*:\)\=\([^	]*\).*/syntax keyword Tag \2/<CR>:wq! tags.vim<CR>/^<CR><F12>
  :map <F12>  :so tags.vim<CR>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:map <F11>  :sp tags<CR>:%s/^\([^     :]*:\)\=\([^    ]*\).*/syntax keyword Tag \2/<CR>:wq! tags.vim<CR>/^<CR><F12>
:map <F12>  :so tags.vim<CR>
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
WARNING: The longer the tags file, the slower this will be, and the more
memory Vim will consume.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{WARNING:} @*
@file{tags} ファイルが大きくなるほどこの操作は遅くなり、消費するメモリ量も多くなる。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Only highlighting typedefs, unions and structs can be done too.  For this you
must use Exuberant ctags (found at http://ctags.sf.net).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
typedef, union, struct だけをハイライトすることもできる。そのためには Exuberant ctags (@url{http://ctags.sf.net} で入手可能) が必要である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Put these lines in your Makefile:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下をあなたの Makefile に加える:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
# Make a highlight file for types.  Requires Exuberant ctags and awk
types: types.vim
types.vim: *.[ch]
	ctags --c-kinds=gstu -o- *.[ch] |\
		awk 'BEGIN{printf("syntax keyword Type\t")}\
			{printf("%s ", $$1)}END{print ""}' > $@
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
# 型用のハイライトファイルを作成する。Exuberant ctags と awk が必要
types: types.vim
types.vim: *.[ch]
        ctags --c-kinds=gstu -o- *.[ch] |\
                awk 'BEGIN{printf("syntax keyword Type\t")}\
                        {printf("%s ", $$1)}END{print ""}' > $@
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
And put these lines in your .vimrc: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
そして以下を @file{.vimrc} に加える:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
   " load the types.vim highlighting file, if it exists
   autocmd BufRead,BufNewFile *.[ch] let fname = expand('<afile>:p:h') . '/types.vim'
   autocmd BufRead,BufNewFile *.[ch] if filereadable(fname)
   autocmd BufRead,BufNewFile *.[ch]   exe 'so ' . fname
   autocmd BufRead,BufNewFile *.[ch] endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
" load the types.vim highlighting file, if it exists
autocmd BufRead,BufNewFile *.[ch] let fname = expand('<afile>:p:h') . '/types.vim'
autocmd BufRead,BufNewFile *.[ch] if filereadable(fname)
autocmd BufRead,BufNewFile *.[ch]   exe 'so ' . fname
autocmd BufRead,BufNewFile *.[ch] endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
16. Window-local syntax				*:ownsyntax*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:ownsyntax}
@pindex :ownsyntax
@cindex ウィンドウローカル構文
@section 16. ウィンドウローカル構文
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Normally all windows on a buffer share the same syntax settings. It is
possible, however, to set a particular window on a file to have its own
private syntax setting. A possible example would be to edit LaTeX source
with conventional highlighting in one window, while seeing the same source
highlighted differently (so as to hide control sequences and indicate bold,
italic etc regions) in another. The 'scrollbind' option is useful here.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
通常は同じバッファを表示するすべてのウィンドウは同じ構文設定を共有する。しかしながら、特定のウィンドウだけ別の構文設定を使用することも可能である。例えば 1 つのウィンドウで LaTeX のソースを普通に表示して、別のウィンドウで異なる表示をする (文字を隠したり太字や斜字体で表示したりする) ことが可能である。その場合は '@option{scrollbind}' オプションを使うと便利である。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To set the current window to have the syntax "foo", separately from all other
windows on the buffer: >
   :ownsyntax foo
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
同じバッファを表示しているウィンドウが複数あって、現在のウィンドウの構文だけを "foo" に設定するには次のようにする:
@example
:ownsyntax foo
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<						*w:current_syntax*
This will set the "w:current_syntax" variable to "foo".  The value of
"b:current_syntax" does not change.  This is implemented by saving and
restoring "b:current_syntax", since the syntax files do set
"b:current_syntax".  The value set by the syntax file is assigned to
"w:current_syntax".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{w:current_syntax}
@vindex w:current_syntax
"w:current_syntax" 変数が "foo" に設定される。"b:current_syntax" 変数の値は変更されない。"b:current_syntax" は構文ファイルによって変更されるが、"b:current_syntax" を一時的に保存・復元することで値が変わらないようになっている。構文ファイルによって設定された値が "w:current_syntax" に代入される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Note: This resets the 'spell', 'spellcapcheck' and 'spellfile' options.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
これは '@option{spell}', '@option{spellcapcheck}' と '@option{spellfile}' オプションをリセットする。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Once a window has its own syntax, syntax commands executed from other windows
on the same buffer (including :syntax clear) have no effect. Conversely,
syntax commands executed from that window do not affect other windows on the
same buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ウィンドウの独自構文が定義されると、同じバッファの他のウィンドウで実行された構文コマンド (@command{:syntax clear} を含む) が影響しなくなる。逆に、そのウィンドウで実行された構文コマンドも他のウィンドウには影響しなくなる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A window with its own syntax reverts to normal behavior when another buffer
is loaded into that window or the file is reloaded.
When splitting the window, the new window will use the original syntax.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
独自構文を持ったウィンドウは他のバッファを読み込むかファイルを再読み込みすることで通常の動作に戻る。ウィンドウを分割したときは、新しいウィンドウは元々の構文を使う。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
17. Color xterms				*xterm-color* *color-xterm*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{xterm-color}
@anchor{color-xterm}
@cindex xterm-color
@cindex color-xterm
@cindex カラー対応 xterm
@section 17. カラー対応 xterm
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Most color xterms have only eight colors.  If you don't get colors with the
default setup, it should work with these lines in your .vimrc: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ほとんどのカラー対応 xterm は 8 色しか持たない。デフォルト設定で色がつかない場合は以下を @file{.vimrc}に加えれば正常に色がつくはずである:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   :if &term =~ "xterm"
   :  if has("terminfo")
   :	set t_Co=8
   :	set t_Sf=<Esc>[3%p1%dm
   :	set t_Sb=<Esc>[4%p1%dm
   :  else
   :	set t_Co=8
   :	set t_Sf=<Esc>[3%dm
   :	set t_Sb=<Esc>[4%dm
   :  endif
   :endif
<	[<Esc> is a real escape, type CTRL-V <Esc>]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if &term =~ "xterm"
:  if has("terminfo")
:    set t_Co=8
:    set t_Sf=<Esc>[3%p1%dm
:    set t_Sb=<Esc>[4%p1%dm
:  else
:    set t_Co=8
:    set t_Sf=<Esc>[3%dm
:    set t_Sb=<Esc>[4%dm
:  endif
:endif
@end verbatim
[<Esc> はエスケープ文字そのもの。@kbd{CTRL-V} @key{<Esc>} とタイプして入力する]
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You might want to change the first "if" to match the name of your terminal,
e.g. "dtterm" instead of "xterm".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最初の "if" を自分のターミナル名にマッチするように変更する必要があるかもしれない。例: "xterm" でなく "dtterm"。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: Do these settings BEFORE doing ":syntax on".  Otherwise the colors may
be wrong.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
これらの設定は "@command{:syntax on}" の前に行うこと。そうでないと色がおかしくなってしまう。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*xiterm* *rxvt*
The above settings have been mentioned to work for xiterm and rxvt too.
But for using 16 colors in an rxvt these should work with terminfo: >
	:set t_AB=<Esc>[%?%p1%{8}%<%t25;%p1%{40}%+%e5;%p1%{32}%+%;%dm
	:set t_AF=<Esc>[%?%p1%{8}%<%t22;%p1%{30}%+%e1;%p1%{22}%+%;%dm
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{xiterm}
@anchor{rxvt}
@cindex xiterm
@cindex rxvt
上の設定は xiterm と rxvt でも動作するように注意されている。しかし rxvt で 16 色を使う場合には terminfo を設定しなければならない:
@example
:set t_AB=<Esc>[%?%p1%@{8@}%<%t25;%p1%@{40@}%+%e5;%p1%@{32@}%+%;%dm
:set t_AF=<Esc>[%?%p1%@{8@}%<%t22;%p1%@{30@}%+%e1;%p1%@{22@}%+%;%dm
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*colortest.vim*
To test your color setup, a file has been included in the Vim distribution.
To use it, execute this command: >
   :runtime syntax/colortest.vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{colortest.vim}
@cindex colortest.vim
色設定をテストするためのファイルが Vim ディストリビューションに入っている。これを使うには次のコマンドを実行する:
@example
:runtime syntax/colortest.vim
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Some versions of xterm (and other terminals, like the Linux console) can
output lighter foreground colors, even though the number of colors is defined
at 8.  Therefore Vim sets the "cterm=bold" attribute for light foreground
colors, when 't_Co' is 8.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
xterm のあるバージョン (と linux コンソールのようなターミナル) は、たとえ色数が 8 に定義されていても、より明るい文字色を出力することができる。そのため 't_Co' が 8 のとき、Vim は明るい文字色に対して "cterm=bold" 属性をセットする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*xfree-xterm*
To get 16 colors or more, get the newest xterm version (which should be
included with XFree86 3.3 and later).  You can also find the latest version
at: >
	http://invisible-island.net/xterm/xterm.html
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{xfree-xterm}
@cindex xfree-xterm
16 色以上を使うには xterm の最新バージョンを入手すること (XFree86 3.3 以降に含まれているはずである)。また、以下の場所でも最新バージョンを入手できる:

@url{http://invisible-island.net/xterm/xterm.html}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Here is a good way to configure it.  This uses 88 colors and enables the
termcap-query feature, which allows Vim to ask the xterm how many colors it
supports. >
	./configure --disable-bold-color --enable-88-color --enable-tcap-query
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次にそれを configure するよい方法を示す。これは 88 色を使い、termcap-query 機能を有効化する。これによって Vim が xterm に何色をサポートしているか問い合わせることができるようになる
@example
./configure --disable-bold-color --enable-88-color --enable-tcap-query
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
If you only get 8 colors, check the xterm compilation settings.
(Also see |UTF8-xterm| for using this xterm with UTF-8 character encoding).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もし 8 色しか使えなかったら xterm のコンパイル設定を確認すること。

(この xterm を UTF-8 エンコーディングで使う場合には |@ref{UTF8-xterm}| も参照)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This xterm should work with these lines in your .vimrc (for 16 colors): >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下を @file{.vimrc} に加えるとこの xterm で動くはずである (16 色用):
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   :if has("terminfo")
   :  set t_Co=16
   :  set t_AB=<Esc>[%?%p1%{8}%<%t%p1%{40}%+%e%p1%{92}%+%;%dm
   :  set t_AF=<Esc>[%?%p1%{8}%<%t%p1%{30}%+%e%p1%{82}%+%;%dm
   :else
   :  set t_Co=16
   :  set t_Sf=<Esc>[3%dm
   :  set t_Sb=<Esc>[4%dm
   :endif
<	[<Esc> is a real escape, type CTRL-V <Esc>]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if has("terminfo")
:  set t_Co=16
:  set t_AB=<Esc>[%?%p1%@{8@}%<%t%p1%@{40@}%+%e%p1%@{92@}%+%;%dm
:  set t_AF=<Esc>[%?%p1%@{8@}%<%t%p1%@{30@}%+%e%p1%@{82@}%+%;%dm
:else
:  set t_Co=16
:  set t_Sf=<Esc>[3%dm
:  set t_Sb=<Esc>[4%dm
:endif
@end verbatim
[<Esc> はエスケープ文字そのもの。@kbd{CTRL-V} @key{<Esc>} とタイプして入力する]
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Without |+terminfo|, Vim will recognize these settings, and automatically
translate cterm colors of 8 and above to "<Esc>[9%dm" and "<Esc>[10%dm".
Colors above 16 are also translated automatically.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{+terminfo}| なしでは Vim はこれらの設定を認識し、自動的に cterm の 8 色と上の設定を "<Esc>[9%dm" と "<Esc>[10%dm" に変換する。16 色以上も自動的に変換される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For 256 colors this has been reported to work: >

   :set t_AB=<Esc>[48;5;%dm
   :set t_AF=<Esc>[38;5;%dm
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下の設定が256色用にうまくいくと報告されている:
@example
:set t_AB=<Esc>[48;5;%dm
:set t_AF=<Esc>[38;5;%dm
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Or just set the TERM environment variable to "xterm-color" or "xterm-16color"
and try if that works.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
または単に @env{TERM} 環境変数を "@var{xterm-color}" または "@var{xterm-16color}" にセットし、うまくいくか試してみるとよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You probably want to use these X resources (in your ~/.Xdefaults file):
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下の X resourcesを(~/@file{.Xdefaults} ファイルで) 使いたいかもしれない:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	XTerm*color0:			#000000
	XTerm*color1:			#c00000
	XTerm*color2:			#008000
	XTerm*color3:			#808000
	XTerm*color4:			#0000c0
	XTerm*color5:			#c000c0
	XTerm*color6:			#008080
	XTerm*color7:			#c0c0c0
	XTerm*color8:			#808080
	XTerm*color9:			#ff6060
	XTerm*color10:			#00ff00
	XTerm*color11:			#ffff00
	XTerm*color12:			#8080ff
	XTerm*color13:			#ff40ff
	XTerm*color14:			#00ffff
	XTerm*color15:			#ffffff
	Xterm*cursorColor:		Black
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
XTerm*color0:                   #000000
XTerm*color1:                   #c00000
XTerm*color2:                   #008000
XTerm*color3:                   #808000
XTerm*color4:                   #0000c0
XTerm*color5:                   #c000c0
XTerm*color6:                   #008080
XTerm*color7:                   #c0c0c0
XTerm*color8:                   #808080
XTerm*color9:                   #ff6060
XTerm*color10:                  #00ff00
XTerm*color11:                  #ffff00
XTerm*color12:                  #8080ff
XTerm*color13:                  #ff40ff
XTerm*color14:                  #00ffff
XTerm*color15:                  #ffffff
Xterm*cursorColor:              Black
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
[Note: The cursorColor is required to work around a bug, which changes the
cursor color to the color of the last drawn text.  This has been fixed by a
newer version of xterm, but not everybody is using it yet.]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
cursorColor にはバグがある。カーソルの色が最後に描画されたテキストの色になってしまうというものである。これは xterm の新しいバージョンを使うと解決するが、まだ全ての人がそれを使っているわけではない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To get these right away, reload the .Xdefaults file to the X Option database
Manager (you only need to do this when you just changed the .Xdefaults file): >
  xrdb -merge ~/.Xdefaults
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらを即座に更新するには @file{.Xdefaults} ファイルをXオプションデータベースマネージャーに再読み込みさせる (@file{.Xdefaults} を変更したときはこれを行う必要がある):
@example
xrdb -merge ~/.Xdefaults
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*xterm-blink* *xterm-blinking-cursor*
To make the cursor blink in an xterm, see tools/blink.c.  Or use Thomas
Dickey's xterm above patchlevel 107 (see above for where to get it), with
these resources:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{xterm-blink}
@anchor{xterm-blinking-cursor}
@cindex xterm-blink
@cindex xterm-blinking-cursor
xterm でカーソルを点滅させるには tools/@file{blink.c} を見ること。または Thomas Dickey の xterm のパッチレベル 107 以上を使い (入手場所は上を参照)、以下のリソースを設定する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	XTerm*cursorBlink:	on
	XTerm*cursorOnTime:	400
	XTerm*cursorOffTime:	250
	XTerm*cursorColor:	White
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
XTerm*cursorBlink:      on
XTerm*cursorOnTime:     400
XTerm*cursorOffTime:    250
XTerm*cursorColor:      White
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*hpterm-color*
These settings work (more or less) for an hpterm, which only supports 8
foreground colors: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hpterm-color}
@cindex hpterm-color
次の設定は hpterm で (大体) うまく機能する。文字色は 8 色だけサポートしている:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   :if has("terminfo")
   :  set t_Co=8
   :  set t_Sf=<Esc>[&v%p1%dS
   :  set t_Sb=<Esc>[&v7S
   :else
   :  set t_Co=8
   :  set t_Sf=<Esc>[&v%dS
   :  set t_Sb=<Esc>[&v7S
   :endif
<	[<Esc> is a real escape, type CTRL-V <Esc>]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:if has("terminfo")
:  set t_Co=8
:  set t_Sf=<Esc>[&v%p1%dS
:  set t_Sb=<Esc>[&v7S
:else
:  set t_Co=8
:  set t_Sf=<Esc>[&v%dS
:  set t_Sb=<Esc>[&v7S
:endif
@end verbatim
[<Esc> はエスケープ文字そのもの。@kbd{CTRL-V} @key{<Esc>} とタイプして入力する]
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*Eterm* *enlightened-terminal*
These settings have been reported to work for the Enlightened terminal
emulator, or Eterm.  They might work for all xterm-like terminals that use the
bold attribute to get bright colors.  Add an ":if" like above when needed. >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Eterm}
@anchor{enlightened-terminal}
@cindex Eterm
@cindex enlightened-terminal
次の設定が Enlightened ターミナルエミュレータまたは Eterm で機能すると報告されている。また、明るい色を表示するのに bold 属性を使う xterm ライクターミナル全てで機能すると思われる。必要なら前述のように ":if" をつけること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
       :set t_Co=16
       :set t_AF=^[[%?%p1%{8}%<%t3%p1%d%e%p1%{22}%+%d;1%;m
       :set t_AB=^[[%?%p1%{8}%<%t4%p1%d%e%p1%{32}%+%d;1%;m
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
:set t_Co=16
:set t_AF=^[[%?%p1%@{8@}%<%t3%p1%d%e%p1%@{22@}%+%d;1%;m
:set t_AB=^[[%?%p1%@{8@}%<%t4%p1%d%e%p1%@{32@}%+%d;1%;m
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*TTpro-telnet*
These settings should work for TTpro telnet.  Tera Term Pro is a freeware /
open-source program for MS-Windows. >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{TTpro-telnet}
@cindex TTpro-telnet
次の設定が TTpro telnet 用にうまくいく。Tera Term Pro は MS-Windows 用のフリーウェア/オープンソースプログラムである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	set t_Co=16
	set t_AB=^[[%?%p1%{8}%<%t%p1%{40}%+%e%p1%{32}%+5;%;%dm
	set t_AF=^[[%?%p1%{8}%<%t%p1%{30}%+%e%p1%{22}%+1;%;%dm
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@example
set t_Co=16
set t_AB=^[[%?%p1%@{8@}%<%t%p1%@{40@}%+%e%p1%@{32@}%+5;%;%dm
set t_AF=^[[%?%p1%@{8@}%<%t%p1%@{30@}%+%e%p1%@{22@}%+1;%;%dm
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Also make sure TTpro's Setup / Window / Full Color is enabled, and make sure
that Setup / Font / Enable Bold is NOT enabled.
(info provided by John Love-Jensen <eljay@Adobe.COM>)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
また、TTpro の Setup→Window→Full Color が有効になっていることと、Setup→Font→Enable Bold が無効になっていることを確認すること。

(この情報は John Love-Jensen <eljay@@Adobe.COM> によって提供された)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
==============================================================================
18. When syntax is slow						*:syntime*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:syntime}
@pindex :syntime
@cindex シンタックスが遅い時には
@section 18. シンタックスが遅い時には
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This is aimed at authors of a syntax file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この章はシンタックスファイルを作る人向けである。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If your syntax causes redrawing to be slow, here are a few hints on making it
faster.  To see slowness switch on some features that usually interfere, such
as 'relativenumber' and |folding|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もしあなたの作ったシンタックスにより再描画が遅くなってしまったら、ここに書いた方法でそれを速くできるかもしれない。|@ref{folding}| や '@option{relativenumber}' といった機能を有効化すると、それらが干渉して遅くなる場合もある。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: this is only available when compiled with the |+profile| feature.
You many need to build Vim with "huge" features.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
|@ref{+profile}| 機能付きでコンパイルされた時のみ利用可能である。"huge" 機能付きで Vimをビルドする必要があるかもしれない。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To find out what patterns are consuming most time, get an overview with this
sequence: >
	:syntime on
	[ redraw the text at least once with CTRL-L ]
	:syntime report
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
時間のかかっているシンタックスパターンを発見するために、以下の様な手順で概要を得られる:
@example
:syntime on
[ @kbd{CTRL-L} で最低でも一度は再描画を実行する ]
:syntime report
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This will display a list of syntax patterns that were used, sorted by the time
it took to match them against the text.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これにより利用されたシンタックスパターンが、マッチにかかった時間の多い順にソートして表示される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:syntime on		Start measuring syntax times.  This will add some
			overhead to compute the time spent on syntax pattern
			matching.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item :syntime on
シンタックスにかかる時間の測定を開始する。測定をするにはシンタックスパターンのマッチに多少のオーバーヘッドが発生する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:syntime off		Stop measuring syntax times.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :syntime off
シンタックスの計測を終了する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:syntime clear		Set all the counters to zero, restart measuring.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :syntime clear
全部のカウンタを 0 にし、計測をやり直す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:syntime report		Show the syntax items used since ":syntime on" in the
			current window.  Use a wider display to see more of
			the output.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :syntime report
現在のウィンドウで "@command{:syntime on}" してから使用されたシンタックス要素を表示する。出力される内容をちゃんと読むには幅の広いディスプレイを使ったほうが良い。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			The list is sorted by total time. The columns are:
			TOTAL		Total time in seconds spent on
					matching this pattern.
			COUNT		Number of times the pattern was used.
			MATCH		Number of times the pattern actually
					matched
			SLOWEST		The longest time for one try.
			AVERAGE		The average time for one try.
			NAME		Name of the syntax item.  Note that
					this is not unique.
			PATTERN		The pattern being used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
リストは総時間 (TOTAL) でソートされている。リストには以下のカラムからなる:
@multitable @columnfractions .3 .7
@item TOTAL @tab パターンのマッチにかかった総時間
@item COUNT @tab パターンが使われた回数
@item MATCH @tab パターンが実際にマッチした回数
@item SLOWEST @tab マッチ 1 回あたりの最長時間
@item AVERAGE @tab マッチ 1 回あたりの平均時間
@item NAME @tab シンタックス要素の名前。
@quotation
@strong{Note:} @*
一意な名前ではないことに注意。
@end quotation
@item PATTERN @tab 使用されたパターン
@end multitable
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Pattern matching gets slow when it has to try many alternatives.  Try to
include as much literal text as possible to reduce the number of ways a
pattern does NOT match.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
パターンマッチングは多くの可能性を試さなければならないときに遅くなる。パターンにできる限り多くのリテラルテキストを含むことで、パターンが無駄にマッチする可能性を減らすよう試してみると良い。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When using the "\@<=" and "\@<!" items, add a maximum size to avoid trying at
all positions in the current and previous line.  For example, if the item is
literal text specify the size of that text (in bytes):
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"\@@<=" や "\@@<!" 要素を使用する時は、マッチする最大サイズを指定すると現在以降の行の全部の位置でパターンを試すことを避けられる。たとえば要素のマッチするものがリテラルテキストならば、そのテキストのサイズをバイト数で指定すると良い。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
"<\@<=span"	Matches "span" in "<span".  This tries matching with "<" in
		many places.
"<\@1<=span"	Matches the same, but only tries one byte before "span".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item "<\@@<=span" @tab "<span" 中の "span" にマッチする。これは "<" があるかどうか多くの場所でマッチを試みる。(ゆえに遅くなりやすい)
@item "<\@@1<=span" @tab 同じものにマッチするが、"span" の前の 1 バイトだけをチェックする。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
 vim:tw=78:sw=4:ts=8:ft=help:norl:
@end ifset
