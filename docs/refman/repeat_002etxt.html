<!DOCTYPE html>
<html lang="ja">
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>

<title>repeat.txt (Vim Reference Manual)</title>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<meta name="description" content="repeat.txt (Vim Reference Manual)">
<meta name="keywords" content="repeat.txt (Vim Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<link href="Mu-Ci-.html" rel="start" title="目次">
<link href="Indexes-CP.html" rel="index" title="Indexes CP">
<link href="Mu-Ci-.html" rel="up" title="目次">
<link href="visual_002etxt.html" rel="next" title="visual.txt">
<link href="undo_002etxt.html" rel="prev" title="undo.txt">
<style>
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="style.css">


</head>

<body lang="ja">
<span id="repeat_002etxt"></span><div class="header">
<p>
Up: <a href="Mu-Ci-.html" accesskey="u" rel="up">目次</a> &nbsp; [<a href="Indexes-CP.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Zao-riFan-sikomando_002c-Vim-script_002c-sukuriputonodebatugu"></span><h2 class="unnumbered">繰り返しコマンド、Vim script、スクリプトのデバッグ</h2>
<pre class="verbatim">*repeat.txt*    For Vim バージョン 8.1.  Last change: 2019 Sep 20


		  VIMリファレンスマニュアル    by Bram Moolenaar
</pre>

<span id="repeating"></span><span id="index-repeating"></span>
<p>繰り返しコマンド、Vim script とデバッグ
</p>
<p>繰り返しについてはユーザーマニュアルの 26 章 |<a href="usr_005f26_002etxt.html">usr_26.txt</a>| に紹介があります。
</p>
<table>
<tr><td width="50%">1. 單發繰り返し</td><td width="50%">|<a href="#single_002drepeat">single-repeat</a>|</td></tr>
<tr><td width="50%">2. 多重繰り返し</td><td width="50%">|<a href="#multi_002drepeat">multi-repeat</a>|</td></tr>
<tr><td width="50%">3. 複雜な繰り返し</td><td width="50%">|<a href="#complex_002drepeat">complex-repeat</a>|</td></tr>
<tr><td width="50%">4. Vim script を使ふ</td><td width="50%">|<a href="#using_002dscripts">using-scripts</a>|</td></tr>
<tr><td width="50%">5. Vimパッケージを使ふ</td><td width="50%">|<a href="#packages">packages</a>|</td></tr>
<tr><td width="50%">6. Vimパッケージを作る</td><td width="50%">|<a href="#package_002dcreate">package-create</a>|</td></tr>
<tr><td width="50%">7. スクリプトのデバッグ</td><td width="50%">|<a href="#debug_002dscripts">debug-scripts</a>|</td></tr>
<tr><td width="50%">8. プロファイリング</td><td width="50%">|<a href="#profiling">profiling</a>|</td></tr>
</table>

<span id="single_002drepeat"></span><span id="index-single_002drepeat"></span>
<span id="index-Dan-Fa-Zao-riFan-si"></span>
<span id="g_t1_002e-Dan-Fa-Zao-riFan-si"></span><h3 class="section">1. 單發繰り返し</h3>

<span id="g_t_002e"></span><span id="index-_002e"></span>
<dl compact="compact">
<dt>.</dt>
<dd><p>最後の變更を繰り返します。變更の回數は [count] で指定した回數で置き換へられます。&rsquo;<samp>cpoptions</samp>&rsquo; に &rsquo;<var>y</var>&rsquo; フラグが含まれてる時には、ヤンクコマンドも繰り返します。コマンドラインコマンドは繰り返しません。
</p></dd>
</dl>

<p>單純な變更は &quot;.&quot; コマンドで繰り返すことができます。回數を指定しなければ、最後の變更の回數が使用されます。回數を指定した場合、最後のそれと置き換へられます。|<a href="eval_002etxt.html#v_003acount">v:count</a>| と |<a href="eval_002etxt.html#v_003acount1">v:count1</a>| が設定されます。
</p>
<p>最後に行はれた變更が番號付きレジスタの指定を含んでゐた場合、レジスタ番號は增加されます。これをどのやうに使ふかの例は |<a href="undo_002etxt.html#redo_002dregister">redo-register</a>| を參照してください。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
ビジュアル選擇を使用したコマンドを繰り返す時は、同じ「サイズ」の範圍が使用されることに注意してください。|<a href="visual_002etxt.html#visual_002drepeat">visual-repeat</a>| を參照してください。
</p></blockquote>

<span id="g_t_0040_003a"></span><span id="index-_0040_003a"></span>
<dl compact="compact">
<dt>@:</dt>
<dd><p>最後のコマンドラインを [count] 回繰り返します。
</p>
<p>{|<a href="various_002etxt.html#g_t_002bcmdline_005fhist">+cmdline_hist</a>| が無效にされてゐると使へない}
</p></dd>
</dl>


<span id="multi_002drepeat"></span><span id="index-multi_002drepeat"></span>
<span id="index-Duo-Zhong-Zao-riFan-si"></span>
<span id="g_t2_002e-Duo-Zhong-Zao-riFan-si"></span><h3 class="section">2. 多重繰り返し</h3>

<span id="g_t_003ag"></span><span id="g_t_003aglobal"></span><span id="E148"></span><span id="index-_003ag"></span>
<span id="index-_003aglobal"></span>
<span id="index-E148"></span>
<dl compact="compact">
<dt>:[range]g[lobal]/{pattern}/[cmd]</dt>
<dd><p>[range] の範圍で {pattern} にマッチする行に對して、Ex コマンド [cmd] (省略した場合 &quot;:p&quot;) を實行します。
</p>
</dd>
<dt>:[range]g[lobal]!/{pattern}/[cmd]</dt>
<dd><p>[range] の範圍で {pattern} にマッチしない行に對して、Ex コマンド [cmd] (省略した場合 &quot;:p&quot;) を實行します。
</p>
<span id="g_t_003av"></span><span id="g_t_003avglobal"></span><span id="index-_003av"></span>
<span id="index-_003avglobal"></span>
</dd>
<dt>:[range]v[global]/{pattern}/[cmd]</dt>
<dd><p>:g! と同じです。
</p></dd>
</dl>

<p>{pattern} の兩側の &rsquo;/&rsquo; の代はりにどんなシングルバイト文字でも使ふことができます。しかしアルファベット、&rsquo;\&rsquo;、&rsquo;&quot;&rsquo;、&rsquo;|&rsquo; は使へません。これは檢索パターンや置換文字列に &rsquo;/&rsquo; が含まれる場合に便利です。
</p>
<p>パターンの定義については |<a href="pattern_002etxt.html#pattern">pattern</a>| を參照してください。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
[cmd] は範圍指定を含むかもしれません。實例は |<a href="tips_002etxt.html#collapse">collapse</a>| や |<a href="usr_005f25_002etxt.html#edit_002dparagraph_002djoin">edit-paragraph-join</a>| を參照してください。
</p></blockquote>

<p>global コマンドの動作は、まづ第 1 に [range] の行をスキャンしマッチした行すべてに印をつけます (複數行にかかるパターンではマッチの最初の行だけが重要です)。
</p>
<p>次のスキャンでマークされたすべての行について、カーソルがその行にあるかのやうに [cmd] が實行されます。&quot;<code>:v</code>&quot; と &quot;<code>:g!</code>&quot; の場合は、マークされてゐないすべての行についてコマンドが實行されmasu。行が削除された場合、そのマークは消滅します。
</p>
<p>省略した場合の [range] はバッファ全體 (1,$) です。コマンドを中斷するには &quot;<kbd>CTRL-C</kbd>&quot; を使用します。ある行についてエラーメッセージが與へられると、そのラインに對するコマンドは中斷され、global コマンドはマッチした次の行の處理を續けます。
</p>
<span id="E147"></span><span id="index-E147"></span>
<p>このコマンドが再歸的に使はれるとき、それは一行のみに働きます。この時は範圍の指定は許されてゐません。これはあるパターンにマッチして別のパターンにマッチしない行を見つけるのに便利です:
</p><pre class="verbatim">:g/found/v/notfound/{cmd}
</pre><p>これは、はじめに &quot;found&quot; を含むすべての行を見つけますが、&quot;notfound&quot; にマッチしないものがあるときにだけ {cmd} を實行します。
</p>
<p>非 Ex コマンドを實行するために &lsquo;<code>:normal</code>&lsquo; コマンドを使用することができます:
</p><pre class="verbatim">:g/pat/normal {commands}
</pre><p>確實に {commands} が完全なコマンドとして終了するやうにしてください。さうでないと Vim は全部のマッチに 1 つ 1 つについて、コマンドの殘りを期待して貴方の入力を待ち續けるでせう。畫面は更新されないので、いま何をしてゐるのかわからないでせう。|<a href="various_002etxt.html#g_t_003anormal">:normal</a>| を參照してください。
</p>
<p>undo/redo コマンドは global コマンドを一度に undo/redo します。以前の文脈マークだけが一度設定されます (&quot;&rdquo;&quot; でグローバルコマンド實行前にカーソルがあつた場所に戾ることができます)。
</p>
<p>global コマンドは最後に使用した檢索パターンと、最後に使用した置換パターンの兩方を設定します (これは vi 互換)。これにより全體に對して文字列置換を行ふのが簡單になります:
</p><pre class="verbatim">:g/pat/s//PAT/g
</pre><p>これは全ての &quot;pat&quot; を &quot;PAT&quot; に置き換へます。同じことは次でも可能です:
</p><pre class="verbatim">:%s/pat/PAT/g
</pre><p>こちらのはうが 2 文字短い！
</p>
<p>Ex モード中で &quot;global&quot; を使ひ、そのコマンドに &quot;<code>:visual</code>&quot; を指定する場合はやや特殊です。これを行ふと、マッチする行へ移動してノーマルモードに入るので、|<a href="intro_002etxt.html#Q">Q</a>| を押して Ex モードへ戾るまでコマンドを實行することができます。これがマッチする各行に對して繰り返されます。これを行つてゐる閒は &quot;<code>:global</code>&quot; を使ふことはできません。中止するには <kbd>CTRL-C</kbd> を 2 回押してください。
</p>
<span id="complex_002drepeat"></span><span id="index-complex_002drepeat"></span>
<span id="index-Fu-Za-naZao-riFan-si"></span>
<span id="g_t3_002e-Fu-Za-naZao-riFan-si"></span><h3 class="section">3. 複雜な繰り返し</h3>

<span id="q"></span><span id="recording"></span><span id="index-q"></span>
<span id="index-recording"></span>
<dl compact="compact">
<dt>q{0-9a-zA-Z&quot;}</dt>
<dd><p>タイプした文字をレジスタ {0-9a-zA-Z&quot;} にレコーディング (大文字なら追記) します。レジスタを實行中は &rsquo;<code>q</code>&rsquo; コマンドは無效化されます。マッピングや |<a href="various_002etxt.html#g_t_003anormal">:normal</a>| の中でも機能しません。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
もしもレコーディングに使つてゐるレジスタが、その最中に |<a href="change_002etxt.html#y">y</a>| や |<a href="change_002etxt.html#p">p</a>| で使はれた場合、恐らく期待しない結果になることに注意してください。なぜなら、|<a href="change_002etxt.html#p">p</a>| で貼り付けられる內容は記錄されたマクロのものになり、|<a href="change_002etxt.html#y">y</a>| でコピーを行ふと記錄されたマクロを上書きしてしまふからです。
</p></blockquote>

</dd>
<dt>q</dt>
<dd><p>レコーディングを終了します。(實裝のメモ: レコーディングを終了する &rsquo;q&rsquo; は、それがマッピングの結果であつてもレジスタに記錄されません)
</p>
<span id="g_t_0040"></span><span id="index-_0040"></span>
</dd>
<dt>@{0-9a-z&quot;.=*+}</dt>
<dd><p>レジスタ {0-9a-z&quot;.=*+} の內容を [count] 回實行します。
</p><blockquote>
<p><strong>Note:</strong> <br>
レジスタ &rsquo;%&rsquo; (現在のファイルの名前) と &rsquo;#&rsquo; (オルタネートファイルの名前) は使用できないことに注意してください。
</p></blockquote>
<p>レジスタはマッピングと同樣に實行されます。つまり、&rsquo;<samp>wildchar</samp>&rsquo; と &rsquo;<samp>wildcharm</samp>&rsquo; の違ひが動作に影響します。
&quot;@=&quot; を使用すると式を入力するためのプロンプトが表示され、そこに入力した式の評價結果が實行されます。|<a href="#g_t_0040_003a">@:</a>| も參照してください。
</p>
<span id="g_t_0040_0040"></span><span id="E748"></span><span id="index-_0040_0040"></span>
<span id="index-E748"></span>
</dd>
<dt>@@</dt>
<dd><p>直前の @{0-9a-z&quot;:*} を [count] 回繰り返します。
</p>
<span id="g_t_003a_0040"></span><span id="g_t_003astar"></span><span id="index-_003a_0040"></span>
<span id="index-_003astar"></span>
<span id="index-_003a_002a"></span>
</dd>
<dt>:[addr]*{0-9a-z&quot;.=+}</dt>
<dt>:[addr]@{0-9a-z&quot;.=*+}</dt>
<dd><p>レジスタ {0-9a-z&quot;.=*+} の內容を Ex コマンドとして實行します。まづ最初にカーソルを [addr] 行に設定します (省略した場合は現在の行)。レジスタの最終行に &lt;CR&gt; が含まれない場合、&rsquo;<samp>cpoptions</samp>&rsquo; に &rsquo;<var>e</var>&rsquo; フラグが含まれてゐれば自動的に追加されます。
</p><blockquote>
<p><strong>Note:</strong> <br>
&quot;<code>:*</code>&quot; コマンドは &rsquo;<samp>cpoptions</samp>&rsquo; に &rsquo;<var>*</var>&rsquo; フラグが含まれてゐた場合にだけ認識されることに注意してください。これは &rsquo;<samp>nocompatible</samp>&rsquo; が使用されてゐる時にはデフォルトにはなりません。
</p></blockquote>
<p>&quot;:@=&quot; には最後に評價された式が使用されます。式の評價結果が Ex コマンドとして實行されます。
これらのコマンド內ではマッピングは行はれません。
</p>
<p>將來: 指定された範圍の各々の行に對してレジスタの內容が實行されるでせう。
</p>
<span id="g_t_003a_0040_003a"></span><span id="index-_003a_0040_003a"></span>
</dd>
<dt>:[addr]@:</dt>
<dd><p>最後のコマンドラインを繰り返します。まづカーソルを [addr] 行に設定します (省略した場合は現在の行)。
</p>
<span id="g_t_003a_0040_0040"></span><span id="index-_003a_0040_0040"></span>
</dd>
<dt>:[addr]@ or :[addr]@@</dt>
<dd><p>最後の :@{0-9a-z&quot;} を繰り返します。まづ最初にカーソルを [addr] 行に設定します (省略した場合は現在の行)。
</p></dd>
</dl>

<span id="using_002dscripts"></span><span id="index-using_002dscripts"></span>
<span id="index-Vim-script-woShi-u"></span>
<span id="g_t4_002e-Vim-script-woShi-u"></span><h3 class="section">4. Vim script を使ふ</h3>

<p>Vim script の書き方はユーザーマニュアルの 41 章 |<a href="usr_005f41_002etxt.html">usr_41.txt</a>| を參照してください。
</p>
<span id="g_t_003aso"></span><span id="g_t_003asource"></span><span id="load_002dvim_002dscript"></span><span id="index-_003aso"></span>
<span id="index-_003asource"></span>
<span id="index-load_002dvim_002dscript"></span>
<dl compact="compact">
<dt>:so[urce] {file}</dt>
<dd><p>Ex コマンドを {file} から讀み込みます。これは &quot;:&quot; で始まるコマンドを列擧したファイルです。{譯注: 實際に &quot;:&quot; を書く必要はありません}
</p>
<p>自動コマンド |<a href="autocmd_002etxt.html#SourcePre">SourcePre</a>| が發生します。
<span id="g_t_003asource_0021"></span><span id="index-_003asource_0021"></span>
</p></dd>
<dt>:so[urce]! {file}</dt>
<dd><p>Vim コマンドを {file} から讀み込みます。ノーマルモードでファイルの內容をあなたがタイプしたのと同じやうに實行されます。
</p>
<p>|<a href="#g_t_003aglobal">:global</a>|, |<a href="editing_002etxt.html#g_t_003aargdo">:argdo</a>|, |<a href="windows_002etxt.html#g_t_003awindo">:windo</a>|, |<a href="windows_002etxt.html#g_t_003abufdo">:bufdo</a>| で使つたとき、ループ中や他のコマンドが續けられたときは、コマンドの實行中は表示は更新されません。
</p>
<p>|<a href="eval_002etxt.html#sandbox">sandbox</a>| 內では使用できません。
</p>
<span id="g_t_003aru"></span><span id="g_t_003aruntime"></span><span id="index-_003aru"></span>
<span id="index-_003aruntime"></span>
</dd>
<dt>:ru[ntime][!] [where] {file} ..</dt>
<dd><p>&rsquo;<samp>runtimepath</samp>&rsquo; か &rsquo;<samp>packpath</samp>&rsquo; で示された各ディレクトリの {file}から Ex コマンドを讀み込みます。ファイルがなくてもエラーにはなりません。
</p>			
<p>例:
</p><pre class="verbatim">:runtime syntax/c.vim
</pre>
<p>{file} には空白で區切つて複數のファイルを指定できます。指定された {file} は &rsquo;<samp>runtimepath</samp>&rsquo; の最初のディレクトリ、次に 2 番目のディレクトリ、と檢索されます。{file} に空白を含めるにはバックスラッシュを使ひます (しかしファイル名に空白を含めるのは望ましくありません。トラブルのもとです)。
</p>
<p>[!] を付けると見つかつた全てのファイルを讀み込みます。付けなければ最初に見つかつたファイルだけを讀み込みます。
</p>
<p>[where] が省略された場合は &rsquo;<samp>runtimepath</samp>&rsquo; が使はれます。
</p>
<p>他の値は以下の通り:
</p><table>
<tr><td width="15%">START</td><td width="85%">&rsquo;<samp>packpath</samp>&rsquo; の &quot;<var>start</var>&quot; ディレクトリ以下を檢索する</td></tr>
<tr><td width="15%">OPT</td><td width="85%">&rsquo;<samp>packpath</samp>&rsquo; の &quot;<var>opt</var>&quot; ディレクトリ以下を檢索する</td></tr>
<tr><td width="15%">PACK</td><td width="85%">&rsquo;<samp>packpath</samp>&rsquo; の &quot;<var>start</var>&quot; と &quot;<var>opt</var>&quot; ディレクトリ以下を檢索する</td></tr>
<tr><td width="15%">ALL</td><td width="85%">まず &rsquo;<samp>runtimepath</samp>&rsquo; が使はれ、次に &rsquo;<samp>packpath</samp>&rsquo; の &quot;<var>start</var>&quot; と &quot;<var>opt</var>&quot; ディレクトリ以下を檢索する</td></tr>
</table>

<p>{file} がワイルドカードを含んでゐるとそれは展開されます。例:
</p><pre class="verbatim">:runtime! plugin/*.vim
</pre><p>これは Vim が起動時にプラグインファイルを讀み込むのに使つてゐるものです。次のは似てゐますが:
</p><pre class="verbatim">:runtime plugin/*.vim
</pre><p>これは最初に見つかつたファイルだけを讀み込みます。
</p>
<p>&rsquo;<samp>verbose</samp>&rsquo; が 1 以上ならファイルが見つからないときにメッセージが表示されます。&rsquo;<samp>verbose</samp>&rsquo; が 2 以上なら見つかつた全てのファイルについてメッセージが表示されます。
</p>
<span id="g_t_003apa"></span><span id="g_t_003apackadd"></span><span id="E919"></span><span id="index-_003apa"></span>
<span id="index-_003apackadd"></span>
<span id="index-E919"></span>
</dd>
<dt>:pa[ckadd][!] {name}</dt>
<dd><p>&rsquo;<samp>packpath</samp>&rsquo; 中の任意のプラグインディレクトリを檢索し、見つかつたプラグインのファイルを讀み込みます。ディレクトリは以下にマッチしなければなりません:
</p><pre class="verbatim">pack/*/opt/{name} ~
</pre><p>見つかつたディレクトリは、もし含まれてゐなければ &rsquo;<samp>runtimepath</samp>&rsquo; に追加されます。もしディレクトリ &lsquo;<samp>pack/*/opt/{name}/after</samp>&rsquo; が存在すれば、&rsquo;<samp>runtimepath</samp>&rsquo; の最後に追加されます。
</p>
<p>もしディレクトリ &quot;pack/*/start&quot; からのパッケージ讀み込みがスキップされた場合、次のディレクトリが最初に檢索されます:
</p><pre class="verbatim">pack/*/start/{name}
</pre>
<blockquote>
<p><strong>Note:</strong> <br>
{name} はディレクトリの名前で、.vim ファイルの名前ではないことに注意してください。以下のパターンにマッチする全てのファイルが讀み込まれます。
</p><pre class="verbatim">pack/*/opt/{name}/plugin/**/*.vim
</pre><p>これにより、ちやうど &rsquo;<samp>runtimepath</samp>&rsquo; 內のプラグインのやうに、&quot;plugin&quot; 以下のサブディレクトリを使ふことができます。
</p></blockquote>

<p>ファイルタイプの檢知が有效化されてゐない場合 (これは通常 .vimrc 中の &quot;syntax enable&quot; か &quot;filetype on&quot; コマンドにより行はれます)、&quot;{name}/ftdetect/*.vim&quot; ファイルを參照します。
</p>
<p>任意の ! が付けられた場合、プラグインのファイルや ftdetect のスクリプトは讀み込まれず、マッチしたディレクトリのみ &rsquo;<samp>runtimepath</samp>&rsquo; に追加されます。これは .vimrc に書く場合は便利です。追加されたプラグインは初期化時に讀み込まれます。|<a href="starting_002etxt.html#load_002dplugins">load-plugins</a>| を參照してください。
</p>
<p>また |<a href="#pack_002dadd">pack-add</a>| も參照してください。
</p>
<p>{|<a href="various_002etxt.html#g_t_002beval">+eval</a>| 機能付きでコンパイルされたときのみ有效}
</p>
<span id="g_t_003apackl"></span><span id="g_t_003apackloadall"></span><span id="index-_003apackl"></span>
<span id="index-_003apackloadall"></span>
</dd>
<dt>:packl[oadall][!]</dt>
<dd><p>&rsquo;<samp>packpath</samp>&rsquo; 以下の &quot;start&quot; ディレクトリ中の全パッケージを讀み込みます。
</p>			
<p>最初に、見つかつたディレクトリが全て &rsquo;<samp>runtimepath</samp>&rsquo; に追加され、次にそのディレクトリ內で見つかつたプラグインが讀み込まれます。これにより、あるプラグインが別のプラグインの何か、例へば &quot;autoload&quot; ディレクトリに依存することが許可されます。これがどのやうに役立つかは |<a href="#packload_002dtwo_002dsteps">packload-two-steps</a>| を參照してください。
</p>
<p>これは通常起動時に .vimrc が讀み込まれた後に自動的に行はれます。このコマンドはそれよりも前に行ふことができます。
</p>
<p>パッケージの讀み込みは一度だけ行はれます。&lsquo;<code>:packloadall</code>&lsquo; を再度使用しても效果はありません。任意の ! が付けられた場合はすでに讀み込みが行はれてゐてもパッケージを讀み込みます。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
|<a href="starting_002etxt.html#vimrc">vimrc</a>| ファイル內に &lsquo;<code>:packloadall</code>&lsquo; が使はれてゐる場合、&rsquo;<samp>runtimepath</samp>&rsquo; オプションが更新され、後で &rsquo;<samp>runtimepath</samp>&rsquo; 內のすべてのプラグインが讀み込まれることに注意してください。これはそれらが再び讀み込まれることを意味します。プラグインはそれを正しく扱ふことが期待されます。
</p></blockquote>

<p>(スクリプトを讀み込む際の) エラーは讀み込んでゐるスクリプトの讀み込みのみを中止させます。その他のプラグインは讀み込まれます。|<a href="#packages">packages</a>| を參照してください。
</p>
<p>{|<a href="various_002etxt.html#g_t_002beval">+eval</a>| 機能付きでコンパイルされたときのみ有效}
</p>
<span id="g_t_003ascripte"></span><span id="g_t_003ascriptencoding"></span><span id="E167"></span><span id="index-_003ascripte"></span>
<span id="index-_003ascriptencoding"></span>
<span id="index-E167"></span>
</dd>
<dt>:scripte[ncoding] [encoding]</dt>
<dd><p>スクリプトで使はれてゐる文字コードを宣言します。それ以降の行は必要なら [encoding] から &rsquo;<samp>encoding</samp>&rsquo; オプションの文字コードに變換されます。例:
</p><pre class="verbatim">scriptencoding iso-8859-5
scriptencoding cp932
</pre><p>[encoding] が空のときは變換はされません。これはそれ以降の行の文字コードの變換を限定するために使へます:
</p><pre class="verbatim">scriptencoding euc-jp
... 變換される ...
scriptencoding
... 變換されない ...
</pre>
<p>變換がシステムによつて提供されない場合、エラーメッセージは表示されず變換もされません。ある行が變換できなかつた場合、エラーにはならず元の行が保持されます。
</p>
<p>&quot;ucs-2&quot; や &quot;ucs-4&quot; を使はないでください。スクリプトをその文字コードで書くことはできません (NULバイトが含まれてしまふため)。スクリプトの最初に utf-8 の BOM (Byte Order Mark: バイトオーダーマーク) があると Vim はそれを認識します。&quot;:scriptencoding utf-8&quot; と書く必要はありません。
</p>
<p>|<a href="starting_002etxt.html#g_t_002evimrc">.vimrc</a>| の中で &rsquo;<samp>encoding</samp>&rsquo; オプションを設定してゐる場合は、&lsquo;<code>:scriptencoding</code>&lsquo; はそれよりも後に置かなければなりません。例:
</p><pre class="verbatim">set encoding=utf-8
scriptencoding utf-8
</pre>
</dd>
<dt>:scriptv[ersion] {version}</dt>
<dd><span id="g_t_003ascriptv"></span><span id="g_t_003ascriptversion"></span><span id="index-_003ascriptv"></span>
<span id="index-_003ascriptversion"></span>
<span id="E999"></span><span id="E984"></span><span id="index-E999"></span>
<span id="index-E984"></span>
<p>同じファイルの後に續く行の Vim のバージョンを指定します。讀み込まれるスクリプトのトップレベルにのみ適用され、函數內部には適用されません。
</p>
<p>{version} が現在の Vim のバージョンがサポートしてゐるものよりも高い場合は E999 が與へられます。スクリプトを古い Vim バージョンで動作するやうに書き直すか、または Vim を新しいバージョンに更新する必要があります。バージョン閒の變更點については |<a href="eval_002etxt.html#vimscript_002dversion">vimscript-version</a>| を參照してください。
</p>
<span id="g_t_003ascr"></span><span id="g_t_003ascriptnames"></span><span id="index-_003ascr"></span>
<span id="index-_003ascriptnames"></span>
</dd>
<dt>:scr[iptnames]</dt>
<dd><p>讀み込まれてゐるスクリプトを讀み込まれた順番どほりに全て表示します。數字はスクリプトの ID (識別子) |<a href="map_002etxt.html#g_t_003cSID_003e">&lt;SID&gt;</a>| に使はれてゐます。
</p>
<p>{|<a href="various_002etxt.html#g_t_002beval">+eval</a>| 付きでコンパイルしないと使へない}
</p>
<span id="g_t_003ascript"></span><span id="index-_003ascript"></span>
</dd>
<dt>:scr[iptnames][!] {scriptId}</dt>
<dd><p>スクリプト {scriptId} を編輯します。&quot;<code>:scriptnames name</code>&quot; は動作しますが、&quot;<code>:script name</code>&quot; を使用することを推奬します。カレントファイルを抛棄 |<a href="editing_002etxt.html#abandon">abandon</a>| できず、[!] も付けられてゐないときは、コマンドは失敗します。
</p>
<span id="g_t_003afini"></span><span id="g_t_003afinish"></span><span id="E168"></span><span id="index-_003afini"></span>
<span id="index-_003afinish"></span>
<span id="index-E168"></span>
</dd>
<dt>:fini[sh]</dt>
<dd><p>スクリプトの讀み込みを停止します。スクリプトファイルでのみ使へます。これはファイルの殘りを讀み込ませないための手輕な方法です。|<a href="eval_002etxt.html#g_t_003atry">:try</a>| を使つた後で |<a href="eval_002etxt.html#g_t_003afinally">:finally</a>| を見つける前に使はれると、まづ &quot;<code>:finally</code>&quot; と |<a href="eval_002etxt.html#g_t_003aendtry">:endtry</a>| の閒のコマンドが實行されます。この手續きは入れ子になつてゐる全ての &quot;<code>:try</code>&quot; に對して適用されます。入れ子の一番外側の &quot;<code>:endtry</code>&quot; に達するとスクリプトを停止します。
</p></dd>
</dl>

<p>全てのコマンドとコマンドシーケンスは、名前付きレジスタに格納することで繰り返し實行することができます。レジスタにコマンドを格納する方法は 2 つあります:
</p><ul>
<li> 記錄コマンド &quot;q&quot; を使用します。實際にコマンドをタイプし、實行しながらそれをレジスタに格納します。今、何が起こつてゐるかを確認できるので簡單です。閒違ひをしたならば、レジスタの內容をいつたんファイルへ書き出 (&quot;p&quot;ut) して、コマンドシーケンスを編輯して、それからそれを削除して再びレジスタに格納することができます。レジスタに追加することで繼續してレコーディングすることができます (大文字を使用します)。
</li><li> コマンドシーケンスを削除かヤンクしてレジスタに入れます。
</li></ul>

<p>良く使ふコマンドシーケンスは &rsquo;<code>:map</code>&rsquo; コマンドでファンクションキーに割當てることができます。
</p>
<p>別の方法としてコマンドをファイルに記述しておき、それを &rsquo;<code>:source!</code>&rsquo; コマンドで讀込んで實行するといふ方法もあります。長いコマンドシーケンスにとつては便利です。ファンクションキーに複雜なコマンドを割當てるために &rsquo;<code>:map</code>&rsquo; コマンドと組み合はせることができます。
</p>
<p>&rsquo;<code>:source</code>&rsquo; コマンドはファイルから 1 行ずつ Ex コマンドを讀込みます。キーボード入力が必要になつた場合にはタイプする必要が生じます。&rsquo;<code>:source!</code>&rsquo; コマンドはスクリプトファイルから 1 字ずつ讀込みます。各々のキャラクタはユーザーがタイプしたものとして解釋されます。
</p>
<p>例: &quot;<code>:!ls</code>&quot; コマンドを實行したとすると |<a href="message_002etxt.html#hit_002denter">hit-enter</a>| プロンプトが表示されます。&quot;!ls&quot; を含むファイルを &rsquo;<code>:source</code>&rsquo; したなら、自分で <code class="tt-key">&lt;Enter&gt;</code> をタイプする必要があるでせう。しかし &rsquo;:!ls&rsquo; を含んだファイルを &rsquo;<code>:source!</code>&rsquo; したなら、&lt;CR&gt; が見つかるまでそのファイルから續く文字が讀込まれます。&quot;<code>:!ls</code>&quot; がファイルの最終行でない限り、&lt;CR&gt; を自分でタイプする必要はないでせう。
</p>
<p>スクリプトファイルの中で &rsquo;<code>:source[!]</code>&rsquo; コマンドを使ふことも可能なので、階層關係のあるスクリプトファイルを作ることもできます。&rsquo;<code>:source</code>&rsquo; コマンドは同時に開くことのできるファイル數 (だいたい 15) と同じだけネスト (入れ子に) することができます。&rsquo;<code>:source!</code>&rsquo; コマンドは 15 段までネストすることができます。
</p>
<p>讀込まれるファイルの中ではファイル名が必要なところに、&quot;&lt;sfile&gt;&quot; といふ文字列 (文字通りであつてスペシャルキーではありません) を使ふことができます。この文字列は讀込まれたファイルのファイル名に置き換へられます。例へば、&quot;<samp>.vimrc</samp>&quot; ファイルと同じ場所に &quot;<samp>other.vimrc</samp>&quot; といふファイルがあれば、&quot;<samp>.vimrc</samp>&quot; から次のコマンドでそれを讀込むことができます:
</p><pre class="verbatim">:source &lt;sfile&gt;:h/other.vimrc
</pre>
<p>スクリプトファイル內では端末依存のキーコードは端末非依存の 2 文字のコードで表現されます。これは異なる種類の端末でも同じ方法で依存キーコードを使用できることを意味します。最初のキーコードの文字は 0x80 つまり 128 で、畫面では &quot;&lsquo;<samp>~@</samp>&rsquo;&quot; と表されます。2 つ目のキャラクタは |<a href="intro_002etxt.html#key_002dnotation">key-notation</a>| の表にて見ることができます。これらのコードはどれも <kbd>CTRL-V</kbd> に續けて 3 つの 10 進コードを叩くことで入力できます。これは termcap コード &lt;t_xx&gt; に對しては使用できません。これらはマッピングの中だけで使ふことができます。
</p>
<span id="g_t_003asource_005fcrnl"></span><span id="W15"></span><span id="index-_003asource_005fcrnl"></span>
<span id="index-W15"></span>
<p>MS-DOS, Win32 と OS/2: &quot;<code>:source</code>&quot; で讀込まれるファイルは通常、行末に &lt;CR&gt;&lt;NL&gt; を持つてゐます。これらは常に機能します。もしも行末に &lt;NL&gt; を持つファイルを使つてゐるならば (例へば UNIX で作られたファイル)、&rsquo;<samp>fileformats</samp>&rsquo; が空でかつ先頭行が &lt;CR&gt; で終はつてなければ正しく認識されます。しかしこれは先頭行が &quot;&lsquo;<samp>:map &lt;F1&gt; :help^M</samp>&rsquo;&quot; (^M は &lt;CR&gt;) のやうな內容だつた場合には失敗します。ファイルの先頭行が &lt;CR&gt; で終はつてゐてその 1 行限りの時、先頭行から &lt;CR&gt; が失はれてしまふのでエラーメッセージが出るでせう。
</p>
<p>Mac Classic: &quot;<samp>:source</samp>&quot; で讀み込まれるファイルは通常、行末に &lt;CR&gt; を持つてゐます。これらは常に機能します。もしも行末に &lt;NL&gt; を持つファイルを使つてゐるならば (例へば UNIX で作られたファイル)、&rsquo;<samp>fileformats</samp>&rsquo; が空でかつ先頭行が &lt;CR&gt; で終はつてなければ正しく認識されます。先頭行に &lt;CR&gt; を持ち &lt;NL&gt; で改行してゐるファイルを使用しないやうに氣をつけてください。
</p>
<p>その他のシステムでは、Vim は &quot;<code>:source</code>&quot; で讀込まれたファイルの行末は &lt;NL&gt; であることを期待します。これは常に機能します。もしも行末が &lt;CR&gt;&lt;NL&gt; であるファイル (例へば MS-DOS で作られたファイル) を使つてゐるならば、全ての行が末尾に &lt;CR&gt; を持つてゐることになります。これは幾つかのコマンド (例、マッピング) にとつて問題となるでせう。自動的に行末記號を檢出する機構はありません。なぜなら &lt;CR&gt; で終了するマッピングの定義をファイルの先頭に書くことは一般的で、自動檢出用の仕組みを作るのが難しいからです。
</p>
<span id="line_002dcontinuation"></span><span id="index-line_002dcontinuation"></span>
<p>&quot;<code>:source</code>&quot; で讀込まれた Ex コマンドスクリプトのファイル內の長い行は、行繼續記號 &quot;\&quot; (backslash) を次行の先頭に插入することで分割できます。バックスラッシュの前に空白を插入することも可能で、これらは無視されます。
</p>
<p>例: 次の記述は
</p><pre class="verbatim">:set comments=sr:/*,mb:*,el:*/,
         \://,
         \b:#,
         \:%,
         \n:&gt;,
         \fb:-
</pre><p>次の 1 行と同じ意味として解釋されます:
</p><pre class="verbatim">:set comments=sr:/*,mb:*,el:*/,://,b:#,:%,n:&gt;,fb:-
</pre>
<p>バックスラッシュの前に先行する空白文字は全部無視されます。しかしながらバックスラッシュのある行の 1 つ前の行末には、自由に空白文字を插入することはできません; 付加的な空白文字が許されるかどうかは、コマンドが分割される位置に依存します。
</p>
<p>スペースが必要な場合には、バックスラッシュの直後に書くのがベストです。行末にスペースを書くと、視認が難しく、誤つて削除されてしまふかもしれません。
</p><pre class="verbatim">:syn match Comment
    \ &quot;very long regexp&quot;
    \ keepend
</pre>
<p>&quot;<code>:append</code>&quot; と &quot;<code>:insert</code>&quot; コマンドには 1 つ問題があります:
</p><pre class="verbatim">:1append
\asdf
.
</pre><p>バックスラッシュは行繼續シンボルに見えますが、コマンドの結果はこのやうになります:
</p><pre class="verbatim">:1appendasdf
.
</pre><p>これを避けるには、&rsquo;<samp>cpoptions</samp>&rsquo; に &rsquo;<var>C</var>&rsquo; フラグを追加することです:
</p><pre class="verbatim">:set cpo+=C
:function Foo()
:1append
\asdf
:.
:set cpo-=C
</pre>
<blockquote>
<p><strong>Note:</strong> <br>
函數の中でその手のコマンドを實行するには、函數定義の際に &rsquo;<var>C</var>&rsquo; フラグを追加する必要があり、それが實行される際にではなことに注意してください。
</p><pre class="verbatim">:set cpo+=C
:function Foo()
:1append
\asdf
.
:endfunction
:set cpo-=C
</pre></blockquote>
<span id="line_002dcontinuation_002dcomment"></span><span id="index-line_002dcontinuation_002dcomment"></span>
<p>行の閒でコメントを追加するために、&rsquo;&quot;\ &rsquo; で開始します。バックスラッシュの後にスペースがあることに注意してください。例:
</p><pre class="verbatim">let array = [
        &quot;\ first entry comment
        \ 'first',
        &quot;\ second entry comment
        \ 'second',
        \ ]
</pre>
<p>解說:
</p>
<p>多くのプログラムは行繼續を、繼續する行の末尾にバックスラッシュを置くことで表現します。その方法を Vim で採用してしまふと、Vi との互換性に重大な缺陷ができてしまひます。たとへばこのやうな Vi のマッピングを考へるとわかりやすい:
</p><pre class="verbatim">:map xx  asdf\
</pre><p>從つて一般的ではないですが、行頭のバックスラッシュを採用してゐます。
</p>
<p>繼續行の中でコメントを開始すると、後續のすべての行がコメントの一部になります。それは長い閒このやうなものだつたので、繼續行のシーケンスの途中でコメントを追加しようとしたとき、\&quot; は有效な繼續行であるため、それを使用することはできませんでした。&rsquo;&quot;\ &rsquo; を使用すると最も近いものになりますが、少し奇妙に見えるかもしれません。バックスラッシュの後にスペースを必要とすることは、これが通常のコメント行にはとても見えないやうにするためです。
</p>
<span id="packages"></span><span id="index-packages"></span>
<span id="index-Vim-patukeziwoShi-u"></span>
<span id="g_t5_002e-Vim-patukeziwoShi-u"></span><h3 class="section">5. Vim パッケージを使ふ</h3>

<p>Vim script のパッケージは 1 つかそれ以上のプラグインを含むディレクトリです。通常のプラグインと比べた長所は以下の通りです:
</p><ul>
<li> パッケージは壓縮ファイルとしてダウンロードでき、獨自のディレクトリに展開されます。よつてそのファイルは他のプラグインと混在することがありません。これは更新と削除を簡素化します。
</li><li> パッケージには git, mercurial などのリポジトリも使用可能です。これはとても更新を簡素化します。
</li><li> パッケージはお互ひに依存する複數のプラグインを含むことができます。
</li><li> パッケージは起動時に自動的に讀み込まれるプラグインと、必要になつた時のみ &lsquo;<code>:packadd</code>&lsquo; により讀み込まれるプラグインを含むことができます。
</li></ul>


<span id="index-patukezinoShi-Yong-toZi-Dong-Du-miIp-mi"></span>
<span id="patukezinoShi-Yong-toZi-Dong-Du-miIp-mi"></span><h4 class="unnumberedsubsec">パッケージの使用と自動讀み込み</h4>

<p>あなたの Vim 關聯のファイルが &quot;~/.vim/&quot; にあるとします。さらに ZIP 壓縮ファイル &quot;/tmp/foopack.zip&quot; からパッケージを追加したい場合は以下の通りです:
</p><pre class="verbatim">% mkdir -p ~/.vim/pack/foo
% cd ~/.vim/pack/foo
% unzip /tmp/foopack.zip
</pre>
<p>&quot;foo&quot; といふディレクトリ名は任意です。あなたが好きな名前を付けられます。
</p>
<p>今あなたの ~/.vim の下には以下のファイルがあるはずです:
</p><pre class="verbatim">pack/foo/README.txt
pack/foo/start/foobar/plugin/foo.vim
pack/foo/start/foobar/syntax/some.vim
pack/foo/opt/foodebug/plugin/debugger.vim
</pre>
<p>Vim が起動した時、.vimrc を處理した後、&rsquo;<samp>packpath</samp>&rsquo; に含まれる &quot;pack/*/start&quot; ディレクトリの下の全てのディレクトリをスキャンします。最初にそのディレクトリは &rsquo;<samp>runtimepath</samp>&rsquo; に追加されます。次に全てのプラグインがロードされます。これら 2 つのステップがどのやうに役立つかについては、|<a href="#packload_002dtwo_002dsteps">packload-two-steps</a>| を參照してください。
</p>
<p>上記の例では &quot;pack/foo/start/foobar/plugin/foo.vim&quot; を見つけて &quot;~/.vim/pack/foo/start/foobar&quot; を &rsquo;<samp>runtimepath</samp>&rsquo; に追加します。
</p>
<p>もし &quot;foobar&quot; プラグインが作動し &rsquo;<samp>filetype</samp>&rsquo; を &quot;<var>some</var>&quot; にセットした場合、&rsquo;<samp>runtimepath</samp>&rsquo; に含まれてゐるため、Vim は上記の <samp>syntax/some.vim</samp> ファイルを見つけます。
</p>
<p>もし存在するなら、Vim は ftdetect ファイルもロードします。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
&quot;pack/foo/opt&quot; 以下のファイルは自動的に讀み込まれず、&quot;pack/foo/start&quot; 以下のファイルのみ讀み込まれることに注意してください。&quot;opt&quot; ディレクトリがどのやうに使はれるかについては下記の |<a href="#pack_002dadd">pack-add</a>| を參照してください。
</p></blockquote>

<p>パッケージの自動讀み込みはプラグインの讀み込みを無效化してゐる場合は起こりません。|<a href="starting_002etxt.html#load_002dplugins">load-plugins</a>| を參照してください。
</p>
<p>&rsquo;<samp>runtimepath</samp>&rsquo; を更新するためにパッケージを讀み込むには:
</p><pre class="verbatim">:packloadall
</pre><p>これはプラグインの讀み込みを無效化してゐても效果があります。自動讀み込みは一度だけ行はれます。
</p>
<p>パッケージに &quot;after&quot; ディレクトリがある場合、そのディレクトリは &rsquo;<samp>runtimepath</samp>&rsquo; の末尾に追加されます。そのため、そこにあるものは全て後でロードされます。
</p>

<span id="index-Dan-YipuraguinnoShi-Yong-tosonoZi-Dong-Du-miIp-mi"></span>
<span id="Dan-YipuraguinnoShi-Yong-tosonoZi-Dong-Du-miIp-mi"></span><h4 class="unnumberedsubsec">單一プラグインの使用とその自動讀み込み</h4>

<p>パッケージでなく單一のプラグインがある場合は、餘分なディレクトリ階層を作成する必要があります。
</p><pre class="verbatim">% mkdir -p ~/.vim/pack/foo/start/foobar
% cd ~/.vim/pack/foo/start/foobar
% unzip /tmp/someplugin.zip
</pre>
<p>これで、次のファイルが作成されます:
</p><pre class="verbatim">pack/foo/start/foobar/plugin/foo.vim
pack/foo/start/foobar/syntax/some.vim
</pre>
<p>ここから上のやうに動作します。
</p>

<span id="index-Ren-Yi-nopuraguin"></span>
<span id="Ren-Yi-nopuraguin"></span><h4 class="unnumberedsubsec">任意のプラグイン</h4>
<span id="pack_002dadd"></span><span id="index-pack_002dadd"></span>
<p>上記の pack ディレクトリから任意のプラグインをロードするには &lsquo;<code>:packadd</code>&lsquo; コマンドを使ひます:
</p><pre class="verbatim">:packadd foodebug
</pre><p>これは &rsquo;<samp>packpath</samp>&rsquo; の &quot;pack/*/opt/foodebug&quot; から <samp>~/.vim/pack/foo/opt/foodebug/plugin/debugger.vim</samp> を見つけて讀み込みます。
</p>
<p>これにより何かしらの條件が滿たされる時に實行されるやうにできます。例へば、Vim がある機能をサポートしてゐるかどうかとか、依存したモノが見つからないとか、さういふことに依存させることができます。
</p>
<p>このコマンドをあなたの |<a href="starting_002etxt.html#g_t_002evimrc">.vimrc</a>| に入れることで、起動時に任意のプラグインを讀み込むこともできます。
</p><pre class="verbatim">:packadd! foodebug
</pre><p>餘分な &quot;!&quot; は Vim が |<a href="starting_002etxt.html#g_t_002d_002dnoplugin">--noplugin</a>| で起動されてゐれば、プラグインがロードされないやうにするためです。
</p>
<p>パッケージが &quot;opt&quot; ディレクトリしか持たなかつたとしても一向に構ひません。その場合、それを使ひたいときは (明示的に) 讀み込む必要があります。
</p>

<span id="index-dokoniHe-woZhi-kuka"></span>
<span id="dokoniHe-woZhi-kuka"></span><h4 class="unnumberedsubsec">どこに何を置くか</h4>

<p>&lsquo;<code>:colorscheme</code>&lsquo; で讀み込まれるカラースキームは &quot;pack/*/start&quot; と &quot;pack/*/opt&quot; の下から探し出されるので、どこにでも置くことができます。たとへば、&quot;<samp>.vim/pack/mycolors/opt/dark/colors/very_dark.vim</samp>&quot; のやうに、&quot;pack/*/opt&quot; の下に置くことをお勸めします。
</p>
<p>Filetype プラグインはファイルタイプに複數のプラグインがあり、&lsquo;<code>:packadd</code>&lsquo; でロードするプラグインを選擇したいのでない限り &quot;pack/*/start&quot; の下に置く必要があります。例へば、コンパイラのバージョンに依存する場合:
</p><pre class="verbatim">if foo_compiler_version &gt; 34
  packadd foo_new
else
  packadd foo_old
endif
</pre>
<p>&quot;after&quot; ディレクトリはパッケージで使ふには十中八九便利ではありません。しかし、使用が禁じられてゐるわけではありません。
</p>
<span id="package_002dcreate"></span><span id="index-package_002dcreate"></span>
<span id="index-Vim-patukeziwoZuo-ru"></span>
<span id="g_t6_002e-Vim-patukeziwoZuo-ru"></span><h3 class="section">6. Vim パッケージを作る</h3>

<p>パッケージとして配布する 1 つ以上のプラグインを記述してゐることを前提とします。
</p>
<p>2 つの無關係なプラグインがある場合は、2 つのパッケージを使用するので、Vim ユーザーはそのパッケージに含まれるものを選擇できます。あるいは、オプションのプラグインで 1 つのパッケージを使用し、&lsquo;<code>:packadd</code>&lsquo; で必要なプラグインを追加するやうにユーザーに指示することもできます。
</p>
<p>パッケージの配布方法を決めます。アーカイブを作成することも、リポジトリを使用することもできます。より多くのユーザーがアーカイブを使用できますが、新しいバージョンに更新するのは少し難しくなります。リポジトリは通常、最新の狀態に保つことができますが、&quot;git&quot; のやうなプログラムが必要です。GitHub ではリリースを作成すると自動的にアーカイブが作られるので、あなたは兩方を同時に行ふことができます。
</p>
<p>ディレクトリ構成は次のやうになります。
</p><pre class="verbatim">start/foobar/plugin/foo.vim         &quot; 常にロードされ、コマンドを定義する
start/foobar/plugin/bar.vim         &quot; 常にロードされ、コマンドを定義する
start/foobar/autoload/foo.vim       &quot; foo コマンドを使用した時に讀み込む
start/foobar/doc/foo.txt            &quot; foo.vim のヘルプ
start/foobar/doc/tags               &quot; ヘルプタグ
opt/fooextra/plugin/extra.vim       &quot; オプションのプラグイン、コマンド定義
opt/fooextra/autoload/extra.vim     &quot; extra コマンドを使用した時に讀み込む
opt/fooextra/doc/extra.txt          &quot; extra.vim のヘルプ
opt/fooextra/doc/tags               &quot; ヘルプタグ
</pre>
<p>これにより、ユーザーは次の操作を行ふことができます。
</p><pre class="verbatim">mkdir ~/.vim/pack/myfoobar
cd ~/.vim/pack/myfoobar
git clone https://github.com/you/foobar.git
</pre>
<p>ここで &quot;myfoobar&quot; はユーザーが選擇できる名前ですが、唯一の條件は他のパッケージとは異なることです。
</p>
<p>ドキュメントでは、プラグインの機能について說明し、オプションのプラグインをロードする方法をユーザーに傳へます。
</p><pre class="verbatim">:packadd! fooextra
</pre>
<p>この packadd コマンドをプラグインの 1 つに追加して、オプションのプラグインが必要なときに實行することができます。
</p>
<p>&lsquo;<code>:helptags</code>&lsquo; コマンドを實行して、<samp>doc/tags</samp> ファイルを生成します。この生成されたファイルをパッケージに含めるといふことは、パッケージディレクトリにパッケージを落とすことができ、ヘルプコマンドがすぐに動作することを意味します。プラグインヘルプを變更した後にコマンドを再實行することを忘れないでください。
</p><pre class="verbatim">:helptags path/start/foobar/doc
:helptags path/opt/fooextra/doc
</pre>

<span id="index-puraguinJian-noYi-Cun-Guan-Xi-"></span>
<span id="puraguinJian-noYi-Cun-Guan-Xi-"></span><h4 class="unnumberedsubsec">プラグイン閒の依存關係</h4>
<span id="packload_002dtwo_002dsteps"></span><span id="index-packload_002dtwo_002dsteps"></span>
<p>同じ機能に依存する 2 つのプラグインがあるとします。共通機能を autoload ディレクトリに置くことで、自動的に見つかるやうにすることができます。あなたのパッケージには次のファイルがあるとします。
</p>
<p>pack/foo/start/one/plugin/one.vim
</p><pre class="verbatim">call foolib#getit()
</pre><p>pack/foo/start/two/plugin/two.vim
</p><pre class="verbatim">call foolib#getit()
</pre><p>pack/foo/start/lib/autoload/foolib.vim
</p><pre class="verbatim">func foolib#getit()
</pre>
<p>これは動作します。なぜなら、パッケージをロードすると、プラグインを讀み込む前に見つかつたすべてのディレクトリが &rsquo;<samp>runtimepath</samp>&rsquo; に追加されるからです。
</p>
<span id="debug_002dscripts"></span><span id="index-debug_002dscripts"></span>
<span id="index-sukuriputonodebatugu"></span>
<span id="g_t7_002e-sukuriputonodebatugu"></span><h3 class="section">7. スクリプトのデバッグ</h3>

<p>スクリプトの動作を知るためのコードを追加することができるのは當り前として、Vim はデバッグモードを提供してゐます。これはスクリプトファイルやユーザーファンクションをステップ實行することやブレークポイントを仕掛けることを可能にします。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
デバッグモードは未完成です。デバッグは Vim の動作に副作用をあたえます。全てをデバッグするのには使へません。例へば畫面がデバッグメッセージで散亂するときなど。
</p></blockquote>

<p>デバッグモードの代はりに &rsquo;<samp>verbose</samp>&rsquo; オプションが使へます。大きな値を設定すると Vim の動作についてより詳細なメッセージを得られます。
</p>

<span id="debug_002dmode"></span><span id="index-debug_002dmode"></span>
<span id="index-debatugumodowoKai-Shi-suru"></span>
<span id="debatugumodowoKai-Shi-suru"></span><h4 class="unnumberedsubsec">デバッグモードを開始する</h4>

<p>デバッグモードを開始するにはこれらの方法のうちどれかを使ひます:
</p><ol>
<li> Vim を |<a href="starting_002etxt.html#g_t_002dD">-D</a>| 引數付きで起動します:
<pre class="verbatim">vim -D file.txt
</pre><p>最初に vimrc を讀み込むところからデバッグを開始します。これは Vim の起動時に何が起こつてゐるのかを調査するのに便利です。副作用として Vim は初期化が完了する前に安全のためターミナルモードを切替へる點があります。
</p>
<p>(Windows や Macintosh の) GUI 專用バージョンでは GUI ウィンドウを開くとすぐにデバッグが開始されます。これを早めるには <samp>vimrc</samp> ファイルに &quot;:gui&quot; と書いてください。
<span id="g_t_003adebug"></span></p></li><li> <span id="index-_003adebug"></span>
&quot;:debug&quot; を前に付けてコマンドを實行します。そのコマンドを實行する閒だけデバッグできます。特定のスクリプトファイルやユーザー函數をデバッグするのに便利です。自動コマンドから呼び出されるスクリプトや函數にも便利です。例:
<pre class="verbatim">:debug edit test.txt.gz
</pre>
</li><li> ブレークポイントをソースファイルやユーザーファンクションに設定します。コマンドラインから次のやうにできます:
<pre class="verbatim">vim -c &quot;breakadd file */explorer.vim&quot;
</pre><p>これは Vim を起動して &quot;explorer.vim&quot; の最初の行を讀み込むところで停止します。デバッグモード中でもブレークポイントを設定できます。
</p></li></ol>

<p>デバッグモード中に實行されるコマンドはそれが實行される前に表示されます。コメントや空の行、實行されない行は飛ばされます。行が &quot;|&quot; を使つて 2 つのコマンドを含んでゐた場合には分けて表示されます。
</p>

<span id="index-debatugumodo"></span>
<span id="debatugumodo"></span><h4 class="unnumberedsubsubsec">デバッグモード</h4>

<p>デバッグモードに入ると、通常の Ex コマンドが使へます。例へば、變數の値を見るには:
</p><pre class="verbatim">echo idx
</pre><p>ユーザーファンクション內では、これはローカル變數の &quot;idx&quot; を表示します。&quot;g:&quot; を頭に付けるとグローバル變數の値を表示します:
</p><pre class="verbatim">echo g:idx
</pre><p>全てのコマンドは實行中の函數やスクリプトの文脈として實行されます。オプションを設定することもできます。例へば何が起こつてゐるのかを表示するために &rsquo;<samp>verbose</samp>&rsquo; を設定することができます。興味のある部分を實行する前に次のやうにするといいでせう:
</p><pre class="verbatim">:set verbose=20
</pre>
<p>スクリーンの更新を必要とするコマンドは避けるべきです。なぜならデバッグモードを拔けるまでその作用に氣づき難いからです。例へば:
</p><pre class="verbatim">:help
</pre><p>これはとても不便です。
</p>
<p>デバッグモードのためのコマンドラインヒストリが別に用意されてゐます。
</p>
<p>函數の行番號はその函數の始まりから數へます。見てゐる行の番號を數へるのに苦勞する場合は、その函數の書かれたファイルを別の Vim で開き、その函數の始まりを探しだし、&quot;99j&quot; を實行してください。&quot;99&quot; は實際の行番號に合はせて變へてください。
</p>
<p>さらに、以下のコマンドが使へます:
<span id="g_t_003econt"></span><span id="index-_003econt"></span>
</p><dl compact="compact">
<dt>cont</dt>
<dd><p>次のブレークポイントまで實行します。
<span id="g_t_003equit"></span><span id="index-_003equit"></span>
</p></dd>
<dt>quit</dt>
<dd><p>異常停止します。これは <kbd>CTRL-C</kbd> を使ふことに似てゐますが、全てを停止するわけではありません。次のブレークポイントで停止します。
<span id="g_t_003enext"></span><span id="index-_003enext"></span>
</p></dd>
<dt>next</dt>
<dd><p>コマンドを實行しそれが終はるとデバッグモードに戾ります。ユーザー函數やソースファイルの呼び出し時には呼び出し元の次の行に進みます。
<span id="g_t_003estep"></span><span id="index-_003estep"></span>
</p></dd>
<dt>step</dt>
<dd><p>コマンドを實行しそれが終はるとデバッグモードに戾ります。ユーザー函數やソースファイルの呼び出し時には呼び出し先の行に進みます。
<span id="g_t_003einterrupt"></span><span id="index-_003einterrupt"></span>
</p></dd>
<dt>interrupt</dt>
<dd><p><kbd>CTRL-C</kbd> を使ふことに似てゐますが、次のコマンドを實行するためにデバッグモードに戾る場所が &quot;&gt;quit&quot; と違ひます。例外割り込みについて |<a href="eval_002etxt.html#g_t_003afinally">:finally</a>| や |<a href="eval_002etxt.html#g_t_003acatch">:catch</a>| をテストするのに便利です。
<span id="g_t_003efinish"></span><span id="index-_003efinish"></span>
</p></dd>
<dt>finish</dt>
<dd><p>實行中のスクリプトやユーザー函數を終了し呼び出し元でデバッグモードに戾ります。
<span id="g_t_003ebt"></span><span id="g_t_003ebacktrace"></span><span id="g_t_003ewhere"></span><span id="index-_003ebt"></span>
<span id="index-_003ebacktrace"></span>
<span id="index-_003ewhere"></span>
</p></dd>
<dt>backtrace or bt or where</dt>
<dd><p>現在のデバッグセッションの呼び出しスタックトレースを表示します。
<span id="g_t_003eframe"></span><span id="index-_003eframe"></span>
</p></dd>
<dt>frame N</dt>
<dd><p>N 番目のスタックフレームへ移動します。+ や - 記號で、相對的に移動できます。例へば、&quot;&lsquo;<samp>:frame +3</samp>&rsquo;&quot; で 3 つ上のスタックフレームへ移動します。
<span id="g_t_003eup"></span><span id="index-_003eup"></span>
</p></dd>
<dt>up</dt>
<dd><p>呼び出しスタックトレースを 1 つ上へ移動します。
<span id="g_t_003edown"></span><span id="index-_003edown"></span>
</p></dd>
<dt>down</dt>
<dd><p>呼び出しスタックトレースを 1 つ下へ移動します。
</p></dd>
</dl>

<p>デバッグモードのコマンドについて:
</p><ul>
<li> 補完はできません。通常の Ex コマンドのみ補完できます。
</li><li> コマンド名は、他のコマンドが同じ文字で始まらないところまで省略できます。&quot;f&quot; は &quot;finish&quot; なるので &quot;frame&quot; を省略するには &quot;fr&quot; を用ゐます。
</li><li> &lt;CR&gt; を押すと前囘のものを繰り返します。關係ないコマンドを使ふとリセットされます (どうすべきかがわかりにくいため)。
</li><li> 同じ名前の Ex コマンドを使ふにはコロンを付けてください: &quot;:cont&quot;, &quot;:next&quot;, &quot;:finish&quot; (省略時も)
</li></ul>

<p>バックトレースは、函數呼び出しの階層を表示します。例へば:
</p><pre class="verbatim">&gt;bt
  3 function One[3]
  2 Two[3]
-&gt;1 Three[3]
  0 Four
行 1: let four = 4
</pre>
<p>&quot;-&gt;&quot; は現在いるフレームを指します。&quot;up&quot;, &quot;down&quot;, &quot;frame N&quot; を使ふことで、別のフレームを選擇できます。
</p>
<p>現在いるフレームの、その函數內でのローカル變數にアクセスできます。現在いるフレームの、現在行の內容を表示する方法はまだありません。
</p>

<span id="index-burekupointonoDing-Yi-"></span>
<span id="burekupointonoDing-Yi-"></span><h4 class="unnumberedsubsubsec">ブレークポイントの定義</h4>
<span id="g_t_003abreaka"></span><span id="g_t_003abreakadd"></span><span id="index-_003abreaka"></span>
<span id="index-_003abreakadd"></span>
<dl compact="compact">
<dt>:breaka[dd] func [lnum] {name}</dt>
<dd><p>函數にブレークポイントを設定します。例:
</p><pre class="verbatim">:breakadd func Explore
</pre><p>函數名が妥當かどうか檢査をしないので、函數定義の前にブレークポイントを定義できます。
</p>
</dd>
<dt>:breaka[dd] file [lnum] {name}</dt>
<dd><p>ソースファイルにブレークポイントを設定します。例:
</p><pre class="verbatim">:breakadd file 43 .vimrc
</pre>
</dd>
<dt>:breaka[dd] here</dt>
<dd><p>カレントファイルのカレント行にブレークポイントを設定します。次を行ふのと同樣です:
</p><pre class="verbatim">:breakadd file &lt;cursor-line&gt; &lt;current-file&gt;
</pre><blockquote>
<p><strong>Note:</strong> <br>
これはファイルを讀み込むときに實行されるコマンドに對してだけ働き、そのファイル中で定義される函數に對しては働かないことに注意してください。
</p></blockquote>

</dd>
<dt>:breaka[dd] expr {expression}</dt>
<dd><p>{expression} の評價結果が異なる値となるときに、常にブレークするブレークポイントを設定します。例:
</p><pre class="verbatim">:breakadd expr g:lnum
</pre>
<p>これはグローバル變數の lnum が變化するときに常にブレークします。
</p><blockquote>
<p><strong>Note:</strong> <br>
|<a href="eval_002etxt.html#script_002dvariable">script-variable</a>| を監視する場合、スクリプトが切り替はつたときにブレークすることに注意してください。これは、定義されたスクリプト內でのみ、そのスクリプト變數が有效だからです。そしてそのスクリプトがいくつかのその他のスクリプトから呼び出される場合、その特定の變數が可視となつたとき、もしくは再度アクセス不能となつたときに常に停止します。
</p></blockquote>
</dd>
</dl>

<p>[lnum] はブレークポイントにする行番號です。Vim はその行かそれ以降で停止します。省略時すると 1 行目になります。
</p>
<span id="g_t_003adebug_002dname"></span><span id="index-_003adebug_002dname"></span>
<p>{name} はファイル名や函數名のパターンです。パターンは自動コマンドで使はれるものと同じです。完全に一致しなければなりません (パターンが &quot;^&quot; で始まつて &quot;$&quot; で終はるやうに)。&quot;*&quot; は全ての文字列に一致します。&rsquo;<samp>ignorecase</samp>&rsquo; は使はれませんが、大文字と小文字を區別しないために &quot;\c&quot; を使ふことができます |<a href="pattern_002etxt.html#g_t_002f_005cc">/\c</a>|。函數名には () を付けないやうに！
</p>
<p>ソースファイル名のパターン檢査はファイルのフルネームに對して行はれます。例:
</p><pre class="verbatim">breakadd file explorer
</pre><p>パスが閒違つてゐるので一致しません。
</p><pre class="verbatim">breakadd file *explorer.vim
</pre><p>&quot;.../plugin/explorer.vim&quot; と &quot;.../plugin/iexplorer.vim&quot; に一致します。
</p><pre class="verbatim">breakadd file */explorer.vim
</pre><p>&quot;.../plugin/explorer.vim&quot; だけに一致します。
</p>
<p>函數名のパターン檢査は &quot;<code>:function</code>&quot; で表示される名前に對して行はれます。ローカル函數には &quot;&lt;SNR&gt;99_&quot; といつたものが前に付くといふことです。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
函數はまづ讀み込まれ、後で實行されることに注意してください。讀み込まれたときに &quot;file&quot; ブレークポイントがチェックされ、實行されるときに &quot;func&quot; ブレークポイントがチェックされます。
</p></blockquote>


<span id="index-burekupointonoXue-Chu-"></span>
<span id="burekupointonoXue-Chu-"></span><h4 class="unnumberedsubsubsec">ブレークポイントの削除</h4>
<span id="g_t_003abreakd"></span><span id="g_t_003abreakdel"></span><span id="E161"></span><span id="index-_003abreakd"></span>
<span id="index-_003abreakdel"></span>
<span id="index-E161"></span>
<dl compact="compact">
<dt>:breakd[el] {nr}</dt>
<dd><p>ブレークポイント {nr} を削除します。|<a href="#g_t_003abreaklist">:breaklist</a>| を使つて番號を確認できます。
</p>
</dd>
<dt>:breakd[el] *</dt>
<dd><p>すべてのブレークポイントを削除します。
</p>
</dd>
<dt>:breakd[el] func [lnum] {name}</dt>
<dd><p>函數內のブレークポイントを削除します。
</p>
</dd>
<dt>:breakd[el] file [lnum] {name}</dt>
<dd><p>ソースファイル內のブレークポイントを削除します。
</p>
</dd>
<dt>:breakd[el] here</dt>
<dd><p>カレントファイルのカレント行のブレークポイントを削除します。
</p></dd>
</dl>

<p>[lnum] が省略されると函數、またはファイルの最初のブレークポイントが削除されます。{name} は &quot;<code>:breakadd</code>&quot; で使つた名前と完全に同じでなければなりません。&quot;explorer&quot; と &quot;*explorer.vim&quot;, &quot;*explorer*&quot; は違ひます。
</p>

<span id="index-burekupointowoLie-Ju-suru"></span>
<span id="burekupointowoLie-Ju-suru"></span><h4 class="unnumberedsubsubsec">ブレークポイントを列擧する</h4>
<span id="g_t_003abreakl"></span><span id="g_t_003abreaklist"></span><span id="index-_003abreakl"></span>
<span id="index-_003abreaklist"></span>
<dl compact="compact">
<dt>:breakl[ist]</dt>
<dd><p>全てのブレークポイントを列擧します。
</p></dd>
</dl>


<span id="index-sonoTa--2"></span>
<span id="sonoTa--2"></span><h4 class="unnumberedsubsubsec">その他</h4>

<span id="g_t_003adebugg"></span><span id="g_t_003adebuggreedy"></span><span id="index-_003adebugg"></span>
<span id="index-_003adebuggreedy"></span>
<dl compact="compact">
<dt>:debugg[reedy]</dt>
<dd><p>デバッグモードのコマンドをユーザーから直接得るのではなく標準入力から讀み込みます。スクリプトのテストのときに便利です。例:
</p><pre class="verbatim">echo 'q^Mq' | vim -e -s -c debuggreedy -c 'breakadd file script.vim' -S script.vim
</pre>
</dd>
<dt>:0debugg[reedy]</dt>
<dd><p>&quot;<code>:debuggreedy</code>&quot; を取り消します。それ以降のデバッグモードコマンドを使はず、ユーザーから直接デバッグモードコマンドを受け取ります。
</p></dd>
</dl>

<span id="profile"></span><span id="profiling"></span><span id="index-profile"></span>
<span id="index-profiling"></span>
<span id="index-purohuairingu"></span>
<span id="g_t8_002e-purohuairingu"></span><h3 class="section">8. プロファイリング</h3>

<p>プロファイリングとは、函數やスクリプトの實行にかかる時閒を計測することです。これを行ふには |<a href="various_002etxt.html#g_t_002bprofile">+profile</a>| 機能が必要です。この機能は &quot;huge&quot; 機能つきでコンパイルしたときだけ含まれます。
</p>
<p>また、函數 |<a href="eval_002etxt.html#reltime_0028_0029">reltime()</a>| を使つても時閒を計測できます。この函數には |<a href="various_002etxt.html#g_t_002breltime">+reltime</a>| 機能だけが必要です。これは &quot;huge&quot; 以外でもしばしばついてきます。
</p>
<p>シンタックスハイライトのプロファイリングについては |<a href="syntax_002etxt.html#g_t_003asyntime">:syntime</a>| を參照してください。
</p>
<p>例へば、one_script.vim スクリプトファイルをプロファイリングするには:
</p><pre class="verbatim">:profile start /tmp/one_script_profile
:profile file one_script.vim
:source one_script.vim
:exit
</pre>

<span id="g_t_003aprof"></span><span id="g_t_003aprofile"></span><span id="E750"></span><span id="index-_003aprof"></span>
<span id="index-_003aprofile"></span>
<span id="index-E750"></span>
<dl compact="compact">
<dt>:prof[ile] start {fname}</dt>
<dd><p>プロファイリングを開始し、終了時に出力を {fname} に出力します。{fname} 中の &quot;~/&quot; や環境變數は展開されます。{fname} がすでに存在するときは、警告なしに上書きされます。變數 |<a href="eval_002etxt.html#v_003aprofiling">v:profiling</a>| に 1 が代入されます。
</p>
</dd>
<dt>:prof[ile] pause</dt>
<dd><p>次項の &quot;:profile pause&quot; が實行されるまでプロファイリングをしません。カウントされるべきでない何かを行ふ時に使ふことができます (例へば外部コマンドなど)。ネストすることはできません。
</p>
</dd>
<dt>:prof[ile] continue</dt>
<dd><p>&quot;:profile pause&quot; の後にこれを實行すると、プロファイリングを再開します。
</p>
</dd>
<dt>:prof[ile] func {pattern}</dt>
<dd><p>パターン {pattern} にマッチする函數をプロファイリングします。{pattern} がどう使はれるかは |<a href="#g_t_003adebug_002dname">:debug-name</a>| を參照してください。
</p>
</dd>
<dt>:prof[ile][!] file {pattern}</dt>
<dd><p>パターン {pattern} にマッチするスクリプトファイルをプロファイリングします。{pattern} がどう使はれるかは |<a href="#g_t_003adebug_002dname">:debug-name</a>| を參照してください。このコマンドはスクリプトそのものをプロファイリングするだけで、その中で定義されてゐる函數のプロファイリングは行ひません。
</p>
<p>[!] がつけられたときは、そのスクリプト中で定義されてゐる全ての函數のプロファイリングも行ひます。
</p><blockquote>
<p><strong>Note:</strong> <br>
スクリプトがこのコマンドの後で讀み込まれたときだけ、そのプロファイリングは始まることに注意してください。スクリプト自身にある <code>:profile</code> コマンドは働きません。
</p></blockquote>


<span id="g_t_003aprofd"></span><span id="g_t_003aprofdel"></span><span id="index-_003aprofd"></span>
<span id="index-_003aprofdel"></span>
</dd>
<dt>:profd[el] ...</dt>
<dd><p>指定された引數に對するプロファイリングを停止します。引數については |<a href="#g_t_003abreakdel">:breakdel</a>| を參照してください。
</p></dd>
</dl>


<p>最初は常に &quot;&lsquo;<samp>:profile start fname</samp>&rsquo;&quot; コマンドで始めなければなりません。結果のファイルは Vim が終了するときに書き出されます。次に出力の例を擧げます。說明のために行番號が行頭についてゐます:
</p>
<pre class="verbatim">1 FUNCTION  Test2()
2 Called 1 time
3 Total time:   0.155251
4  Self time:   0.002006
5
6 count  total (s)   self (s)
7     9              0.000096   for i in range(8)
8     8   0.153655   0.000410     call Test3()
9     8              0.000070   endfor
10                              &quot; Ask a question
11    1              0.001341   echo input(&quot;give me an answer: &quot;)
</pre>
<p>ヘッダー (1 行目から 4 行目) は函數全體にかかつた時閒を示してゐます。&quot;Total&quot; はこの函數を實行してゐる閒に經過した時閒です。&quot;Self&quot; は &quot;Total&quot; のうち、次のことにかかつた時閒を引いたものです:
</p><ul>
<li> 他のユーザー定義函數
</li><li> スクリプトの讀み込み
</li><li> 自動コマンドの實行
</li><li> 外部 (シェル) プログラム
</li></ul>

<p>7 行目から 11 行目は各實行行にかかつた時閒を示してゐます。實行されない行はカウントされません。それゆゑ、コメント行は決してカウントされません。
</p>
<p>Count の桁はその行が何囘實行されたかを示します。7 行目の &quot;for&quot; コマンドはそれ以下の行と同樣に何囘も實行されることに注意してください。これは、ループの終はりを檢出するためにこの行が何囘も實行されるためです。
</p>
<p>ユーザー入力待ちにかかつた時閒は一切カウントされません。それゆゑ、input() のプロンプトに反應するのにどれだけ時閒がかからうとも無關係です。
</p>
<p>プロファイリングはどこで時閒が費やされたかのよい指標を與へてくれますが、多くの原因によりその結果がごまかされてしまふ場合があるといふことを覺えておいてください:
</p>
<ul>
<li> システム函數 gettimeofday() に依存する時閒計測の精度。たとへ時閒がマイクロ秒で表示されてゐたとしても、1/100 秒の精度しかないこともあります。

</li><li> 實經過時閒が計測されます。他のプロセスがビジーであると、それが豫測できない箇所で遲れを引き起こす可能性があります。

</li><li> 1 行に複數のコマンドを書いてゐると、1 つの時閒しか得られません。ここのコマンドに對して時閒を見るにはその行を分割してください。

</li><li> 各行の時閒の總和をとると、たいてい函數全體の時閒より小さくなります。各行の閒にオーバーヘッドがあります。

</li><li> Vim が終了する前に削除された函數は、プロファイリング情報を生成しません。必要なら變數 |<a href="eval_002etxt.html#v_003aprofiling">v:profiling</a>| をチェックしてください:
<pre class="verbatim">:if !v:profiling
:   delfunc MyFunc
:endif
</pre></li><li> マルチプロセッサーシステム上では、スリープモードが作動したときや、省力のためプロセッサーの周波數が下がつたとき、プロファイリングが奇妙な結果を出すかもしれません。

</li><li> 函數が再歸的に呼ばれた場合、&quot;self&quot; 時閒は正しくありません。
</li></ul>


<hr>
<div class="header">
<p>
Up: <a href="Mu-Ci-.html" accesskey="u" rel="up">目次</a> &nbsp; [<a href="Indexes-CP.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
