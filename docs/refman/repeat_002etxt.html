<!DOCTYPE html>
<html lang="ja">
<!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ -->
<head>

<title>repeat.txt (Vim Reference Manual)</title>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<meta name="description" content="repeat.txt (Vim Reference Manual)">
<meta name="keywords" content="repeat.txt (Vim Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<link href="Mu-Ci-.html#g_t_76ee_6b21" rel="start" title="目次">
<link href="Indexes-CP.html#Indexes-CP" rel="index" title="Indexes CP">
<link href="Mu-Ci-.html#g_t_76ee_6b21" rel="up" title="目次">
<link href="visual_002etxt.html#visual_002etxt" rel="next" title="visual.txt">
<link href="undo_002etxt.html#undo_002etxt" rel="prev" title="undo.txt">
<style>
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="style.css">


</head>

<body lang="ja">
<a name="repeat_002etxt"></a>
<div class="header">
<p>
Up: <a href="Mu-Ci-.html#g_t_76ee_6b21" accesskey="u" rel="up">目次</a> &nbsp; [<a href="Indexes-CP.html#Indexes-CP" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Zao-riFan-sikomando_002c-Vim-script_002c-sukuriputonodebatugu"></a>
<h2 class="unnumbered">繰り返しコマンド、Vim script、スクリプトのデバッグ</h2>
<pre class="verbatim">*repeat.txt*    For Vim バージョン 8.1.  Last change: 2019 Jun 14


		  VIMリファレンスマニュアル    by Bram Moolenaar
</pre>

<a name="repeating"></a><a name="index-repeating"></a>
<p>繰り返しコマンド、Vim script とデバッグ
</p>
<p>繰り返しについてはユーザーマニュアルの 26 章 |<a href="usr_005f26_002etxt.html#usr_005f26_002etxt">usr_26.txt</a>| に紹介がある。
</p>
<table>
<tr><td width="50%">1. 單發繰り返し</td><td width="50%">|<a href="#single_002drepeat">single-repeat</a>|</td></tr>
<tr><td width="50%">2. 多重繰り返し</td><td width="50%">|<a href="#multi_002drepeat">multi-repeat</a>|</td></tr>
<tr><td width="50%">3. 複雜な繰り返し</td><td width="50%">|<a href="#complex_002drepeat">complex-repeat</a>|</td></tr>
<tr><td width="50%">4. Vim script を使ふ</td><td width="50%">|<a href="#using_002dscripts">using-scripts</a>|</td></tr>
<tr><td width="50%">5. Vimパッケージを使ふ</td><td width="50%">|<a href="#packages">packages</a>|</td></tr>
<tr><td width="50%">6. Vimパッケージを作る</td><td width="50%">|<a href="#package_002dcreate">package-create</a>|</td></tr>
<tr><td width="50%">7. スクリプトのデバッグ</td><td width="50%">|<a href="#debug_002dscripts">debug-scripts</a>|</td></tr>
<tr><td width="50%">8. プロファイリング</td><td width="50%">|<a href="#profiling">profiling</a>|</td></tr>
</table>

<a name="single_002drepeat"></a><a name="index-single_002drepeat"></a>
<a name="index-Dan-Fa-Zao-riFan-si"></a>
<a name="g_t1_002e-Dan-Fa-Zao-riFan-si"></a>
<h3 class="section">1. 單發繰り返し</h3>

<a name="g_t_002e"></a><a name="index-_002e"></a>
<dl compact="compact">
<dt>.</dt>
<dd><p>最後の變更を繰り返す。變更の回數は [count] で指定した回數で置き換へられる。&rsquo;<samp>cpoptions</samp>&rsquo; に &rsquo;<var>y</var>&rsquo; フラグが含まれてる時には、ヤンクコマンドも繰り返す。コマンドラインコマンドは繰り返さない。
</p></dd>
</dl>

<p>單純な變更は &quot;.&quot; コマンドで繰り返すことができる。回數を指定しなければ、最後の變更の回數が使用される。回數を指定した場合、最後のそれと置き換へられる。|<a href="eval_002etxt.html#v_003acount">v:count</a>| と |<a href="eval_002etxt.html#v_003acount1">v:count1</a>| が設定される。
</p>
<p>最後に行はれた變更が番號付きレジスタの指定を含んでゐた場合、レジスタ番號は增加される。これをどのやうに使ふかの例は |<a href="undo_002etxt.html#redo_002dregister">redo-register</a>| を參照。
</p>
<p>ビジュアル選擇を使用したコマンドを繰り返す時は、同じ「サイズ」の範圍が使用されることに注意。|<a href="visual_002etxt.html#visual_002drepeat">visual-repeat</a>| を參照。
</p>
<a name="g_t_0040_003a"></a><a name="index-_0040_003a"></a>
<dl compact="compact">
<dt>@:</dt>
<dd><p>最後のコマンドラインを [count] 回繰り返す。
</p>
<p>{|<a href="various_002etxt.html#g_t_002bcmdline_005fhist">+cmdline_hist</a>| が無效にされてゐると使へない}
</p></dd>
</dl>


<a name="multi_002drepeat"></a><a name="index-multi_002drepeat"></a>
<a name="index-Duo-Zhong-Zao-riFan-si"></a>
<a name="g_t2_002e-Duo-Zhong-Zao-riFan-si"></a>
<h3 class="section">2. 多重繰り返し</h3>

<a name="g_t_003ag"></a><a name="g_t_003aglobal"></a><a name="E148"></a><a name="index-_003ag"></a>
<a name="index-_003aglobal"></a>
<a name="index-E148"></a>
<dl compact="compact">
<dt>:[range]g[lobal]/{pattern}/[cmd]</dt>
<dd><p>[range] の範圍で {pattern} にマッチする行に對して、Ex コマンド [cmd] (省略した場合 &quot;:p&quot;) を實行する。
</p>
</dd>
<dt>:[range]g[lobal]!/{pattern}/[cmd]</dt>
<dd><p>[range] の範圍で {pattern} にマッチしない行に對して、Ex コマンド [cmd] (省略した場合 &quot;:p&quot;) を實行する。
</p>
<a name="g_t_003av"></a><a name="g_t_003avglobal"></a><a name="index-_003av"></a>
<a name="index-_003avglobal"></a>
</dd>
<dt>:[range]v[global]/{pattern}/[cmd]</dt>
<dd><p>:g! と同じ。
</p></dd>
</dl>

<p>{pattern} の兩側の &rsquo;/&rsquo; の代はりにどんなシングルバイト文字でも使ふことができる。しかしアルファベット、&rsquo;\&rsquo;、&rsquo;&quot;&rsquo;、&rsquo;|&rsquo; は使へない。これは、檢索パターンや置換文字列に &rsquo;/&rsquo; が含まれる場合に便利である。
</p>
<p>パターンの定義については |<a href="pattern_002etxt.html#pattern">pattern</a>| を參照。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
[cmd] は範圍指定を含むかもしれない。實例は |<a href="tips_002etxt.html#collapse">collapse</a>| や |<a href="usr_005f25_002etxt.html#edit_002dparagraph_002djoin">edit-paragraph-join</a>| を參照。
</p></blockquote>

<p>global コマンドの動作はまず第 1 に [range] の行をスキャンしマッチした行すべてに印をつける (複數行にかかるパターンではマッチの最初の行だけが重要である)。
</p>
<p>次のスキャンでマークされたすべての行について、カーソルがその行にあるかのやうに [cmd] が實行される。&quot;:v&quot; と &quot;:g!&quot; の場合は、マークされてゐないすべての行についてコマンドが實行される。行が削除された場合そのマークは消滅する。
</p>
<p>省略した場合の [range] はバッファ全體 (1,$) である。コマンドを中斷するには &quot;<kbd>CTRL-C</kbd>&quot; を使用する。ある行についてエラーメッセージが與へられると、そのラインに對するコマンドは中斷され global コマンドはマッチした次の行の處理を續ける。
</p>
<a name="E147"></a><a name="index-E147"></a>
<p>このコマンドが再歸的に使はれるとき、それは一行のみに働く。この時は範圍の指定は許されてゐない。これはあるパターンにマッチして別のパターンにマッチしない行を見つけるのに便利だ:
</p><pre class="verbatim">:g/found/v/notfound/{cmd}
</pre><p>これは、はじめに &quot;found&quot; を含むすべての行を見つけるが、&quot;notfound&quot; にマッチしないものがあるときにだけ {cmd} を實行する。
</p>
<p>非 Ex コマンドを實行するには &lsquo;<code>:normal</code>&lsquo; コマンドを使用すれば良い:
</p><pre class="verbatim">:g/pat/normal {commands}
</pre><p>確實に {commands} が完全なコマンドとして終了するやうにすること。さうでないと Vim は全部のマッチに 1 つ 1 つについて、コマンドの殘りを期待して貴方の入力を待ち續けるだらう。畫面は更新されないので、いま何をしてゐるのかわからないだらう。|<a href="various_002etxt.html#g_t_003anormal">:normal</a>| を參照。
</p>
<p>undo/redo コマンドは global コマンドを一度に undo/redo する。以前の文脈マークだけが一度設定される (&quot;&rdquo;&quot; でグローバルコマンド實行前にカーソルがあつた場所に戾ることができる)。
</p>
<p>global コマンドは最後に使用した檢索パターンと、最後に使用した置換パターンの兩方を設定する (これは vi 互換)。これにより全體に對して文字列置換を行ふのが簡單になる:
</p><pre class="verbatim">:g/pat/s//PAT/g
</pre><p>これは全ての &quot;pat&quot; を &quot;PAT&quot; に置き換へる。同じことがこれでも可能:
</p><pre class="verbatim">:%s/pat/PAT/g
</pre><p>こつちのはうが 2 文字短い！
</p>
<p>Ex モード中で &quot;global&quot; を使ひ、そのコマンドに &quot;<code>:visual</code>&quot; を指定する場合はやや特殊である。これを行ふと、マッチする行へ移動してノーマルモードに入るので、|<a href="intro_002etxt.html#Q">Q</a>| を押して Ex モードへ戾るまでコマンドを實行することができる。これがマッチする各行に對して繰り返される。これを行つてゐる閒は &quot;:global&quot; を使ふことはできない。中止するには <kbd>CTRL-C</kbd> を 2 回押すこと。
</p>
<a name="complex_002drepeat"></a><a name="index-complex_002drepeat"></a>
<a name="index-Fu-Za-naZao-riFan-si"></a>
<a name="g_t3_002e-Fu-Za-naZao-riFan-si"></a>
<h3 class="section">3. 複雜な繰り返し</h3>

<a name="q"></a><a name="recording"></a><a name="index-q"></a>
<a name="index-recording"></a>
<dl compact="compact">
<dt>q{0-9a-zA-Z&quot;}</dt>
<dd><p>タイプした文字をレジスタ {0-9a-zA-Z&quot;} にレコーディングする (大文字なら追記)。レジスタを實行中は &rsquo;<code>q</code>&rsquo; コマンドは無效化される。マッピングや |<a href="various_002etxt.html#g_t_003anormal">:normal</a>| の中でも機能しない。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
もしレコーディングに使つてゐるレジスタが、その最中に |<a href="change_002etxt.html#y">y</a>| や |<a href="change_002etxt.html#p">p</a>| で使はれた場合、恐らく期待しない結果になるだらう。なぜなら、|<a href="change_002etxt.html#p">p</a>| で貼り付けられる內容は記錄されたマクロのものになり、|<a href="change_002etxt.html#y">y</a>| でコピーを行ふと記錄されたマクロを上書きしてしまふからである。
</p></blockquote>

</dd>
<dt>q</dt>
<dd><p>レコーディングを終了する。(實裝のメモ: レコーディングを終了する &rsquo;q&rsquo; は、それがマッピングの結果であつてもレジスタに記錄されない)
</p>
<a name="g_t_0040"></a><a name="index-_0040"></a>
</dd>
<dt>@{0-9a-z&quot;.=*+}</dt>
<dd><p>レジスタ {0-9a-z&quot;.=*+} の內容を [count] 回實行する。
</p><blockquote>
<p><strong>Note:</strong> <br>
レジスタ &rsquo;%&rsquo; (現在のファイルの名前) と &rsquo;#&rsquo; (オルタネートファイルの名前) は使用できない。
</p></blockquote>
<p>レジスタはマッピングと同樣に實行される。つまり、&rsquo;<samp>wildchar</samp>&rsquo; と &rsquo;<samp>wildcharm</samp>&rsquo; の違ひが動作に影響する。&quot;@=&quot; を使用すると式を入力するためのプロンプトが表示され、そこに入力した式の評價結果が實行される。|<a href="#g_t_0040_003a">@:</a>| も參照。
</p>
<a name="g_t_0040_0040"></a><a name="E748"></a><a name="index-_0040_0040"></a>
<a name="index-E748"></a>
</dd>
<dt>@@</dt>
<dd><p>直前の @{0-9a-z&quot;:*} を [count] 回繰り返す。
</p>
<a name="g_t_003a_0040"></a><a name="g_t_003astar"></a><a name="index-_003a_0040"></a>
<a name="index-_003a_002a"></a>
</dd>
<dt>:[addr]*{0-9a-z&quot;.=+}</dt>
<dt>:[addr]@{0-9a-z&quot;.=*+}</dt>
<dd><p>レジスタ {0-9a-z&quot;.=*+} の內容を Ex コマンドとして實行する。まづ最初にカーソルを [addr] 行に設定する (省略した場合現在の行)。レジスタの最終行に &lt;CR&gt; が含まれない場合、&rsquo;<samp>cpoptions</samp>&rsquo; に &rsquo;<var>e</var>&rsquo; フラグが含まれてゐれば自動的に追加される。
</p><blockquote>
<p><strong>Note:</strong> <br>
&quot;<code>:*</code>&quot; コマンドは &rsquo;<samp>cpoptions</samp>&rsquo; に &rsquo;<var>*</var>&rsquo; フラグが含まれてゐた場合にだけ認識されることに留意。これは &rsquo;<samp>nocompatible</samp>&rsquo; が使用されてゐる時にはデフォルトにはならない。
</p></blockquote>
<p>&quot;:@=&quot; には最後に評價された式が使用される。式の評價結果が Ex コマンドとして實行される。これらのコマンド內ではマッピングは行はれない。
</p>
<p>將來: 指定された範圍の各々の行に對してレジスタの內容が實行されるだらう。
</p>
<a name="g_t_003a_0040_003a"></a><a name="index-_003a_0040_003a"></a>
</dd>
<dt>:[addr]@:</dt>
<dd><p>最後のコマンドラインを繰り返す。まづカーソルを [addr] 行に設定する (省略した場合現在の行)。
</p>
<a name="g_t_003a_0040_0040"></a><a name="index-_003a_0040_0040"></a>
</dd>
<dt>:[addr]@ or :[addr]@@</dt>
<dd><p>最後の :@{0-9a-z&quot;} を繰り返す。まづ最初にカーソルを [addr] 行に設定する (省略した場合現在の行)。
</p></dd>
</dl>

<a name="using_002dscripts"></a><a name="index-using_002dscripts"></a>
<a name="index-Vim-script-woShi-u"></a>
<a name="g_t4_002e-Vim-script-woShi-u"></a>
<h3 class="section">4. Vim script を使ふ</h3>

<p>Vim script の書き方はユーザーマニュアルの 41 章 |<a href="usr_005f41_002etxt.html#usr_005f41_002etxt">usr_41.txt</a>| を參照。
</p>
<a name="g_t_003aso"></a><a name="g_t_003asource"></a><a name="load_002dvim_002dscript"></a><a name="index-_003aso"></a>
<a name="index-_003asource"></a>
<a name="index-load_002dvim_002dscript"></a>
<dl compact="compact">
<dt>:so[urce] {file}</dt>
<dd><p>Ex コマンドを {file} から讀み込む。これは &quot;:&quot; で始まるコマンドを列擧したファイルである。{譯注: 實際に &quot;:&quot; を書く必要はない}
</p>
<p>自動コマンド |<a href="autocmd_002etxt.html#SourcePre">SourcePre</a>| が發生する。
<a name="g_t_003asource_0021"></a><a name="index-_003asource_0021"></a>
</p></dd>
<dt>:so[urce]! {file}</dt>
<dd><p>Vim コマンドを {file} から讀み込む。ノーマルモードでファイルの內容をあなたがタイプしたのと同じやうに實行される。
</p>
<p>|<a href="#g_t_003aglobal">:global</a>|, |<a href="editing_002etxt.html#g_t_003aargdo">:argdo</a>|, |<a href="windows_002etxt.html#g_t_003awindo">:windo</a>|, |<a href="windows_002etxt.html#g_t_003abufdo">:bufdo</a>| で使つたとき、ループ中や他のコマンドが續けられたときは、コマンドの實行中は表示は更新されない。
</p>
<p>|<a href="eval_002etxt.html#sandbox">sandbox</a>| 內では使用できない。
</p>
<a name="g_t_003aru"></a><a name="g_t_003aruntime"></a><a name="index-_003aru"></a>
<a name="index-_003aruntime"></a>
</dd>
<dt>:ru[ntime][!] [where] {file} ..</dt>
<dd><p>&rsquo;<samp>runtimepath</samp>&rsquo; か &rsquo;<samp>packpath</samp>&rsquo; で示された各ディレクトリの {file}から Ex コマンドを讀み込む。ファイルがなくてもエラーにはならない。
</p>			
<p>例:
</p><pre class="verbatim">:runtime syntax/c.vim
</pre>
<p>{file} には空白で區切つて複數のファイルを指定できる。指定された {file} は &rsquo;<samp>runtimepath</samp>&rsquo; の最初のディレクトリ、次に 2 番目のディレクトリ、と檢索される。{file} に空白を含めるにはバックスラッシュを使ふ (しかしファイル名に空白を含めるのは望ましくない。トラブルのもとである)。
</p>
<p>[!] を付けると見つかつた全てのファイルを讀み込む。付けなければ最初に見つかつたファイルだけを讀み込む。
</p>
<p>[where] が省略された場合は &rsquo;<samp>runtimepath</samp>&rsquo; が使はれる。
</p>
<p>他の値は以下の通り:
</p><table>
<tr><td width="15%">START</td><td width="85%">&rsquo;<samp>packpath</samp>&rsquo; の &quot;<var>start</var>&quot; ディレクトリ以下を檢索する</td></tr>
<tr><td width="15%">OPT</td><td width="85%">&rsquo;<samp>packpath</samp>&rsquo; の &quot;<var>opt</var>&quot; ディレクトリ以下を檢索する</td></tr>
<tr><td width="15%">PACK</td><td width="85%">&rsquo;<samp>packpath</samp>&rsquo; の &quot;<var>start</var>&quot; と &quot;<var>opt</var>&quot; ディレクトリ以下を檢索する</td></tr>
<tr><td width="15%">ALL</td><td width="85%">まず &rsquo;<samp>runtimepath</samp>&rsquo; が使はれ、次に &rsquo;<samp>packpath</samp>&rsquo; の &quot;<var>start</var>&quot; と &quot;<var>opt</var>&quot; ディレクトリ以下を檢索する</td></tr>
</table>

<p>{file} がワイルドカードを含んでゐるとそれは展開される。例:
</p><pre class="verbatim">:runtime! plugin/*.vim
</pre><p>これは Vim が起動時にプラグインファイルを讀み込むのに使つてゐるものである。次のは似てゐるが:
</p><pre class="verbatim">:runtime plugin/*.vim
</pre><p>これは最初に見つかつたファイルだけを讀み込む。
</p>
<p>&rsquo;<samp>verbose</samp>&rsquo; が 1 以上ならファイルが見つからないときにメッセージが表示される。&rsquo;<samp>verbose</samp>&rsquo; が 2 以上なら見つかつた全てのファイルについてメッセージが表示される。
</p>
<a name="g_t_003apa"></a><a name="g_t_003apackadd"></a><a name="E919"></a><a name="index-_003apa"></a>
<a name="index-_003apackadd"></a>
<a name="index-E919"></a>
</dd>
<dt>:pa[ckadd][!] {name}</dt>
<dd><p>&rsquo;<samp>packpath</samp>&rsquo; 中の任意のプラグインディレクトリを檢索し、見つかつたプラグインのファイルを讀み込む。ディレクトリは以下にマッチしなければならない:
</p><pre class="verbatim">pack/*/opt/{name} ~
</pre><p>見つかつたディレクトリは、もし含まれてゐなければ &rsquo;<samp>runtimepath</samp>&rsquo; に追加される。もしディレクトリ &lsquo;<samp>pack/*/opt/{name}/after</samp>&rsquo; が存在すれば、&rsquo;<samp>runtimepath</samp>&rsquo; の最後に追加される。
</p>
<p>もしディレクトリ &quot;pack/*/start&quot; からのパッケージ讀み込みがスキップされた場合、次のディレクトリが最初に檢索される:
</p><pre class="verbatim">pack/*/start/{name}
</pre>
<blockquote>
<p><strong>Note:</strong> <br>
{name} はディレクトリの名前である。.vim ファイルの名前ではない。以下のパターンにマッチする全てのファイルが讀み込まれる。
</p><pre class="verbatim">pack/*/opt/{name}/plugin/**/*.vim
</pre><p>これにより、ちやうど &rsquo;<samp>runtimepath</samp>&rsquo; 內のプラグインのやうに、&quot;plugin&quot; 以下のサブディレクトリを使ふことができる。
</p></blockquote>

<p>ファイルタイプの檢知が有效化されてゐない場合 (これは通常 .vimrc 中の &quot;syntax enable&quot; か &quot;filetype on&quot; コマンドにより行はれる)、&quot;{name}/ftdetect/*.vim&quot; ファイルを參照する。
</p>
<p>任意の ! が付けられた場合、プラグインのファイルや ftdetect のスクリプトは讀み込まれず、マッチしたディレクトリのみ &rsquo;<samp>runtimepath</samp>&rsquo; に追加される。これは .vimrc に書く場合は便利である。追加されたプラグインは初期化時に讀み込まれる。|<a href="starting_002etxt.html#load_002dplugins">load-plugins</a>| を參照。
</p>
<p>また |<a href="#pack_002dadd">pack-add</a>| も參照。
</p>
<p>{|<a href="various_002etxt.html#g_t_002beval">+eval</a>| 機能付きでコンパイルされたときのみ有效}
</p>
<a name="g_t_003apackl"></a><a name="g_t_003apackloadall"></a><a name="index-_003apackl"></a>
<a name="index-_003apackloadall"></a>
</dd>
<dt>:packl[oadall][!]</dt>
<dd><p>&rsquo;<samp>packpath</samp>&rsquo; 以下の &quot;start&quot; ディレクトリ中の全パッケージを讀み込む。
</p>			
<p>最初に、見つかつたディレクトリが全て &rsquo;<samp>runtimepath</samp>&rsquo; に追加され、次にそのディレクトリ內で見つかつたプラグインが讀み込まれる。これにより、あるプラグインが別のプラグインの何か、例へば &quot;autoload&quot; ディレクトリに依存することが許可される。これがどのやうに役立つかは |<a href="#packload_002dtwo_002dsteps">packload-two-steps</a>| を參照。
</p>
<p>これは通常起動時に .vimrc が讀み込まれた後に自動的に行はれる。このコマンドはそれよりも前に行ふことができる。
</p>
<p>パッケージの讀み込みは一度だけ行はれる。&lsquo;<code>:packloadall</code>&lsquo; を再度使用しても效果はない。任意の ! が付けられた場合はすでに讀み込みが行はれてゐてもパッケージを讀み込む。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
|<a href="starting_002etxt.html#vimrc">vimrc</a>| ファイル內に &lsquo;<code>:packloadall</code>&lsquo; が使はれてゐる場合、&rsquo;<samp>runtimepath</samp>&rsquo; オプションが更新され、後で &rsquo;<samp>runtimepath</samp>&rsquo; 內のすべてのプラグインが讀み込まれることに注意。これはそれらが再び讀み込まれることを意味する。プラグインはそれを正しく扱ふことが期待される。
</p></blockquote>

<p>(スクリプトを讀み込む際の) エラーは讀み込んでゐるスクリプトの讀み込みのみを中止させる。その他のプラグインは讀み込まれる。|<a href="#packages">packages</a>| を參照。
</p>
<p>{|<a href="various_002etxt.html#g_t_002beval">+eval</a>| 機能付きでコンパイルされたときのみ有效}
</p>
<a name="g_t_003ascripte"></a><a name="g_t_003ascriptencoding"></a><a name="E167"></a><a name="index-_003ascripte"></a>
<a name="index-_003ascriptencoding"></a>
<a name="index-E167"></a>
</dd>
<dt>:scripte[ncoding] [encoding]</dt>
<dd><p>スクリプトで使はれてゐる文字コードを宣言する。それ以降の行は必要なら [encoding] から &rsquo;<samp>encoding</samp>&rsquo; オプションの文字コードに變換される。例:
</p><pre class="verbatim">scriptencoding iso-8859-5
scriptencoding cp932
</pre><p>[encoding] が空のときは變換はされない。これはそれ以降の行の文字コードの變換を限定するために使へる:
</p><pre class="verbatim">scriptencoding euc-jp
... 變換される ...
scriptencoding
... 變換されない ...
</pre>
<p>變換がシステムによつて提供されない場合、エラーメッセージは表示されず變換もされない。ある行が變換できなかつた場合、エラーにはならず元の行が保持される。
</p>
<p>&quot;ucs-2&quot; や &quot;ucs-4&quot; を使はないこと。スクリプトをその文字コードで書くことはできない (NULバイトが含まれてしまふため)。スクリプトの最初に utf-8 の BOM (Byte Order Mark: バイトオーダーマーク) があると Vim はそれを認識する。&quot;:scriptencoding utf-8&quot; と書く必要はない。
</p>
<p>|<a href="starting_002etxt.html#g_t_002evimrc">.vimrc</a>| の中で &rsquo;<samp>encoding</samp>&rsquo; オプションを設定してゐる場合は、&lsquo;:scriptencoding&lsquo; はそれよりも後に置かなければならない。例:
</p><pre class="verbatim">set encoding=utf-8
scriptencoding utf-8
</pre>
</dd>
<dt>:scriptv[ersion] {version}</dt>
<dd><a name="g_t_003ascriptv"></a><a name="g_t_003ascriptversion"></a><a name="index-_003ascriptv"></a>
<a name="index-_003ascriptversion"></a>
<a name="E999"></a><a name="E984"></a><a name="index-E999"></a>
<a name="index-E984"></a>
<p>同じファイルの後に續く行の Vim のバージョンを指定する。讀み込まれるスクリプトのトップレベルにのみ適用され、函數內部には適用されない。
</p>
<p>{version} が現在の Vim のバージョンがサポートしてゐるものよりも高い場合は E999 が與へられる。スクリプトを古い Vim バージョンで動作するやうに書き直すか、または Vim を新しいバージョンに更新する必要がある。バージョン閒の變更點については |<a href="eval_002etxt.html#vimscript_002dversion">vimscript-version</a>| を參照。
</p>
<a name="g_t_003ascr"></a><a name="g_t_003ascriptnames"></a><a name="index-_003ascr"></a>
<a name="index-_003ascriptnames"></a>
</dd>
<dt>:scr[iptnames]</dt>
<dd><p>讀み込まれてゐるスクリプトを讀み込まれた順番どほりに全て表示する。數字はスクリプトの ID (識別子) |<a href="map_002etxt.html#g_t_003cSID_003e">&lt;SID&gt;</a>| に使はれてゐる。
</p>
<p>{|<a href="various_002etxt.html#g_t_002beval">+eval</a>| 付きでコンパイルしないと使へない}
</p>
<a name="g_t_003ascript"></a><a name="index-_003ascript"></a>
</dd>
<dt>:scr[iptnames][!] {scriptId}</dt>
<dd><p>スクリプト {scriptId} を編輯する。&quot;<code>:scriptnames name</code>&quot; は動作するが、&quot;<code>:script name</code>&quot; を使用することを推奬する。カレントファイルを抛棄 |<a href="editing_002etxt.html#abandon">abandon</a>| できず、[!] も付けられてゐないときは、コマンドは失敗する。
</p>
<a name="g_t_003afini"></a><a name="g_t_003afinish"></a><a name="E168"></a><a name="index-_003afini"></a>
<a name="index-_003afinish"></a>
<a name="index-E168"></a>
</dd>
<dt>:fini[sh]</dt>
<dd><p>スクリプトの讀み込みを停止する。スクリプトファイルでのみ使へる。これはファイルの殘りを讀み込ませないための手輕な方法である。|<a href="eval_002etxt.html#g_t_003atry">:try</a>| を使つた後で |<a href="eval_002etxt.html#g_t_003afinally">:finally</a>| を見つける前に使はれると、まづ &quot;<code>:finally</code>&quot; と |<a href="eval_002etxt.html#g_t_003aendtry">:endtry</a>| の閒のコマンドが實行される。この手續きは入れ子になつてゐる全ての &quot;<code>:try</code>&quot; に對して適用される。入れ子の一番外側の &quot;<code>:endtry</code>&quot; に達するとスクリプトを停止する。
</p></dd>
</dl>

<p>全てのコマンドとコマンドシーケンスは、名前付きレジスタに格納することで繰り返し實行することができる。レジスタにコマンドを格納する方法は 2 つある:
</p><ul>
<li> 記錄コマンド &quot;q&quot; を使用する。實際にコマンドをタイプし、實行しながらそれをレジスタに格納する。今、何が起こつてゐるかを確認できるので簡單である。閒違ひをしたならば、レジスタの內容をいつたんファイルへ書き出 (&quot;p&quot;ut) して、コマンドシーケンスを編輯して、それからそれを削除して再びレジスタに格納することができる。レジスタに追加することで繼續してレコーディングすることができる (大文字を使用する)。
</li><li> コマンドシーケンスを削除かヤンクしてレジスタに入れる。
</li></ul>

<p>良く使ふコマンドは &rsquo;<code>:map</code>&rsquo; コマンドでファンクションキーに割當てることができる:
</p>
<p>別の方法としてコマンドをファイルに記述しておき、それを &rsquo;<code>:source!</code>&rsquo; コマンドで讀込んで實行するといふ方法もある。長いコマンドシーケンスにとつては便利である。ファンクションキーに複雜なコマンドを割當てるために &rsquo;<code>:map</code>&rsquo; コマンドと組み合はせることができる。
</p>
<p>&rsquo;<code>:source</code>&rsquo; コマンドはファイルから 1 行ずつ Ex コマンドを讀込む。キーボード入力が必要になつた場合にはタイプする必要が生じる。&rsquo;<code>:source!</code>&rsquo; コマンドはスクリプトファイルから 1 字ずつ讀込む。各々のキャラクタはユーザーがタイプしたものとして解釋される。
</p>
<p>例: &quot;<code>:!ls</code>&quot; コマンドを實行したとすると |<a href="message_002etxt.html#hit_002denter">hit-enter</a>| プロンプトが表示される。&quot;!ls&quot; を含むファイルを &rsquo;<code>:source</code>&rsquo; したならば、自分で <code class="tt-key">&lt;Enter&gt;</code> をタイプする必要があるだらう。しかし &rsquo;:!ls&rsquo; を含んだファイルを &rsquo;<code>:source!</code>&rsquo; したならば、&lt;CR&gt; が見つかるまでそのファイルから續く文字が讀込まれる。&quot;<code>:!ls</code>&quot; がファイルの最終行でない限り、&lt;CR&gt; を自分でタイプする必要はないだらう。
</p>
<p>スクリプトファイルの中で &rsquo;<code>:source[!]</code>&rsquo; コマンドを使ふことも可能なので、階層關係のあるスクリプトファイルを作ることもできる。&rsquo;<code>:source</code>&rsquo; コマンドは同時に開くことのできるファイル數 (だいたい 15) と同じだけネスト (入れ子に) することができる。&rsquo;<code>:source!</code>&rsquo; コマンドは 15 段までネストすることができる。
</p>
<p>讀込まれるファイルの中ではファイル名が必要なところに、&quot;&lt;sfile&gt;&quot; といふ文字列 (文字通りであつてスペシャルキーではない) を使ふことができる。この文字列は讀込まれたファイルのファイル名に置き換へられる。例へば、&quot;<samp>.vimrc</samp>&quot; ファイルと同じ場所に &quot;<samp>other.vimrc</samp>&quot; といふファイルがあれば、&quot;<samp>.vimrc</samp>&quot; から次のコマンドでそれを讀込むことができる:
</p><pre class="verbatim">:source &lt;sfile&gt;:h/other.vimrc
</pre>
<p>スクリプトファイル內では端末依存のキーコードは端末非依存の 2 文字のコードで表現される。これは異なる種類の端末でも同じ方法で依存キーコードを使用できることを意味する。最初のキーコードの文字は 0x80 つまり 128 で、畫面では &quot;&lsquo;<samp>~@</samp>&rsquo;&quot; と表される。2 つ目のキャラクタは |<a href="intro_002etxt.html#key_002dnotation">key-notation</a>| の表にて見ることができる。これらのコードはどれも <kbd>CTRL-V</kbd> に續けて 3 つの 10 進コードを叩くことで入力できる。これは termcap コード &lt;t_xx&gt; に對しては使用できない。これらはマッピングの中だけで使ふことができる。
</p>
<a name="g_t_003asource_005fcrnl"></a><a name="W15"></a><a name="index-_003asource_005fcrnl"></a>
<a name="index-W15"></a>
<p>MS-DOS, Win32 and OS/2: &quot;<code>:source</code>&quot; で讀込まれるファイルは通常、行末に &lt;CR&gt;&lt;NL&gt; を持つてゐる。これらは常に働く。もしも行末に &lt;NL&gt; を持つファイルを使つてゐるならば (例へば UNIX で作られたファイル)、&rsquo;<samp>fileformats</samp>&rsquo; が空でかつ先頭行が &lt;CR&gt; で終はつてなければ正しく認識される。しかしこれは先頭行が &quot;&lsquo;<samp>:map &lt;F1&gt; :help^M</samp>&rsquo;&quot; (^M は &lt;CR&gt;) みたいな內容だつた場合には失敗する。ファイルの先頭行が &lt;CR&gt; で終はつてゐてその 1 行限りの時、先頭行から &lt;CR&gt; が失はれてしまふのでエラーメッセージが出るだらう。
</p>
<p>Mac Classic: &quot;<samp>:source</samp>&quot; で讀み込まれるファイルは通常、行末に &lt;CR&gt; を持つてゐる。これらは常に機能する。もしも行末に &lt;NL&gt; を持つファイルを使つてゐるならば (例へば UNIX で作られたファイル)、&rsquo;<samp>fileformats</samp>&rsquo; が空でかつ先頭行が &lt;CR&gt; で終はつてなければ正しく認識される。先頭行に &lt;CR&gt; を持ち &lt;NL&gt; で改行してゐるファイルを使用しないやうに氣をつけること。
</p>
<p>その他のシステムでは、Vim は &quot;<code>:source</code>&quot; で讀込まれたファイルの行末は &lt;NL&gt; であることを期待する。これは常に働く。もしも行末が &lt;CR&gt;&lt;NL&gt; であるファイル (例へば MS-DOS で作られたファイル) を使つてゐるならば、全ての行が末尾に &lt;CR&gt; を持つてゐることになる。これは幾つかのコマンドにとつて問題となるだらう (例、マッピング)。自動的に行末記號を檢出する機構はない。なぜなら &lt;CR&gt; で終了するマッピングの定義をファイルの先頭に書くことは一般的で、自動檢出用の仕組みを作るのが難しいからである。
</p>
<a name="line_002dcontinuation"></a><a name="index-line_002dcontinuation"></a>
<p>&quot;<code>:source</code>&quot; で讀込まれた Ex コマンドスクリプトのファイル內の長い行は、行繼續記號 &quot;\&quot; (backslash) を次行の先頭に插入することで分割できる。バックスラッシュの前に空白を插入することも可能で、これらは無視される。
</p>
<p>例: 次の記述は
</p><pre class="verbatim">:set comments=sr:/*,mb:*,el:*/,
         \://,
         \b:#,
         \:%,
         \n:&gt;,
         \fb:-
</pre><p>次の 1 行と同じ意味として解釋される:
</p><pre class="verbatim">:set comments=sr:/*,mb:*,el:*/,://,b:#,:%,n:&gt;,fb:-
</pre>
<p>バックスラッシュの前に先行する空白文字は全部無視される。しかしながらバックスラッシュのある行の 1 つ前の行末には、自由に空白文字を插入することはできない; 付加的な空白文字が許されるかどうかは、コマンドが分割される位置に依存する。
</p>
<p>スペースが必要な場合には、バックスラッシュの直後に書くのがベストである。行末にスペースを書くと、視認が難しく、誤つて削除されてしまふかもしれない。
</p><pre class="verbatim">:syn match Comment
    \ &quot;very long regexp&quot;
    \ keepend
</pre>
<p>&quot;<code>:append</code>&quot; と &quot;<code>:insert</code>&quot; コマンドには1つ問題がある:
</p><pre class="verbatim">:1append
\asdf
.
</pre><p>バックスラッシュは行繼續シンボルに見えるが、コマンドの結果はこのやうになる:
</p><pre class="verbatim">:1appendasdf
.
</pre><p>これを避けるには、&rsquo;<samp>cpoptions</samp>&rsquo; に &rsquo;<var>C</var>&rsquo; フラグを追加することだ:
</p><pre class="verbatim">:set cpo+=C
:function Foo()
:1append
\asdf
:.
:set cpo-=C
</pre>
<blockquote>
<p><strong>Note:</strong> <br>
函數の中でその手のコマンドを實行するには、函數定義の際に &rsquo;<var>C</var>&rsquo; フラグを追加する必要があり、それが實行される際にではない。
</p><pre class="verbatim">:set cpo+=C
:function Foo()
:1append
\asdf
.
:endfunction
:set cpo-=C
</pre></blockquote>
<a name="line_002dcontinuation_002dcomment"></a><a name="index-line_002dcontinuation_002dcomment"></a>
<p>行の閒でコメントを追加するために、&rsquo;&quot;\ &rsquo; で開始する。バックスラッシュの後にスペースがあることに注意。例:
</p><pre class="verbatim">let array = [
        &quot;\ first entry comment
        \ 'first',
        &quot;\ second entry comment
        \ 'second',
        \ ]
</pre>
<p>解說:
</p>
<p>多くのプログラムは行繼續を、繼續する行の末尾にバックスラッシュを置くことで表現する。その方法をVimで採用してしまふと、Viとの互換性に重大な缺陷ができてしまふ。たとへばこのやうなViのマッピングを考へるとわかりやすい:
</p><pre class="verbatim">:map xx  asdf\
</pre><p>從つて一般的ではないが行頭のバックスラッシュを採用してゐる。
</p>
<p>繼續行中でコメントを開始すると、續く繼續行のすべてがコメントの一部となる。これは長い閒好まれてゐたので、繼續する行の途中にコメントの追加を可能にした時に、正しい繼續行であるため、\&quot; を使ふことができなかつた。&rsquo;&quot;\ &rsquo; の使用は極めて類似してゐるのだが、ちよつと氣持ち惡く感じるかもしれない。バックスラッシュの後にスペースが必要なのは、これを普通のコメント行のやうにするの見込はない。
</p>
<a name="packages"></a><a name="index-packages"></a>
<a name="index-Vim-patukeziwoShi-u"></a>
<a name="g_t5_002e-Vim-patukeziwoShi-u"></a>
<h3 class="section">5. Vim パッケージを使ふ</h3>

<p>Vim script のパッケージは 1 つかそれ以上のプラグインを含むディレクトリである。通常のプラグインと比べた長所は以下の通りである:
</p><ul>
<li> パッケージは壓縮ファイルとしてダウンロードでき、獨自のディレクトリに展開される。よつてそのファイルは他のプラグインと混在することがない。これは更新と削除を簡素化する。
</li><li> パッケージには git, mercurial などのリポジトリも使用可能。これはとても更新を簡素化する。
</li><li> パッケージはお互ひに依存する複數のプラグインを含むことができる。
</li><li> パッケージは起動時に自動的に讀み込まれるプラグインと、必要になつた時のみ &lsquo;:packadd&lsquo; により讀み込まれるプラグインを含むことができる。
</li></ul>


<a name="index-patukezinoShi-Yong-toZi-Dong-Du-miIp-mi"></a>
<a name="patukezinoShi-Yong-toZi-Dong-Du-miIp-mi"></a>
<h4 class="unnumberedsubsec">パッケージの使用と自動讀み込み</h4>

<p>あなたの Vim 關聯のファイルは &quot;~/.vim/&quot; にあるとする。さらに ZIP 壓縮ファイル &quot;/tmp/foopack.zip&quot; からパッケージを追加したい場合は以下の通りである:
</p><pre class="verbatim">% mkdir -p ~/.vim/pack/foo
% cd ~/.vim/pack/foo
% unzip /tmp/foopack.zip
</pre>
<p>&quot;foo&quot; といふディレクトリ名は任意である。あなたのお好きな名前を付けてよい。
</p>
<p>今あなたの ~/.vim の下に以下のファイルがあるはずである:
</p><pre class="verbatim">pack/foo/README.txt
pack/foo/start/foobar/plugin/foo.vim
pack/foo/start/foobar/syntax/some.vim
pack/foo/opt/foodebug/plugin/debugger.vim
</pre>
<p>Vim が起動した時、.vimrc を處理した後、&rsquo;<samp>packpath</samp>&rsquo; に含まれる &quot;pack/*/start&quot; ディレクトリの下の全てのディレクトリをスキャンする。最初にそのディレクトリは &rsquo;<samp>runtimepath</samp>&rsquo; に追加される。次に全てのプラグインがロードされる。これら 2 つのステップがどのやうに役立つかについては、|<a href="#packload_002dtwo_002dsteps">packload-two-steps</a>| 參照。
</p>
<p>上記の例では &quot;pack/foo/start/foobar/plugin/foo.vim&quot; を見つけて &quot;~/.vim/pack/foo/start/foobar&quot; を &rsquo;<samp>runtimepath</samp>&rsquo; に追加する。
</p>
<p>もし &quot;foobar&quot; プラグインが作動し &rsquo;<samp>filetype</samp>&rsquo; を &quot;<var>some</var>&quot; にセットした場合、&rsquo;<samp>runtimepath</samp>&rsquo; に含まれてゐるため、Vim は上記の <samp>syntax/some.vim</samp> ファイルを見つける。
</p>
<p>もし存在するなら、Vim は ftdetect ファイルもロードする。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
&quot;pack/foo/opt&quot; 以下のファイルは自動的に讀み込まれず、&quot;pack/foo/start&quot; 以下のファイルのみ讀み込まれることに注意すること。&quot;opt&quot; ディレクトリがどのやうに使はれるかについては下記の |<a href="#pack_002dadd">pack-add</a>| を參照。
</p></blockquote>

<p>パッケージの自動讀み込みはプラグインの讀み込みを無效化してゐる場合は起こらない。|<a href="starting_002etxt.html#load_002dplugins">load-plugins</a>| を參照。
</p>
<p>&rsquo;<samp>runtimepath</samp>&rsquo; を更新するためにパッケージを讀み込むには:
</p><pre class="verbatim">:packloadall
</pre><p>これはプラグインの讀み込みを無效化してゐても效果がある。自動讀み込みは一度だけ行はれる。
</p>
<p>パッケージに &quot;after&quot; ディレクトリがある場合、そのディレクトリは &rsquo;<samp>runtimepath</samp>&rsquo; の末尾に追加される。そのため、そこにあるものは全て後でロードされる。
</p>

<a name="index-Dan-YipuraguinnoShi-Yong-tosonoZi-Dong-Du-miIp-mi"></a>
<a name="Dan-YipuraguinnoShi-Yong-tosonoZi-Dong-Du-miIp-mi"></a>
<h4 class="unnumberedsubsec">單一プラグインの使用とその自動讀み込み</h4>

<p>パッケージでなく單一のプラグインがある場合は、餘分なディレクトリ階層を作成する必要がある。
</p><pre class="verbatim">% mkdir -p ~/.vim/pack/foo/start/foobar
% cd ~/.vim/pack/foo/start/foobar
% unzip /tmp/someplugin.zip
</pre>
<p>これで、次のファイルが作成される。
</p><pre class="verbatim">pack/foo/start/foobar/plugin/foo.vim
pack/foo/start/foobar/syntax/some.vim
</pre>
<p>ここから上のやうに動作する。
</p>

<a name="index-Ren-Yi-nopuraguin"></a>
<a name="Ren-Yi-nopuraguin"></a>
<h4 class="unnumberedsubsec">任意のプラグイン</h4>
<a name="pack_002dadd"></a><a name="index-pack_002dadd"></a>
<p>上記の pack ディレクトリから任意のプラグインをロードするには &lsquo;<code>:packadd</code>&lsquo; コマンドを使ふ:
</p><pre class="verbatim">:packadd foodebug
</pre><p>これは &rsquo;<samp>packpath</samp>&rsquo; の &quot;pack/*/opt/foodebug&quot; から <samp>~/.vim/pack/foo/opt/foodebug/plugin/debugger.vim</samp> を見つけ讀み込む。
</p>
<p>これにより何かしらの條件が滿たされる時に實行されるやうにできる。例へば、Vim がある機能をサポートしてゐるかどうかとか、依存したモノが見つからないとか、さういふことに依存させることができる。
</p>
<p>このコマンドをあなたの |<a href="starting_002etxt.html#g_t_002evimrc">.vimrc</a>| に入れることで、起動時に任意のプラグインを讀み込むこともできる。
</p><pre class="verbatim">:packadd! foodebug
</pre><p>餘分な &quot;!&quot; は Vim が |<a href="starting_002etxt.html#g_t_002d_002dnoplugin">--noplugin</a>| で起動されてゐれば、プラグインがロードされないやうにするためである。
</p>
<p>パッケージが &quot;opt&quot; ディレクトリしか持たなかつたとしても一向に構はない。その場合、それを使ひたいときは (明示的に) 讀み込む必要がある。
</p>

<a name="index-dokoniHe-woZhi-kuka"></a>
<a name="dokoniHe-woZhi-kuka"></a>
<h4 class="unnumberedsubsec">どこに何を置くか</h4>

<p>&lsquo;<code>:colorscheme</code>&lsquo; で讀み込まれるカラースキームは &quot;pack/*/start&quot; と &quot;pack/*/opt&quot; の下から探し出されるのでどこにでも置くことができる。たとへば、&quot;<samp>.vim/pack/mycolors/opt/dark/colors/very_dark.vim</samp>&quot; のやうに、&quot;pack/*/opt&quot; の下に置くことをお勸めする。
</p>
<p>Filetype プラグインはファイルタイプに複數のプラグインがあり、&lsquo;<code>:packadd</code>&lsquo; でロードするプラグインを選擇したいのでない限り &quot;pack/*/start&quot; の下に置く必要がある。例へば、コンパイラのバージョンに依存する場合:
</p><pre class="verbatim">if foo_compiler_version &gt; 34
  packadd foo_new
else
  packadd foo_old
endif
</pre>
<p>&quot;after&quot; ディレクトリはパッケージで使ふには十中八九便利ではない。しかし、使用が禁じられてゐるわけではない。
</p>
<a name="package_002dcreate"></a><a name="index-package_002dcreate"></a>
<a name="index-Vim-patukeziwoZuo-ru"></a>
<a name="g_t6_002e-Vim-patukeziwoZuo-ru"></a>
<h3 class="section">6. Vim パッケージを作る</h3>

<p>パッケージとして配布する 1 つ以上のプラグインを記述してゐることを前提とする。
</p>
<p>2 つの無關係なプラグインがある場合は、2 つのパッケージを使用するので、Vim ユーザーはそのパッケージに含まれるものを選擇できる。あるいは、オプションのプラグインで 1 つのパッケージを使用し、&lsquo;<code>:packadd</code>&lsquo; で必要なプラグインを追加するやうにユーザーに指示することもできる。
</p>
<p>パッケージの配布方法を決める。アーカイブを作成することも、リポジトリを使用することもできる。より多くのユーザーがアーカイブを使用できるが、新しいバージョンに更新するのは少し難しくなる。リポジトリは通常、最新の狀態に保つことができるが、&quot;git&quot; のやうなプログラムが必要である。github ではリリースを作成すると自動的にアーカイブが作られるので、あなたは兩方を同時に行ふことができる。
</p>
<p>ディレクトリ構成は次のやうになる。
</p><pre class="verbatim">start/foobar/plugin/foo.vim         &quot; 常にロードされ、コマンドを定義する
start/foobar/plugin/bar.vim         &quot; 常にロードされ、コマンドを定義する
start/foobar/autoload/foo.vim       &quot; foo コマンドを使用した時に讀み込む
start/foobar/doc/foo.txt            &quot; foo.vim のヘルプ
start/foobar/doc/tags               &quot; ヘルプタグ
opt/fooextra/plugin/extra.vim       &quot; オプションのプラグイン、コマンド定義
opt/fooextra/autoload/extra.vim     &quot; extra コマンドを使用した時に讀み込む
opt/fooextra/doc/extra.txt          &quot; extra.vim のヘルプ
opt/fooextra/doc/tags               &quot; ヘルプタグ
</pre>
<p>これにより、ユーザーは次の操作を行ふことができる。
</p><pre class="verbatim">mkdir ~/.vim/pack/myfoobar
cd ~/.vim/pack/myfoobar
git clone https://github.com/you/foobar.git
</pre>
<p>ここで &quot;myfoobar&quot; はユーザーが選擇できる名前だが、唯一の條件は他のパッケージとは異なることである。
</p>
<p>ドキュメントでは、プラグインの機能について說明し、オプションのプラグインをロードする方法をユーザーに傳へる。
</p><pre class="verbatim">:packadd! fooextra
</pre>
<p>この packadd コマンドをプラグインの 1 つに追加して、オプションのプラグインが必要なときに實行することができる。
</p>
<p>&lsquo;<code>:helptags</code>&lsquo; コマンドを實行して、<samp>doc/tags</samp> ファイルを生成する。この生成されたファイルをパッケージに含めるといふことは、パッケージディレクトリにパッケージを落とすことができ、ヘルプコマンドがすぐに動作することを意味する。プラグインヘルプを變更した後にコマンドを再實行することを忘れないでほしい。
</p><pre class="verbatim">:helptags path/start/foobar/doc
:helptags path/opt/fooextra/doc
</pre>

<a name="index-puraguinJian-noYi-Cun-Guan-Xi-"></a>
<a name="puraguinJian-noYi-Cun-Guan-Xi-"></a>
<h4 class="unnumberedsubsec">プラグイン閒の依存關係</h4>
<a name="packload_002dtwo_002dsteps"></a><a name="index-packload_002dtwo_002dsteps"></a>
<p>同じ機能に依存する 2 つのプラグインがあるとする。共通機能を autoload ディレクトリに置くことで、自動的に見つかるやうにすることができる。あなたのパッケージには次のファイルがあるとする。
</p>
<p>pack/foo/start/one/plugin/one.vim
</p><pre class="verbatim">call foolib#getit()
</pre><p>pack/foo/start/two/plugin/two.vim
</p><pre class="verbatim">call foolib#getit()
</pre><p>pack/foo/start/lib/autoload/foolib.vim
</p><pre class="verbatim">func foolib#getit()
</pre>
<p>これは動作する。なぜなら、パッケージをロードすると、プラグインを讀み込む前に見つかつたすべてのディレクトリが &rsquo;<samp>runtimepath</samp>&rsquo; に追加されるからである。
</p>
<a name="debug_002dscripts"></a><a name="index-debug_002dscripts"></a>
<a name="index-sukuriputonodebatugu"></a>
<a name="g_t7_002e-sukuriputonodebatugu"></a>
<h3 class="section">7. スクリプトのデバッグ</h3>

<p>スクリプトの動作を知るためのコードを追加することができるのは當り前として、Vim はデバッグモードを提供してゐる。これはスクリプトファイルやユーザーファンクションをステップ實行することやブレークポイントを仕掛けることを可能にする。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
デバッグモードは未完成である。デバッグは Vim の動作に副作用をあたえる。全てをデバッグするのには使へない。例へば畫面がデバッグメッセージで散亂するときなど。
</p></blockquote>

<p>デバッグモードの代はりに &rsquo;<samp>verbose</samp>&rsquo; オプションが使へる。大きな値を設定すると Vim の動作についてより詳細なメッセージを得られる。
</p>

<a name="debug_002dmode"></a><a name="index-debug_002dmode"></a>
<a name="index-debatugumodowoKai-Shi-suru"></a>
<a name="debatugumodowoKai-Shi-suru"></a>
<h4 class="unnumberedsubsec">デバッグモードを開始する</h4>

<p>デバッグモードを開始するにはこれらの方法のうちどれかを使ふ:
</p><ol>
<li> Vim を |<a href="starting_002etxt.html#g_t_002dD">-D</a>| 引數付きで起動する:
<pre class="verbatim">vim -D file.txt
</pre><p>最初に vimrc を讀み込むところからデバッグを開始する。これは Vim の起動時に何が起こつてゐるのかを調査するのに便利である。副作用として Vim は初期化が完了する前に安全のためターミナルモードを切替へる。
</p>
<p>(Windows や Macintosh の) GUI 專用バージョンでは GUI ウィンドウを開くとすぐにデバッグが開始する。これを早めるには <samp>vimrc</samp> ファイルに &quot;:gui&quot; と書くこと。
<a name="g_t_003adebug"></a></p></li><li> <a name="index-_003adebug"></a>
&quot;:debug&quot; を前に付けてコマンドを實行する。そのコマンドを實行する閒だけデバッグできる。特定のスクリプトファイルやユーザー函數をデバッグするのに便利である。オートコマンドから呼び出されるスクリプトや函數にも便利である。例:
<pre class="verbatim">:debug edit test.txt.gz
</pre>
</li><li> ブレークポイントをソースファイルやユーザーファンクションに設定する。コマンドラインから次のやうにできる:
<pre class="verbatim">vim -c &quot;breakadd file */explorer.vim&quot;
</pre><p>これは Vim を起動して &quot;explorer.vim&quot; の最初の行を讀み込むところで停止する。デバッグモード中でもブレークポイントを設定できる。
</p></li></ol>

<p>デバッグモード中に實行されるコマンドはそれが實行される前に表示される。コメントや空の行、實行されない行は飛ばされる。行が &quot;|&quot; を使つて 2 つのコマンドを含んでゐた場合には分けて表示される。
</p>

<a name="index-debatugumodo"></a>
<a name="debatugumodo"></a>
<h4 class="unnumberedsubsubsec">デバッグモード</h4>

<p>デバッグモードに入ると、通常の Ex コマンドが使へる。例へば、變數の値を見るには:
</p><pre class="verbatim">echo idx
</pre><p>ユーザーファンクション內では、これはローカル變數の &quot;idx&quot; を表示する。&quot;g:&quot; を頭に付けるとグローバル變數の値を表示する:
</p><pre class="verbatim">echo g:idx
</pre><p>全てのコマンドは實行中の函數やスクリプトの文脈として實行される。オプションを設定することもできる。例へば何が起こつてゐるのかを表示するために &rsquo;<samp>verbose</samp>&rsquo; を設定することができる。興味のある部分を實行する前に次のやうにするといいだらう:
</p><pre class="verbatim">:set verbose=20
</pre>
<p>スクリーンの更新を必要とするコマンドは避けるべきである。なぜならデバッグモードを拔けるまでその作用に氣づき難いからである。例へば:
</p><pre class="verbatim">:help
</pre><p>これはとても不便である。
</p>
<p>デバッグモードのためのコマンドラインヒストリが別に用意されてゐる。
</p>
<p>函數の行番號はその函數の始まりから數へる。見てゐる行の番號を數へるのに苦勞する場合はその函數の書かれたファイルを別の Vim で開き、その函數の始まりを探しだし、&quot;99j&quot; を實行すること。&quot;99&quot; は實際の行番號に合はせて變へること。
</p>
<p>さらに、以下のコマンドが使へる:
<a name="g_t_003econt"></a><a name="index-_003econt"></a>
</p><dl compact="compact">
<dt>cont</dt>
<dd><p>次のブレークポイントまで實行する。
<a name="g_t_003equit"></a><a name="index-_003equit"></a>
</p></dd>
<dt>quit</dt>
<dd><p>異常停止する。これは <kbd>CTRL-C</kbd> を使ふことに似てゐるが、全てを停止するわけではない。次のブレークポイントで停止する。
<a name="g_t_003enext"></a><a name="index-_003enext"></a>
</p></dd>
<dt>next</dt>
<dd><p>コマンドを實行しそれが終はるとデバッグモードに戾る。ユーザー函數やソースファイルの呼び出し時には呼び出し元の次の行に進む。
<a name="g_t_003estep"></a><a name="index-_003estep"></a>
</p></dd>
<dt>step</dt>
<dd><p>コマンドを實行しそれが終はるとデバッグモードに戾る。ユーザー函數やソースファイルの呼び出し時には呼び出し先の行に進む。
<a name="g_t_003einterrupt"></a><a name="index-_003einterrupt"></a>
</p></dd>
<dt>interrupt</dt>
<dd><p><kbd>CTRL-C</kbd> を使ふことに似てゐるが、次のコマンドを實行するためにデバッグモードに戾る場所が &quot;&gt;quit&quot; と違ふ。例外割り込みについて |<a href="eval_002etxt.html#g_t_003afinally">:finally</a>| や |<a href="eval_002etxt.html#g_t_003acatch">:catch</a>| をテストするのに便利である。
<a name="g_t_003efinish"></a><a name="index-_003efinish"></a>
</p></dd>
<dt>finish</dt>
<dd><p>實行中のスクリプトやユーザー函數を終了し呼び出し元でデバッグモードに戾る。
<a name="g_t_003ebt"></a><a name="g_t_003ebacktrace"></a><a name="g_t_003ewhere"></a><a name="index-_003ebt"></a>
<a name="index-_003ebacktrace"></a>
<a name="index-_003ewhere"></a>
</p></dd>
<dt>backtrace or bt or where</dt>
<dd><p>現在のデバッグセッションの呼び出しスタックトレースを表示する。
<a name="g_t_003eframe"></a><a name="index-_003eframe"></a>
</p></dd>
<dt>frame N</dt>
<dd><p>N 番目のスタックフレームへ移動する。+ や - 記號で、相對的に移動できる。例へば、&quot;&lsquo;<samp>:frame +3</samp>&rsquo;&quot; で 3 つ上のスタックフレームへ移動する。
<a name="g_t_003eup"></a><a name="index-_003eup"></a>
</p></dd>
<dt>up</dt>
<dd><p>呼び出しスタックトレースを 1 つ上へ移動する。
<a name="g_t_003edown"></a><a name="index-_003edown"></a>
</p></dd>
<dt>down</dt>
<dd><p>呼び出しスタックトレースを 1 つ下へ移動する。
</p></dd>
</dl>

<p>デバッグモードのコマンドについて:
</p><ul>
<li> 補完はできない。通常の Ex コマンドのみ補完できる。
</li><li> コマンド名は、他のコマンドが同じ文字で始まらないところまで省略できる。&quot;f&quot; は &quot;finish&quot; なるので &quot;frame&quot; を省略するには &quot;fr&quot; を用ゐる。
</li><li> &lt;CR&gt; を押すと前囘のものを繰り返す。關係ないコマンドを使ふとリセットされる (どうすべきかがわかりにくいため)。
</li><li> 同じ名前の Ex コマンドを使ふにはコロンを付けること: &quot;:cont&quot;, &quot;:next&quot;, &quot;:finish&quot; (省略時も)
</li></ul>

<p>バックトレースは、函數呼び出しの階層を表示する。例へば:
</p><pre class="verbatim">&gt;bt
  3 function One[3]
  2 Two[3]
-&gt;1 Three[3]
  0 Four
行 1: let four = 4
</pre>
<p>&quot;-&gt;&quot; は現在いるフレームを指す。&quot;up&quot;、&quot;down&quot;、&quot;frame N&quot; を使ふことで、別のフレームを選擇できる。
</p>
<p>現在いるフレームの、その函數內でのローカル變數にアクセスできる。現在いるフレームの、現在行の內容を表示する方法はまだない。
</p>

<a name="index-burekupointonoDing-Yi-"></a>
<a name="burekupointonoDing-Yi-"></a>
<h4 class="unnumberedsubsubsec">ブレークポイントの定義</h4>
<a name="g_t_003abreaka"></a><a name="g_t_003abreakadd"></a><a name="index-_003abreaka"></a>
<a name="index-_003abreakadd"></a>
<dl compact="compact">
<dt>:breaka[dd] func [lnum] {name}</dt>
<dd><p>函數にブレークポイントを設定する。例:
</p><pre class="verbatim">:breakadd func Explore
</pre><p>函數名が妥當かどうか檢査しないので、函數定義の前にブレークポイントを定義できる。
</p>
</dd>
<dt>:breaka[dd] file [lnum] {name}</dt>
<dd><p>ソースファイルにブレークポイントを設定する。例:
</p><pre class="verbatim">:breakadd file 43 .vimrc
</pre>
</dd>
<dt>:breaka[dd] here</dt>
<dd><p>カレントファイルのカレント行にブレークポイントを設定する。次を行ふのと同樣である:
</p><pre class="verbatim">:breakadd file &lt;cursor-line&gt; &lt;current-file&gt;
</pre><blockquote>
<p><strong>Note:</strong> <br>
これはファイルを讀み込むときに實行されるコマンドに對してだけ働く。そのファイル中で定義される函數に對しては働かない。
</p></blockquote>

</dd>
<dt>:breaka[dd] expr {expression}</dt>
<dd><p>{expression} の評價結果が異なる値となるときに常にブレークするブレークポイントを設定する。例:
</p><pre class="verbatim">:breakadd expr g:lnum
</pre>
<p>これはグローバル變數の lnum が變化するときに常にブレークする。
</p><blockquote>
<p><strong>Note:</strong> <br>
|<a href="eval_002etxt.html#script_002dvariable">script-variable</a>| を監視する場合、スクリプトが切り替はつたときにブレークする。これは、定義されたスクリプト內でのみ、そのスクリプト變數が有效だからである。そしてそのスクリプトがいくつかのその他のスクリプトから呼び出される場合、その特定の變數が可視となつたとき、もしくは再度アクセス不能となつたときに常に停止する。
</p></blockquote>
</dd>
</dl>

<p>[lnum] はブレークポイントにする行番號である。Vim はその行かそれ以降で停止する。省略時すると 1 行目になる。
</p>
<a name="g_t_003adebug_002dname"></a><a name="index-_003adebug_002dname"></a>
<p>{name} はファイル名や函數名のパターンである。パターンはオートコマンドで使はれるものと同じである。完全に一致しなければならない (パターンが &quot;^&quot; で始まつて &quot;$&quot; で終はるやうに)。&quot;*&quot; は全ての文字列に一致する。&rsquo;<samp>ignorecase</samp>&rsquo; は使はれないが、大文字と小文字を區別しないために &quot;\c&quot; を使ふことができる |<a href="pattern_002etxt.html#g_t_002f_005cc">/\c</a>|。函數名には () を付けないやうに！
</p>
<p>ソースファイル名のパターン檢査はファイルのフルネームに對して行はれる。例:
</p><pre class="verbatim">breakadd file explorer
</pre><p>パスが閒違つてゐるので一致しない。
</p><pre class="verbatim">breakadd file *explorer.vim
</pre><p>&quot;.../plugin/explorer.vim&quot; と &quot;.../plugin/iexplorer.vim&quot; に一致する。
</p><pre class="verbatim">breakadd file */explorer.vim
</pre><p>&quot;.../plugin/explorer.vim&quot; だけに一致する。
</p>
<p>函數名のパターン檢査は &quot;<code>:function</code>&quot; で表示される名前に對して行はれる。ローカル函數には &quot;&lt;SNR&gt;99_&quot; といつたものが前に付くといふことである。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
函數はまづ讀み込まれ、後で實行される。讀み込まれたときに &quot;file&quot; ブレークポイントがチェックされ、實行されるときに &quot;func&quot; ブレークポイントがチェックされる。
</p></blockquote>


<a name="index-burekupointonoXue-Chu-"></a>
<a name="burekupointonoXue-Chu-"></a>
<h4 class="unnumberedsubsubsec">ブレークポイントの削除</h4>
<a name="g_t_003abreakd"></a><a name="g_t_003abreakdel"></a><a name="E161"></a><a name="index-_003abreakd"></a>
<a name="index-_003abreakdel"></a>
<a name="index-E161"></a>
<dl compact="compact">
<dt>:breakd[el] {nr}</dt>
<dd><p>ブレークポイント {nr} を削除する。|<a href="#g_t_003abreaklist">:breaklist</a>| を使つて番號を確認できる。
</p>
</dd>
<dt>:breakd[el] *</dt>
<dd><p>すべてのブレークポイントを削除する。
</p>
</dd>
<dt>:breakd[el] func [lnum] {name}</dt>
<dd><p>函數內のブレークポイントを削除する。
</p>
</dd>
<dt>:breakd[el] file [lnum] {name}</dt>
<dd><p>ソースファイル內のブレークポイントを削除する。
</p>
</dd>
<dt>:breakd[el] here</dt>
<dd><p>カレントファイルのカレント行のブレークポイントを削除する。
</p></dd>
</dl>

<p>[lnum] が省略されると函數、またはファイルの最初のブレークポイントが削除される。{name} は &quot;<code>:breakadd</code>&quot; で使つた名前と完全に同じでなければならない。&quot;explorer&quot; と &quot;*explorer.vim&quot;, &quot;*explorer*&quot; は違ふ。
</p>

<a name="index-burekupointowoLie-Ju-suru"></a>
<a name="burekupointowoLie-Ju-suru"></a>
<h4 class="unnumberedsubsubsec">ブレークポイントを列擧する</h4>
<a name="g_t_003abreakl"></a><a name="g_t_003abreaklist"></a><a name="index-_003abreakl"></a>
<a name="index-_003abreaklist"></a>
<dl compact="compact">
<dt>:breakl[ist]</dt>
<dd><p>全てのブレークポイントを列擧する。
</p></dd>
</dl>


<a name="index-sonoTa--2"></a>
<a name="sonoTa--2"></a>
<h4 class="unnumberedsubsubsec">その他</h4>

<a name="g_t_003adebugg"></a><a name="g_t_003adebuggreedy"></a><a name="index-_003adebugg"></a>
<a name="index-_003adebuggreedy"></a>
<dl compact="compact">
<dt>:debugg[reedy]</dt>
<dd><p>デバッグモードのコマンドをユーザーから直接得るのではなく標準入力から讀み込む。スクリプトのテストのときに便利である。例:
</p><pre class="verbatim">echo 'q^Mq' | vim -e -s -c debuggreedy -c 'breakadd file script.vim' -S script.vim
</pre>
</dd>
<dt>:0debugg[reedy]</dt>
<dd><p>&quot;<code>:debuggreedy</code>&quot; を取り消す。それ以降のデバッグモードコマンドを使はず、ユーザーから直接デバッグモードコマンドを受け取る。
</p></dd>
</dl>

<a name="profile"></a><a name="profiling"></a><a name="index-profile"></a>
<a name="index-profiling"></a>
<a name="index-purohuairingu"></a>
<a name="g_t8_002e-purohuairingu"></a>
<h3 class="section">8. プロファイリング</h3>

<p>プロファイリングとは、函數やスクリプトの實行にかかる時閒を計測することである。これを行ふには |<a href="various_002etxt.html#g_t_002bprofile">+profile</a>| 機能が必要である。この機能は &quot;huge&quot; 機能つきでコンパイルしたときだけ含まれる。
</p>
<p>また、函數 |<a href="eval_002etxt.html#reltime_0028_0029">reltime()</a>| を使つても時閒を計測できる。この函數には |<a href="various_002etxt.html#g_t_002breltime">+reltime</a>| 機能だけが必要である。これは &quot;huge&quot; 以外でもしばしばついてくる。
</p>
<p>シンタックスハイライトのプロファイリングについては |<a href="syntax_002etxt.html#g_t_003asyntime">:syntime</a>| を參照せよ。
</p>
<p>例へば、one_script.vim スクリプトファイルをプロファイリングするには:
</p><pre class="verbatim">:profile start /tmp/one_script_profile
:profile file one_script.vim
:source one_script.vim
:exit
</pre>

<a name="g_t_003aprof"></a><a name="g_t_003aprofile"></a><a name="E750"></a><a name="index-_003aprof"></a>
<a name="index-_003aprofile"></a>
<a name="index-E750"></a>
<dl compact="compact">
<dt>:prof[ile] start {fname}</dt>
<dd><p>プロファイリングを開始し、終了時に出力を {fname} に出力する。{fname} 中の &quot;~/&quot; や環境變數は展開される。{fname} がすでに存在するときは、警告なしに上書きされる。變數 |<a href="eval_002etxt.html#v_003aprofiling">v:profiling</a>| に 1 が代入される。
</p>
</dd>
<dt>:prof[ile] pause</dt>
<dd><p>次項の &quot;:profile pause&quot; が實行されるまでプロファイリングをしない。カウントされるべきでない何かを行ふ時に使ふことができる (例へば外部コマンドなど)。ネストすることはできない。
</p>
</dd>
<dt>:prof[ile] continue</dt>
<dd><p>&quot;:profile pause&quot; の後にこれを實行すると、プロファイリングを再開する。
</p>
</dd>
<dt>:prof[ile] func {pattern}</dt>
<dd><p>パターン {pattern} にマッチする函數をプロファイリングする。{pattern} がどう使はれるかは |<a href="#g_t_003adebug_002dname">:debug-name</a>| を參照。
</p>
</dd>
<dt>:prof[ile][!] file {pattern}</dt>
<dd><p>パターン {pattern} にマッチするスクリプトファイルをプロファイリングする。{pattern} がどう使はれるかは |<a href="#g_t_003adebug_002dname">:debug-name</a>| を參照。このコマンドはスクリプトそのものをプロファイリングするだけで、その中で定義されてゐる函數のプロファイリングは行はない。
</p>
<p>[!] がつけられたときは、そのスクリプト中で定義されてゐる全ての函數のプロファイリングも行ふ。
</p><blockquote>
<p><strong>Note:</strong> <br>
スクリプトがこのコマンドの後で讀み込まれたときだけ、そのプロファイリングは始まる。スクリプト自身にある <code>:profile</code> コマンドは働かない。
</p></blockquote>


<a name="g_t_003aprofd"></a><a name="g_t_003aprofdel"></a><a name="index-_003aprofd"></a>
<a name="index-_003aprofdel"></a>
</dd>
<dt>:profd[el] ...</dt>
<dd><p>指定された引數に對するプロファイリングを停止する。引數については |<a href="#g_t_003abreakdel">:breakdel</a>| を參照。
</p></dd>
</dl>


<p>最初は常に &quot;&lsquo;<samp>:profile start fname</samp>&rsquo;&quot; コマンドで始めなければならない。結果のファイルは Vim が終了するときに書き出される。次に出力の例を擧げる。說明のために行番號が行頭についてゐる:
</p>
<pre class="verbatim">1 FUNCTION  Test2()
2 Called 1 time
3 Total time:   0.155251
4  Self time:   0.002006
5
6 count  total (s)   self (s)
7     9              0.000096   for i in range(8)
8     8   0.153655   0.000410     call Test3()
9     8              0.000070   endfor
10                              &quot; Ask a question
11    1              0.001341   echo input(&quot;give me an answer: &quot;)
</pre>
<p>ヘッダー (1 行目から 4 行目) は函數全體にかかつた時閒を示してゐる。&quot;Total&quot; はこの函數を實行してゐる閒に經過した時閒である。&quot;Self&quot; は &quot;Total&quot; のうち、次のことにかかつた時閒を引いたものである:
</p><ul>
<li> 他のユーザー定義函數
</li><li> スクリプトの讀み込み
</li><li> 自動コマンドの實行
</li><li> 外部 (シェル) プログラム
</li></ul>

<p>7 行目から 11 行目は各實行行にかかつた時閒を示してゐる。實行されない行はカウントされない。それゆゑ、コメント行は決してカウントされない。
</p>
<p>Count の桁はその行が何囘實行されたかを示す。7 行目の &quot;for&quot; コマンドはそれ以下の行と同樣に何囘も實行されることに注意すること。これは、ループの終はりを檢出するためにこの行が何囘も實行されるためである。
</p>
<p>ユーザー入力待ちにかかつた時閒は一切カウントされない。それゆゑ、input() のプロンプトに反應するのにどれだけ時閒がかからうとも無關係である。
</p>
<p>プロファイリングはどこで時閒が費やされたかのよい指標を與へてくれるが、多くの原因によりその結果がごまかされてしまふ場合があるといふことを覺えておくやうに:
</p>
<ul>
<li> システム函數 gettimeofday() に依存する時閒計測の精度。たとへ時閒がマイクロ秒で表示されてゐたとしても、1/100 秒の精度しかないこともある。

</li><li> 實經過時閒が計測される。他のプロセスがビジーであると、それが豫測できない箇所で遲れを引き起こす可能性がある。

</li><li> 1 行に複數のコマンドを書いてゐると、1 つの時閒しか得られない。ここのコマンドに對して時閒を見るにはその行を分割すること。

</li><li> 各行の時閒の總和をとると、たいてい函數全體の時閒より小さくなる。各行の閒にオーバーヘッドがある。

</li><li> Vim が終了する前に削除された函數はプロファイリング情報を生成しない。必要なら變數 |<a href="eval_002etxt.html#v_003aprofiling">v:profiling</a>| をチェックすること:
<pre class="verbatim">:if !v:profiling
:   delfunc MyFunc
:endif
</pre></li><li> マルチプロセッサーシステム上では、スリープモードが作動したときや、省力のためプロセッサーの周波數が下がつたとき、プロファイリングが奇妙な結果を出すかもしれない。

</li><li> 函數が再歸的に呼ばれた場合、&quot;self&quot; 時閒は正しくない。
</li></ul>


<hr>
<div class="header">
<p>
Up: <a href="Mu-Ci-.html#g_t_76ee_6b21" accesskey="u" rel="up">目次</a> &nbsp; [<a href="Indexes-CP.html#Indexes-CP" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
