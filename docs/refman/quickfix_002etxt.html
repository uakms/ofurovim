<!DOCTYPE html>
<html lang="ja">
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>

<title>quickfix.txt (Vim Reference Manual)</title>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<meta name="description" content="quickfix.txt (Vim Reference Manual)">
<meta name="keywords" content="quickfix.txt (Vim Reference Manual)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<link href="Mu-Ci-.html" rel="start" title="目次">
<link href="Indexes-CP.html" rel="index" title="Indexes CP">
<link href="Mu-Ci-.html" rel="up" title="目次">
<link href="ft_005fada_002etxt.html" rel="next" title="ft_ada.txt">
<link href="filetype_002etxt.html" rel="prev" title="filetype.txt">
<style>
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="style.css">


</head>

<body lang="ja">
<span id="quickfix_002etxt"></span><div class="header">
<p>
Up: <a href="Mu-Ci-.html" accesskey="u" rel="up">目次</a> &nbsp; [<a href="Indexes-CP.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Bian-Ji-_002c-konpairu_002c-Xiu-Zheng-_002c-noLiu-rewoZao-kusurukomando"></span><h2 class="unnumbered">編輯、コンパイル、修正、の流れを早くするコマンド</h2>
<pre class="verbatim">*quickfix.txt*  For Vim バージョン 8.1.  Last change: 2019 Oct 22


		  VIMリファレンスマニュアル    by Bram Moolenaar
</pre>

<p>この話題に關してはユーザーマニュアルの |<a href="usr_005f30_002etxt.html#g_t30_002e1">30.1</a>| でも紹介されてゐる。
</p>
<table>
<tr><td width="50%">1. QuickFix コマンドの使ひ方</td><td width="50%">|<a href="#quickfix">quickfix</a>|</td></tr>
<tr><td width="50%">2. エラーウィンドウ</td><td width="50%">|<a href="#quickfix_002dwindow">quickfix-window</a>|</td></tr>
<tr><td width="50%">3. 複數のエラーリストを使ふ</td><td width="50%">|<a href="#quickfix_002derror_002dlists">quickfix-error-lists</a>|</td></tr>
<tr><td width="50%">4. :make の使ひ方</td><td width="50%">|<a href="#g_t_003amake_005fmakeprg">:make_makeprg</a>|</td></tr>
<tr><td width="50%">5. :grep の使ひ方</td><td width="50%">|<a href="#grep">grep</a>|</td></tr>
<tr><td width="50%">6. コンパイラを選擇する</td><td width="50%">|<a href="#compiler_002dselect">compiler-select</a>|</td></tr>
<tr><td width="50%">7. エラーフォーマット</td><td width="50%">|<a href="#error_002dfile_002dformat">error-file-format</a>|</td></tr>
<tr><td width="50%">8. ディレクトリスタック</td><td width="50%">|<a href="#quickfix_002ddirectory_002dstack">quickfix-directory-stack</a>|</td></tr>
<tr><td width="50%">9. 具體的なエラーファイルフォーマット</td><td width="50%">|<a href="#errorformats">errorformats</a>|</td></tr>
</table>

<p>コンパイル時に |<a href="various_002etxt.html#g_t_002bquickfix">+quickfix</a>| 機能が無效にされた場合は、QuickFix コマンドは使へない。
</p>
<span id="quickfix"></span><span id="Quickfix"></span><span id="E42"></span><span id="index-quickfix"></span>
<span id="index-Quickfix"></span>
<span id="index-E42"></span>
<span id="index-QuickFix-komandonoShi-iFang-"></span>
<span id="g_t1_002e-QuickFix-komandonoShi-iFang-"></span><h3 class="section">1. QuickFix コマンドの使ひ方</h3>

<p>Vim には編輯-コンパイル-編輯のサイクルを加速するための特別なモードがある。これは Amiga の Manx&rsquo;s Aztec C compiler の quickfix オプションにインスパイアされた。C コンパイラから出力されたエラーメッセージをファイルに保存し、Vim でそのエラーにジャンプするといふアイデアである。エラーメッセージを全部覺えておかなくても、それぞれの問題を檢證し、修正することができる。
</p>
<p>QuickFix コマンドはより一般的に、ファイル中の位置のリストを作成し、ジャンプするために使ふことができる。例へば、|<a href="#g_t_003avimgrep">:vimgrep</a>| はパターンにマッチした位置をリストする。スクリプト中で |<a href="eval_002etxt.html#getqflist_0028_0029">getqflist()</a>| を使つてこれらの位置を參照することができる。そのため、編輯・コンパイル・修正のサイクル以外にも多くの事に利用できる。
</p>
<p>ファイルにエラーメッセージがあるなら &quot;vim -q filename&quot; で起動する:
</p><pre class="verbatim">vim -q filename
</pre>
<p>Vim の中でコマンドを實行し結果を得る方法の 1 つに |<a href="#g_t_003amake">:make</a>| コマンドがある (後述)。
</p>
<p>各コンパイラからのエラーメッセージを解釋させるためには、オプション &rsquo;<samp>errorformat</samp>&rsquo; をセットする (下の |<a href="#errorformat">errorformat</a>| を參照)。
</p>
<span id="quickfix_002dID"></span><span id="index-quickfix_002dID"></span>
<p>各 QuickFix リストは QuickFix ID と呼ばれる一意な識別子を持ち、この番號は Vim セッションの中で變はらない。|<a href="eval_002etxt.html#getqflist_0028_0029">getqflist()</a>| 函數はリストに割り當てられた識別子の取得に使用できる。QuickFix リスト番號もある。この番號は、10 個以上のリストが QuickFix スタックに追加されるたびに變更される可能性がある。
</p>
<span id="location_002dlist"></span><span id="E776"></span><span id="index-location_002dlist"></span>
<span id="index-E776"></span>
<p>ロケーションリストはウィンドウローカルな QuickFix リストである。&lsquo;:vimgrep&lsquo;, &lsquo;:grep&lsquo;, &lsquo;:helpgrep&lsquo;, &lsquo;:make&lsquo; などのコマンドは QuickFix リストを作成するが、それらに對應する &lsquo;:lvimgrep&lsquo;, &lsquo;:lgrep&lsquo;, &lsquo;:lhelpgrep&lsquo;, &lsquo;:lmake&lsquo; などのコマンドを使ふことでロケーションリストを得ることができる。
<span id="location_002dlist_002dfile_002dwindow"></span><span id="index-location_002dlist_002dfile_002dwindow"></span>
ロケーションリストはウィンドウに關聯付けられてゐて、各ウィンドウが別々のロケーションリストを持つことができる。ロケーションリストは1個のウィンドウにだけ關聯付けることができる。ロケーションリストは QuickFix リストとは獨立してゐる。
</p>
<p>ロケーションリストを持つウィンドウが分割されると、新しいウィンドウはロケーションリストのコピーを得る。ロケーションリストへの參照が全てなくなると、そのロケーションリストは破毀される。
</p>
<span id="quickfix_002dchangedtick"></span><span id="index-quickfix_002dchangedtick"></span>
<p>全ての QuickFix リストとロケーションリストはそのリストに行はれた變更の總數を追跡する讀み込み專用の changedtick 變數を持つ。QuickFix リストが變更されるたびに、この總數はインクリメントされる。これは、リストが變更されたときだけアクションを實行することに使用できる。|<a href="eval_002etxt.html#getqflist_0028_0029">getqflist()</a> および |<a href="eval_002etxt.html#getloclist_0028_0029">getloclist()</a>| 函數は changedtick の現在の値を問ひ合はせるのに使用できる。changedtick 變數を變更することはできない。
</p>
<p>以下の QuickFix コマンドが利用できる。ロケーションリストコマンドは QuickFix コマンドに似てゐて、QuickFix コマンドのプリフィックス &rsquo;c&rsquo; が &rsquo;l&rsquo; に置き換はつてゐる。
</p>
<span id="E924"></span><span id="index-E924"></span>
<p>ロケーションリストコマンドで處理されてゐるにもかかはらず現在のウィンドウが |<a href="autocmd_002etxt.html#autocommand">autocommand</a>| により閉ぢられる場合、それは中斷される。
</p>
<span id="E925"></span><span id="E926"></span><span id="index-E925"></span>
<span id="index-E926"></span>
<p>ロケーションリストコマンドで處理されてゐるにもかかはらず現在の QuickFix またはロケーションリストが |<a href="autocmd_002etxt.html#autocommand">autocommand</a>| に變更される場合、それは中斷される。
</p>
<dl compact="compact">
<dd><span id="g_t_003acc"></span><span id="index-_003acc"></span>
</dd>
<dt>:cc[!] [nr]</dt>
<dt>:[nr]cc[!]</dt>
<dd><p>エラー [nr]を表示する。 [nr] が省略されると同じエラーが再度表示される。[!] が無く、現在のバッファに變更が有りウィンドウが1つしか無く、&rsquo;<samp>hidden</samp>&rsquo; も &rsquo;<samp>autowrite</samp>&rsquo; も off である場合には、他のバッファへジャンプする事は無い。
</p>
<p>[!] を使用して他のバッファに移る時、現在のバッファへの變更點は、&rsquo;<samp>hidden</samp>&rsquo; がセットされてゐるか別のウィンドウが開いてゐるかしない場合、破毀されてしまふ。バッファ移動の際は設定 &rsquo;<samp>switchbuf</samp>&rsquo; が關係してくる。
</p>
<p>quickfix ウィンドウで使用するときは、現在行の &quot;.&quot; や 最終行の &quot;$&quot; を含む行番號を使用できる。
</p>
<span id="g_t_003all"></span><span id="index-_003all"></span>
</dd>
<dt>:ll[!] [nr]</dt>
<dt>:[nr]ll[!]</dt>
<dd><p>&quot;:cc&quot; と同樣だが、QuickFix リストでなくカレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acn"></span><span id="g_t_003acne"></span><span id="g_t_003acnext"></span><span id="E553"></span><span id="index-_003acn"></span>
<span id="index-_003acne"></span>
<span id="index-_003acnext"></span>
<span id="index-E553"></span>
</dd>
<dt>:[count]cn[ext][!]</dt>
<dd><p>ファイル名を含むエラーリストで [count] 個後のエラーを表示する。ファイル名が無かつた場合 [count] 個後のエラーに移動する。[!] と &rsquo;<samp>switchbuf</samp>&rsquo; については |<a href="#g_t_003acc">:cc</a>| を參照。
</p>
<span id="g_t_003alne"></span><span id="g_t_003alnext"></span><span id="index-_003alne"></span>
<span id="index-_003alnext"></span>
</dd>
<dt>:[count]lne[xt][!]</dt>
<dd><p>&quot;:cnext&quot; と同樣だが、QuickFix リストでなくカレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acp"></span><span id="g_t_003acprevious"></span><span id="g_t_003acprev"></span><span id="g_t_003acN"></span><span id="g_t_003acNext"></span><span id="index-_003acp"></span>
<span id="index-_003acprevious"></span>
<span id="index-_003acprev"></span>
<span id="index-_003acN"></span>
<span id="index-_003acNext"></span>
</dd>
<dt>:[count]cN[ext][!] または</dt>
<dt>:[count]cp[revious][!]</dt>
<dd><p>ファイル名を含むエラーリストで [count] 個前のエラーを表示する。ファイル名が無かつた場合 [count] 個前のエラーに移動する。[!] と &rsquo;<samp>switchbuf</samp>&rsquo; については |<a href="#g_t_003acc">:cc</a>| を參照。
</p>

<span id="g_t_003alp"></span><span id="g_t_003alprevious"></span><span id="g_t_003alprev"></span><span id="g_t_003alN"></span><span id="g_t_003alNext"></span><span id="index-_003alp"></span>
<span id="index-_003alprevious"></span>
<span id="index-_003alprev"></span>
<span id="index-_003alN"></span>
<span id="index-_003alNext"></span>
</dd>
<dt>:[count]lN[ext][!] または</dt>
<dt>:[count]lp[revious][!]</dt>
<dd><p>&quot;:cNext&quot; と &quot;:cprevious&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acabo"></span><span id="g_t_003acabove"></span><span id="index-_003acabo"></span>
<span id="index-_003acabove"></span>
</dd>
<dt>:[count]cabo[ve]</dt>
<dd><p>カレントバッファの現在行の [count] 上のエラーに移動する。[count] を省略すると、1 が使用される。エラーがない場合は、エラーメッセージが表示される。quickfix リストのエントリは、バッファ番號と行番號でソートされてゐると假定する。同じ行に複數のエラーがある場合は、最初のエントリだけが使用される。[count] が現在の行より上のエントリの數を超えると、ファイル內の最初のエラーが選擇される。
</p>
<span id="g_t_003alab"></span><span id="g_t_003alabove"></span><span id="index-_003alab"></span>
<span id="index-_003alabove"></span>
</dd>
<dt>:[count]lab[ove]</dt>
<dd><p>quickfix リストの代はりにカレントウィンドウの location リストが使用されることを除けば、&quot;<code>:cabove</code>&quot; と同じ。
</p>
<span id="g_t_003acbel"></span><span id="g_t_003acbelow"></span><span id="index-_003acbel"></span>
<span id="index-_003acbelow"></span>
</dd>
<dt>:[count]cbel[ow]</dt>
<dd><p>カレントバッファの現在行の [count] 下にあるエラーに移動する。[count] を省略すると、1 が使用される。エラーがない場合は、エラーメッセージが表示される。quickfix リストのエントリは、バッファ番號と行番號でソートされてゐると假定する。同じ行に複數のエラーがある場合は、最初のエントリだけが使用される。[count] が現在の行より下のエントリの數を超えると、ファイル內の最後のエラーが選擇される。
</p>
<span id="g_t_003albel"></span><span id="g_t_003albelow"></span><span id="index-_003albel"></span>
<span id="index-_003albelow"></span>
</dd>
<dt>:[count]lbel[ow]</dt>
<dd><p>quickfix リストの代はりにカレントウィンドウの location リストが使用されることを除けば、&quot;<code>:cbelow</code>&quot; と同じ。
</p>
<span id="g_t_003acbe"></span><span id="g_t_003acbefore"></span><span id="index-_003acbe"></span>
<span id="index-_003acbefore"></span>
</dd>
<dt>:[count]cbe[fore]</dt>
<dd><p>カレントバッファ內の現在のカーソル位置の [count] 前のエラーに移動する。[count] を省略すると、1 が使用される。エラーがない場合は、エラーメッセージが表示される。quickfix リストのエントリは、バッファ、行番號および桁番號でソートされてゐると假定する。[count] が現在位置より前のエントリ數を超えると、ファイル內の最初のエラーが選擇される。
</p>
<span id="g_t_003albe"></span><span id="g_t_003albefore"></span><span id="index-_003albe"></span>
<span id="index-_003albefore"></span>
</dd>
<dt>:[count]lbe[fore]</dt>
<dd><p>quickfix リストの代はりにカレントウィンドウの location リストが使用されることを除けば、&quot;<code>:cbefore</code>&quot; と同じ。
</p>
<span id="g_t_003acaf"></span><span id="g_t_003acafter"></span><span id="index-_003acaf"></span>
<span id="index-_003acafter"></span>
</dd>
<dt>:[count]caf[ter]</dt>
<dd><p>カレントバッファ內の現在のカーソル位置の [count] 後のエラーに移動する。[count] を省略すると、1 が使用される。エラーがない場合は、エラーメッセージが表示される。quickfix リストのエントリは、バッファ、行番號および桁番號でソートされてゐると假定する。[count] が現在位置以降のエントリ數を超えると、ファイル內の最後のエラーが選擇される。
</p>
<span id="g_t_003alaf"></span><span id="g_t_003alafter"></span><span id="index-_003alaf"></span>
<span id="index-_003alafter"></span>
</dd>
<dt>:[count]laf[ter]</dt>
<dd><p>quickfix リストの代はりにカレントウィンドウの location リストが使用されることを除けば、&quot;<code>:cafter</code>&quot; と同じ。
</p>
<span id="g_t_003acnf"></span><span id="g_t_003acnfile"></span><span id="index-_003acnf"></span>
<span id="index-_003acnfile"></span>
</dd>
<dt>:[count]cnf[ile][!]</dt>
<dd><p>ファイル名を含むエラーリストで [count] 個後のファイルの最初のエラーを表示する。ファイル名が無いか後のファイルが無い場合には、[count] 後のエラーに移動する。[!] と &rsquo;<samp>switchbuf</samp>&rsquo; については |<a href="#g_t_003acc">:cc</a>| を參照。
</p>
<span id="g_t_003alnf"></span><span id="g_t_003alnfile"></span><span id="index-_003alnf"></span>
<span id="index-_003alnfile"></span>
</dd>
<dt>:[count]lnf[ile][!]</dt>
<dd><p>&quot;:cnfile&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acpf"></span><span id="g_t_003acpfile"></span><span id="g_t_003acNf"></span><span id="g_t_003acNfile"></span><span id="index-_003acpf"></span>
<span id="index-_003acpfile"></span>
<span id="index-_003acNf"></span>
<span id="index-_003acNfile"></span>
</dd>
<dt>:[count]cNf[ile][!] または</dt>
<dt>:[count]cpf[ile][!]</dt>
<dd><p>ファイル名を含むエラーリストで [count] 個前のファイルの最後のエラーを表示する。ファイル名が無いか後のファイルが無い場合には、[count] 個前のエラーに移動する。[!] と &rsquo;<samp>switchbuf</samp>&rsquo; については |<a href="#g_t_003acc">:cc</a>| を參照。
</p>

<span id="g_t_003alpf"></span><span id="g_t_003alpfile"></span><span id="g_t_003alNf"></span><span id="g_t_003alNfile"></span><span id="index-_003alpf"></span>
<span id="index-_003alpfile"></span>
<span id="index-_003alNf"></span>
<span id="index-_003alNfile"></span>
</dd>
<dt>:[count]lNf[ile][!] または</dt>
<dt>:[count]lpf[ile][!]</dt>
<dd><p>&quot;:cNfile&quot; と &quot;:cpfile&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acrewind"></span><span id="g_t_003acr"></span><span id="index-_003acrewind"></span>
<span id="index-_003acr"></span>
</dd>
<dt>:cr[ewind][!] [nr]</dt>
<dd><p>[nr] のエラーを表示する。 [nr] が省略されると一番最初のエラーが表示される。|<a href="#g_t_003acc">:cc</a>| を參照。
</p>
<span id="g_t_003alrewind"></span><span id="g_t_003alr"></span><span id="index-_003alrewind"></span>
<span id="index-_003alr"></span>
</dd>
<dt>:lr[ewind][!] [nr]</dt>
<dd><p>&quot;:crewind&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acfirst"></span><span id="g_t_003acfir"></span><span id="index-_003acfirst"></span>
<span id="index-_003acfir"></span>
</dd>
<dt>:cfir[st][!] [nr]</dt>
<dd><p>&quot;:crewind&quot; と同じ。
</p>
<span id="g_t_003alfirst"></span><span id="g_t_003alfir"></span><span id="index-_003alfirst"></span>
<span id="index-_003alfir"></span>
</dd>
<dt>:lfir[st][!] [nr]</dt>
<dd><p>&quot;:lrewind&quot; と同じ。
</p>
<span id="g_t_003aclast"></span><span id="g_t_003acla"></span><span id="index-_003aclast"></span>
<span id="index-_003acla"></span>
</dd>
<dt>:cla[st][!] [nr]</dt>
<dd><p>[nr] のエラーを表示する。 [nr] が省略されると一番最後のエラーが表示される。|<a href="#g_t_003acc">:cc</a>| を參照。
</p>
<span id="g_t_003allast"></span><span id="g_t_003alla"></span><span id="index-_003allast"></span>
<span id="index-_003alla"></span>
</dd>
<dt>:lla[st][!] [nr]</dt>
<dd><p>&quot;:clast&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acq"></span><span id="g_t_003acquit"></span><span id="index-_003acq"></span>
<span id="index-_003acquit"></span>
</dd>
<dt>:cq[uit][!]</dt>
<dd><p>Vim をエラーとして終了することで、コンパイラが同じファイルをコンパイルする事が無くなる。
</p><blockquote>
<p><strong>警告:</strong> <br>
ファイルに對する變更はすべて失はれる ([!] を指定しなくても)！ このコマンドは、システムへの戾り値が非零であるといふこと以外 &quot;:qall!&quot; |<a href="editing_002etxt.html#g_t_003aqall">:qall</a>| と同じである。
</p></blockquote>

<span id="g_t_003acf"></span><span id="g_t_003acfile"></span><span id="index-_003acf"></span>
<span id="index-_003acfile"></span>
</dd>
<dt>:cf[ile][!] [errorfile]</dt>
<dd><p>エラーファイルを讀みこみ最初のエラーへ移動する。Vim がオプション -q で起動された時には自動的に行はれる。コンパイルの閒 Vim を實行したままにしたい時に使ふことができる。エラーファイルの名前を與へればオプション &rsquo;<samp>errorfile</samp>&rsquo; に [errorfile] が設定される。[!] については |<a href="#g_t_003acc">:cc</a>| を參照。
</p>
<p>エラーファイルのエンコーディングが &rsquo;<samp>encoding</samp>&rsquo; と異なる場合には、&rsquo;<samp>makeencoding</samp>&rsquo; オプションでエンコーディングを指定できる。
</p>
<span id="g_t_003alf"></span><span id="g_t_003alfi"></span><span id="g_t_003alfile"></span><span id="index-_003alf"></span>
<span id="index-_003alfi"></span>
<span id="index-_003alfile"></span>
</dd>
<dt>:lf[ile][!] [errorfile]</dt>
<dd><p>&quot;:cfile&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。コマンドラインオプション -q を使つてロケーションリストを設定することはできない。
</p>

<span id="g_t_003acg"></span><span id="g_t_003acgetfile"></span><span id="index-_003acg"></span>
<span id="index-_003acgetfile"></span>
</dd>
<dt>:cg[etfile] [errorfile]</dt>
<dd><p>エラーファイルを讀み込む。&quot;:cfile&quot; に似てゐるが、最初のエラーに移動しない。
</p>
<p>エラーファイルのエンコーディングが &rsquo;<samp>encoding</samp>&rsquo; と異なる場合には、&rsquo;<samp>makeencoding</samp>&rsquo; オプションでエンコーディングを指定できる。
</p>

<span id="g_t_003alg"></span><span id="g_t_003alge"></span><span id="g_t_003algetfile"></span><span id="index-_003alg"></span>
<span id="index-_003alge"></span>
<span id="index-_003algetfile"></span>
</dd>
<dt>:lg[etfile] [errorfile]</dt>
<dd><p>&quot;:cgetfile&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acaddf"></span><span id="g_t_003acaddfile"></span><span id="index-_003acaddf"></span>
<span id="index-_003acaddfile"></span>
</dd>
<dt>:caddf[ile] [errorfile]</dt>
<dd><p>エラーファイルを讀み込み、現在の QuickFix リストにエラーを追加する。QuickFix リストがまだない場合は、新しいリストが作成される。
</p>
<p>エラーファイルのエンコーディングが &rsquo;<samp>encoding</samp>&rsquo; と異なる場合には、&rsquo;<samp>makeencoding</samp>&rsquo; オプションでエンコーディングを指定できる。
</p>
<span id="g_t_003aladdf"></span><span id="g_t_003aladdfile"></span><span id="index-_003aladdf"></span>
<span id="index-_003aladdfile"></span>
</dd>
<dt>:laddf[ile] [errorfile]</dt>
<dd><p>&quot;:caddfile&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acb"></span><span id="g_t_003acbuffer"></span><span id="E681"></span><span id="index-_003acb"></span>
<span id="index-_003acbuffer"></span>
<span id="index-E681"></span>
</dd>
<dt>:cb[uffer][!] [bufnr]</dt>
<dd><p>カレントバッファからエラーリストを讀み込む。 [bufnr] を指定すると、カレントバッファの代はりにそのバッファが使はれる。bufnr には讀み込まれてゐるバッファ番號を指定しなければならない。
</p>
<p>範圍を指定すると、讀み込む行を指定することができる。範圍指定がないとバッファ全體が使はれる。[!] については |<a href="#g_t_003acc">:cc</a>| を參照。
</p>
<span id="g_t_003alb"></span><span id="g_t_003albuffer"></span><span id="index-_003alb"></span>
<span id="index-_003albuffer"></span>
</dd>
<dt>:lb[uffer][!] [bufnr]</dt>
<dd><p>&quot;:cbuffer&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acgetb"></span><span id="g_t_003acgetbuffer"></span><span id="index-_003acgetb"></span>
<span id="index-_003acgetbuffer"></span>
</dd>
<dt>:cgetb[uffer] [bufnr]</dt>
<dd><p>カレントバッファからエラーリストを讀み込む。&quot;:cbuffer&quot; と同じだが、最初のエラーにジャンプしない點が異なる。
</p>
<span id="g_t_003algetb"></span><span id="g_t_003algetbuffer"></span><span id="index-_003algetb"></span>
<span id="index-_003algetbuffer"></span>
</dd>
<dt>:lgetb[uffer] [bufnr]</dt>
<dd><p>&quot;:cgetbuffer&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acad"></span><span id="g_t_003acadd"></span><span id="g_t_003acaddbuffer"></span><span id="index-_003acad"></span>
<span id="index-_003acadd"></span>
<span id="index-_003acaddbuffer"></span>
</dd>
<dt>:cad[dbuffer] [bufnr]</dt>
<dd><p>カレントバッファからエラーリストを讀み込み、現在の QuickFix リストにエラーを追加する。QuickFix リストがまだ存在しない場合は、新しいリストが作成される。それ以外は &quot;:cbuffer&quot; と同じ。
</p>
<span id="g_t_003aladdb"></span><span id="g_t_003aladdbuffer"></span><span id="index-_003aladdb"></span>
<span id="index-_003aladdbuffer"></span>
</dd>
<dt>:laddb[uffer] [bufnr]</dt>
<dd><p>&quot;:caddbuffer&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acex"></span><span id="g_t_003acexpr"></span><span id="E777"></span><span id="index-_003acex"></span>
<span id="index-_003acexpr"></span>
<span id="index-E777"></span>
</dd>
<dt>:cex[pr][!] {expr}</dt>
<dd><p>{expr} の結果を使つて QuickFix リストを作成し、最初のエラーにジャンプする。
</p>
<p>{expr} が文字列のときは、その文字列を改行コードで區切り、各行を &rsquo;<samp>errorformat</samp>&rsquo; のグローバル値に從つて解釋し、結果を QuickFix リストに追加する。
</p>
<p>{expr} がリストのときはリストの各文字列要素を解釋し、QuickFix リストに追加する。リスト中の文字列でない要素は無視される。[!] については |<a href="#g_t_003acc">:cc</a>| を參照。
</p>
<p>例:
</p><pre class="verbatim">:cexpr system('grep -n xyz *')
:cexpr getline(1, '$')
</pre><span id="g_t_003alex"></span><span id="g_t_003alexpr"></span><span id="index-_003alex"></span>
<span id="index-_003alexpr"></span>
</dd>
<dt>:lex[pr][!] {expr}</dt>
<dd><p>|<a href="#g_t_003acexpr">:cexpr</a>| と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acgete"></span><span id="g_t_003acgetexpr"></span><span id="index-_003acgete"></span>
<span id="index-_003acgetexpr"></span>
</dd>
<dt>:cgete[xpr] {expr}</dt>
<dd><p>{expr} の結果を使つて QuickFix リストを作成する。|<a href="#g_t_003acexpr">:cexpr</a>| と同樣だが、最初のエラーにジャンプしない點が異なる。
</p>
<span id="g_t_003algete"></span><span id="g_t_003algetexpr"></span><span id="index-_003algete"></span>
<span id="index-_003algetexpr"></span>
</dd>
<dt>:lgete[xpr] {expr}</dt>
<dd><p>|<a href="#g_t_003acgetexpr">:cgetexpr</a>| と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acadde"></span><span id="g_t_003acaddexpr"></span><span id="index-_003acadde"></span>
<span id="index-_003acaddexpr"></span>
</dd>
<dt>:cadde[xpr] {expr}</dt>
<dd><p>{expr} を評價し、結果の行を現在のQuickFixリストに追加する。QuickFix リストがまだ無い場合は、新しいリストが作成される。現在のカーソル位置は變はらない。より詳しくは |<a href="#g_t_003acexpr">:cexpr</a>| を參照。
</p>
<p>例:
</p><pre class="verbatim">:g/mypattern/caddexpr expand(&quot;%&quot;) . &quot;:&quot; . line(&quot;.&quot;) .  &quot;:&quot; . getline(&quot;.&quot;)
</pre><span id="g_t_003alad"></span><span id="g_t_003aaddd"></span><span id="g_t_003aladdexpr"></span><span id="index-_003alad"></span>
<span id="index-_003aaddd"></span>
<span id="index-_003aladdexpr"></span>
</dd>
<dt>:lad[dexpr] {expr}</dt>
<dd><p>&quot;:caddexpr&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acl"></span><span id="g_t_003aclist"></span><span id="index-_003acl"></span>
<span id="index-_003aclist"></span>
</dd>
<dt>:cl[ist] [from] [, [to]]</dt>
<dd><p>有效なエラーを全て列擧する |<a href="#quickfix_002dvalid">quickfix-valid</a>|。[from] 及び／もしくは [to] で行數を指定された場合、その範圍のエラーが表示される。負であつた場合最後のエラーから數へる。-1 が最後のエラーとなる。設定 &rsquo;<samp>switchbuf</samp>&rsquo; がバッファの移動に關係する。
|<a href="various_002etxt.html#g_t_003afilter">:filter</a>| コマンドは與へられたパターンにマッチしてゐる Quickfix エントリのみを表示するのに使ふことができる。パターンはファイル名、モジュール名、エントリのテキストに對してマッチされる。
</p>
</dd>
<dt>:cl[ist] +{count}</dt>
<dd><p>現在と次の {count} 個の有效なエラーを列擧する。これは &quot;:clist from from+count&quot; と似てゐる。ここで &quot;from&quot; はエラーの現在の場所である。
</p>
</dd>
<dt>:cl[ist]! [from] [, [to]]</dt>
<dd><p>全てのエラーを表示する。
</p>
</dd>
<dt>:cl[ist]! +{count}</dt>
<dd><p>現在と次の {count} 個のエラー行を列擧する。これは現在の評價されてゐない行の後にある評價されてゐない行を見るのに便利である。例へば &quot;:clist&quot; は次のやうに表示する:
</p><pre class="verbatim">8384 testje.java:252: error: cannot find symbol
</pre><p>それから &quot;:cl! +3&quot; を使ふと、結果はかうだ:
</p><pre class="verbatim">8384 testje.java:252: error: cannot find symbol
8385:   ZexitCode = Fmainx();
8386:               ^
8387:   symbol:   method Fmainx()
</pre>
<span id="g_t_003alli"></span><span id="g_t_003allist"></span><span id="index-_003alli"></span>
<span id="index-_003allist"></span>
</dd>
<dt>:lli[st] [from] [, [to]]</dt>
<dd><p>&quot;:clist&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
</dd>
<dt>:lli[st]! [from] [, [to]]</dt>
<dd><p>カレントウィンドウのロケーションリストの中身を全部表示する。
</p></dd>
</dl>

<p>正しいエラーの位置は隱されたマークによつて示されてゐるので、例へ行を插入したり削除したとしても問題はない (Manx&rsquo;s Z editor ではさうではない)。時々マークが幾つかの理由で消されてしまふ事があり、メッセージ &quot;line changed&quot; がその警告となる。一度 Vim を終了し再起動した場合マークは失はれ正しいエラー位置は把握できない。
</p>
<p>QuickFix コマンド (&rsquo;<code>:make</code>&rsquo;, &rsquo;<code>:grep</code>&rsquo; など) を實行する前後に 2 つの自動コマンドが利用できる。詳しくは |<a href="autocmd_002etxt.html#QuickFixCmdPre">QuickFixCmdPre</a>| と |<a href="autocmd_002etxt.html#QuickFixCmdPost">QuickFixCmdPost</a>| を參照。
</p>
<span id="QuickFixCmdPost_002dexample"></span><span id="index-QuickFixCmdPost_002dexample"></span>
<p>&rsquo;<samp>encoding</samp>&rsquo; とロケールが異なる場合、コンパイラのエラーメッセージと Vim 內部のエンコーディングが異なる場合がある。次のやうにすれば、このメッセージを變換できる:
</p><pre class="verbatim">function QfMakeConv()
   let qflist = getqflist()
   for i in qflist
      let i.text = iconv(i.text, &quot;cp936&quot;, &quot;utf-8&quot;)
   endfor
   call setqflist(qflist)
endfunction

au QuickfixCmdPost make call QfMakeConv()
</pre><p>代はりに &rsquo;<samp>makeencoding</samp>&rsquo; オプションを使ふこともできる。
</p>
<span id="quickfix_002dtitle"></span><span id="index-quickfix_002dtitle"></span>
<p>すべての QuickFix リストとロケーションリストはタイトルを持つ。デフォルトではタイトルはそのリストを作成したコマンドに設定される。|<a href="eval_002etxt.html#getqflist_0028_0029">getqflist()</a>| と |<a href="eval_002etxt.html#getloclist_0028_0029">getloclist()</a>| 函數はそれぞれ QuickFix リストとロケーションリストのタイトルを取得するために使はれる。|<a href="eval_002etxt.html#setqflist_0028_0029">setqflist()</a>| と |<a href="eval_002etxt.html#setloclist_0028_0029">setloclist()</a>| 函數はそれぞれ QuickFix リストとロケーションリストのタイトルを變更するために使はれる。例:
</p><pre class="verbatim">call setqflist([], 'a', {'title' : 'Cmd output'})
echo getqflist({'title' : 1})
call setloclist(3, [], 'a', {'title' : 'Cmd output'})
echo getloclist(3, {'title' : 1})
</pre><span id="quickfix_002dindex"></span><span id="index-quickfix_002dindex"></span>
<p>いづれかの quickfix コマンド (例へば |<a href="#g_t_003acc">:cc</a>|, |<a href="#g_t_003acnext">:cnext</a>|, |<a href="#g_t_003acprev">:cprev</a>| 等) を使用して quickfix/location リストエントリに移動すると、そのエントリが現在選擇されてゐるエントリになる。quickfix/location リストで現在選擇されてゐるエントリのインデックスは、getqflist()/getloclist() 函數を使つて取得できる。例:
</p><pre class="verbatim">echo getqflist({'idx' : 0}).idx
echo getqflist({'id' : qfid, 'idx' : 0}).idx
echo getloclist(2, {'idx' : 0}).idx
</pre><p>新しい quickfix リストの場合、最初のエントリが選擇され、インデックスは 1 になる。すべての quickfix/location リスト內のすべてのエントリは、setqflist() 函數を使用して現在選擇されてゐるエントリとして設定できる。例:
</p><pre class="verbatim">call setqflist([], 'a', {'idx' : 12})
call setqflist([], 'a', {'id' : qfid, 'idx' : 7})
call setloclist(1, [], 'a', {'idx' : 7})
</pre><span id="quickfix_002dsize"></span><span id="index-quickfix_002dsize"></span>
<p>あなたは QuickFix リストとロケーションリストの中の項目の數をそれぞれ |<a href="eval_002etxt.html#getqflist_0028_0029">getqflist()</a>| と |<a href="eval_002etxt.html#getloclist_0028_0029">getloclist()</a>| 函數を使用して取得できる。例:
</p><pre class="verbatim">echo getqflist({'size' : 1})
echo getloclist(5, {'size' : 1})
</pre><span id="quickfix_002dcontext"></span><span id="index-quickfix_002dcontext"></span>
<p>任意の Vim の型は QuickFix リストまたはロケーションリストとのコンテキストとして關聯付けることができる。|<a href="eval_002etxt.html#setqflist_0028_0029">setqflist()</a>| と |<a href="eval_002etxt.html#setloclist_0028_0029">setloclist()</a>| 函數はコンテキストを QuickFix とロケーションリストにそれぞれ關聯付けることに使用できる。|<a href="eval_002etxt.html#getqflist_0028_0029">getqflist()</a>| と |<a href="eval_002etxt.html#getloclist_0028_0029">getloclist()</a>| 函數はそれぞれ QuickFix とロケーションリストのコンテキストの取得に使用できる。これは複數の QuickFix/ロケーションリストを取り扱ふ Vim プラグインにとつて便利である。
</p>
<p>例:
</p><pre class="verbatim">let somectx = {'name' : 'Vim', 'type' : 'Editor'}
call setqflist([], 'a', {'context' : somectx})
echo getqflist({'context' : 1})

let newctx = ['red', 'green', 'blue']
call setloclist(2, [], 'a', {'id' : qfid, 'context' : newctx})
echo getloclist(2, {'id' : qfid, 'context' : 1})
</pre><span id="quickfix_002dparse"></span><span id="index-quickfix_002dparse"></span>
<p>|<a href="eval_002etxt.html#getqflist_0028_0029">getqflist()</a>| 函數を使用して QuickFix リストを作成または變更せずに、&rsquo;<samp>errorformat</samp>&rsquo; を使用して行のリストをパースできる。例:
</p><pre class="verbatim">echo getqflist({'lines' : [&quot;F1:10:Line10&quot;, &quot;F2:20:Line20&quot;]})
echo getqflist({'lines' : systemlist('grep -Hn quickfix *')})
</pre><p>これは &rsquo;<samp>items</samp>&rsquo; キーに行からパースされた QuickFix の項目のリストが含まれてゐる辭書を返す。以下は &rsquo;<samp>errorformat</samp>&rsquo; オプションを變更せずにカスタム &rsquo;<samp>errorformat</samp>&rsquo; を使つて行をパースする方法を示してゐる:
</p><pre class="verbatim">echo getqflist({'efm' : '%f#%l#%m', 'lines' : ['F1#10#Line']})
</pre>
<span id="QuickFix-risutoyarokesiyonrisutoZhongnobatuhuaniDui-sitekomandowoShi-Xing-_003a"></span><h4 class="unnumberedsubsec">QuickFix リストやロケーションリスト中のバッファに對してコマンドを實行:</h4>
<dl compact="compact">
<dd><span id="g_t_003acdo"></span><span id="index-_003acdo"></span>
</dd>
<dt>:cdo[!] {cmd}</dt>
<dd><p>QuickFix リスト中の有效な各項目に對して {cmd} を實行する。以下の操作と同樣に動作する:
</p><pre class="verbatim">:cfirst
:{cmd}
:cnext
:{cmd}
etc.
</pre><p>カレントファイルが破毀できず(|<a href="editing_002etxt.html#abandon">abandon</a>|)、かつ [!] が與へられない場合、このコマンドは失敗する。次のエントリへの移動が失敗すると、實行は停止する。最後のバッファ (またはエラーが起こつたバッファ) がカレントウィンドウになる。{cmd} の中では &rsquo;|&rsquo; で複數のコマンドを連結できる。
</p>
<p>QuickFix リスト中の有效な項目のみが使はれる。「範圍」を指定して項目を選擇することができる。例:
</p><pre class="verbatim">:10,$cdo cmd
</pre><p>かうすることで 1 番目から 9 番目までをスキップできる。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
このコマンドを實行してゐる閒、Syntax 自動コマンドイベントが &rsquo;<samp>eventignore</samp>&rsquo; に追加され、無效化される。これは各バッファの編輯を大幅にスピードアップさせる。
</p></blockquote>
<p>|<a href="windows_002etxt.html#g_t_003abufdo">:bufdo</a>|, |<a href="tabpage_002etxt.html#g_t_003atabdo">:tabdo</a>|, |<a href="editing_002etxt.html#g_t_003aargdo">:argdo</a>|, |<a href="windows_002etxt.html#g_t_003awindo">:windo</a>|, |<a href="#g_t_003aldo">:ldo</a>|, |<a href="#g_t_003acfdo">:cfdo</a>|, |<a href="#g_t_003alfdo">:lfdo</a>| も參照。
</p>
<span id="g_t_003acfdo"></span><span id="index-_003acfdo"></span>
</dd>
<dt>:cfdo[!] {cmd}</dt>
<dd><p>QuickFix リスト中の各ファイルに對して {cmd} を實行する。以下の操作と同樣に動作する:
</p><pre class="verbatim">:cfirst
:{cmd}
:cnfile
:{cmd}
etc.
</pre><p>それ以外は &lsquo;:cdo&lsquo; の場合と同樣である。
</p>
<span id="g_t_003aldo"></span><span id="index-_003aldo"></span>
</dd>
<dt>:ld[o][!] {cmd}</dt>
<dd><p>カレントウィンドウのロケーションリスト中の有效な各項目に對して {cmd} を實行する。以下の操作と同樣に動作する:
</p><pre class="verbatim">:lfirst
:{cmd}
:lnext
:{cmd}
etc.
</pre><p>ロケーションリスト中の有效な項目のみが使はれる。それ以外は &lsquo;:cdo&lsquo; の場合と同樣である。
</p>
<span id="g_t_003alfdo"></span><span id="index-_003alfdo"></span>
</dd>
<dt>:lfdo[!] {cmd}</dt>
<dd><p>カレントウィンドウのロケーションリスト中の各ファイルに對して {cmd} を實行する。以下の操作と同樣に動作する:
</p><pre class="verbatim">:lfirst
:{cmd}
:lnfile
:{cmd}
etc.
</pre><p>それ以外は &lsquo;:cdo&lsquo; の場合と同樣である。
</p></dd>
</dl>

<span id="cfilter_002dplugin"></span><span id="g_t_003aCfilter"></span><span id="g_t_003aLfilter"></span><span id="index-cfilter_002dplugin"></span>
<span id="index-_003aCfilter"></span>
<span id="index-_003aLfilter"></span>
<span id="QUICKFIX-mataha-LOCATIONrisutonohuirutaringu_003a"></span><h4 class="unnumberedsubsec">QUICKFIX または LOCATIONリストのフィルタリング:</h4>
<p>quickfix リストのエントリ數が多すぎる場合は、cfilter プラグインを使用してエントリ數を減らすことができる。プラグインをロードする:
</p><pre class="verbatim">packadd cfilter
</pre>
<p>その後で、以下のコマンドを使つて、quickfix/location リストをフィルタすることができる:
</p><pre class="verbatim">:Cfilter[!] /{pat}/
:Lfilter[!] /{pat}/
</pre>
<p>|<a href="#g_t_003aCfilter">:Cfilter</a>| コマンドは、現在の quickfix リストの {pat} に一致するエントリから新しい quickfix リストを作成する。{pat} は Vim の正規表現 |<a href="pattern_002etxt.html#regular_002dexpression">regular-expression</a>| パターンである。ファイル名とエントリのテキストの兩方が {pat} と照合される。オプションの ! が指定された場合、{pat} と一致しないエントリが使用される。パターンは、次のいづれかの文字を使用して任意に圍むことができる: &rsquo;, &quot;, /。パターンが空の場合は、最後に使用された檢索パターンが使用される。
</p>
<p>|<a href="#g_t_003aLfilter">:Lfilter</a>| コマンドは |<a href="#g_t_003aCfilter">:Cfilter</a>| と同じ動作をするが、カレント location リストを操作する。
</p>
<span id="quickfix_002dwindow"></span><span id="index-quickfix_002dwindow"></span>
<span id="index-erauindou"></span>
<span id="g_t2_002e-erauindou"></span><h3 class="section">2. エラーウィンドウ</h3>

<dl compact="compact">
<dd><span id="g_t_003acope"></span><span id="g_t_003acopen"></span><span id="w_003aquickfix_005ftitle"></span><span id="index-_003acope"></span>
<span id="index-_003acopen"></span>
<span id="index-w_003aquickfix_005ftitle"></span>
</dd>
<dt>:cope[n] [height]</dt>
<dd><p>現在のエラーリストを表示するウィンドウを開く。
</p>
<p>[height] が與へられたとき、(餘地があれば) ウィンドウの高さがその値になる。[height] を省略したときはウィンドウの高さは 10 行になる。
</p>
<p>すでに QuickFix ウィンドウがある場合はそれがカレントウィンドウになる。2 個目の QuickFix ウィンドウを開くことはできない。[height] が指定されたとき、既存のウィンドウはその高さにリサイズされる。
</p>
<span id="quickfix_002dbuffer"></span><span id="index-quickfix_002dbuffer"></span>
<p>ウィンドウは &rsquo;<samp>buftype</samp>&rsquo; の値が &quot;<var>quickfix</var>&quot; である特別なバッファを含んでゐる。これを變更してはならない！ウィンドウは w:quickfix_title 變數を持つてゐる。この變數は quickfix リストを生成したコマンドを示してゐる。變數の値は &rsquo;<samp>statusline</samp>&rsquo; が適切に調整されてゐればステータスラインに表示される。このバッファが quickfix のコマンドまたは函數により變更さるたびに、|<a href="eval_002etxt.html#b_003achangedtick">b:changedtick</a>| 變數はインクリメントされる。このバッファにおける變數の値は getqflist() や getloclist() 函數を用い &rsquo;<samp>qfbufnr</samp>&rsquo; アイテムを通して取得できる。location リストの場合は、location リストが削除されるときに、このバッファも削除される。
</p>
<span id="g_t_003alop"></span><span id="g_t_003alopen"></span><span id="index-_003alop"></span>
<span id="index-_003alopen"></span>
</dd>
<dt>:lop[en] [height]</dt>
<dd><p>カレントウィンドウのロケーションリストを表示するウィンドウを開く。カレントウィンドウにロケーションリストが存在するときだけ動作する。一度に 2 個以上のロケーションリストを開くことができる。それ以外は &quot;:copen&quot; と同樣。
</p>
<span id="g_t_003accl"></span><span id="g_t_003acclose"></span><span id="index-_003accl"></span>
<span id="index-_003acclose"></span>
</dd>
<dt>:ccl[ose]</dt>
<dd><p>QuickFix ウィンドウを閉ぢる。
</p>
<span id="g_t_003alcl"></span><span id="g_t_003alclose"></span><span id="index-_003alcl"></span>
<span id="index-_003alclose"></span>
</dd>
<dt>:lcl[ose]</dt>
<dd><p>カレントウィンドウのロケーションリストを表示してゐるウィンドウを閉ぢる。
</p>
<span id="g_t_003acw"></span><span id="g_t_003acwindow"></span><span id="index-_003acw"></span>
<span id="index-_003acwindow"></span>
</dd>
<dt>:cw[indow] [height]</dt>
<dd><p>認識されたエラーがあるとき QuickFix ウィンドウを開く。ウィンドウがすでに開いてゐて認識されたエラーがない場合はウィンドウを閉ぢる。
</p>
<span id="g_t_003alw"></span><span id="g_t_003alwindow"></span><span id="index-_003alw"></span>
<span id="index-_003alwindow"></span>
</dd>
<dt>:lw[indow] [height]</dt>
<dd><p>&quot;:cwindow&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acbo"></span><span id="g_t_003acbottom"></span><span id="index-_003acbo"></span>
<span id="index-_003acbottom"></span>
</dd>
<dt>:cbo[ttom]</dt>
<dd><p>QuickFix ウィンドウの最後の行にカーソルを移動し、見える樣にスクロールする。これは非同期コールバックでエラーを追加するのに便利である。大量の更新に伴ふ多くの再描畫を避けるには一度限り呼び出すこと。
</p>
<span id="g_t_003albo"></span><span id="g_t_003albottom"></span><span id="index-_003albo"></span>
<span id="index-_003albottom"></span>
</dd>
<dt>:lbo[ttom]</dt>
<dd><p>現在のウィンドウに關するロケーションリストが表示されてゐるウィンドウである事を除いて &quot;:cbottom&quot; と同じ。
</p></dd>
</dl>

<p>通常、QuickFixウィンドウはスクリーンの一番下に現れる。垂直分割したウィンドウがある場合は、一番右下に現れる。常に最大幅を占めるやうにさせたい場合は
</p><pre class="verbatim">:botright cwindow
</pre><p>とする。このウィンドウを |<a href="windows_002etxt.html#window_002dmoving">window-moving</a>| コマンドで移動させることもできる。例へば、一番上に移動させたければ <kbd>CTRL-W K</kbd> とする。&rsquo;<samp>winfixheight</samp>&rsquo; オプションが設定されれば、&rsquo;<samp>winheight</samp>&rsquo; と &rsquo;<samp>equalalways</samp>&rsquo; を無視し、たいていその高さを維持する。高さを手動で變更することもできる (例へばステータスラインをマウスで上へドラッグするなど)。
</p>
<p>QuickFix ウィンドウには各行に 1 個ずつエラーが表示される。その行數はエラー番號に等しい。現在の項目は QuickFixLine ハイライティングでハイライトされる。あなたはそれをあなたの好みに變更することができる。例:
</p><pre class="verbatim">:hi QuickFixLine ctermbg=Yellow guibg=Yellow
</pre>
<p>&quot;:.cc&quot; でカーソル下のエラーに移動できる。<code class="tt-key">&lt;Enter&gt;</code> キーを押すのと行をダブルクリックするのは同じ效果がある。そのエラーを含むファイルが QuickFix ウィンドウの上に開かれる。そのファイルがすでにウィンドウに開かれてゐたらそのウィンドウがアクティブになる。そのウィンドウにあるバッファが變更されてゐて、そのエラーが別のファイルにある場合はエラーへの移動は失敗する。まづ、そのウィンドウが破毀してもよいバッファを含んでゐることを確かめなければならない。
<span id="CTRL_002dW_005f_003cEnter_003e"></span><span id="CTRL_002dW_005f_003cCR_003e"></span><span id="index-CTRL_002dW_005f_003cEnter_003e"></span>
<span id="index-CTRL_002dW_005f_003cCR_003e"></span>
<kbd>CTRL-W</kbd> <code class="tt-key">&lt;Enter&gt;</code>を使ふと、新しいウィンドウを開いてそこでエラーにジャンプできる。
</p>
<p>QuickFix ウィンドウが一杯になつたとき、2 つの自動コマンドイベントが發生する。第一は &rsquo;<samp>filetype</samp>&rsquo; オプションが &quot;<var>qf</var>&quot; にセットされ、FileType イベントが發生する (|<a href="filetype_002etxt.html#qf_002evim">qf.vim</a>| も參照してください)。それから BufReadPost イベントが發生する。そのときのバッファ名は &quot;quickfix&quot; となる。これを使つてエラーリストに對して操作を行ふことができる。例:
</p><pre class="verbatim">au BufReadPost quickfix  setlocal modifiable
        \ | silent exe 'g/^/s//\=line(&quot;.&quot;).&quot; &quot;/'
        \ | setlocal nomodifiable
</pre><p>これは各行に行番號を追加する。文字列の置換 &quot;<code>:s</code>&quot; コマンドの中で使はれてゐる &quot;\=&quot; に注目。これは式を評價するのに使はれる。BufWinEnter イベントも發生する。ここでもバッファ名は &quot;quickfix&quot; になる。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
存在する QuickFix リストに追加される場合、autocommand イベントは發生しません。
</p></blockquote>

<blockquote>
<p><strong>Note:</strong> <br>
QuickFix ウィンドウ內で變更を加へてもエラーのリストには何の影響もない。變更を防ぐために &rsquo;<samp>modifiable</samp>&rsquo; がオフになつてゐる。それでも行を削除や插入した場合は、テキストとエラー番號の關係がめちやくちやになる。本當にエラーリストを變更したいのなら、QuickFix ウィンドウの內容をファイルに保存し、&quot;:cfile&quot; を實行、ファイルをパースさせ、新しいエラーリストとして使ふこと。
</p></blockquote>

<span id="location_002dlist_002dwindow"></span><span id="index-location_002dlist_002dwindow"></span>
<p>ロケーションリストウィンドウはロケーションリストの中身を表示する。ロケーションウィンドウを開くと、カレントウィンドウの下に開かれ、カレントウィンドウのロケーションリストが表示される。ロケーションリストは QuickFix ウィンドウに似てゐるが、一度に 2 個以上のロケーションリストウィンドウを開ける點が異なる。このウィンドウ內でロケーションリストコマンドを使ふと、表示されてゐるロケーションリストが使はれる。
</p>
<p>ロケーションリストウィンドウからファイルを選擇すると、以下のステップによつて、そのファイルを編輯するウィンドウが探される。
</p>
<ol>
<li> ロケーションリストウィンドウに表示されてゐるロケーションリストに關聯付けられてゐるウィンドウがあるなら、そのウィンドウが使はれる。
</li><li> 上のステップが失敗した場合、そのファイルが既に他のウィンドウで開かれてゐるなら、そのウィンドウが使はれる。
</li><li> 上のステップが失敗した場合、&rsquo;<samp>buftype</samp>&rsquo; がセットされてゐないバッファを表示してゐるウィンドウが存在するなら、そのウィンドウが使はれる。
</li><li> 上のステップが失敗した場合、新しいウィンドウでファイルが開かれる。
</li></ol>

<p>上の全ての場合において、選擇されたウィンドウに對してまだロケーションリストが關聯付けられてゐなかつた場合、ロケーションリストウィンドウに表示されてゐるロケーションリストが關聯づけられる。
</p>
<span id="quickfix_002dwindow_002dID"></span><span id="index-quickfix_002dwindow_002dID"></span>
<p>|<a href="eval_002etxt.html#getqflist_0028_0029">getqflist()</a>| と |<a href="eval_002etxt.html#getloclist_0028_0029">getloclist()</a>| 函數を使用して、QuickFix ウィンドウとロケーションリストウィンドウのウィンドウ ID をそれぞれ取得できる (もしあれば)。例：
</p><pre class="verbatim">echo getqflist({'winid' : 1}).winid
echo getloclist(2, {'winid' : 1}).winid
</pre><span id="getqflist_002dexamples"></span><span id="index-getqflist_002dexamples"></span>
<p>|<a href="eval_002etxt.html#getqflist_0028_0029">getqflist()</a>| 函數と |<a href="eval_002etxt.html#getloclist_0028_0029">getloclist()</a>| 函數は、それぞれ quickfix とロケーションリストのさまざまな屬性を取得するのに使用できる。これらの函數の使用例を以下に示す：
</p><pre class="verbatim">&quot; 現在の QuickFix リストのタイトルを取得する
:echo getqflist({'title' : 0}).title

&quot; 現在の QuickFix リストの識別子を取得する
:let qfid = getqflist({'id' : 0}).id

&quot; スタックの中の 4 番目の QuickFix リストの識別子を取得する
:let qfid = getqflist({'nr' : 4, 'id' : 0}).id

&quot; 特定の識別子を持つ QuickFix リストが存在するかどうかを檢査する
:if getqflist({'id' : qfid}).id == qfid

&quot; スタックの中の現在の QuickFix リストのインデックスを取得する
:let qfnum = getqflist({'nr' : 0}).nr

&quot; 識別子により指定された QuickFix リストの items を取得する
:echo getqflist({'id' : qfid, 'items' : 0}).items

&quot; id により指定された QuickFix リストの中の項目の數を取得する
:echo getqflist({'id' : qfid, 'size' : 0}).size

&quot; スタックの中の 3 番目の QuickFix リストの context を取得する
:echo getqflist({'nr' : 3, 'context' : 0}).context

&quot; スタックの中の QuickFix リストの數を取得する
:echo getqflist({'nr' : '$'}).nr

&quot; 現在の QuickFix リストが變更された回數を取得する
:echo getqflist({'changedtick' : 0}).changedtick

&quot; 識別子により指定された QuickFix リストの中の現在の項目を取得する
:echo getqflist({'id' : qfid, 'idx' : 0}).idx

&quot; 識別子を使用して全ての QuickFix リスト屬性を取得する
:echo getqflist({'id' : qfid, 'all' : 0})

&quot; lines のリストの値からテキストをパースして QuickFix リストを返す
:let myList = [&quot;a.java:10:L10&quot;, &quot;b.java:20:L20&quot;]
:echo getqflist({'lines' : myList}).items

&quot; カスタム 'efm' を使用してテキストをパースして QuickFix リストを返す
:echo getqflist({'lines' : ['a.c#10#Line 10'], 'efm':'%f#%l#%m'}).items

&quot; QuickFix リストのウィンドウ ID を取得する
:echo getqflist({'winid' : 0}).winid

&quot; QuickFix リストのウィンドウのバッファ番號を取得する
:echo getqflist({'qfbufnr' : 0}).qfbufnr

&quot; 現在のロケーションリストの context を取得する
:echo getloclist(0, {'context' : 0}).context

&quot; 3 番目のウィンドウのロケーションリストのウィンドウ ID を取得する
:echo getloclist(3, {'winid' : 0}).winid

&quot; 3番目のウィンドウのロケーションリストのバッファ番號を取得する
:echo getloclist(3, {'qfbufnr' : 0}).qfbufnr

&quot; ロケーションリストウィンドウ (winnr: 4) のファイルウィンドウ ID を取得する
:echo getloclist(4, {'filewinid' : 0}).filewinid
</pre><span id="setqflist_002dexamples"></span><span id="index-setqflist_002dexamples"></span>
<p>|<a href="eval_002etxt.html#setqflist_0028_0029">setqflist()</a>| 函數と |<a href="eval_002etxt.html#setloclist_0028_0029">setloclist()</a>| 函數は、それぞれ quickfix とロケーションリストのさまざまな屬性を設定するのに使用できる。これらの函數の使用例を以下に示す：
</p><pre class="verbatim">&quot; title と context を持つ空の QuickFix リストを作成する
:let t = 'Search results'
:let c = {'cmd' : 'grep'}
:call setqflist([], ' ', {'title' : t, 'context' : c})

&quot; 現在の QuickFix リストの title を設定する
:call setqflist([], 'a', {'title' : 'Mytitle'})

&quot; 識別子により指定された QuickFix リストの現在のエントリを變更する
:call setqflist([], 'a', {'id' : qfid, 'idx' : 10})

&quot; 識別子により指定された QuickFix リストの context を設定する
:call setqflist([], 'a', {'id' : qfid, 'context' : {'val' : 100}})

&quot; コマンド出力から新しい QuickFix リストを作成する
:call setqflist([], ' ', {'lines' : systemlist('grep -Hn main *.c')})

&quot; カスタム 'efm' を使用してテキストをパースして特定の QuickFix リストに追加する
:call setqflist([], 'a', {'id' : qfid,
            \ 'lines' : [&quot;a.c#10#L10&quot;, &quot;b.c#20#L20&quot;], 'efm':'%f#%l#%m'})

&quot; 識別子により指定された QuickFix リストに items を追加する
:let newItems = [{'filename' : 'a.txt', 'lnum' : 10, 'text' : &quot;Apple&quot;},
                \ {'filename' : 'b.txt', 'lnum' : 20, 'text' : &quot;Orange&quot;}]
:call setqflist([], 'a', {'id' : qfid, 'items' : newItems})

&quot; 識別子により指定された QuickFix リストを空にする
:call setqflist([], 'r', {'id' : qfid, 'items' : []})

&quot; スタックの中の全ての QuickFix リストを開放する
:call setqflist([], 'f')

&quot; 4 番目の QuickFix リストの title を設定する
:call setqflist([], 'a', {'nr' : 4, 'title' : 'SomeTitle'})

&quot; スタックの最後に新しい QuickFix リストを作成する
:call setqflist([], ' ', {'nr' : '$',
                    \ 'lines' : systemlist('grep -Hn class *.java')})

&quot; コマンド出力から新しいロケーションリストを作成する
:call setloclist(0, [], ' ', {'lines' : systemlist('grep -Hn main *.c')})

&quot; 3 番目のウィンドウのロケーションリスト項目を置き換へる
:call setloclist(3, [], 'r', {'items' : newItems})
</pre><span id="quickfix_002derror_002dlists"></span><span id="index-quickfix_002derror_002dlists"></span>
<span id="index-Fu-Shu-noerarisutowoShi-u"></span>
<span id="g_t3_002e-Fu-Shu-noerarisutowoShi-u"></span><h3 class="section">3. 複數のエラーリストを使ふ</h3>

<p>これまでは 1 つだけのエラーリストがあると假定してきた。實際は最後に使つた 10 個迄のエラーリストが記憶される。新しいリストではじめた時には、以前のリストは自動的に保存される。古いエラーリストにアクセスするために、2 つのコマンドが用意されてゐる。これらは存在するエラーリストの內 1 つを現在のエラーリストに設定する。
</p>
<dl compact="compact">
<dd><span id="g_t_003acolder"></span><span id="g_t_003acol"></span><span id="E380"></span><span id="index-_003acolder"></span>
<span id="index-_003acol"></span>
<span id="index-E380"></span>
</dd>
<dt>:col[der] [count]</dt>
<dd><p>古いエラーリストへ移動する。[count] が與へられると、その回數繰り返し移動する。既に一番古いエラーリストにゐる場合、エラーメッセージが表示される。
</p>
<span id="g_t_003alolder"></span><span id="g_t_003alol"></span><span id="index-_003alolder"></span>
<span id="index-_003alol"></span>
</dd>
<dt>:lol[der] [count]</dt>
<dd><p>&lsquo;:colder&lsquo; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003acnewer"></span><span id="g_t_003acnew"></span><span id="E381"></span><span id="index-_003acnewer"></span>
<span id="index-_003acnew"></span>
<span id="index-E381"></span>
</dd>
<dt>:cnew[er] [count]</dt>
<dd><p>新しいエラーリストへ移動する。[count] が與へられると、その回數繰り返し移動する。既に一番新しいエラーリストにゐる場合、エラーメッセージが表示される。
</p>
<span id="g_t_003alnewer"></span><span id="g_t_003alnew"></span><span id="index-_003alnewer"></span>
<span id="index-_003alnew"></span>
</dd>
<dt>:lnew[er] [count]</dt>
<dd><p>&lsquo;:cnewer&lsquo; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003achistory"></span><span id="g_t_003achi"></span><span id="index-_003achistory"></span>
<span id="index-_003achi"></span>
</dd>
<dt>:[count]chi[story]</dt>
<dd><p>エラーリストの一覽を表示する。現在のリストは &quot;&gt;&quot; でマークされる。出力は以下の樣になる:
</p><pre class="verbatim">  error list 1 of 3; 43 errors
&gt; error list 2 of 3; 0 errors
  error list 3 of 3; 15 errors
</pre>
<p>[count] が與へられると、count 番目の QuickFix リストがカレントリストになる。例:
</p><pre class="verbatim">&quot; 4 番目の QuickFix リストをカレントにする
:4chistory
</pre><span id="g_t_003alhistory"></span><span id="g_t_003alhi"></span><span id="index-_003alhistory"></span>
<span id="index-_003alhi"></span>
</dd>
<dt>:[count]lhi[story]</dt>
<dd><p>ロケーションリストの一覽を表示する。&lsquo;<code>:chistory</code>&lsquo; の樣に。
</p></dd>
</dl>

<p>新しいエラーリストが追加された時には、それがカレントリストとなる。
</p>
<p>&quot;:colder&quot; が實行された後で &quot;:make&quot; や &quot;:grep&quot; が實行され新しいエラーリストが追加されたときは 1 個新しいリストが上書きされる。これは &quot;:grep&quot; |<a href="#grep">grep</a>| でブラウジングしてゐるときに特に便利である。もつと最近のエラーリストを殘しておきたい場合は初めに &quot;:cnewer 99&quot; を行ふこと。
</p>
<p>quickfix やロケーションリストのスタック數を取得するには、特別な値 &rsquo;$&rsquo; に設定されたリスト番號でそれぞれ、|<a href="eval_002etxt.html#getqflist_0028_0029">getqflist()</a>| 函數と |<a href="eval_002etxt.html#getloclist_0028_0029">getloclist()</a>| 函數を使用できる。例：
</p><pre class="verbatim">echo getqflist({'nr' : '$'}).nr
echo getloclist(3, {'nr' : '$'}).nr
</pre><p>スタック內の現在のリスト番號を取得するには：
</p><pre class="verbatim">echo getqflist({'nr' : 0}).nr
</pre><span id="g_t_003amake_005fmakeprg"></span><span id="index-_003amake_005fmakeprg"></span>
<span id="index-_003amake-noShi-iFang-"></span>
<span id="g_t4_002e-_003amake-noShi-iFang-"></span><h3 class="section">4. :make の使ひ方</h3>

<dl compact="compact">
<dd><span id="g_t_003amak"></span><span id="g_t_003amake"></span><span id="index-_003amak"></span>
<span id="index-_003amake"></span>
</dd>
<dt>:mak[e][!] [arguments]</dt>
<dd><ol>
<li> |<a href="autocmd_002etxt.html#QuickFixCmdPre">QuickFixCmdPre</a>| に關聯付けられた自動コマンドが全て實行される。
</li><li> オプション &rsquo;<samp>autowrite</samp>&rsquo; が on ならば變更のあるバッファは保存される。
</li><li> &rsquo;<samp>makeef</samp>&rsquo; からエラーファイルの名前が生成される。&rsquo;<samp>makeef</samp>&rsquo; が &quot;<var>##</var>&quot; を含まずかつ既に名前が存在する場合それは削除される。

</li><li> オプション &rsquo;<samp>makeprg</samp>&rsquo; で與へられたプログラム (省略時 &quot;make&quot;) が [argument] をオプションにして實行され、出力が errorfile に保存される (Unix ではそれも畫面に echo される)。
</li><li> &rsquo;<samp>errorformat</samp>&rsquo; を使つて errorfile が讀みこまれる。
</li><li> |<a href="autocmd_002etxt.html#QuickFixCmdPost">QuickFixCmdPost</a>| に關聯付けられた自動コマンドが全て實行される。後述のサンプルを參照。
</li><li> [!] が與へられてゐないときは最初のエラーに移動する。
</li><li> エラーファイルが削除される。
</li><li> |<a href="#g_t_003acnext">:cnext</a>| や |<a href="#g_t_003acprevious">:cprevious</a>| などのコマンドでエラー閒を移動できる。上を參照。
</li></ol>
<p>このコマンドは如何なるコメントも受けつけず、どんな &quot; といふ文字も argument の一部とみなされる。プログラム出力のエンコーディングが &rsquo;<samp>encoding</samp>&rsquo; と異なる場合には、&rsquo;<samp>makeencoding</samp>&rsquo; オプションでエンコーディングを指定できる。
</p>
<span id="g_t_003almak"></span><span id="g_t_003almake"></span><span id="index-_003almak"></span>
<span id="index-_003almake"></span>
</dd>
<dt>:lmak[e][!] [arguments]</dt>
<dd><p>&quot;:make&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p></dd>
</dl>

<p>コマンド &quot;:make&quot; はオプション &rsquo;<samp>makeprg</samp>&rsquo; で與へられるコマンドを實行する。これはオプション &rsquo;<samp>shell</samp>&rsquo; で與へられたシェルにコマンドを渡す事で實行されてゐる。以下をタイピングするのとほぼ同じである。
</p><pre class="verbatim">&quot;:!{makeprg} [arguments] {shellpipe} {errorfile}&quot;.
</pre>
<p>{makeprg}は &rsquo;<samp>makeprg</samp>&rsquo; オプションで指定された文字列である。&quot;make&quot; に限らず、どんなコマンドでも使用できる。&rsquo;%&rsquo; と &rsquo;#&rsquo; の文字は通常通りコマンドライン中で展開される。擴張子無しの現在ファイル名を表すのに &quot;%&lt;&quot;、擴張子無しの代替ファイル名を表すのに &quot;#&lt;&quot; が使へる。例へば:
</p><pre class="verbatim">:set makeprg=make\ #&lt;.o
</pre>
<table>
<tr><td width="99%">[arguments] &quot;:make&quot; より後に入力した全て。</td></tr>
<tr><td width="99%">{shellpipe} オプション &rsquo;<samp>shellpipe</samp>&rsquo;</td></tr>
<tr><td width="99%">{errorfile} オプション &rsquo;<samp>makeef</samp>&rsquo;。&quot;##&quot; は一意な名前にする</td></tr>
</table>

<p>コマンドが arguments の後にオプションを必要とするならば、{makeprg} の中で引數リストに展開される置換子 &quot;$*&quot; が使用できる。$* は引數全てに置換へられる。例:
</p><pre class="verbatim">:set makeprg=latex\ \\\\nonstopmode\ \\\\input\\{$*}
</pre><p>またはより單純に
</p><pre class="verbatim">:let &amp;mp = 'latex \\nonstopmode \\input\{$*}'
</pre><p>&quot;$*&quot; は次の例のやうに何度でも與へる事ができる:
</p><pre class="verbatim">:set makeprg=gcc\ -o\ $*\ $*
</pre>
<p>オプション &rsquo;<samp>shellpipe</samp>&rsquo; の省略値は Amiga, MS-DOS と Win32 では &quot;&gt;&quot; である。これはコンパイラの出力が直接ファイルに出力されスクリーンには出力されないことを意味する。Unix では &quot;| tee&quot; が使用される。コンパイラがファイルに出力すると同時にスクリーンにも表示される。使つてゐるシェルに應じて標準エラーへの出力も含めるために &quot;|&amp; tee&quot; や &quot;2&gt;&amp;1| tee&quot; が省略値となる。
</p>
<p>&rsquo;<samp>shellpipe</samp>&rsquo; が空の場合、{errorfile} が省略される。これはコンパイラ自身がエラーファイルを作成する場合 (Manx&rsquo;s Amiga C) に便利である。
</p>

<span id="QuickFixCmdPost-woShi-tuteenkodeinguwoXiu-Zheng-suru"></span><h4 class="unnumberedsubsec">QuickFixCmdPost を使つてエンコーディングを修正する</h4>

<p>ビルドプログラムが出力するメッセージと &rsquo;<samp>encoding</samp>&rsquo; の値が異なる場合がある。この例は、Vim がそのエラーメッセージを讀み込んだ後でエンコーディングを變換する方法を示してゐる:
</p>
<pre class="verbatim">function QfMakeConv()
   let qflist = getqflist()
   for i in qflist
      let i.text = iconv(i.text, &quot;cp936&quot;, &quot;utf-8&quot;)
   endfor
   call setqflist(qflist)
endfunction

au QuickfixCmdPost make call QfMakeConv()
</pre>
<p>(Faque Cheng による例)
</p>
<p>代はりに &rsquo;<samp>makeencoding</samp>&rsquo; オプションを使ふこともできる。
</p>
<span id="grep"></span><span id="lid"></span><span id="index-grep"></span>
<span id="index-lid"></span>
<span id="index-_003avimgrep-to-_003agrep-noShi-iFang-"></span>
<span id="g_t5_002e-_003avimgrep-to-_003agrep-noShi-iFang-"></span><h3 class="section">5. :vimgrep と :grep の使ひ方</h3>

<p>Vim にはパターンを檢索する方法が 2 つある: 內部 grep と外部 grep である。內部 grep の利點は、全てのシステム上で動作し、Vim の强力な檢索パターンを使へることである。內部 grep が目的に合はない場合は外部 grep を使ふことができる。
</p>
<p>內部 grep はファイルをメモリに讀み込むため、より遲い。利點は:
</p><ul>
<li> ファイルを開くときと同樣に改行コードとエンコーディングが自動的に認識される。
</li><li> Vim の檢索パターンを使ふ。複數行にわたるパターンが使へる。
</li><li> プラグインが有效になつてゐれば、壓縮ファイル、リモートファイルを檢索できる。|<a href="pi_005fgzip_002etxt.html#gzip">gzip</a>| |<a href="pi_005fnetrw_002etxt.html#netrw">netrw</a>|
</li></ul>

<p>これを行ふために、Vim は各ファイルを編輯するときと同じやうに讀み込む。そのファイルにマッチがなかつたら、そのバッファは消去 (wiped out) される。多數のファイルを扱ふときのメモリ不足やファイル記述子不足を避けるために、ここではオプション &rsquo;<samp>hidden</samp>&rsquo; は無視される。しかし、コマンド修飾子 |<a href="windows_002etxt.html#g_t_003ahide">:hide</a>| が使はれたときは、バッファが讀み込まれたままになる。これによつて、同じファイルを續けて檢索するのがとても高速になる。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
檢索結果へのリンク一覽を開くには |<a href="#g_t_003acopen">:copen</a>| (|<a href="#g_t_003algrep">:lgrep</a>| なら |<a href="#g_t_003alopen">:lopen</a>|) が使はれる。|<a href="various_002etxt.html#g_t_003asilent">:silent</a>| コマンドを使ふことで grep の出力が畫面いつぱいに表示されるのを防ぐことができる。|<a href="#g_t_003agrep">:grep</a>| コマンドを &quot;:grep!&quot; 形式で使ふと最初のマッチに自動的にジャンプしなくなる。これらのコマンドを組み合はせて NewGrep コマンドを作ると次のやうになる:
</p><pre class="verbatim">command! -nargs=+ NewGrep execute 'silent grep! &lt;args&gt;' | copen 42
</pre></blockquote>


<span id="index-Vim-noNei-Bu--grep-noShi-iFang-"></span>
<span id="g_t5_002e1-Vim-noNei-Bu--grep-noShi-iFang-"></span><h4 class="subsection">5.1 Vim の內部 grep の使ひ方</h4>

<dl compact="compact">
<dd><span id="g_t_003avim"></span><span id="g_t_003avimgrep"></span><span id="E682"></span><span id="E683"></span><span id="index-_003avim"></span>
<span id="index-_003avimgrep"></span>
<span id="index-E682"></span>
<span id="index-E683"></span>
</dd>
<dt>:vim[grep][!] /{pattern}/[g][j] {file} ...</dt>
<dd><p>ファイル {file} から {pattern} を檢索し、マッチ位置をエラーリストに追加する。&rsquo;<samp>wildignore</samp>&rsquo; にマッチしたファイルは無視される。&rsquo;<samp>suffixes</samp>&rsquo; にマッチしたファイルは最後に檢索される。
</p>
<p>フラグ &rsquo;<var>g</var>&rsquo; がない場合、各行は 1 度だけ追加される。&rsquo;<var>g</var>&rsquo; がある場合、マッチ位置が每囘追加される。
</p>
<p>{pattern} は Vim の檢索パターンである。/ で圍まない場合、それが {pattern} 中に現れない限り、どんな非 ID 文字 (|<a href="options_002etxt.html#g_t_0027isident_0027">'isident'</a>| を參照) でも使へる。&rsquo;<samp>ignorecase</samp>&rsquo; が適用される。パターン中に |<a href="pattern_002etxt.html#g_t_002f_005cc">/\c</a>| を含めると大文字小文字を區別しなくなり、|<a href="pattern_002etxt.html#g_t_002f_005cC">/\C</a>| を含めると區別するやうになる。これは &rsquo;<samp>ignorecase</samp>&rsquo; より優先される。&rsquo;<samp>smartcase</samp>&rsquo; は適用されない。{pattern} が空のときは (つまり // が指定されたときは)、最後に使はれた檢索パターンが使用される。|<a href="pattern_002etxt.html#last_002dpattern">last-pattern</a>|
</p>
</dd>
<dt>:{count}vim[grep] ...</dt>
<dd><p>このコマンドの前に數字が置かれると、その數が檢索するマッチの最大數となる。&quot;:1vimgrep pattern file&quot; とすると最初のマッチだけを檢索する。マッチが存在するかどうかだけをチェックしたく、それが見つかつたらすぐに終了してほしい場合に便利である。
</p>
<p>フラグ &rsquo;<var>j</var>&rsquo; がない場合、最初のマッチへジャンプする。&rsquo;<var>j</var>&rsquo; がある場合は QuickFix リストが更新されるだけである。[!] がついた場合、カレントバッファに對する變更は全て失はれる。
</p>
<p>進行狀況を示すため、1 秒程度ごとに檢索されたファイル名が表示される。
</p>
<p>例:
</p><pre class="verbatim">:vimgrep /an error/ *.c
:vimgrep /\&lt;FileName\&gt;/ *.h include/*
:vimgrep /myfunc/ **/*.c
</pre><p>&quot;**&quot; の使ひ方については |<a href="editing_002etxt.html#starstar_002dwildcard">starstar-wildcard</a>| を參照。
</p>
</dd>
<dt>:vim[grep][!] {pattern} {file} ...</dt>
<dd><p>上と同樣だが、パターンを非 ID 文字で圍むのでなく、空白でパターンを區切る。パターンは ID 文字で始まらねばならない。
</p>
<p>例:
</p><pre class="verbatim">:vimgrep Error *.c
</pre><span id="g_t_003alv"></span><span id="g_t_003alvimgrep"></span><span id="index-_003alv"></span>
<span id="index-_003alvimgrep"></span>
</dd>
<dt>:lv[imgrep][!] /{pattern}/[g][j] {file} ... または</dt>
<dt>:lv[imgrep][!] {pattern} {file} ...</dt>
<dd><p>&quot;:vimgrep&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003avimgrepa"></span><span id="g_t_003avimgrepadd"></span><span id="index-_003avimgrepa"></span>
<span id="index-_003avimgrepadd"></span>
</dd>
<dt>:vimgrepa[dd][!] /{pattern}/[g][j] {file} ... または</dt>
<dt>:vimgrepa[dd][!] {pattern} {file} ...</dt>
<dd><p>&quot;:vimgrep&quot; と同樣だが、新しくエラーリストを作る代はりに、現在のリストに追加する。
</p>
<span id="g_t_003alvimgrepa"></span><span id="g_t_003alvimgrepadd"></span><span id="index-_003alvimgrepa"></span>
<span id="index-_003alvimgrepadd"></span>
</dd>
<dt>:lvimgrepa[dd][!] /{pattern}/[g][j] {file} ... または</dt>
<dt>:lvimgrepa[dd][!] {pattern} {file} ...</dt>
<dd><p>&quot;:vimgrepadd&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p></dd>
</dl>

<span id="index-Wai-Bu--grep"></span>
<span id="g_t5_002e2-Wai-Bu--grep"></span><h4 class="subsection">5.2 外部 grep</h4>

<p>Vim はコンパイラに對するのと同じ方法 (|<a href="#g_t_003amake">:make</a>| 參照) で &quot;grep&quot; や GNU id-utils などの grep ライクなプログラムと連携できる。
</p>
<p>[Unix 豆智識: Unix のコマンド &quot;grep&quot; の名前は &quot;:g/re/p&quot; に由來してゐる。&quot;re&quot; は Regular Expression (正規表現) を意味する。]
</p>
<dl compact="compact">
<dd><span id="g_t_003agr"></span><span id="g_t_003agrep"></span><span id="index-_003agr"></span>
<span id="index-_003agrep"></span>
</dd>
<dt>:gr[ep][!] [arguments]</dt>
<dd><p>&quot;:make&quot; と同じやうにしかし &rsquo;<samp>makeprg</samp>&rsquo; の代はりに &rsquo;<samp>grepprg</samp>&rsquo; が、&rsquo;<samp>errorformat</samp>&rsquo; の代はりに &rsquo;<samp>grepformat</samp>&rsquo; が使はれる。&rsquo;<samp>grepprg</samp>&rsquo; が &quot;<var>internal</var>&quot; の場合、|<a href="#g_t_003avimgrep">:vimgrep</a>| と同樣に機能する。その場合、パターンが區切り文字で圍まれてゐなければならないことに注意。
</p>
<p>プログラム出力のエンコーディングが &rsquo;<samp>encoding</samp>&rsquo; と異なる場合には、&rsquo;<samp>makeencoding</samp>&rsquo; オプションでエンコーディングを指定できる。
</p>
<span id="g_t_003algr"></span><span id="g_t_003algrep"></span><span id="index-_003algr"></span>
<span id="index-_003algrep"></span>
</dd>
<dt>:lgr[ep][!] [arguments]</dt>
<dd><p>&quot;:grep&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p>
<span id="g_t_003agrepa"></span><span id="g_t_003agrepadd"></span><span id="index-_003agrepa"></span>
<span id="index-_003agrepadd"></span>
</dd>
<dt>:grepa[dd][!] [arguments]</dt>
<dd><p>&quot;:grep&quot; と似てゐるが、新しいエラーリストを作らず、解釋されたエラーが現在のリストに追加される。
</p>
<p>例:
</p><pre class="verbatim">:call setqflist([])
:bufdo grepadd! something %
</pre><p>1 番目のコマンドは新しい空のエラーリストを作成する。2 番目のコマンドはバッファリスト內の各バッファに對し &quot;grepadd&quot; を實行する。最初のエラーへジャンプするのを避けるために ! を使つてゐることに注意。|<a href="windows_002etxt.html#g_t_003abufdo">:bufdo</a>| でジャンプすることはできない。
</p>
<p>引數リスト內のファイルに對して實行し、マッチがないファイルでのエラーを囘避する例:
</p><pre class="verbatim">:silent argdo try 
  \ | grepadd! something %
  \ | catch /E480:/
  \ | endtry&quot;
</pre><p>プログラム出力のエンコーディングが &rsquo;<samp>encoding</samp>&rsquo; と異なる場合には、&rsquo;<samp>makeencoding</samp>&rsquo; オプションでエンコーディングを指定できる。
</p>
<span id="g_t_003algrepa"></span><span id="g_t_003algrepadd"></span><span id="index-_003algrepa"></span>
<span id="index-_003algrepadd"></span>
</dd>
<dt>:lgrepa[dd][!] [arguments]</dt>
<dd><p>&quot;:grepadd&quot; と同樣だが、QuickFix リストでなく、カレントウィンドウのロケーションリストが使はれる。
</p></dd>
</dl>

<span id="index-grep-wosetutoatupusuru"></span>
<span id="g_t5_002e3-grep-wosetutoatupusuru"></span><h4 class="subsection">5.3 grep をセットアップする</h4>

<p>標準的な &quot;grep&quot; プログラムがインストールされてゐれば :grep コマンドはデフォルトのままで動くだらう。使ひ方は標準的なコマンドにとてもよく似てゐる:
</p><pre class="verbatim">:grep foo *.c
</pre>
<p>これは擴張子.c の全てのファイルの中から部分文字列 &quot;foo&quot; を檢索する。:grep への引數はそのまま &quot;grep&quot; プログラムに渡されるので、その &quot;grep&quot; がサポートするオプションはなんでも使ふことができる。
</p>
<p>デフォルトでは :grep は grep を -n オプションつきで呼び出す (これはファイル名と行番號を出力させる)。これは &rsquo;<samp>grepprg</samp>&rsquo; オプションで變更できる。次のやうな場合に &rsquo;<samp>grepprg</samp>&rsquo; を變更する必要があるだらう:
</p>
<table>
<tr><td width="10%">a)</td><td width="90%">&quot;grep&quot; 以外の名前のプログラムを使つてゐるとき</td></tr>
<tr><td width="10%">b)</td><td width="90%">grepをフルパスで呼ばなければならないとき</td></tr>
<tr><td width="10%">c)</td><td width="90%">他のオプションを自動的に渡したいとき (例: 大文字・小文字の無視)</td></tr>
</table>

<p>&quot;grep&quot; が實行されると、Vim はその結果を &rsquo;<samp>grepformat</samp>&rsquo; オプションに從つて解釋する。このオプションは &rsquo;<samp>errorformat</samp>&rsquo; オプションと同樣に働くので詳細はそちらを參照すること。あなたの grep が標準的でない書式で出力したり、あるいは特別な書式を持つ他のプログラムを使つてゐる場合は &rsquo;<samp>grepformat</samp>&rsquo; をデフォルト値から變更する必要があるだらう。
</p>
<p>結果が解釋されると、|<a href="#quickfix">quickfix</a>| モードにおけるコンパイルエラーと同樣に、Vim はマッチした部分を含む最初のファイルを讀み込み、對應した行へジャンプする。その後は |<a href="#g_t_003acnext">:cnext</a>|, |<a href="#g_t_003aclist">:clist</a>| などのコマンドを使つて他のマッチにジャンプすることができる。
</p>

<span id="index-id_002dutils-toGong-ni-_003agrep-woShi-u"></span>
<span id="g_t5_002e4-id_002dutils-toGong-ni-_003agrep-woShi-u"></span><h4 class="subsection">5.4 id-utils と共に :grep を使ふ</h4>

<p>:grep を GNU id-utils と共に使ふにはこのやうにする:
</p><pre class="verbatim">:set grepprg=lid\ -Rgrep\ -s
:set grepformat=%f:%l:%m
</pre>
<p>そして
</p><pre class="verbatim">:grep (regexp)
</pre><p>これで期待通りの動作をする。
</p>
<p>(最初に mkid をするのを忘れてゐなければ)
</p>

<span id="index-_003avimgrep-ya-_003agrep-woShi-tutesosukodowowatariBu-ku"></span>
<span id="g_t5_002e5-_003avimgrep-ya-_003agrep-woShi-tutesosukodowowatariBu-ku"></span><h4 class="subsection">5.5 :vimgrep や :grep を使つてソースコードをわたり步く</h4>

<p>Vim が保存するエラーリストのスタックを使ふことによつて、ファイルをわたり步き、函數とその函數が呼んでゐる函數を探すことができる。例へば、read_file() 函數に引數を加へたいとする。次のやうにコマンドを打てばよい:
</p><pre class="verbatim">:vimgrep /\&lt;read_file\&gt;/ *.c
</pre>
<p>:cn でマッチのリストを巡り、引數を加へることができる。またあるとき上位の函數 msg() から新しい引數を得て、それを變更しなければならないとする。ならばかうするとよい:
</p><pre class="verbatim">:vimgrep /\&lt;msg\&gt;/ *.c
</pre>
<p>msg() 函數を變更してゐるときに、上位から引數を得なければならない函數をもう 1 個見つけたとする。ならばその函數を見つけるのにまた &quot;:vimgrep&quot; を使へばよい。1 つの函數が終はつたら、
</p><pre class="verbatim">:colder
</pre><p>とすれば 1 つ前に戾ることができる。
</p>
<p>これはツリーをわたるのに似てゐる: &quot;:vimgrep&quot; が 1 レベル深く進むにつれて、分岐のリストが 1 つ作られる。&quot;:colder&quot; は 1 つ上に戾る。&quot;:vimgrep&quot; と &quot;:colder&quot; を使つてツリーに似た方法ですべての場所をわたることができる。これを一貫して行へば、&quot;todo&quot; のリストを書き留めることなく、すべての場所に行くことができる。
</p>
<span id="compiler_002dselect"></span><span id="index-compiler_002dselect"></span>
<span id="index-konpairawoXuan-bu"></span>
<span id="g_t6_002e-konpairawoXuan-bu"></span><h3 class="section">6. コンパイラを選ぶ</h3>

<dl compact="compact">
<dd><span id="g_t_003acomp"></span><span id="g_t_003acompiler"></span><span id="E666"></span><span id="index-_003acomp"></span>
<span id="index-_003acompiler"></span>
<span id="index-E666"></span>
</dd>
<dt>:comp[iler][!] {name}</dt>
<dd><p>コンパイラ {name} を使ふときに機能するオプションを設定する。&quot;!&quot; オプションがない場合は現在のバッファに對して設定される。&quot;!&quot; がある場合はグローバルオプションが設定される。
</p>
<p>&quot;file.foo&quot; で &quot;:compiler foo&quot; とし、その後別のバッファで &quot;:compiler! bar&quot; としたとき、Vim は &quot;file.faoo&quot; では &quot;foo&quot; を使ひ續ける。
</p>
<p>{|<a href="various_002etxt.html#g_t_002beval">+eval</a>| 機能なしでコンパイルされた場合には使用できない}
</p></dd>
</dl>


<p>&quot;compiler&quot; ディレクトリ內にある Vim プラグインによつて、選擇されたコンパイラを使ふためのオプションが設定される。&lsquo;:compiler&lsquo; はローカルオプションを設定し、&lsquo;:compiler!&lsquo; はグローバルオプションを設定する。
<span id="current_005fcompiler"></span><span id="index-current_005fcompiler"></span>
Vim の古いバージョンをサポートするために、それらのプラグインは常に &quot;b:current_compiler&quot; でなく &quot;current_compiler&quot; を使ふ。このコマンドが實際に行ふことは次の通り:
</p>
<ul>
<li> 變數 &quot;current_compiler&quot; と &quot;b:current_compiler&quot; を削除する
</li><li> ユーザーコマンド &quot;CompilerSet&quot; を定義する。&quot;!&quot; がついた場合は &quot;:set&quot; を行ひ、&quot;!&quot; が無い場合は &quot;:setlocal&quot; を實行する。
</li><li> &quot;:runtime! compiler/{name}.vim&quot; を實行する。このプラグインは &quot;CompilerSet&quot;に伴ふオプションを設定し、變數 &quot;current_compiler&quot; をそのコンパイラの名前に設定すると期待される。
</li><li> ユーザーコマンド &quot;CompilerSet&quot; を削除する。
</li><li> &quot;b:current_compiler&quot; を &quot;current_compiler&quot; の値に設定する。
</li><li> &quot;!&quot; が無い場合は &quot;current_compiler&quot; の元の値を復元する。
</li></ul>


<p>コンパイラプラグインを書くためには |<a href="usr_005f41_002etxt.html#write_002dcompiler_002dplugin">write-compiler-plugin</a>| を參照せよ。
</p>

<span id="quickfix_002dgcc"></span><span id="compiler_002dgcc"></span><span id="index-quickfix_002dgcc"></span>
<span id="index-compiler_002dgcc"></span>
<span id="GCC"></span><h4 class="unnumberedsubsec">GCC</h4>

<p>GCC 用に設定できる變數は 1 つある:
</p>
<dl compact="compact">
<dt>g:compiler_gcc_ignore_unmatched_lines</dt>
<dd><p>GCC 用に定義されたどのパターンにもマッチしない行を無視する。make から起動されたコマンドの出力のせゐで誤檢出 (false positive) が發生してしまふときに有用である。
</p></dd>
</dl>


<span id="quickfix_002dmanx"></span><span id="compiler_002dmanx"></span><span id="index-quickfix_002dmanx"></span>
<span id="index-compiler_002dmanx"></span>
<span id="MANX-AZTEC-C"></span><h4 class="unnumberedsubsec">MANX AZTEC C</h4>

<p>Amiga 上で Manx&rsquo;s Aztec C compiler とともに Vim を使ふには次のやうにする:
</p><ul>
<li> 環境變數 CCEDIT を次のコマンドで設定する:
<pre class="verbatim">mset &quot;CCEDIT=vim -q&quot;
</pre></li><li> -qf オプションをつけてコンパイルする。もしコンパイラがエラーを見つけたら Vim がカーソルを最初のエラーの上に置いた狀態で起動する。エラーメッセージは最後の行に表示される。上で述べたコマンドを使つて他のエラーへ移動することができる。エラーを修正し、ファイルを保存できる。
</li><li> Vim を普通に終了するとコンパイラが同じファイルを再コンパイルする。:cq コマンドで終了した場合はコンパイラは終了する。エラーを修正できないときや、まづ他のファイルをコンパイルする必要があるときはさうするとよい。
</li></ul>

<p>Amiga における Quickfix モードには他にも制限がある。コンパイラは最初の 25 個のエラーしか出力しない (Manx&rsquo;s のドキュメントにはそれ以上出力する方法が書かれてゐない)。それ以上のエラーを探したいのならば、幾つかのエラーを修正しエディタを拔ける必要がある。再コンパイルの後殘り 25 個のエラーが出てくる
</p>
<p>Vim がコンパイラから起動された場合、:sh やいくつかの :! コマンドは機能しない。Vim がコンパイラと同じプロセスの中で動いてゐるため、標準出力が利用できないからである。
</p>

<span id="quickfix_002dperl"></span><span id="compiler_002dperl"></span><span id="index-quickfix_002dperl"></span>
<span id="index-compiler_002dperl"></span>
<span id="PERL-1"></span><h4 class="unnumberedsubsec">PERL</h4>

<p>Perl コンパイラプラグインはコンパイルはしないが、Perl 內部の構文チェック機能を呼び出し、その出力を解析してエラーを QuickFix モードで修正できるやうにする。
</p>
<p>チェックするファイルの中に &quot;no warnings&quot; または &quot;$^W = 0&quot; と書いてあつても關係なく警告が表示される。これを無效にするには g:perl_compiler_force_warnings に 0 を代入する。例:
</p><pre class="verbatim">let g:perl_compiler_force_warnings = 0
</pre>

<span id="compiler_002dpyunit"></span><span id="index-compiler_002dpyunit"></span>
<span id="PYUNIT-COMPILER"></span><h4 class="unnumberedsubsec">PYUNIT COMPILER</h4>

<p>これは實際にはコンパイラではなく、Python 言語用のユニットテストフレームワークである。PYUNIT はバージョン 2.0 から Python 標準ディストリビューションに含まれるやうになつた。それより古いバージョンは <a href="http://pyunit.sourceforge.net">http://pyunit.sourceforge.net</a> で入手できる。
</p>
<p>フレームワークの助けを借りてテストを走らせるとき、エラーがあれば Vim によつて解釋され、QuickFix モードで表示される。
</p>
<p>殘念ながら、テストを走らせる標準的な方法はない。alltests.py スクリプトがよく使はれると思はれるが、それだけである。よつて、&rsquo;<samp>makeprg</samp>&rsquo; に對する實用的な値は
</p><pre class="verbatim">setlocal makeprg=./alltests.py &quot; テストスイートを走らせる
setlocal makeprg=python\ %:S   &quot; 1 つのテストケースを走らせる
</pre><p>となる。
</p>
<p>次も參照。<a href="http://vim.sourceforge.net/tip_view.php?tip_id=280.">http://vim.sourceforge.net/tip_view.php?tip_id=280.</a>
</p>

<span id="compiler_002dtex"></span><span id="index-compiler_002dtex"></span>
<span id="TEX-COMPILER"></span><h4 class="unnumberedsubsec">TEX COMPILER</h4>

<p>ディストリビューションに含まれてゐる TeX 用のコンパイラスクリプト ($VIMRUNTIME/compiler/tex.vim) は、可能なら make コマンドを使ふ。コンパイラがカレントディレクトリに &quot;Makefile&quot; または &quot;makefile&quot; といふファイルを見つけたら、*TeX ファイルを make を使つて處理しようとし、その makefile 通りの動作をする。この場合コンパイラは &rsquo;<samp>errorformat</samp>&rsquo; を *TeX 出力用にセットし、&rsquo;<samp>makeprg</samp>&rsquo; は觸らずにそのままにしておく。&quot;Makefie&quot; も &quot;makefile&quot; も見つからない場合はコンパイラは make を使はない。makefile を無視するやうに指定することもできる。變數 b:tex_ignore_makefile か g:tex_ignore_makefile を設定すればよい (これらは存在するかのみチェックされる)。
</p>
<p>コンパイラが make を使はないことになつたら、コンパイラは入力を處理するプログラムを選擇する。變數 b:tex_flavorかg:tex_flavor (この順で探される) が存在すれば、それが :make コマンドのためのオプションを定義する。もし兩方とも存在しなければ、既定値 &quot;latex&quot; になる。例へば、AMS-TeX で書かれた mypaper.tex から \input された <samp>chapter2.tex</samp> を編輯中に
</p><pre class="verbatim">:let b:tex_flavor = 'amstex'
:compiler tex
</pre><p>[editing...]
</p><pre class="verbatim">:make mypaper
</pre>
<blockquote>
<p><strong>Note:</strong> <br>
處理するファイルの名前を引數に指定しなければならないことに注意 (\input か \include されたファイルを編輯中に正しいファイルを處理するため; % を引數なしに置換するポータブルな方法もよい)。これはソースではなく、ターゲットを指定するといふ make の意味論ではないが、擴張子 &quot;.tex&quot; を除いたファイル名を指定してもよい。その場合、「<samp>filename.dvi</samp> または <samp>filename.pdf</samp> または filename.[コンパイラに應じた何らかの結果の擴張子] をメイクしろ」といふことを意味する。
</p></blockquote>

<blockquote>
<p><strong>Note:</strong> <br>
tex コマンドライン文法は MikTex (Srinath Avadhanula によつて提案された) と teTeX (Artem Chuprina によつてチェックされた) の兩方で使へるやうに設定されてゐる。|<a href="#errorformat_002dLaTeX">errorformat-LaTeX</a>| からの提案は他のシェルや OS で動かせるやうにするには複雜すぎるし、他の TeX オプションを使ふことも許さない。もしあなたの TeX が &quot;-interaction=nonstopmode&quot; をサポートしてゐなければ、コマンドラインから \nonstopmode を表現する他の方法とともにその旨を報告してください。
</p></blockquote>

<span id="error_002dfile_002dformat"></span><span id="index-error_002dfile_002dformat"></span>
<span id="index-erahuomatuto"></span>
<span id="g_t7_002e-erahuomatuto"></span><h3 class="section">7. エラーフォーマット</h3>

<span id="errorformat"></span><span id="E372"></span><span id="E373"></span><span id="E374"></span><span id="E375"></span><span id="E376"></span><span id="E377"></span><span id="E378"></span><span id="index-errorformat"></span>
<span id="index-E372"></span>
<span id="index-E373"></span>
<span id="index-E374"></span>
<span id="index-E375"></span>
<span id="index-E376"></span>
<span id="index-E377"></span>
<span id="index-E378"></span>
<p>&rsquo;<samp>errorformat</samp>&rsquo; オプションは認識されるエラーフォーマットのリストを指定する。その中からエラーメッセージにマッチした最初のフォーマットが使はれる。複數のフォーマットを指定して、數種類のメッセージに對應したり、複數のコンパイラに對應したりすることができる。|<a href="#efm_002dentries">efm-entries</a>| を參照。
</p>
<p>&rsquo;<samp>errorformat</samp>&rsquo; の各要素は、scanf に似たフォーマットを記述する文字列である。はじめに、scanf がどのやうに働くか知る必要がある。C コンパイラのドキュメントを讀むこと。以下は Vim が理解する % の項目である。他は無效になる。
</p>
<p>&rsquo;<samp>errorformat</samp>&rsquo; 中の特別な文字はコンマとバックスラッシュである。それがどう扱はれるかは |<a href="#efm_002dentries">efm-entries</a>| を參照。&quot;%%&quot; はリテラル &quot;%&quot; にマッチする。よつてこれはバックスラッシュでエスケープしない。
</p>
<p>&lsquo;:make&lsquo;と &lsquo;:grep&lsquo; の出力のすべての NUL 文字は SOH (0x01) に置換されるので注意。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
デフォルトでは大文字と小文字の違ひは無視される。もし大文字・小文字の區別をしたいなら &quot;\C&quot; をパターンに付け加へる |<a href="pattern_002etxt.html#g_t_002f_005cC">/\C</a>|。
</p></blockquote>

<p>Vim は任意の長さの行を讀み取るが、最初の 4095 バイトのみが使用され、殘りは無視される。要素の長さは 1023 バイトまでである。
</p>

<span id="Ji-Ben-Yao-Su-"></span><h4 class="unnumberedsubsec">基本要素</h4>

<table>
<tr><td width="20%">%f</td><td width="80%">ファイル名 (文字列を檢索)</td></tr>
<tr><td width="20%">%o</td><td width="80%">モジュール名 (文字列を檢索)</td></tr>
<tr><td width="20%">%l</td><td width="80%">行番號 (數字を檢索)</td></tr>
<tr><td width="20%">%c</td><td width="80%">桁番號 (エラーの桁を表す數字 (&lt;Tab&gt; 1 個は 1 桁と數へる))</td></tr>
<tr><td width="20%">%v</td><td width="80%">畫面上の桁番號 (エラーの畫面上の桁を表す番號 (&lt;Tab&gt; 1 個はスクリーン上 8 桁と數へる))</td></tr>
<tr><td width="20%">%t</td><td width="80%">エラーの種類 (1 文字を檢索)</td></tr>
<tr><td width="20%">%n</td><td width="80%">エラー番號 (數字を檢索)</td></tr>
<tr><td width="20%">%m</td><td width="80%">エラーメッセージ (文字列を檢索)</td></tr>
<tr><td width="20%">%r</td><td width="80%">その行の殘り全部 %O/%P/%Q</td></tr>
<tr><td width="20%">%p</td><td width="80%">ポインタ行 (&rsquo;-&rsquo;, &rsquo;.&rsquo;, &rsquo; &rsquo; またはタブの列を檢索し、その長さを桁番號とする)</td></tr>
<tr><td width="20%">%*{conv}</td><td width="80%">scanf に割り當てられない變換</td></tr>
<tr><td width="20%">%%</td><td width="80%">1 個のリテラル &rsquo;%&rsquo;</td></tr>
<tr><td width="20%">%s</td><td width="80%">テキスト檢索 (文字列を檢索)</td></tr>
</table>

<p>&quot;%f&quot; の變換は現在の &rsquo;<samp>isfname</samp>&rsquo; の設定に依存する。&quot;~/&quot; はホームディレクトリ名に展開され、環境變數も展開される。
</p>
<p>變換 &quot;%f&quot; と &quot;%m&quot; はその文字列の終端を檢出しなければならない。通常は、後に續く文字と要素がマッチすれば、そこが終端になる。もし後に續く要素がなかつたら、その行の殘りの部分がマッチする。&quot;%f&quot; の後に &rsquo;%&rsquo; かバックスラッシュが續いてゐるなら、それは &rsquo;<samp>isfname</samp>&rsquo; 文字の列を檢索する。
</p>
<p>MS-DOS, MS-Windows そして OS/2 では、&quot;C:&quot; で始まる部分は &quot;%f&quot; に含まれる。&quot;%f:&quot; と指定したときでもさうなる。これはアルファベット 1 文字の名前のファイルは檢出されないことを意味する。
</p>
<p>&quot;%p&quot; の後には通常 &quot;^&quot; をつける。これは、以下のやうな出力によつてエラーの桁を示すコンパイラ用に使へる:
</p><pre class="verbatim">            ^
または &gt;
   ---------^
</pre><p>これは複數行のエラーメッセージでも使へる。實用的なサンプルとしては |<a href="#errorformat_002djavac">errorformat-javac</a>| を參照。
</p>
<p>&quot;%s&quot; はエラー行の位置を探すためのテキストを指定する。そのテキストは文字列リテラルして使はれる。檢索テキストに正確にマッチするエラー行を探すために、&quot;^&quot; と&quot;$&quot; がテキストに加へられる。また、テキストの先頭に &quot;\V&quot; が追加され、&quot;very nomagic&quot; とされる。&quot;%s&quot; はエラー出力中の行番號がない行を探すために使ふことができる。シェルコマンド &quot;grep&quot; の出力のやうに。
</p>
<p>パターンがある場合は行番號は使はれない。
</p>
<p>&quot;%o&quot; は quickfix 項目の中のモジュール名を指定する。もし指定があればそれがファイル名の代はりに quickfix エラーウィンドウの中で使はれる。モジュール名は結果を表示するためだけに使はれ、ファイル名はそのファイルにジャンプするときに使はれる。
</p>
<span id="deirekutoriwoBian-Geng-suru"></span><h4 class="unnumberedsubsec">ディレクトリを變更する</h4>

<p>次の大文字の變換文字は、特別なフォーマット文字列のタイプを指定する。これらのうち高々 1 つをコンマ區切りのフォーマットパターンの先頭につけることができる。
</p>
<p>&quot;%f&quot; によつて讀まれるファイル名の前につけたす必要があるディレクトリ名を出力するコンパイラがある (例: GNU make)。以下のコードはそれらのディレクトリ名を解釋するのに使はれる。そのディレクトリ名は內部のディレクトリスタックに保存される。
<span id="E379"></span><span id="index-E379"></span>
</p><table>
<tr><td width="10%">%D</td><td width="90%">&quot;enter directory&quot; フォーマット文字列。これ以下の %f はそのディレクトリ名を檢索する。</td></tr>
<tr><td width="10%">%X</td><td width="90%">&quot;leave directory&quot; フォーマット文字列。これ以下の %f はディレクトリスタックの1つ前のディレクトリを檢索する。</td></tr>
</table>

<p>&quot;enter directory&quot; や &quot;leave directory&quot; フォーマットを定義する場合、&quot;%D&quot; や &quot;%X&quot; は部分文字列の最初に置かれなけれならない。Vimはディレクトリ變更を追跡し相對パスによつて指定されたファイル名の前にカレントディレクトリ名をつけたす。Tips や制限など詳細は |<a href="#quickfix_002ddirectory_002dstack">quickfix-directory-stack</a>| を參照。
</p>

<span id="errorformat_002dmulti_002dline"></span><span id="index-errorformat_002dmulti_002dline"></span>
<span id="index-Fu-Shu-Xing-niwatarumetusezi"></span>
<span id="Fu-Shu-Xing-niwatarumetusezi"></span><h4 class="unnumberedsubsec">複數行にわたるメッセージ</h4>

<p>複數行メッセージにわたるメッセージを解釋することも可能である。取りうるプリフィックスは:
</p><table>
<tr><td width="10%">%E</td><td width="90%">複數行エラーメッセージの開始</td></tr>
<tr><td width="10%">%W</td><td width="90%">複數行警告メッセージの開始</td></tr>
<tr><td width="10%">%I</td><td width="90%">複數行情報メッセージの開始</td></tr>
<tr><td width="10%">%A</td><td width="90%">複數行メッセージの開始 (種類指定なし)</td></tr>
<tr><td width="10%">%&gt;</td><td width="90%">現在と同じパターンで始まつてゐる次行 |<a href="#efm_002d_0025_003e">efm-%&gt;</a>|</td></tr>
<tr><td width="10%">%C</td><td width="90%">複數行メッセージの繼續</td></tr>
<tr><td width="10%">%Z</td><td width="90%">複數行メッセージの終了</td></tr>
</table>
<p>これらに對して &rsquo;+&rsquo; と &rsquo;-&rsquo; をつけることもできる。|<a href="#efm_002dignore">efm-ignore</a>| を參照。
</p>
<p>パターンに &quot;\n&quot; を含めても、複數行のメッセージにはマッチしない。
</p>
<p>例: コンパイラが次のフォーマットでエラーを出力したとする。
</p>
<p>(行頭の行番號は實際の出力の一部ではない):
</p>
<pre class="verbatim">1  Error 275
2  line 42
3  column 3
4  ' ' expected after '--'
</pre>
<p>適切なエラーフォーマット文字列はこのやうになる:
</p><pre class="verbatim">:set efm=%EError\ %n,%Cline\ %l,%Ccolumn\ %c,%Z%m
</pre>
<p>すると、このエラーに對し |<a href="#g_t_003aclist">:clist</a>| が表示するエラーメッセージはこのやうになる:
</p><pre class="verbatim">1:42 col 3 error 275:  ' ' expected after '--'
</pre>
<p>別の例: 次のエラーメッセージを出力する Python インタープリターを考へる。
</p>
<p>(行頭の行番號は實際の出力の一部ではない):
</p>
<pre class="verbatim"> 1  ==============================================================
 2  FAIL: testGetTypeIdCachesResult (dbfacadeTest.DjsDBFacadeTest)
 3  --------------------------------------------------------------
 4  Traceback (most recent call last):
 5    File &quot;unittests/dbfacadeTest.py&quot;, line 89, in testFoo
 6      self.assertEquals(34, dtid)
 7    File &quot;/usr/lib/python2.2/unittest.py&quot;, line 286, in
 8   failUnlessEqual
 9      raise self.failureException, \
10  AssertionError: 34 != 33
11
12  --------------------------------------------------------------
13  Ran 27 tests in 0.063s
</pre>
<p>このメッセージに關する情報だけを |<a href="#g_t_003aclist">:clist</a>| で表示させたいところだらう。
</p>
<p>このやうに:
</p><pre class="verbatim">5 unittests/dbfacadeTest.py:89:  AssertionError: 34 != 33
</pre>
<p>そのためにはエラーフォーマット文字列を次のやうに定義する:
</p><pre class="verbatim">:set efm=%C\ %.%#,%A\ \ File\ \&quot;%f\&quot;\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m
</pre>
<blockquote>
<p><strong>Note:</strong> <br>
&quot;%C&quot; を &quot;%A&quot; の前に置いてゐることに注意: &rsquo; %.%#&rsquo; (これは正規表現 &rsquo; .*&rsquo; を意味する) がスペースで始まるすべての行にマッチするので、それが7行目を以降を隱してくれる。さうでないと7行目は別のエラーメッセージの始まりと解釋されてしまふ。エラーフォーマットは常に、リストの中から 1 つ 1 つ、最初のマッチが起こるまで試されていく。
</p></blockquote>
<span id="efm_002d_0025_003e"></span><span id="index-efm_002d_0025_003e"></span>
<p>要素 %&gt; は &rsquo;<samp>errorformat</samp>&rsquo; の最初の方に出てくるパターンを試すのを避けるために使へる。これはほとんど何にでもマッチするパターンに便利である。例へば、エラーがこのやうなら:
</p><pre class="verbatim">Error in line 123 of foo.c:
unknown variable &quot;i&quot;
</pre>
<p>これは以下でマッチできる:
</p><pre class="verbatim">:set efm=xxx,%E%&gt;Error in line %l of %f:,%Z%m
</pre><p>ここで &quot;xxx&quot; には 2 番目の行にもマッチするパターンが入るとする。
</p>
<blockquote>
<p><strong>重要:</strong> <br>
エラーフォーマットのどの部分が以前にマッチしたかは記憶されてゐない。すなはち、エラーファイルの各行が每囘エラーフォーマットの各行に對してテストされる。例へば、次のやうになつてゐるとする:
</p><pre class="verbatim">setlocal efm=aa,bb,cc,dd,ee
</pre><p>ここで aa, bb などはエラーフォーマット文字列とする。エラーファイルの各行がパターン aa, 次に bb, 次に cc… とテストされる。cc がエラーの 1 つ前の行にマッチしたからといつて、dd が現在行に對して最初にテストされるといふことにはならない。cc と dd が複數行エラーフォーマット文字列だつたとしても、である。
</p></blockquote>



<span id="errorformat_002dseparate_002dfilename"></span><span id="index-errorformat_002dseparate_002dfilename"></span>
<span id="index-huairuMing-woFen-Ge-suru"></span>
<span id="huairuMing-woFen-Ge-suru"></span><h4 class="unnumberedsubsec">ファイル名を分割する</h4>

<p>1 度現れたファイル名を複數のメッセージが參照する場合には、これらのプリフィックスが有效である。
</p><table>
<tr><td width="10%">%O</td><td width="90%">1 行ファイルメッセージ: マッチ部分を讀み込む (それ以前に記憶されてゐたものは消去される)</td></tr>
<tr><td width="10%">%P</td><td width="90%">1 行ファイルメッセージ: ファイル%fをスタックにプッシュする。</td></tr>
<tr><td width="10%">%Q</td><td width="90%">1 行ファイルメッセージ: スタックから最後のファイル名をポップする。</td></tr>
</table>

<p>例: 次のエラーログファイルを出力するコンパイラがあるとする (行番號は實際の出力ではない)
</p>
<pre class="verbatim"> 1  [a1.tt]
 2  (1,17)  error: ';' missing
 3  (21,2)  warning: variable 'z' not defined
 4  (67,3)  error: end of file found before string ended
 5
 6  [a2.tt]
 7
 8  [a3.tt]
 9  NEW compiler v1.1
10  (2,2)   warning: variable 'x' not defined
11  (67,3)  warning: 's' already defined
</pre>
<p>このログファイルは [...] で圍まれたファイルに對し複數のメッセージを示してゐる。これは次のエラーフォーマットで適切に解釋できる:
</p><pre class="verbatim">:set efm=%+P[%f],(%l\\,%c)%*[\ ]%t%*[^:]:\ %m,%-Q
</pre>
<p>|<a href="#g_t_003aclist">:clist</a>| を呼ぶとこれらをファイル名とともに適切に表示してくれる:
</p>
<pre class="verbatim">2 a1.tt:1 col 17 error: ';' missing
3 a1.tt:21 col 2 warning: variable 'z' not defined
4 a1.tt:67 col 3 error: end of file found before string ended
8 a3.tt:2 col 2 warning: variable 'x' not defined
9 a3.tt:67 col 3 warning: 's' already defined
</pre>
<p>行全體にマッチする他のプリフィックスとは違ひ、%P, %Q, %Oは同一行の複數のパターンにマッチさせるのに使へる。それゆゑ、次のやうにファイルがネストした場合を解釋することもできる:
</p><pre class="verbatim">{&quot;file1&quot; {&quot;file2&quot; error1} error2 {&quot;file3&quot; error3 {&quot;file4&quot; error4 error5}}}
</pre><p>%O はファイル名情報のプッシュ・ポップを含まない文字列を解釋する。發展例については |<a href="#errorformat_002dLaTeX">errorformat-LaTeX</a>| を參照。
</p>

<span id="efm_002dignore"></span><span id="index-efm_002dignore"></span>
<span id="index-metuseziQuan-Ti-woWu-Shi-suruShi-u"></span>
<span id="metuseziQuan-Ti-woWu-Shi-suruShi-u"></span><h4 class="unnumberedsubsec">メッセージ全體を無視する・使ふ</h4>

<p>&rsquo;+&rsquo;, &rsquo;-&rsquo; は大文字の指定文字と組み合はせて使ふ。&rsquo;%+A&rsquo; や &rsquo;%-G&rsquo; のやうに指定文字の前につける。
</p><table>
<tr><td width="10%">%-</td><td width="90%">複數行のマッチを含まない。</td></tr>
<tr><td width="10%">%+</td><td width="90%">エラー文字列%m中でマッチした行全體</td></tr>
</table>

<p>プリフィックス %G だけは &rsquo;+&rsquo; か &rsquo;-&rsquo; と組み合はせたときのみ意味を持つ。これはコンパイラバージョンのやうな一般的な情報を含む行か、無視するべきヘッダーを讀み込む。
</p><table>
<tr><td width="10%">%-G</td><td width="90%">このメッセージを無視する</td></tr>
<tr><td width="10%">%+G</td><td width="90%">一般的なメッセージ</td></tr>
</table>


<span id="patanmatutingu"></span><h4 class="unnumberedsubsec">パターンマッチング</h4>

<p>古いバージョンの Vim との下位互換性の爲に scanf() と同じ &quot;%*[]&quot; といふ記法がサポートされてゐる。しかし、フォーマット文字列に Vim がサポートするほぼ全ての正規表現を用ゐる事も可能である。正規表現言語のメタ文字は普通の文字列やファイル檢索の一部と重なつてしまふから (從つて內部的にはエスケープされる必要がある)、メタシンボルは &rsquo;%&rsquo; を付加して表記される必要がある:
</p><table>
<tr><td width="10%">%\</td><td width="90%">單體の &rsquo;\&rsquo; といふ文字。これは &quot;:set errorformat=&quot; の定義の中ではエスケープされて (&quot;%\\&quot;) 書かれなければならない。</td></tr>
<tr><td width="10%">%.</td><td width="90%">單體の &rsquo;.&rsquo; といふ文字。</td></tr>
<tr><td width="10%">%#</td><td width="90%">單體の &rsquo;*&rsquo; (!) といふ文字。</td></tr>
<tr><td width="10%">%^</td><td width="90%">單體の &rsquo;^&rsquo; といふ文字。注意: これなしでも行頭にはマッチするので、これは特に便利ではない。</td></tr>
<tr><td width="10%">%$</td><td width="90%">單體の &rsquo;$&rsquo; といふ文字。注意: これなしでも行末にはマッチするので、これは特に便利ではない。</td></tr>
<tr><td width="10%">%[</td><td width="90%">單體の &rsquo;[&rsquo; といふ文字。文字の範圍 [] のために使はれる。</td></tr>
<tr><td width="10%">%~</td><td width="90%">單體の &rsquo;~&rsquo; といふ文字。</td></tr>
</table>
<p>表現の中でキャラクタクラスを使用する場合 (槪要は |<a href="pattern_002etxt.html#g_t_002f_005ci">/\i</a>| を參照)、數量子 &quot;\+&quot; を含む語は scanf() の中に &quot;%*&quot; といふ記法で書くことができる。例: &quot;%\\d%\\+&quot; (&quot;\d\+&quot;,&quot;どんな數字でも&quot;) は &quot;%*\\d&quot; と等價である。
</p><blockquote>
<p><strong>重要:</strong> <br>
\(...\) のグループ表現は、內部變換に使ふため豫約されてゐるからフォーマット指定內では使用することができない。
</p></blockquote>


<span id="efm_002dentries"></span><span id="index-efm_002dentries"></span>
<span id="index-_0027errorformat_0027-Nei-noFu-Shu-noYao-Su-"></span>
<span id="g_t_0027errorformat_0027-Nei-noFu-Shu-noYao-Su-"></span><h4 class="unnumberedsubsec">&rsquo;<samp>errorformat</samp>&rsquo; 內の複數の要素</h4>

<p>複數のコンパイラからの出力を見つけることを可能にするために、コンマで區切つて複數のフォーマットパターンを &rsquo;<samp>errorformat</samp>&rsquo; に設定することができるだらう (<strong>Note:</strong> コンマ直後の空白は無視される)。完全にマッチした最初のパターンが採擇される。マッチするものが無い場合、最後にマッチした部分が使はれるが、ファイルネームは除外されエラーメッセージは全體のメッセージとして設定される。複數のコンパイラからの出力メッセージにマッチしてしまふパターンがあつた (しかし正確には一致しない) 時には、より制限されたもの {譯注: 他のメッセージにマッチし難いもの} の後に置く。
</p>
<p>パターンの先頭にコンマを含めるにはバックスラッシュ (&quot;:set&quot; コマンド中では 2 度タイプするべきだ) を添へる。バックスラッシュを含めるためには 2 つ與へる (つまり &quot;:set&quot; コマンドの中では 4 つタイプする)。また、&quot;:set&quot; コマンド內のスペースの前にはバックスラッシュを置く必要がある。
</p>

<span id="quickfix_002dvalid"></span><span id="index-quickfix_002dvalid"></span>
<span id="index-You-Xiao-namatuti"></span>
<span id="You-Xiao-namatuti"></span><h4 class="unnumberedsubsec">有效なマッチ</h4>

<p>もし &rsquo;<samp>errorformat</samp>&rsquo; に完全には一致しない行が現れた場合、エラーメッセージ全體が表示され、エントリは無效とされコマンド &quot;:cn&quot; や &quot;:cp&quot; 使用時にはスキップされる (有效なエントリが全く無い場合で無い限り)。エラーメッセージの全てはコマンド &quot;:cl!&quot; で表示する事ができる。
</p>
<p>エラーフォーマットがファイル名を含んでゐないと Vim は正しいファイルへジャンプすることができない。手動でやる必要がある。
</p>

<p>例
</p>
<p>Aztec compiler のファイルの書式は:
</p><pre class="verbatim">ファイル名&gt;行:列:エラータイプ:識別番號:メッセージ
</pre><table>
<tr><td width="30%">ファイル名</td><td width="70%">エラーが見つかつたファイルの名前</td></tr>
<tr><td width="30%">行</td><td width="70%">エラーが見つかつた行の通し番號</td></tr>
<tr><td width="30%">列</td><td width="70%">エラーが見つかつた場所の列數 (行先頭からの文字數)</td></tr>
<tr><td width="30%">タイプ</td><td width="70%">エラーの種類、通常は一文字で &rsquo;E&rsquo; か &rsquo;W&rsquo;</td></tr>
<tr><td width="30%">識別番號</td><td width="70%">エラーの番號 (マニュアルの檢索用)</td></tr>
<tr><td width="30%">メッセージ</td><td width="70%">エラーの說明</td></tr>
</table>

<p>これは &rsquo;<samp>errorformat</samp>&rsquo; をこのやうに設定すればマッチできる:
</p><pre class="verbatim">%f&gt;%l:%c:%t:%n:%m
</pre>
<span id="Dan-Xing-erawoChu-Li-suru-C-konpairanotamenoJi-tukanoLi_003a"></span><h4 class="unnumberedsubsec">單行エラーを出力する C コンパイラのための幾つかの例:</h4>
<table>
<tr><td width="70%">%f:%l:\ %t%*[^0123456789]%n:\ %m</td><td width="30%">Manx/Aztec C エラーメッセージ (scanf() は [0-9] を理解しない)</td></tr>
<tr><td width="70%">%f\ %l\ %t%*[^0-9]%n:\ %m</td><td width="30%">SAS C 用</td></tr>
<tr><td width="70%">\&quot;%f\&quot;\\,%*[^0-9]%l:\ %m</td><td width="30%">generic C compilers 用</td></tr>
<tr><td width="70%">%f:%l:\ %m</td><td width="30%">GCC 用</td></tr>
<tr><td width="70%">%f:%l:\ %m,%Dgmake[%*\\d]:\ Entering\ directory\ &lsquo;%f&rsquo;, <br> %Dgmake[%*\\d]:\ Leaving\ directory\ &lsquo;%f&rsquo;</td><td width="30%">GCC with gmake 用 (行を連結すること！)</td></tr>
<tr><td width="70%">%f(%l)\ :\ %*[^:]:\ %m</td><td width="30%">old SCO C compiler (pre-OS5)</td></tr>
<tr><td width="70%">%f(%l)\ :\ %t%*[^0-9]%n:\ %m</td><td width="30%">idem, エラーの種類と番號つき</td></tr>
<tr><td width="70%">%f:%l:\ %m,In\ file\ included\ from\ %f:%l:,\^I\^Ifrom\ %f:%l%m</td><td width="30%">いくつかの擴張つき GCC</td></tr>
</table>

<p>複數行メッセージを扱ふために擴張した例が次の所で與へられる。|<a href="#errorformat_002dJikes">errorformat-Jikes</a>| と |<a href="#errorformat_002dLaTeX">errorformat-LaTeX</a>| を參照。
</p>
<p>:set コマンドで使ふときにはスペースとダブルクォートの前にバックスラッシュが必要なことに注意。コンマの前には 2 つのバックスラッシュを置く。1 つは :set コマンドのため、もう 1 つはコンマがエラーフォーマットの區切りと認識されるのを避けるためである。
</p>

<span id="metuseziwohuirutaringusuru"></span><h4 class="unnumberedsubsec">メッセージをフィルタリングする</h4>

<p>もしコンパイラがフォーマットに合はないエラーメッセージを作成する場合、エラーメッセージをこのフォーマットに變換するプログラムを書く方法もある。その時はコマンド &quot;:make&quot; によつて起動されるプログラムオプション &rsquo;<samp>makeprg</samp>&rsquo; を變更することで指定できる。例:
</p><pre class="verbatim">:set mp=make\ \\\|&amp;\ error_filter
</pre><p>パイプ (|) の前のバックスラッシュはコマンドセパレータとして認識されないために必要。コマンド &quot;set&quot; では空白の前にバックスラッシュが必要。
</p>
<span id="quickfix_002ddirectory_002dstack"></span><span id="index-quickfix_002ddirectory_002dstack"></span>
<span id="index-deirekutorisutatuku"></span>
<span id="g_t8_002e-deirekutorisutatuku"></span><h3 class="section">8. ディレクトリスタック</h3>

<p>Quickfix は make の出力を解釋し、使はれたディレクトリ全てをスタックで保持する。GNU-Make ではディレクトリに入つたり出たりすると常に絕對パスで表示されるので、これはむしろシンプルである。これは makefile 中の cd コマンドか、起動パラメーター &quot;-C dir&quot; (makefile の讀みこみ前にディレクトリを變更) なのかには因らない。GNU-Make に强制的に處理の前後にワーキングディレクトリを表示されるためにスイッチ &quot;-w&quot; を使用するのは便利かもしれない。
</p>
<p>GNU-make を使用しない場合、正しいディレクトリを管理する事はもつと複雜になる。例へば AIX-make はワーキングディレクトリに關してなんの情報も表示しない。よつて makefile に細工が必要となる。LessTif の makefile には &quot;Making {target} in {dir}&quot; と表示するコマンドがある。ここにはディレクトリを出る時の情報とその相對パスが表示されないといふ重要な問題もある。
</p>
<p>パスの關係とメッセージ &quot;leave directory&quot; が現れない問題のために Vim では次のアルゴリズムで對處してゐる:
</p>
<table>
<tr><td width="10%">1)</td><td width="90%">與へられたディレクトリがカレントディレクトリの子か調べる。眞ならばそれをカレントディレクトリとする。</td></tr>
<tr><td width="10%">2)</td><td width="90%">カレントディレクトリの子ディレクトリでなかつた場合、上のディレクトリの子ディレクトリか (つまり兄弟ディレクトリ) を調べる。</td></tr>
<tr><td width="10%">3)</td><td width="90%">まだディレクトリが見つからない場合、これは Vim のカレントディレクトリの子ディレクトリだと假定される。</td></tr>
</table>

<p>付け加へて、全てのファイルについて認識されたディレクトリに實際に存在するのか調べられる。もしもなければディレクトリスタックの中の全てのディレクトリ (サブディレクトリではない) について探す。これでも見つからなければ Vim のカレントディレクトリにあるものと假定される。
</p>
<p>このアルゴリズムには制限がある。この例は make がディレクトリに入つた時に &quot;Making all in dir&quot; の形で情報を表示すると假定してゐる。
</p>
<span id="g_t1_0029-Ci-noyounadeirekutoritohuairugaatutatosuru"></span><h4 class="unnumberedsubsec">1) 次のやうなディレクトリとファイルがあつたとする</h4>
<pre class="verbatim">./dir1
./dir1/file1.c
./file1.c
</pre>
<p>カレントディレクトリの前に make が &quot;./dir1&quot; を處理し &quot;./file1.c&quot; にエラーがあると Vimは &quot;./dir1/file.c&quot; をロードしてしまふ。
</p>
<p>これはメッセージ &quot;leave directory&quot; があれば解決する事ができる。
</p>
<span id="g_t2_0029-Ci-noyounadeirekutoritohuairugaatutatosuru"></span><h4 class="unnumberedsubsec">2) 次のやうなディレクトリとファイルがあつたとする</h4>
<pre class="verbatim">./dir1
./dir1/dir2
./dir2
</pre>
<p>次のやうになる:
</p>
<pre class="verbatim">Make の出力                    Vim が解釋するディレクトリ
------------------------       ----------------------------
Making all in dir1             ./dir1
Making all in dir2             ./dir1/dir2
Making all in dir2             ./dir1/dir2
</pre>
<p>これはメッセージ &quot;enter directory&quot; に絕對パスが記述されるか、メッセージ &quot;leave directory&quot; が表示されれば解決される。
</p>
<p>この問題を避けるため、ディレクトリの絕對パスとメッセージ &quot;leave directory&quot; が表示されるやうにすればよい。
</p>
<p>Makefile の例:
</p>
<pre class="verbatim">Unix:
    libs:
            for dn in $(LIBDIRS); do                            \
                (cd $$dn; echo &quot;Entering dir '$$(pwd)'&quot;; make); \
                echo &quot;Leaving dir&quot;;                             \
            done
</pre>
<p>上の出力を取り扱ふために
</p><pre class="verbatim">%DEntering\ dir\ '%f',%XLeaving\ dir
</pre><p>を &rsquo;<samp>errorformat</samp>&rsquo; につけ加へる。
</p>
<blockquote>
<p><strong>Note:</strong> <br>
Vim はメッセージ &quot;leave directory&quot; の中のディレクトリ名がカレントディレクトリかどうかはチェックしない。これが何故メッセージ &quot;Leaveing dir&quot; だけで良いかの理由だ。
</p></blockquote>

<span id="errorformats"></span><span id="index-errorformats"></span>
<span id="index-Ju-Ti-De-naerahuairuhuomatuto"></span>
<span id="g_t9_002e-Ju-Ti-De-naerahuairuhuomatuto"></span><h3 class="section">9. 具體的なエラーファイルフォーマット</h3>

<span id="errorformat_002dJikes"></span><span id="index-errorformat_002dJikes"></span>
<p>IBM Research によつて公開されてゐる Java コンパイラ Jikes(TM) はシンプルなマルチラインエラーメッセージを出力する。
</p>
<p>このメッセージにマッチする &rsquo;<samp>errorformat</samp>&rsquo; の文字列を下に示す。これをユーザーの |<a href="starting_002etxt.html#vimrc">vimrc</a>| に書くことで Vim がデフォルトで認識するフォーマットを上書きする事ができる。またデフォルトに追加インストールする方法は |<a href="options_002etxt.html#g_t_003aset_002b_003d">:set+=</a>| を參照。
</p>
<pre class="verbatim">:set efm=%A%f:%l:%c:%*\\d:%*\\d:,
      \%C%*\\s%trror:%m,
      \%+C%*[^:]%trror:%m,
      \%C%*\\s%tarning:%m,
      \%C%m
</pre><p>Jikes(TM) はオプション &quot;+E&quot; とともに起動されたときは 1 行エラーメッセージを出力する。これは次によつてマッチできる。
</p><pre class="verbatim">:setl efm=%f:%l:%v:%*\\d:%*\\d:%*\\s%m
</pre><span id="errorformat_002djavac"></span><span id="index-errorformat_002djavac"></span>
<p>この &rsquo;<samp>errorformat</samp>&rsquo; は、エラーの桁を示すのに &quot;^&quot; の行を出力する javac 用にうまく動作すると報告されてゐる:
</p><pre class="verbatim">:setl efm=%A%f:%l:\ %m,%-Z%p^,%-C%.%#
</pre><p>または:
</p><pre class="verbatim">:setl efm=%A%f:%l:\ %m,%+Z%p^,%+C%.%#,%-G%.%#
</pre><p>Michael F. Lamb が考案した別の方法を以下に示す。これは Unix 用で、最初にエラーをフィルタリングする:
</p><pre class="verbatim">:setl errorformat=%Z%f:%l:\ %m,%A%p^,%-G%*[^sl]%.%#
:setl makeprg=javac\ %:S\ 2&gt;&amp;1\ \\\|\ vim-javac-filter
</pre>
<p>以下の行を &quot;vim-javac-filter&quot; といふファイルに書いて、PATH の通つたディレクトリ (例へば~/bin) に置き、實行可能にしておく必要がある:
</p><pre class="verbatim">#!/bin/sed -f
/\^$/s/\t/\ /g;/:[0-9]\+:/{h;d};/^[ \t]*\^/G;
</pre><p>{譯注: BSD sed では動作しないやうです。GNU sed では動作します。}
</p>
<p>この sed スクリプトを言葉で說明すると次のやうになる:
</p><ul>
<li> 1 つのタブを1つのスペースに置換し、
</li><li> ファイル名・行番號・エラーメッセージを含む行をポインタ行 (&quot;^&quot; の行のこと) の直後に移動する。これによつて、エラーメッセージ行とポインタ行の閒の使はれないテキストが無視され、vim の「複數行メッセージ」の記法にマッチするやうになり、また、それを「複數行メッセージの繼續」として含めなくてもよいやうになる。
</li></ul>

<span id="errorformat_002dant"></span><span id="index-errorformat_002dant"></span>
<p>ant (<a href="http://jakarta.apache.org/">http://jakarta.apache.org/</a>) 用には、各 javac の出力行の前につく [javac] を受け取るために、上のエラーフォーマットを修正しなければならない:
</p><pre class="verbatim">:set efm=%A\ %#[javac]\ %f:%l:\ %m,%-Z\ %#[javac]\ %p^,%-C%.%#
</pre>
<p>javac や jikes と ant をともに扱ふためにこの &rsquo;<samp>errorformat</samp>&rsquo; を調整することができる。jikes を使つてゐるなら、jikes の +E コマンドラインスイッチを使ふことを ant に敎えなければならない (このスイッチは jikes に 1 行エラーメッセージを生成させる)。これが <samp>build.xml</samp> ファイルの 2 行目が行つてゐることである:
</p><pre class="verbatim">&lt;property name = &quot;build.compiler&quot;       value = &quot;jikes&quot;/&gt;
&lt;property name = &quot;build.compiler.emacs&quot; value = &quot;true&quot;/&gt;
</pre>
<p>javac, jikes と組み合はせた ant を扱ふ &rsquo;<samp>errorformat</samp>&rsquo; はかうである:
</p><pre class="verbatim">:set efm=\ %#[javac]\ %#%f:%l:%c:%*\\d:%*\\d:\ %t%[%^:]%#:%m,
         \%A\ %#[javac]\ %f:%l:\ %m,%-Z\ %#[javac]\ %p^,%-C%.%#
</pre><span id="errorformat_002djade"></span><span id="index-errorformat_002djade"></span>
<p>jade (<a href="http://www.jclark.com/">http://www.jclark.com/</a> 參照) のエラーを解釋するのは簡單である:
</p><pre class="verbatim">:set efm=jade:%f:%l:%c:%t:%m
</pre><span id="errorformat_002dLaTeX"></span><span id="index-errorformat_002dLaTeX"></span>
<p>次のは複數行に渡つてエラーメッセージを表示する (La)TeX タイプセッティングシステム用の &rsquo;<samp>errorformat</samp>&rsquo; 文字列を指定する 1 つの例である。&quot;:clist&quot; や &quot;:cc&quot; 等々のコマンドは先行する空白を削除して複數行のものを一行にまとめて表示する。
</p>
<p>以下の LaTeX 用 errorformat はマルチラインエラーを出力する他のコンパイラへ應用するのは簡單だらう。
</p>
<p>コマンドは |<a href="starting_002etxt.html#vimrc">vimrc</a>| ファイルか別の Vim script ファイルに書ける。例へば LaTeX に關聯した內容を含むスクリプトを LaTeX ソースの編輯時にだけ讀みこまれるやうにする。
</p>
<p>サンプルの全行をコピーしたことを確認する (順番もそのまま)。行の始まりに見ることのできる &rsquo;\&rsquo; の表記は |<a href="repeat_002etxt.html#line_002dcontinuation">line-continuation</a>| を參照。
</p>
<blockquote>
<p>まず &rsquo;<samp>makeprg</samp>&rsquo; を LaTeX が最初のエラーで止まることなく複數のエラーを返すやうに準備する。
</p><pre class="verbatim">:set makeprg=latex\ \\\\nonstopmode\ \\\\input\\{$*}
</pre><p>マルチラインエラーメッセージの始まり:
</p><pre class="verbatim">:set efm=%E!\ LaTeX\ %trror:\ %m,
       \%E!\ %m,
</pre><p>マルチライン警告メッセージの始まり; 最初の 2 つは行番號も含んでゐる。幾つかの正規表現の意味:
</p><ul>
<li> &quot;%.%#&quot;  (&quot;.*&quot;)   文字列 (空文字列も含む) にマッチ
</li><li> &quot;%*\\d&quot; (&quot;\d\+&quot;) 數字にマッチ
</li></ul>
<pre class="verbatim">       \%+WLaTeX\ %.%#Warning:\ %.%#line\ %l%.%#,
       \%+W%.%#\ at\ lines\ %l--%*\\d,
       \%WLaTeX\ %.%#Warning:\ %m,
</pre><p>エラー/警告メッセージが續く可能性; 最初の 1 つは行番號も含んでゐる:
</p><pre class="verbatim">       \%Cl.%l\ %m,
       \%+C\ \ %m.,
       \%+C%.%#-%.%#,
       \%+C%.%#[]%.%#,
       \%+C[]%.%#,
       \%+C%.%#%[{}\\]%.%#,
       \%+C&lt;%.%#&gt;%.%#,
       \%C\ \ %m,
</pre><p>次のパターンにマッチする行には重要な情報は含まれてゐない; よつてメッセージに含まないやうにする。
</p><pre class="verbatim">       \%-GSee\ the\ LaTeX%m,
       \%-GType\ \ H\ &lt;return&gt;%m,
       \%-G\ ...%.%#,
       \%-G%.%#\ (C)\ %.%#,
       \%-G(see\ the\ transcript%.%#),
</pre><p>通常、空白文字だけの行は表示しない:
</p><pre class="verbatim">       \%-G%*\\s,
</pre><p>LaTeX の出力ログには個々のライン每にエラーのあつたファイル名が特定(記述)されてゐるわけではない; ログのあらゆる所で與へられ、括弧にくくられてゐる。續くパターンはそれらの名前を取り出し內部スタックに保存しようと試みる。パターンは時として 1 つの行を複數回走査 (1 つ目を見つけた後、同じ行に次のを發見しようと) するので、パターンの末尾の &quot;%r&quot; が行の殘りの部分が次の試行で解釋の對象になることと、行の末尾に達するまでそれが繰り返されることを示す。
</p>
<p>&rsquo;(&rsquo;...&rsquo;)&rsquo; でくくられたファイル名を讀み飛ばす;明らかにエラーを含まないファイルはスタックに積まない:
</p><pre class="verbatim">       \%+O(%f)%r,
</pre><p>ファイル名をスタックに積む。名前は &rsquo;(&rsquo; の後に與へられる。
</p><pre class="verbatim">       \%+P(%f%r,
       \%+P\ %\\=(%f%r,
       \%+P%*[^()](%f%r,
       \%+P[%\\d%[^()]%#(%f%r,
</pre><p>&rsquo;)&rsquo; が見つかつたらファイル名をスタックから取り崩す。
</p><pre class="verbatim">       \%+Q)%r,
       \%+Q%*[^()])%r,
       \%+Q[%\\d%*[^()])%r
</pre></blockquote>

<blockquote>
<p><strong>Note:</strong> <br>
幾つかのケースにおいて LaTeX の出力したログの中のファイル名を正確に取り出す事ができないことに注意。括弧の對應が正しくつかない時パーサーは混亂してしまふ。上記のサンプルはもつとも一般的なケースだけ檢出できるやうにしてある。目的に合はせてこのサンプルを變へる事はできる。例へば全てのゐまいましい &quot;Overfull ...&quot; といふ警告メッセージがエラーとして認識されてしまふ事を防ぐ事ができる。
</p>
<p>付け加へて LaTeX コンパイラの出力をフィルタリングするには、[La]TeX コンパイラによつて生成されるファイル <samp>*.log</samp> を直接讀むことも可能である。これは起こる可能性のあるエラーについてより便利な情報を澤山含んでゐる。しかしそのやうに複雜なファイルを正確に解釋するには、外部フィルタを使ふほうが良い。そのやうな Vim に識別されるフィルタの作り方はずつと以前に述べたので參照。
</p></blockquote>

<span id="errorformat_002dPerl"></span><span id="index-errorformat_002dPerl"></span>
<p>$VIMRUNTIME/tools に efm_perl.pl スクリプトがある。これは Perl のエラーメッセージをフィルタし、QuickFix モードが理解できるフォーマットに變換する。使ひ方はファイルの先頭を參照。(このスクリプトはもう非推奬で、今は |<a href="#compiler_002dperl">compiler-perl</a>| を參照のこと)
</p>


<hr>
<div class="header">
<p>
Up: <a href="Mu-Ci-.html" accesskey="u" rel="up">目次</a> &nbsp; [<a href="Indexes-CP.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
