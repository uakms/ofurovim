@ifset JA  @c ----------- v -----------  JA  -*- tab-width: 8 -*-
@node tips.txt, , , 目次
@unnumbered さまざまな Tips
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*tips.txt*      For Vim version 8.1.  Last change: 2009 Nov 07


		  VIM REFERENCE MANUAL    by Bram Moolenaar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
*tips.txt*      For Vim バージョン 8.1.  Last change: 2009 Nov 07


		  VIMリファレンスマニュアル	  by Bram Moolenaar
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Tips and ideas for using Vim				*tips*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{tips}
@cindex tips
@cindex Vim を使うときのヒントとアイデア
Vim を使うときのヒントとアイデア
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These are just a few that we thought would be helpful for many users.
You can find many more tips on the wiki.  The URL can be found on
http://www.vim.org
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは、多くのユーザーにとって便利だろうと思うことの一部です。wiki にはもっと多くの tips があります。@url{http://www.vim.org}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Don't forget to browse the user manual, it also contains lots of useful tips
|usr_toc.txt|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザーマニュアルも参照してください。ユーザーマニュアルにはたくさんの tips が含まれています |@ref{usr_toc.txt}|。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Editing C programs				|C-editing|
Finding where identifiers are used		|ident-search|
Switching screens in an xterm			|xterm-screens|
Scrolling in Insert mode			|scroll-insert|
Smooth scrolling				|scroll-smooth|
Correcting common typing mistakes		|type-mistakes|
Counting words, lines, etc.			|count-items|
Restoring the cursor position			|restore-position|
Renaming files					|rename-files|
Change a name in multiple files			|change-name|
Speeding up external commands			|speed-up|
Useful mappings					|useful-mappings|
Compressing the help files			|gzip-helpfile|
Executing shell commands in a window		|shell-window|
Hex editing					|hex-editing|
Using <> notation in autocommands		|autocmd-<>|
Highlighting matching parens			|match-parens|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item |@ref{C-editing}| @tab C のプログラムを編集する
@item |@ref{ident-search}| @tab 識別子が使われている場所を検索する
@item |@ref{xterm-screens}| @tab xterm でのスクリーンの切り替え
@item |@ref{scroll-insert}| @tab 挿入モードでスクロールを行う
@item |@ref{scroll-smooth}| @tab スムーズにスクロールさせる
@item |@ref{type-mistakes}| @tab ありがちなタイプミスを修正する
@item |@ref{count-items}| @tab 単語や行などの数を数える
@item |@ref{restore-position}| @tab カーソルの位置を戻す
@item |@ref{rename-files}| @tab ファイルをリネームする
@item |@ref{change-name}| @tab 複数ファイル中の名前を置換する
@item |@ref{speed-up}| @tab 外部コマンドの実行速度を速くする
@item |@ref{useful-mappings}| @tab 便利なマッピング
@item |@ref{gzip-helpfile}| @tab ヘルプファイルを圧縮する
@item |@ref{shell-window}| @tab ウィンドウでシェルコマンドを実行する
@item |@ref{hex-editing}| @tab バイナリ編集
@item |@ref{autocmd-<>}| @tab 自動コマンドで <> 表記を使う
@item |@ref{match-parens}| @tab 対応する括弧を強調する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Editing C programs					*C-editing*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{C-editing}
@cindex C-editing
@cindex C のプログラムを編集する
@section C のプログラムを編集する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are quite a few features in Vim to help you edit C program files.  Here
is an overview with tags to jump to:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim には C のプログラムファイルを編集するのを手助けする機能がたくさんあります。詳細をジャンプして確認できるようにタグつきで機能のあらましを紹介しましょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|usr_29.txt|		Moving through programs chapter in the user manual.
|usr_30.txt|		Editing programs chapter in the user manual.
|C-indenting|		Automatically set the indent of a line while typing
			text.
|=|			Re-indent a few lines.
|format-comments|	Format comments.

|:checkpath|		Show all recursively included files.
|[i|			Search for identifier under cursor in current and
			included files.
|[_CTRL-I|		Jump to match for "[i"
|[I|			List all lines in current and included files where
			identifier under the cursor matches.
|[d|			Search for define under cursor in current and included
			files.

|CTRL-]|		Jump to tag under cursor (e.g., definition of a
			function).
|CTRL-T|		Jump back to before a CTRL-] command.
|:tselect|		Select one tag out of a list of matching tags.

|gd|			Go to Declaration of local variable under cursor.
|gD|			Go to Declaration of global variable under cursor.

|gf|			Go to file name under the cursor.

|%|			Go to matching (), {}, [], /* */, #if, #else, #endif.
|[/|			Go to previous start of comment.
|]/|			Go to next end of comment.
|[#|			Go back to unclosed #if, #ifdef, or #else.
|]#|			Go forward to unclosed #else or #endif.
|[(|			Go back to unclosed '('
|])|			Go forward to unclosed ')'
|[{|			Go back to unclosed '{'
|]}|			Go forward to unclosed '}'

|v_ab|			Select "a block" from "[(" to "])", including braces
|v_ib|			Select "inner block" from "[(" to "])"
|v_aB|			Select "a block" from "[{" to "]}", including brackets
|v_iB|			Select "inner block" from "[{" to "]}"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item |@ref{usr_29.txt}| @tab ユーザーマニュアルの「プログラム内の移動」
@item |@ref{usr_30.txt}| @tab ユーザーマニュアルの「プログラムの編集」
@item |@ref{C-indenting}| @tab テキストをタイプ中、自動的に行をインデントします。
@item |@ref{=}| @tab 数行をインデントし直します。
@item |@ref{format-comments}| @tab コメントを自動的にフォーマットします。
@item
@item |@ref{:checkpath}| @tab 再帰的にインクルードされるファイルをすべて表示します。
@item |@ref{[i}| @tab カーソルの下にある単語と同じものを現在のファイルとインクルードされるファイルから探します。
@item |@ref{[_CTRL-I}| @tab "[i" でマッチした場所にジャンプします。
@item |@ref{[I}| @tab カーソルの下にある単語と同じものを現在のファイルとインクルードされるファイルから探し出しその行のリストを表示します。
@item
@item |@ref{[d}| @tab カーソルの下の単語の定義を現在のファイルとインクルードされるファイルから探します
@item |@ref{CTRL-]}| @tab カーソルの下のタグにジャンプします。(例、関数の定義)
@item |@ref{CTRL-T}| @tab CTRL-] コマンドの前に戻ります。
@item |@ref{:tselect}| @tab マッチしたタグのリストから 1 つ選びます。
@item
@item |@ref{gd}| @tab カーソルの下のローカル変数の宣言にジャンプする。
@item |@ref{gD}| @tab カーソルの下のグローバル変数の宣言にジャンプする。
@item
@item |@ref{gf}| @tab カーソルの下のファイル名にジャンプする。
@item
@item |@ref{%}| @tab 対応する (), @{@}, [], /* */, #if, #else, #endif に移動する。
@item |@ref{[/}| @tab 前のコメントが始まる場所に移動する。
@item |@ref{]/}| @tab 次のコメントが終わる場所に移動する。
@item |@ref{[#}| @tab 前の閉じられていない #if, #ifdef, #else に移動する。
@item |@ref{]#}| @tab 次の閉じられていない #else, #endif に移動する。
@item |@ref{[(}| @tab 前の閉じられていない '(' に移動する。
@item |@ref{])}| @tab 次の閉じられていない ')' に移動する。
@item |@ref{[@{}| @tab 前の閉じられていない '@{' に移動する。
@item |@ref{]@}}| @tab 次の閉じられていない '@}' に移動する。
@item
@item |@ref{v_ab}| @tab 「ブロック("[("から"])"まで)」を括弧を含めて選択する。
@item |@ref{v_ib}| @tab 「ブロック("[("から"])"まで)の内部」を選択する。
@item |@ref{v_aB}| @tab 「ブロック("[@{"から"]@}"まで)」を括弧を含めて選択する。
@item |@ref{v_iB}| @tab 「ブロック("[@{"から"]@}"まで)の内部」を選択する。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Finding where identifiers are used			*ident-search*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ident-search}
@cindex ident-search
@cindex 識別子が使われている場所を検索する
@section 識別子が使われている場所を検索する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You probably already know that |tags| can be used to jump to the place where a
function or variable is defined.  But sometimes you wish you could jump to all
the places where a function or variable is being used.  This is possible in
two ways:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{tags}| が関数や変数の定義された場所へのジャンプに使えることはすでにわかりましたが、ときどき関数や変数が使われている場所にジャンプしたいことがあります。これは 2 つの方法で実現することができます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
1. Using the |:grep| command.  This should work on most Unix systems,
   but can be slow (it reads all files) and only searches in one directory.
2. Using ID utils.  This is fast and works in multiple directories.  It uses a
   database to store locations.  You will need some additional programs for
   this to work.  And you need to keep the database up to date.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item
|@ref{:grep}| を使う方法。この方法はほとんどの Unix システムでうまく動作しますが遅いですし (全てのファイルを読むため)、1 つのディレクトリの中だけしか検索できません。
@item
ID ユーティリティを使う方法。この方法は速いですし複数のディレクトリを検索できます。この方法は位置を記憶するためにデータベースを使用します。いくつかのプログラムを新たに入れる必要があります。そして、データベースを最新に保つことが要求されます。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Using the GNU id-tools:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec GNU id-tools と Vim を連動させる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
What you need:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
必要なもの:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The GNU id-tools installed (mkid is needed to create ID and lid is needed to
  use the macros).
- An identifier database file called "ID" in the current directory.  You can
  create it with the shell command "mkid file1 file2 ..".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item The GNU id-tools がインストールされていること (ID を生成するには mkid が必要でマクロを使うのにlidが必要です)。
@item 現在のディレクトリに "ID" と呼ばれる識別子データベースファイルがあること。シェルコマンド "mkid file1 file2 .." で作成可能です。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Put this in your .vimrc: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次の行を @file{.vimrc} に追加してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	map _u :call ID_search()<Bar>execute "/\\<" . g:word . "\\>"<CR>
	map _n :n<Bar>execute "/\\<" . g:word . "\\>"<CR>

	function! ID_search()
	  let g:word = expand("<cword>")
	  let x = system("lid --key=none ". g:word)
	  let x = substitute(x, "\n", " ", "g")
	  execute "next " . x
	endfun
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
map _u :call ID_search()<Bar>execute "/\\<" . g:word . "\\>"<CR>
map _n :n<Bar>execute "/\\<" . g:word . "\\>"<CR>

function! ID_search()
  let g:word = expand("<cword>")
  let x = system("lid --key=none ". g:word)
  let x = substitute(x, "\n", " ", "g")
  execute "next " . x
endfun
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To use it, place the cursor on a word, type "_u" and vim will load the file
that contains the word.  Search for the next occurrence of the word in the
same file with "n".  Go to the next file with "_n".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これを使うには、単語上にカーソルを置いて、"_u" とタイプすれば Vim は単語を含んだファイルを読みこみます。同じファイルで次に単語が出てくるところを検索するには "n" をタイプします。"_n" で次のファイルに行きます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This has been tested with id-utils-3.2 (which is the name of the id-tools
archive file on your closest gnu-ftp-mirror).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この方法は id-utils-3.2 を使って動作を確認しました (id-utlis-3.2 は id-tools アーカイブの名前です。近くの gnu-ftp-mirror から入手してください。)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
[the idea for this comes from Andreas Kutschera]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[このアイデアは Andreas Kutschera さんから頂いたものです]
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Switching screens in an xterm		*xterm-screens* *xterm-save-screen*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{xterm-screens}
@anchor{xterm-save-screen}
@cindex xterm-screens
@cindex xterm-save-screen
@cindex xterm でのスクリーンの切り替え
@section xterm でのスクリーンの切り替え
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
(From comp.editors, by Juergen Weigert, in reply to a question)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
(comp.editors で質問に答えて Juergen Weigert 氏が投稿したもの)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:> Another question is that after exiting vim, the screen is left as it
:> was, i.e. the contents of the file I was viewing (editing) was left on
:> the screen. The output from my previous like "ls" were lost,
:> ie. no longer in the scrolling buffer. I know that there is a way to
:> restore the screen after exiting vim or other vi like editors,
:> I just don't know how. Helps are appreciated. Thanks.
:
:I imagine someone else can answer this.  I assume though that vim and vi do
:the same thing as each other for a given xterm setup.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
:> もう 1 つの質問は Vim を終了させた後にスクリーンがそのまま残っていることに関してです。例えばいままで見ていた (編集していた) 内容がスクリーンに残っていますよね。そして前に行った ls などのコマンドの出力が消えてしまうのです(例えばスクロールバッファからなくなってしまう)。Vim や他の vi 風のエディタでもどうにかして前の画面を復元する方法があるとは思うのですが、どのようにすれば実現できるのかわかりません。教えていただけると嬉しいです。それでは。

:どなたか詳しい方が答えて下さると思います。Vim も vi も xterm の設定をみて同じことをそれぞれやっていると思うのですが。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
They not necessarily do the same thing, as this may be a termcap vs.
terminfo problem.  You should be aware that there are two databases for
describing attributes of a particular type of terminal: termcap and
terminfo.  This can cause differences when the entries differ AND when of
the programs in question one uses terminfo and the other uses termcap
(also see |+terminfo|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらは必ずしも同じ動作をするとは限りません、というのはこれは termcap と terminfo の問題であるかもしれないからです。個々のタイプのターミナルの属性を記述するデータベースには termcap と terminfo という 2 つのデータベースがあるということを知っておいてください。エントリが異なっていて、かつ質問にあったプログラムのどれかが termcap を使っていて他のものが terminfo を使っていた場合、違う動作をすることになりえます。

(|@ref{+terminfo}| も参照してください)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In your particular problem, you are looking for the control sequences
^[[?47h and ^[[?47l.  These switch between xterms alternate and main screen
buffer.  As a quick workaround a command sequence like >
	echo -n "^[[?47h"; vim ... ; echo -n "^[[?47l"
may do what you want.  (My notation ^[ means the ESC character, further down
you'll see that the databases use \E instead).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この問題の場合、^[[?47h と ^[[?47l というコントロールシーケンスが答えになります。これらは xterm のメインスクリーンバッファともう一方のバッファを切り替えるのに用いられます。簡単に動作させてみるには次のコマンドを打ってみてください。
@verbatim
echo -n "^[[?47h"; vim ... ; echo -n "^[[?47l"
@end verbatim
あなたが望む動作はこれかもしれません。(ここで ^[ は ESC キャラクターを意味します。このあとデータベースではこの記号の代わりに \E を使っていることがわかるでしょう)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
On startup, vim echoes the value of the termcap variable ti (terminfo:
smcup) to the terminal.  When exiting, it echoes te (terminfo: rmcup).  Thus
these two variables are the correct place where the above mentioned control
sequences should go.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
起動時に vim は termcap の ti 変数 (terminfo の場合: smcup) の値を echo し、終了時には te 変数 (terminfo の場合: rmcup) の値をターミナルに echo します。というわけで、これらの 2 つの変数が上記のコントロールシーケンスを設定する正しい場所です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Compare your xterm termcap entry (found in /etc/termcap) with your xterm
terminfo entry (retrieved with "infocmp -C xterm").  Both should contain
entries similar to: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
xterm の termcap エントリ (/etc/termcap にあります) と xterm の terminfo エントリ (infocmp -C xterm として入手します) とを比べてみてください。双方に次のようなエントリが含まれている必要があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:te=\E[2J\E[?47l\E8:ti=\E7\E[?47h:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:te=\E[2J\E[?47l\E8:ti=\E7\E[?47h:
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
PS: If you find any difference, someone (your sysadmin?) should better check
    the complete termcap and terminfo database for consistency.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{追伸:} @* もしなんらかの違いを見つけた場合、だれかが (システム管理者かな？) termcap と terminfo データベースを継続的にチェックするようにした方がよいです。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
NOTE 1: If you recompile Vim with FEAT_XTERM_SAVE defined in feature.h, the
builtin xterm will include the mentioned "te" and "ti" entries.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note1:} @*
feature.h で定義される FEAT_XTERM_SAVE をつけて Vim を再コンパイルすると内蔵の xterm は上記の "te" と "ti" エントリを含むようになります。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
NOTE 2: If you want to disable the screen switching, and you don't want to
change your termcap, you can add these lines to your .vimrc: >
	:set t_ti= t_te=
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note2:} @*
スクリーンのスイッチを行わないようにし、termcap の変更も行いたくない場合次の行を .vimrc に加えてください。
@verbatim
:set t_ti= t_te=
@end verbatim
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Scrolling in Insert mode				*scroll-insert*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{scroll-insert}
@cindex scroll-insert
@cindex 挿入モードでスクロールを行う
@section 挿入モードでスクロールを行う
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you are in insert mode and you want to see something that is just off the
screen, you can use CTRL-X CTRL-E and CTRL-X CTRL-Y to scroll the screen.
						|i_CTRL-X_CTRL-E|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
挿入モードでスクリーンの外の部分を見たい場合、@kbd{CTRL-X} @kbd{CTRL-E} と @kbd{CTRL-X} @kbd{CTRL-Y} を使うことでスクリーンをスクロールさせることができます。|@ref{i_CTRL-X_CTRL-E}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To make this easier, you could use these mappings: >
	:inoremap <C-E> <C-X><C-E>
	:inoremap <C-Y> <C-X><C-Y>
(Type this literally, make sure the '<' flag is not in 'cpoptions').
You then lose the ability to copy text from the line above/below the cursor
|i_CTRL-E|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これを簡単に行うには次のマッピングをすることができます:
@verbatim
:inoremap <C-E> <C-X><C-E>
:inoremap <C-Y> <C-X><C-Y>
@end verbatim
(文字通り入力するには、'@var{<}' フラグが '@option{cpoptions}' にないことを確認してください) しかしこれを行うとカーソルの上/下の行のテキストをコピーする機能が使えなくなります。|@ref{i_CTRL-E}|.
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Also consider setting 'scrolloff' to a larger value, so that you can always see
some context around the cursor.  If 'scrolloff' is bigger than half the window
height, the cursor will always be in the middle and the text is scrolled when
the cursor is moved up/down.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カーソルの周りの前後を常に見渡せるように '@option{scrolloff}' オプションの値を大きい値に設定するのもよいです。'@option{scrolloff}' の値がウィンドウの高さの半分以上に設定されているとカーソルが常にスクリーンの中央にあることになりテキストはカーソルの上下移動にあわせてスクロールすることになります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Smooth scrolling					*scroll-smooth*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{scroll-smooth}
@cindex scroll-smooth
@cindex スムーズにスクロールさせる
@section スムーズにスクロールさせる
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you like the scrolling to go a bit smoother, you can use these mappings: >
	:map <C-U> <C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y>
	:map <C-D> <C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もう少しスムーズにスクロールさせたい場合、次のマッピングを使うこともできます:
@verbatim
:map <C-U> <C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y>
:map <C-D> <C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E>
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
(Type this literally, make sure the '<' flag is not in 'cpoptions').
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
(文字通り入力するには、'@var{<}' フラグが '@option{cpoptions}' にないことを確認してください)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Correcting common typing mistakes			*type-mistakes*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{type-mistakes}
@cindex type-mistakes
@cindex ありがちなタイプミスを修正する
@section ありがちなタイプミスを修正する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When there are a few words that you keep on typing in the wrong way, make
abbreviations that correct them.  For example: >
	:ab teh the
	:ab fro for
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
しょっちゅう間違ってタイプする単語がいくつかあれば、短縮入力を修正するのに利用しましょう。例えば:
@verbatim
:ab teh the
:ab fro for
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Counting words, lines, etc.				*count-items*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{count-items}
@cindex count-items
@cindex 単語や行などの数を数える
@section 単語や行などの数を数える
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To count how often any pattern occurs in the current buffer use the substitute
command and add the 'n' flag to avoid the substitution.  The reported number
of substitutions is the number of items.  Examples: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カレントバッファの中になんらかのパターンがどのくらいの回数現れるのかを数えるには、@command{substitute} コマンドを使い、実際に置換するのを避けるためにフラグ '@var{n}' をつけます。報告される数がそのアイテムの数です。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:%s/./&/gn		characters
	:%s/\i\+/&/gn		words
	:%s/^//n		lines
	:%s/the/&/gn		"the" anywhere
	:%s/\<the\>/&/gn	"the" as a word
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .5 .5
@item :%s/./&/gn @tab 文字
@item :%s/\i\+/&/gn @tab 単語
@item :%s/^//n @tab 行
@item :%s/the/&/gn @tab "the" (どこかしら)
@item :%s/\<the\>/&/gn @tab "the" (単語一致)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You might want to reset 'hlsearch' or do ":nohlsearch".
Add the 'e' flag if you don't want an error when there are no matches.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'hlsearch' をリセットするか、":nohlsearch" をしたくなるかもしれません。マッチが1個もないときにエラーになってほしくなければフラグ 'e' をつけます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An alternative is using |v_g_CTRL-G| in Visual mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
別の方法としては、ビジュアルモードで |@ref{v_g_CTRL-G}| を使います。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to find matches in multiple files use |:vimgrep|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
複数のファイルから検索したければ |@ref{:vimgrep}| を使います。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*count-bytes*
If you want to count bytes, you can use this:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{count-bytes}
@cindex count-bytes
@cindex バイト数を数える
バイト数を数えるにはこれを使ってください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Visually select the characters (block is also possible)
	Use "y" to yank the characters
	Use the strlen() function: >
		:echo strlen(@")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列を選択してください (ブロック選択も使えます) @*
"y" でコピーしてください @*
そして、strlen() を使います @*
@verbatim
:echo strlen(@")
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
A line break is counted for one byte.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
改行は 1 バイトとして数えられます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Restoring the cursor position				*restore-position*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{restore-position}
@cindex restore-position
@cindex カーソルの位置を戻す
@section カーソルの位置を戻す
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Sometimes you want to write a mapping that makes a change somewhere in the
file and restores the cursor position, without scrolling the text.  For
example, to change the date mark in a file: >
   :map <F2> msHmtgg/Last [cC]hange:\s*/e+1<CR>"_D"=strftime("%Y %b %d")<CR>p'tzt`s
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ときにはファイルのどこかに変更を加えて、テキストをスクロールすることなくカーソルを元の位置に戻すようなマッピングを書きたくなることがあります。ファイルに書いた日付を変更する例をあげます:
@verbatim
:map <F2> msHmtgg/Last [cC]hange:\s*/e+1<CR>"_D"=strftime("%Y %b %d")<CR>p'tzt`s
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Breaking up saving the position:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
位置を記憶する:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	ms	store cursor position in the 's' mark
	H	go to the first line in the window
	mt	store this position in the 't' mark
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item ms @tab 's' マークにカーソルの位置を記録します
@item H @tab ウィンドウに表示された最初の行に移動します
@item mt @tab その行を 't' マークに記録します
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Breaking up restoring the position:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
位置を元に戻す:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	't	go to the line previously at the top of the window
	zt	scroll to move this line to the top of the window
	`s	jump to the original position of the cursor
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .2 .8
@item 't @tab 先程のウィンドウに表示された最初の行に移動します
@item zt @tab その行がウィンドウの最初に表示されるようにスクロールします
@item `s @tab 最初の位置に戻ります
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For something more advanced see |winsaveview()| and |winrestview()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
より高度なことについては |@ref{winsaveview()}| と |@ref{winrestview()}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Renaming files						*rename-files*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{rename-files}
@cindex rename-files
@cindex ファイルをリネームする
@section ファイルをリネームする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Say I have a directory with the following files in them (directory picked at
random :-):
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば以下のようなファイルを含むディレクトリがあるとします(ディレクトリはランダムに選び出したものです :-):
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
buffer.c
charset.c
digraph.c
...
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
 buffer.c
 charset.c
 digraph.c
 ...
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
and I want to rename *.c *.bla.  I'd do it like this: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
そして *.c を *.bla にリネームしたい場合次のようなコマンドを実行します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	$ vim
	:r !ls *.c
	:%s/\(.*\).c/mv & \1.bla
	:w !sh
	:q!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
$ vim
:r !ls *.c
:%s/\(.*\).c/mv & \1.bla
:w !sh
:q!
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Change a name in multiple files				*change-name*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{change-name}
@cindex change-name
@cindex 複数ファイル中の名前を置換する
@section 複数ファイル中の名前を置換する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Example for using a script file to change a name in several files:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
スクリプトファイルを使って複数ファイル中の名前を置換する例です:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	Create a file "subs.vim" containing substitute commands and a :update
	command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下のように置換コマンドと @command{:update} コマンドを含む "@file{subs.vim}" というファイルを作成します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		:%s/Jones/Smith/g
		:%s/Allen/Peter/g
		:update
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:%s/Jones/Smith/g
:%s/Allen/Peter/g
:update
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	Execute Vim on all files you want to change, and source the script for
	each argument: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim で置換したい全ファイルを開き、各引数に対してこのスクリプトを実行します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		vim *.let
		argdo source subs.vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
vim *.let
argdo source subs.vim
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
See |:argdo|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:argdo}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Speeding up external commands				*speed-up*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{speed-up}
@cindex speed-up
@cindex 外部コマンドの実行速度を速くする
@section 外部コマンドの実行速度を速くする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In some situations, execution of an external command can be very slow.  This
can also slow down wildcard expansion on Unix.  Here are a few suggestions to
increase the speed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
いくつかの状況では外部コマンドの実行速度が非常に遅くなる場合があります。これは Unix でのワイルドカード展開が行われた場合もそうです。いくつかのスピードアップする方法を紹介しましょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If your .cshrc (or other file, depending on the shell used) is very long, you
should separate it into a section for interactive use and a section for
non-interactive use (often called secondary shells).  When you execute a
command from Vim like ":!ls", you do not need the interactive things (for
example, setting the prompt).  Put the stuff that is not needed after these
lines: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もし @file{.cshrc} (もしくは他のファイル、使っているシェルによります) が非常に長いならばそれを対話的に使う部分とそうでない用途 (セカンダリーシェルとよく呼ばれます) の部分にわけるべきです。Vim から ":!ls" のようなコマンドを実行する場合、対話的に行う必要はありませんよね (例えば、プロンプトを出させたり)。次の行の後にそれらをおくようにしてください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	if ($?prompt == 0) then
		exit 0
	endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
if ($?prompt == 0) then
    exit 0
endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Another way is to include the "-f" flag in the 'shell' option, e.g.: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もう 1 つの方法は '@option{shell}' オプションに "@var{-f}" フラグをつける方法です、例えば:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:set shell=csh\ -f
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:set shell=csh\ -f
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
(the backslash is needed to include the space in the option).
This will make csh completely skip the use of the .cshrc file.  This may cause
some things to stop working though.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
(オプションの中にスペースを含めるにはバックスラッシュが必要です)

こうすると csh が @file{.cshrc} ファイルを読み込まないようにすることができます。しかしこうすることでなんらかが動作しない場合もあるかもしれません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Useful mappings						*useful-mappings*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{useful-mappings}
@cindex useful-mappings
@cindex 便利なマッピング
@section 便利なマッピング
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here are a few mappings that some people like to use.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ここでいくつか好んで使われるマッピングを紹介します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*map-backtick*  >
	:map ' `
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{map-backtick}
@cindex map-backtick
@verbatim
:map ' `
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Make the single quote work like a backtick.  Puts the cursor on the column of
a mark, instead of going to the first non-blank character in the line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シングル引用符の動作をバック引用符の動作のようにします。カーソルをマークがある行の最初の非空白文字に移動させるのではなく、マークがある桁位置に移動させます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*emacs-keys*
For Emacs-style editing on the command-line: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{emacs-keys}
@cindex emacs-keys
@cindex Emacs スタイルキーバインド
コマンドラインでのキーバインドを Emacs スタイルにします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	" start of line
	:cnoremap <C-A>		<Home>
	" back one character
	:cnoremap <C-B>		<Left>
	" delete character under cursor
	:cnoremap <C-D>		<Del>
	" end of line
	:cnoremap <C-E>		<End>
	" forward one character
	:cnoremap <C-F>		<Right>
	" recall newer command-line
	:cnoremap <C-N>		<Down>
	" recall previous (older) command-line
	:cnoremap <C-P>		<Up>
	" back one word
	:cnoremap <Esc><C-B>	<S-Left>
	" forward one word
	:cnoremap <Esc><C-F>	<S-Right>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
" 行頭へ移動
:cnoremap <C-A>     <Home>
" 一文字戻る
:cnoremap <C-B>     <Left>
" カーソルの下の文字を削除
:cnoremap <C-D>     <Del>
" 行末へ移動
:cnoremap <C-E>     <End>
" 一文字進む
:cnoremap <C-F>     <Right>
" コマンドライン履歴を 1 つ進む
:cnoremap <C-N>     <Down>
" コマンドライン履歴を 1 つ戻る
:cnoremap <C-P>     <Up>
" 前の単語へ移動
:cnoremap <Esc><C-B>    <S-Left>
" 次の単語へ移動
:cnoremap <Esc><C-F>    <S-Right>
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
NOTE: This requires that the '<' flag is excluded from 'cpoptions'. |<>|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
これを利用するには '@option{cpoptions}' から '@var{<}' フラグを外しておく必要があります。|@ref{<>}|
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*format-bullet-list*
This mapping will format any bullet list.  It requires that there is an empty
line above and below each list entry.  The expression commands are used to
be able to give comments to the parts of the mapping. >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{format-bullet-list}
@cindex format-bullet-list
このマッピングはブレットリストのフォーマットを整えるものです。それぞれのリストのエントリの前後に空行がある必要があります。式が使われているのはマッピングを部分的に解説するコメントを入れるためです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	:let m =     ":map _f  :set ai<CR>"    " need 'autoindent' set
	:let m = m . "{O<Esc>"		      " add empty line above item
	:let m = m . "}{)^W"		      " move to text after bullet
	:let m = m . "i     <CR>     <Esc>"    " add space for indent
	:let m = m . "gq}"		      " format text after the bullet
	:let m = m . "{dd"		      " remove the empty line
	:let m = m . "5lDJ"		      " put text after bullet
	:execute m			      |" define the mapping
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:let m =     ":map _f  :set ai<CR>"   " 'autoindent' をセット
:let m = m . "{O<Esc>"                " アイテムの上に空行を挿入
:let m = m . "}{)^W"                  " ブレットの後のテキストに移動
:let m = m . "i    <CR>     <Esc>"    " インデントの為のスペースを挿入
:let m = m . "gq}"                    " ブレットの後のテキストを整形
:let m = m . "{dd"                    " 空行を削除
:let m = m . "5lDJ"                   " ブレットの後にテキストを置く
:execute m                           |" マッピングを決定する
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
(<> notation |<>|.  Note that this is all typed literally.  ^W is "^" "W", not
CTRL-W.  You can copy/paste this into Vim if '<' is not included in
'cpoptions'.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
(<> 表記法 |@ref{<>}|。これらは文字どおりにタイプするということに注意してください。^W は "^" "W" で CTRL-W ではありません。'@option{cpoptions}' に '@var{<}' がなければ Vim にコピー/ペーストすることができますよ。)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that the last comment starts with |", because the ":execute" command
doesn't accept a comment directly.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最後のコメントは |" で始まっていることに注意してください、これは "@command{:execute}" コマンドが直接のコメントを受け付けないからです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You also need to set 'textwidth' to a non-zero value, e.g., >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
また '@option{textwidth}' を 0 以外の値にしておく必要があります。例えば:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:set tw=70
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:set tw=70
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A mapping that does about the same, but takes the indent for the list from the
first line (Note: this mapping is a single long line with a lot of spaces): >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
最初の行からインデントすることになりますが次のようなマッピングでも同じことができます (@strong{Note:} このマッピングは多くのスペースを含む長い 1 つの行です):
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:map _f :set ai<CR>}{a                                                          <Esc>WWmmkD`mi<CR><Esc>kkddpJgq}'mJO<Esc>j
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
       :map _f :set ai<CR>}{a                               <Esc>WWmmkD`mi<CR><Esc>kkddpJgq}'mJO<Esc>j
@end verbatim
@quotation
@strong{補足:} @*
「タブ幅を 8、端末の幅を 80 桁にして表示すると、:map と <Esc> の行頭が揃う」というお話しらしいけど、タブ嫌いやねん。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*collapse*
These two mappings reduce a sequence of empty (;b) or blank (;n) lines into a
single line >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{collapse}
@cindex collapse
これら 2 つのマッピングは空行 (;b) もしくは空白文字のみからなる行 (;n) の連続を 1 行にします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    :map ;b   GoZ<Esc>:g/^$/.,/./-j<CR>Gdd
    :map ;n   GoZ<Esc>:g/^[ <Tab>]*$/.,/[^ <Tab>]/-j<CR>Gdd
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:map ;b   GoZ<Esc>:g/^$/.,/./-j<CR>Gdd
:map ;n   GoZ<Esc>:g/^[ <Tab>]*$/.,/[^ <Tab>]/-j<CR>Gdd
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Compressing the help files				*gzip-helpfile*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gzip-helpfile}
@cindex gzip-helpfile
@cindex ヘルプファイルを圧縮する
@section ヘルプファイルを圧縮する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For those of you who are really short on disk space, you can compress the help
files and still be able to view them with Vim.  This makes accessing the help
files a bit slower and requires the "gzip" program.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ディスクスペースに空きがあまりない人はヘルプファイルを圧縮することができます。圧縮した後でもヘルプファイルを閲覧することはできます。ヘルプファイルへのアクセスは少し遅くなります。また "gzip" プログラムが必要です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
(1) Compress all the help files: "gzip doc/*.txt".

(2) Edit "doc/tags" and change the ".txt" to ".txt.gz": >
	:%s=\(\t.*\.txt\)\t=\1.gz\t=

(3) Add this line to your vimrc: >
	set helpfile={dirname}/help.txt.gz
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item
すべてのヘルプファイルを圧縮するには: "gzip doc/*.txt"

@item
"doc/tags" を編集して ".txt" を ".txt.gz" にします。
@verbatim
:%s=\(\t.*\.txt\)\t=\1.gz\t=
@end verbatim

@item
次の行を vimrc に追加します:
@verbatim
set helpfile={dirname}/help.txt/gz
@end verbatim
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Where {dirname} is the directory where the help files are.  The |gzip| plugin
will take care of decompressing the files.
You must make sure that $VIMRUNTIME is set to where the other Vim files are,
when they are not in the same location as the compressed "doc" directory.  See
|$VIMRUNTIME|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{dirname@} はヘルプファイルのある場所です。|@ref{gzip}| プラグインがファイルの解凍をします。それともし圧縮された "doc" ディレクトリと同じ場所に他の Vim ファイルがない場合、@env{$VIMRUNTIME} が他の Vim ファイルがある場所になるようにしておかなければなりません。|@ref{$VIMRUNTIME}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Executing shell commands in a window			*shell-window*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{shell-window}
@cindex shell-window
@cindex ウィンドウでシェルコマンドを実行する
@section ウィンドウでシェルコマンドを実行する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
See |terminal|.

Another solution is splitting your terminal screen or display window with the
"splitvt" program.  You can probably find it on some ftp server.  The person
that knows more about this is Sam Lantinga <slouken@cs.ucdavis.edu>.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{terminal}| を参照。

別の方法は、"splitvt" プログラムを使って端末のスクリーンもしくはウィンドウの表示を分割するこです。このプログラムはたぶんどこかの ftp サーバーで見つけることができると思います。このプログラムに詳しいのは Sam Lantinga <slouken@@cs.ucdavis.edu> です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Another alternative is the "window" command, found on BSD Unix systems, which
supports multiple overlapped windows.  Or the "screen" program, found at
www.uni-erlangen.de, which supports a stack of windows.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
また別の方法は "window" コマンドを利用する方法で、このコマンドは BSD Unix システムにあります。このコマンドは複数のウィンドウをオーバーラップさせることができます。それか "screen" プログラムを使うかです。これは @url{www.uni-erlangen.de} で見つけることができ、このプログラムでウィンドウの積み重ねをすることができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Hex editing					*hex-editing* *using-xxd*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hex-editing}
@anchor{using-xxd}
@cindex hex-editing
@cindex using-xxd
@cindex バイナリ編集
@section バイナリ編集
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
See section |23.4| of the user manual.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザーマニュアルの |@ref{23.4}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If one has a particular extension that one uses for binary files (such as exe,
bin, etc), you may find it helpful to automate the process with the following
bit of autocmds for your <.vimrc>.  Change that "*.bin" to whatever
comma-separated list of extension(s) you find yourself wanting to edit: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もしそのファイルがバイナリファイル特有の拡張子 (exe、bin など) をしているときは、あなたの <.vimrc> に次の自動コマンドを加えることで、変換の過程を自動化しておくこともできます。"*.bin" をあなたの編集したいファイルの拡張子の、コンマで区切られたリストに変えてください:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	" vim -b : edit binary using xxd-format!
	augroup Binary
	  au!
	  au BufReadPre  *.bin let &bin=1
	  au BufReadPost *.bin if &bin | %!xxd
	  au BufReadPost *.bin set ft=xxd | endif
	  au BufWritePre *.bin if &bin | %!xxd -r
	  au BufWritePre *.bin endif
	  au BufWritePost *.bin if &bin | %!xxd
	  au BufWritePost *.bin set nomod | endif
	augroup END
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
" vim -b : edit binary using xxd-format!
augroup Binary
  au!
  au BufReadPre  *.bin let &bin=1
  au BufReadPost *.bin if &bin | %!xxd
  au BufReadPost *.bin set ft=xxd | endif
  au BufWritePre *.bin if &bin | %!xxd -r
  au BufWritePre *.bin endif
  au BufWritePost *.bin if &bin | %!xxd
  au BufWritePost *.bin set nomod | endif
augroup END
@end verbatim

@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Using <> notation in autocommands			*autocmd-<>*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{autocmd-<>}
@cindex autocmd-<>
@cindex 自動コマンドで <> 表記を使う
@section 自動コマンドで <> 表記を使う
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The <> notation is not recognized in the argument of an :autocmd.  To avoid
having to use special characters, you could use a self-destroying mapping to
get the <> notation and then call the mapping from the autocmd.  Example:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
<> 表記は @command{:autocmd} の引数として使っても正しく解釈されません。特殊な文字を入力するのを避けるには、<> 表記をするための自己破壊的なマッピング行ってそれから自動コマンドの中でそのマッピングを呼び出すことで実現することもできます。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*map-self-destroy*  >
 " This is for automatically adding the name of the file to the menu list.
 " It uses a self-destroying mapping!
 " 1. use a line in the buffer to convert the 'dots' in the file name to \.
 " 2. store that in register '"'
 " 3. add that name to the Buffers menu list
 " WARNING: this does have some side effects, like overwriting the
 " current register contents and removing any mapping for the "i" command.
 "
 autocmd BufNewFile,BufReadPre * nmap i :nunmap i<CR>O<C-R>%<Esc>:.g/\./s/\./\\./g<CR>0"9y$u:menu Buffers.<C-R>9 :buffer <C-R>%<C-V><CR><CR>
 autocmd BufNewFile,BufReadPre * normal i
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{map-self-destroy}
@cindex map-self-destroy
@verbatim
 " この方法はファイル名を自動的にメニューリストに追加するものです。
 " 自己破壊的なマッピングを使っています！
 " 1. ファイル名に含まれる 'dots' を \. に変更するためにバッファの 1 つの行を使
 "    います。
 " 2. それをレジスタ '"' に格納します。
 " 3. その名前をバッファメニューリストに追加します。
 " 警告: この方法にはいくらか副作用があります。現在のレジスタの内容を上書きし
 " たり "i" コマンドへのマッピングをすべて削除してしまったりします。
 "
 autocmd BufNewFile,BufReadPre * nmap i :nunmap i<CR>O<C-R>%<Esc>:.g/\./s/\./\\./g<CR>0"9y$u:menu Buffers.<C-R>9 :buffer <C-R>%<C-V><CR><CR>
 autocmd BufNewFile,BufReadPre * normal i
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Another method, perhaps better, is to use the ":execute" command.  In the
string you can use the <> notation by preceding it with a backslash.  Don't
forget to double the number of existing backslashes and put a backslash before
'"'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もう 1 つのよりよい方法は "@command{:execute}" コマンドを使う方法です。文字列の中ではバックスラッシュを前置することで <> 表記が使えます。それまであったバックスラッシュは \\ という風に 2 回重ねるのを忘れないでください。また '"' の前にもバックスラッシュを前置しなければなりません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
>
  autocmd BufNewFile,BufReadPre * exe "normal O\<C-R>%\<Esc>:.g/\\./s/\\./\\\\./g\<CR>0\"9y$u:menu Buffers.\<C-R>9 :buffer \<C-R>%\<C-V>\<CR>\<CR>"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
autocmd BufNewFile,BufReadPre * exe "normal O\<C-R>%\<Esc>:.g/\\./s/\\./\\\\./g\<CR>0\"9y$u:menu Buffers.\<C-R>9 :buffer \<C-R>%\<C-V>\<CR>\<CR>"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For a real buffer menu, user functions should be used (see |:function|), but
then the <> notation isn't used, which defeats using it as an example here.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
実際のバッファメニューではユーザー定義関数を使うべきですが (|@ref{:function}| を参照)、そうすると <> 表記は使いませんので、ここでの例としてそれを使うのは不適切です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
Highlighting matching parens					*match-parens*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{match-parens}
@cindex match-parens
@cindex 対応する括弧を強調する
@section 対応する括弧を強調する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This example shows the use of a few advanced tricks:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この例はいくつかの高度なトリックを紹介しています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- using the |CursorMoved| autocommand event
- using |searchpairpos()| to find a matching paren
- using |synID()| to detect whether the cursor is in a string or comment
- using |:match| to highlight something
- using a |pattern| to match a specific position in the file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item 自動コマンドイベント |@ref{CursorMoved}| の使い方
@item |@ref{searchpairpos()}| を使って対応する括弧を見つける方法
@item |@ref{synID()}| を使ってカーソルが文字列やコメントの中にあるかを判定する方法
@item |@ref{:match}| を使って何かを強調する方法
@item |@ref{pattern}| を使ってファイルの特定の位置にマッチさせる方法
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This should be put in a Vim script file, since it uses script-local variables.
It skips matches in strings or comments, unless the cursor started in string
or comment.  This requires syntax highlighting.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはスクリプトローカル変数を使っているので、Vim script ファイル中に書かなければなりません。カーソルが文字列やコメントの中にないならば、文字列やコメントはスキップして検索します。構文強調が有効になっている必要があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A slightly more advanced version is used in the |matchparen| plugin.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これより若干高度なバージョンがプラグイン |@ref{matchparen}| の中で使われています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
>
	let s:paren_hl_on = 0
	function s:Highlight_Matching_Paren()
	  if s:paren_hl_on
	    match none
	    let s:paren_hl_on = 0
	  endif

	  let c_lnum = line('.')
	  let c_col = col('.')

	  let c = getline(c_lnum)[c_col - 1]
	  let plist = split(&matchpairs, ':\|,')
	  let i = index(plist, c)
	  if i < 0
	    return
	  endif
	  if i % 2 == 0
	    let s_flags = 'nW'
	    let c2 = plist[i + 1]
	  else
	    let s_flags = 'nbW'
	    let c2 = c
	    let c = plist[i - 1]
	  endif
	  if c == '['
	    let c = '\['
	    let c2 = '\]'
	  endif
	  let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' .
		\ '=~?	"string\\|comment"'
	  execute 'if' s_skip '| let s_skip = 0 | endif'

	  let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip)

	  if m_lnum > 0 && m_lnum >= line('w0') && m_lnum <= line('w$')
	    exe 'match Search /\(\%' . c_lnum . 'l\%' . c_col .
		  \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
	    let s:paren_hl_on = 1
	  endif
	endfunction

	autocmd CursorMoved,CursorMovedI * call s:Highlight_Matching_Paren()
	autocmd InsertEnter * match none
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
let s:paren_hl_on = 0
function s:Highlight_Matching_Paren()
  if s:paren_hl_on
    match none
    let s:paren_hl_on = 0
  endif

  let c_lnum = line('.')
  let c_col = col('.')

  let c = getline(c_lnum)[c_col - 1]
  let plist = split(&matchpairs, ':\|,')
  let i = index(plist, c)
  if i < 0
    return
  endif
  if i % 2 == 0
    let s_flags = 'nW'
    let c2 = plist[i + 1]
  else
    let s_flags = 'nbW'
    let c2 = c
    let c = plist[i - 1]
  endif
  if c == '['
    let c = '\['
    let c2 = '\]'
  endif
  let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' .
    \ '=~?  "string\\|comment"'
  execute 'if' s_skip '| let s_skip = 0 | endif'

  let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip)

  if m_lnum > 0 && m_lnum >= line('w0') && m_lnum <= line('w$')
    exe 'match Search /\(\%' . c_lnum . 'l\%' . c_col .
      \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
    let s:paren_hl_on = 1
  endif
endfunction

autocmd CursorMoved,CursorMovedI * call s:Highlight_Matching_Paren()
autocmd InsertEnter * match none
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<

 vim:tw=78:ts=8:noet:ft=help:norl:
@end ifset
