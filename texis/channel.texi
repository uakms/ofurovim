@ifset JA  @c ----------- v -----------  JA  -*- tab-width: 8 -*-
@node channel.txt, , , 目次
@unnumbered ジョブ、チャネル、プロセス間通信
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*channel.txt*      For Vim version 8.1.  Last change: 2019 Sep 11


		  VIM REFERENCE MANUAL	  by Bram Moolenaar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
*channel.txt*      For Vim バージョン 8.1.  Last change: 2019 Sep 11


		     VIMリファレンスマニュアル    by Bram Moolenaar
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
		      Inter-process communication		*channel*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{channel}
@cindex channel
プロセス間通信
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim uses channels to communicate with other processes.
A channel uses a socket or pipes.			*socket-interface*
Jobs can be used to start processes and communicate with them.
The Netbeans interface also uses a channel. |netbeans|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は別のプロセスと通信するのにチャネルを用います。

チャネルはソケットまたはパイプを用います。

@anchor{socket-interface}
@cindex socket-interface
ジョブはプロセスを開始し、プロセスと通信するために使用できます。

Netbeans インターフェイスもチャネルを使っています。|@ref{netbeans}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. Overview				|job-channel-overview|
2. Channel demo				|channel-demo|
3. Opening a channel			|channel-open|
4. Using a JSON or JS channel		|channel-use|
5. Channel commands			|channel-commands|
6. Using a RAW or NL channel		|channel-raw|
7. More channel functions		|channel-more|
8. Channel functions details		|channel-functions-details|
9. Starting a job with a channel	|job-start|
10. Starting a job without a channel	|job-start-nochannel|
11. Job functions			|job-functions-details|
12. Job options				|job-options|
13. Controlling a job			|job-control|
14. Using a prompt buffer		|prompt-buffer|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .6 .4
@item 1. 概要 @tab |@ref{job-channel-overview}|
@item 2. チャネルデモ @tab |@ref{channel-demo}|
@item 3. チャネルを開く @tab |@ref{channel-open}|
@item 4. JSON, JS チャネルを使う @tab |@ref{channel-use}|
@item 5. チャネルコマンド @tab |@ref{channel-commands}|
@item 6. RAW, NL チャネルを使う @tab |@ref{channel-raw}|
@item 7. その他のチャネル機能 @tab |@ref{channel-more}|
@item 8. チャネル関数の詳細 @tab |@ref{channel-functions-details}|
@item 9. チャネルでジョブを開始する @tab |@ref{job-start}|
@item 10. チャネルなしでジョブを開始する @tab |@ref{job-start-nochannel}|
@item 11. ジョブ関数 @tab |@ref{job-functions-details}|
@item 12. ジョブオプション @tab |@ref{job-options}|
@item 13. ジョブを制御する @tab |@ref{job-control}|
@item 14. プロンプトバッファを使う @tab |@ref{prompt-buffer}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{only when compiled with the |+channel| feature for channel stuff}
	You can check this with: `has('channel')`
{only when compiled with the |+job| feature for job stuff}
	You can check this with: `has('job')`
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{Vim が |@ref{+channel}| 機能付きでコンパイルされたときのみ有効@} @*
`@command{has('channel')}` でこれを確認できる

@{Vim が |@ref{+job}| 機能付きでコンパイルされたときのみ有効@} @*
`@command{has('job')}` でこれを確認できる
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
1. Overview						*job-channel-overview*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-channel-overview}
@cindex job-channel-overview
@section 1. 概要
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are four main types of jobs:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
主に 4 種類のジョブがあります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
1. A daemon, serving several Vim instances.
   Vim connects to it with a socket.
2. One job working with one Vim instance, asynchronously.
   Uses a socket or pipes.
3. A job performing some work for a short time, asynchronously.
   Uses a socket or pipes.
4. Running a filter, synchronously.
   Uses pipes.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item いくつかの Vim インスタンスを扱うデーモン。Vim はソケットで接続します。
@item 1 つの Vim インスタンスを 1 つのジョブが非同期に処理する。ソケットまたはパイプを使用します。
@item 短時間、非同期で仕事をするジョブ。ソケットまたはパイプを使用します。
@item フィルタを同期して実行する。パイプを使用します。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For when using sockets See |job-start|, |job-start-nochannel| and
|channel-open|.  For 2 and 3, one or more jobs using pipes, see |job-start|.
For 4 use the ":{range}!cmd" command, see |filter|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ソケットを使用する場合 |@ref{job-start}|, |@ref{job-start-nochannel}| および |@ref{channel-open}| 参照。2 と 3 の場合は、パイプを使用する 1 つ以上のジョブです (|@ref{job-start}| 参照)。

4 の場合、"@command{:@{range@}!cmd}" コマンドを使用します (|@ref{filter}| 参照)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Over the socket and pipes these protocols are available:
RAW	nothing known, Vim cannot tell where a message ends
NL	every message ends in a NL (newline) character
JSON	JSON encoding |json_encode()|
JS	JavaScript style JSON-like encoding |js_encode()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ソケットとパイプ上でこれらのプロトコルを利用できます:
@multitable @columnfractions .1 .9
@item RAW @tab 何も知られていない、Vim はメッセージの終わりを知らせない。
@item NL @tab すべてのメッセージは NL (改行) 文字で終わります。
@item JSON @tab JSON エンコーディング |@ref{json_encode()}|
@item JS @tab JavaScript スタイルの JSON 風のエンコーディング |@ref{js_encode()}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Common combination are:
- Using a job connected through pipes in NL mode.  E.g., to run a style
  checker and receive errors and warnings.
- Using a daemon, connecting over a socket in JSON mode.  E.g. to lookup
  cross-references in a database.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
共通の組み合わせ:
@itemize
@item NL モードでパイプを介して接続されたジョブを使用します。例えば、スタイルチェッカーを実行し、エラーと警告を受け取ります。
@item デーモンを使用して、JSON モードでソケットに接続します。例えば、データベース内の相互参照を参照します。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
2. Channel demo				*channel-demo* *demoserver.py*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{channel-demo}
@anchor{demoserver.py}
@cindex channel-demo
@cindex demoserver.py
@cindex チャネルデモ
@section 2. チャネルデモ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This requires Python.  The demo program can be found in
$VIMRUNTIME/tools/demoserver.py
Run it in one terminal.  We will call this T1.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デモには Python が必要です。デモプログラムは次の場所にあります。

@env{$VIMRUNTIME}/tools/@file{demoserver.py}

それをあるターミナルで実行しましょう。そのターミナルを T1 と呼びます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Run Vim in another terminal.  Connect to the demo server with: >
	let channel = ch_open('localhost:8765')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次に別のターミナルで Vim を実行します。そして以下のコマンドでサーバーに接続します:
@verbatim
let channel = ch_open('localhost:8765')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In T1 you should see:
	=== socket opened === ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
T1 の中に次のように表示されます:
@verbatim
=== socket opened ===
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can now send a message to the server: >
	echo ch_evalexpr(channel, 'hello!')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ついにサーバーにメッセージを送信できます:
@verbatim
echo ch_evalexpr(channel, 'hello!')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The message is received in T1 and a response is sent back to Vim.
You can see the raw messages in T1.  What Vim sends is:
	[1,"hello!"] ~
And the response is:
	[1,"got it"] ~
The number will increase every time you send a message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このメッセージは T1 で受信され、Vim には応答が送り返されます。

T1 では Vim が送った生のメッセージを確認できます:
@verbatim
[1,"hello!"]
@end verbatim
そしてレスポンスはこうなります:
@verbatim
[1,"got it"]
@end verbatim
この数値はメッセージを送るたびに増加していきます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The server can send a command to Vim.  Type this on T1 (literally, including
the quotes):
	["ex","echo 'hi there'"] ~
And you should see the message in Vim. You can move the cursor a word forward:
	["normal","w"] ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
サーバーは Vim にコマンドを送信できます。T1 において、次のように正確に (引用符を含めて文字通りに) タイプしてください:
@verbatim
["ex","echo 'hi there'"]
@end verbatim
するとそのメッセージが Vim に表示されます。カーソルを 1 単語先に移動することができます:
@verbatim
["normal","w"]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To handle asynchronous communication a callback needs to be used: >
	func MyHandler(channel, msg)
	  echo "from the handler: " . a:msg
	endfunc
	call ch_sendexpr(channel, 'hello!', {'callback': "MyHandler"})
Vim will not wait for a response.  Now the server can send the response later
and MyHandler will be invoked.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
非同期通信を取り扱うためにはコールバック (以下ハンドラー) が必要です:
@verbatim
func MyHandler(channel, msg)
  echo "from the handler: " . a:msg
endfunc
call ch_sendexpr(channel, 'hello!', {'callback': "MyHandler"})
@end verbatim
Vim は応答を待つことはありません。これで、サーバーは応答を後で送信し、MyHandler が呼び出されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Instead of giving a callback with every send call, it can also be specified
when opening the channel: >
	call ch_close(channel)
	let channel = ch_open('localhost:8765', {'callback': "MyHandler"})
	call ch_sendexpr(channel, 'hello!')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
send を呼ぶたびに毎回コールバックを指定する代わりに、チャネルを開く際に指定することもできます:
@verbatim
call ch_close(channel)
let channel = ch_open('localhost:8765', {'callback': "MyHandler"})
call ch_sendexpr(channel, 'hello!')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When trying out channels it's useful to see what is going on.  You can tell
Vim to write lines in log file: >
	call ch_logfile('channellog', 'w')
See |ch_logfile()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
チャネルを試してみると、何が起こっているのかを知ることができます。あなたは Vim にログファイルに行を書くよう指示することができます:
@verbatim
call ch_logfile('channellog', 'w')
@end verbatim
|@ref{ch_logfile()}| 参照.
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
3. Opening a channel					*channel-open*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{channel-open}
@cindex channel-open
@cindex チャネルを開く
@section 3. チャネルを開く
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To open a channel: >
    let channel = ch_open({address} [, {options}])
    if ch_status(channel) == "open"
      " use the channel
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
チャネルを開くには次のようにします:
@verbatim
let channel = ch_open({address} [, {options}])
if ch_status(channel) == "open"
  " use the channel
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Use |ch_status()| to see if the channel could be opened.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{ch_status()}| を使用して、チャネルを開くことができたかどうかを確認します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{address} has the form "hostname:port".  E.g., "localhost:8765".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{address@} は "ホスト名:ポート番号" の形式です。例: "localhost:8765"
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{options} is a dictionary with optional entries:	*channel-open-options*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{channel-open-options}
@cindex channel-open-options
@{options@} はオプションのエントリを持つ辞書です:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
"mode" can be:						*channel-mode*
	"json" - Use JSON, see below; most convenient way. Default.
	"js"   - Use JS (JavaScript) encoding, more efficient than JSON.
	"nl"   - Use messages that end in a NL character
	"raw"  - Use raw messages
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{channel-mode}
@cindex channel-mode
"mode" でモード (通信フォーマット) を指定します:
@multitable @columnfractions .1 .9
@item "json" @tab JSON を使う (詳しくは下記を参照。もっとも使いやすい方法。既定)
@item "js" @tab JS (JavaScript) エンコーディングを使用し、JSON よりも効率的。
@item "nl" @tab NL 文字で終わるメッセージを使う
@item "raw" @tab raw メッセージを使う
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*channel-callback* *E921*
"callback"	A function that is called when a message is received that is
		not handled otherwise.  It gets two arguments: the channel
		and the received message. Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{channel-callback}
@anchor{E921}
@cindex channel-callback
@erindex E921
@item "callback"
メッセージ受信時に他のハンドラーで扱われない時に呼ばれます。これはチャネルのハンドルと、受信したメッセージの 2 つの引数を取ります。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	func Handle(channel, msg)
	  echo 'Received: ' . a:msg
	endfunc
	let channel = ch_open("localhost:8765", {"callback": "Handle"})
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
func Handle(channel, msg)
  echo '受信した: ' . a:msg
endfunc
let channel = ch_open("localhost:8765", {"callback": "Handle"})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When "mode" is "json" or "js" the "msg" argument is the body
		of the received message, converted to Vim types.
		When "mode" is "nl" the "msg" argument is one message,
		excluding the NL.
		When "mode" is "raw" the "msg" argument is the whole message
		as a string.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"mode" が "json", "js" の時には、"msg" 引数は受信したメッセージの本文で、Vim の型に変換されています。

"mode" が "nl" の時には、"msg" 引数は NL を除く 1 つのメッセージです。

"mode" が "raw" の時には、"msg" 引数はメッセージ全体を格納した文字列です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For all callbacks: Use |function()| to bind it to arguments
		and/or a Dictionary.  Or use the form "dict.function" to bind
		the Dictionary.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
すべてのコールバック: |@ref{function()}| を使用して、引数および/または辞書にバインドします。または、"dict.function" という形式を使用して辞書をバインドします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Callbacks are only called at a "safe" moment, usually when Vim
		is waiting for the user to type a character.  Vim does not use
		multi-threading.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コールバックは、通常、Vim がユーザーが文字を入力するのを待っているとき、「安全な」瞬間にのみ呼び出されます。Vim はマルチスレッドを使用しません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*close_cb*
"close_cb"	A function that is called when the channel gets closed, other
		than by calling ch_close().  It should be defined like this: >
	func MyCloseHandler(channel)
<		Vim will invoke callbacks that handle data before invoking
		close_cb, thus when this function is called no more data will
		be passed to the callbacks.  However, if a callback causes Vim
		to check for messages, the close_cb may be invoked while still
		in the callback.  The plugin must handle this somehow, it can
		be useful to know that no more data is coming.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{close_cb}
@cindex close_cb
@item "close_cb"
|@ref{ch_close()}| を呼び出す以外に、チャネルが閉じられたときに呼び出される関数。このように定義する必要があります:
@verbatim
func MyCloseHandler(channel)
@end verbatim                
Vim は close_cb を呼び出す前にデータを処理するコールバックを呼び出します。したがって、この関数が呼び出されると、それ以上のデータはコールバックに渡されません。ただし、コールバックにより Vim のメッセージのチェックが発生するなら、コールバック中に close_cb が呼び出されることがあります。プラグインは何とかこれを処理する必要があり、これ以上データが来ていないことを知っておくと便利です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*channel-drop*
"drop"		Specifies when to drop messages:
		    "auto"	When there is no callback to handle a message.
				The "close_cb" is also considered for this.
		    "never"	All messages will be kept.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{channel-drop}
@cindex channel-drop
@item "drop"
メッセージをいつドロップするかを指定します:
@multitable @columnfractions .1 .9
@item "auto" @tab メッセージを処理するコールバックがない場合。"close_cb" もこのために考慮されます。
@item "never" @tab すべてのメッセージが保存されます。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*channel-noblock*
"noblock"	Same effect as |job-noblock|.  Only matters for writing.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{channel-noblock}
@cindex channel-noblock
@item "noblock"
|@ref{job-noblock}| と同じ効果。書き込み時にのみ重要です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*waittime*
"waittime"	The time to wait for the connection to be made in
		milliseconds.  A negative number waits forever.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{waittime}
@cindex waittime
@item "waittime"
接続がミリ秒単位で待機する時間。負の数は永遠に待ちます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The default is zero, don't wait, which is useful if a local
		server is supposed to be running already.  On Unix Vim
		actually uses a 1 msec timeout, that is required on many
		systems.  Use a larger value for a remote server, e.g.  10
		msec at least.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デフォルトはゼロで、待機しません。これは、ローカルサーバーがすでに実行されている場合に便利です。Unix Vim では実際には 1ms のタイムアウトが使われます。多くのシステムではそれが必要なためです。リモートサーバーには大きな値を使用してください。例: 少なくとも 10msec。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*channel-timeout*
"timeout"	The time to wait for a request when blocking, E.g. when using
		ch_evalexpr().  In milliseconds.  The default is 2000 (2
		seconds).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{channel-timeout}
@cindex channel-timeout
@item "timeout"
ブロッキング時にリクエストを待つ時間。例: |@ref{ch_evalexpr()}| を使用するとき。ミリ秒単位。デフォルトは 2000 (2秒) です。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When "mode" is "json" or "js" the "callback" is optional.  When omitted it is
only possible to receive a message after sending one.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"mode" が "json" か "js" の時には "callback" はオプションです。これを省略した場合、メッセージを 1 つ受信するにはメッセージを 1 つ送信する必要があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To change the channel options after opening it use |ch_setoptions()|.  The
arguments are similar to what is passed to |ch_open()|, but "waittime" cannot
be given, since that only applies to opening the channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
チャネルオプションを開いた後に変更するには、|@ref{ch_setoptions()}| を使用します。引数は |@ref{ch_open()}| に渡されるものと似ていますが、"waittime" は与えられません。これはチャネルを開く場合にのみ適用されるためです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For example, the handler can be added or changed: >
    call ch_setoptions(channel, {'callback': callback})
When "callback" is empty (zero or an empty string) the handler is removed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えば、ハンドラーは後から追加したり、変更したりできます:
@verbatim
call ch_setoptions(channel, {'callback': callback})
@end verbatim
"callback" が空の場合 (一度も指定しないか、空文字列を指定した場合) ハンドラーは削除されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
After a callback has been invoked Vim will update the screen and put the
cursor back where it belongs.  Thus the callback should not need to do
`:redraw`.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コールバックが呼び出された後、Vim は画面を更新し、カーソルをそれが属する場所に戻します。コールバックは `@command{:redraw}` を行う必要はありません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The timeout can be changed: >
    call ch_setoptions(channel, {'timeout': msec})
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
タイムアウトは次のように変更できます:
@verbatim
call ch_setoptions(channel, {'timeout': msec})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							  *channel-close* *E906*
Once done with the channel, disconnect it like this: >
    call ch_close(channel)
When a socket is used this will close the socket for both directions.  When
pipes are used (stdin/stdout/stderr) they are all closed.  This might not be
what you want!  Stopping the job with job_stop() might be better.
All readahead is discarded, callbacks will no longer be invoked.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{channel-close}
@anchor{E906}
@cindex channel-close
@erindex E906
チャネルを使い終わったら、以下のように切断してください:
@verbatim
call ch_close(channel)
@end verbatim
ソケットが使用されていると、両方向のソケットが閉じられます。パイプが使用されていると (stdin/stdout/stderr)、それらはすべて閉じられます。これはあなたが望むものではないかもしれません! |@ref{job_stop()}| でジョブを停止する方が良いかもしれません。すべての先読みは破棄され、コールバックは呼び出されなくなります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that a channel is closed in three stages:
  - The I/O ends, log message: "Closing channel". There can still be queued
    messages to read or callbacks to invoke.
  - The readahead is cleared, log message: "Clearing channel".  Some variables
    may still reference the channel.
  - The channel is freed, log message: "Freeing channel".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
チャネルは 3 つの段階で閉じられることに注意してください:
@itemize
@item I/O が終了し、ログメッセージ: "Closing channel" が表示されます。呼び出すための読み込みまたはコールバックのキューに入れられたメッセージがまだ残っている可能性があります。
@item 先読みがクリアされ、ログメッセージ: "Clearing channel" が表示されます。変数によっては引き続きチャネルを参照することがあります。
@item チャネルが解放され、ログメッセージ： "Freeing channel" が表示されます。
@end itemize
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the channel can't be opened you will get an error message.  There is a
difference between MS-Windows and Unix: On Unix when the port doesn't exist
ch_open() fails quickly.  On MS-Windows "waittime" applies.
*E898* *E901* *E902*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E898}
@anchor{E901}
@anchor{E902}
@erindex E898
@erindex E901
@erindex E902
チャネルを開くことができない場合、エラーメッセージが表示されます。MS-Windows と Unix には違いがあります: Unix では、ポートが存在しないとき、|@ref{ch_open()}| はすぐに失敗します。MS-Windows では "waittime" が適用されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If there is an error reading or writing a channel it will be closed.
*E630* *E631* 
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E630}
@anchor{E631}
@erindex E630
@erindex E631
チャネルを読み書きする際にエラーが発生した場合、チャネルは閉じられます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
4. Using a JSON or JS channel					*channel-use*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{channel-use}
@cindex channel-use
@cindex JSON, JS チャネルを使う
@section 4. JSON、JS チャネルを使う
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If mode is JSON then a message can be sent synchronously like this: >
    let response = ch_evalexpr(channel, {expr})
This awaits a response from the other side.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"mode" が JSON の場合は、以下のようにメッセージを同期的に送信できます:
@verbatim
let response = ch_evalexpr(channel, {expr})
@end verbatim
これは通信相手から応答があるまで待ち合わせます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When mode is JS this works the same, except that the messages use
JavaScript encoding.  See |js_encode()| for the difference.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
mode が JS の場合は、メッセージが JavaScript エンコーディングを使用する点を除いて、これは同じです。その違いについては、|@ref{js_encode()}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To send a message, without handling a response or letting the channel callback
handle the response: >
    call ch_sendexpr(channel, {expr})
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
応答を処理せずにメッセージを送信する、またはチャネルコールバックに応答を処理させるには:
@verbatim
call ch_sendexpr(channel, {expr})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To send a message and letting the response handled by a specific function,
asynchronously: >
    call ch_sendexpr(channel, {expr}, {'callback': Handler})
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
メッセージを送信し、応答を特別な関数で非同期的に処理する場合には、このようにします:
@verbatim
call ch_sendexpr(channel, {expr}, {'callback': Handler})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim will match the response with the request using the message ID.  Once the
response is received the callback will be invoked.  Further responses with the
same ID will be ignored.  If your server sends back multiple responses you
need to send them with ID zero, they will be passed to the channel callback.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は、メッセージ ID を使用して要求との応答を照合します。応答が受信されると、コールバックが呼び出されます。同じ ID を持つさらなる応答は無視されます。あなたのサーバーが複数の応答を返信する場合、ID ゼロで送信する必要があります。それらはチャネルコールバックに渡されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The {expr} is converted to JSON and wrapped in an array.  An example of the
message that the receiver will get when {expr} is the string "hello":
	[12,"hello"] ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{expr@} は JSON に変換され、配列で包まれます。@{expr@} として文字列 "hello" を送信した場合に、通信相手が受け取るメッセージの例は次のようになります:
@verbatim
[12,"hello"]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The format of the JSON sent is:
    [{number},{expr}]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
送信される JSON のフォーマットはこのようになっています:
@verbatim
[{number},{expr}]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In which {number} is different every time.  It must be used in the response
(if any):

    [{number},{response}]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{number@} には毎回異なる値が入ります。これは応答があるならば、必ず使われます:
@verbatim
[{number},{response}]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This way Vim knows which sent message matches with which received message and
can call the right handler.  Also when the messages arrive out of order.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このようにして、受信したメッセージがどの送信メッセージに対応するかを知ることができ、正しいハンドラーを呼び出すことができます。これによって応答メッセージの到着順序を気にしなくても良くなります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A newline character is terminating the JSON text.  This can be used to
separate the read text.  For example, in Python:
	splitidx = read_text.find('\n')
	message = read_text[:splitidx]
	rest = read_text[splitidx + 1:]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
改行文字が JSON テキストを終了しています。これは、読み込まれたテキストを区切るために使用できます。例えば Python では:
@verbatim
splitidx = read_text.find('\n')
message = read_text[:splitidx]
rest = read_text[splitidx + 1:]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The sender must always send valid JSON to Vim.  Vim can check for the end of
the message by parsing the JSON.  It will only accept the message if the end
was received.  A newline after the message is optional.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
送信側はかならず有効な JSON を Vim へ送らなければなりません。Vim は JSON として解釈することで、受信メッセージの終端をチェックします。終端を受信することが、メッセージを受理する唯一の方法です。メッセージ最後の改行はオプションです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the process wants to send a message to Vim without first receiving a
message, it must use the number zero:
    [0,{response}]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
サーバープロセスが Vim からのメッセージを受信すること無く、メッセージを送信するには、数値に 0 を使う必要があります。
@verbatim
[0,{response}]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Then channel handler will then get {response} converted to Vim types.  If the
channel does not have a handler the message is dropped.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
するとチャネルのハンドラーが @{response@} を Vim の方に変換したものを受け取るでしょう。チャネルにハンドラーが関連付けられていない場合には、メッセージは破棄されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It is also possible to use ch_sendraw() and ch_evalraw() on a JSON or JS
channel.  The caller is then completely responsible for correct encoding and
decoding.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
JSON または JS チャネルで |@ref{ch_sendraw()}| および |@ref{ch_evalraw()}| を使用することもできます。その場合呼び出し元は、正しくエンコードとデコードを行う完全な責任があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
5. Channel commands					*channel-commands*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{channel-commands}
@cindex channel-commands
@cindex チャネルコマンド
@section 5. チャネルコマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
With a JSON channel the process can send commands to Vim that will be
handled by Vim internally, it does not require a handler for the channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
JSON チャネルを使用すると、サーバープロセス側は Vim へコマンドを送信できます。そのコマンドはチャネルのハンドラーを介さずに、Vim の内部で実行されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Possible commands are:				*E903* *E904* *E905*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E903}
@anchor{E904}
@anchor{E905}
@erindex E903
@erindex E904
@erindex E905
実行可能なコマンドは以下のとおりです:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    ["redraw", {forced}]
    ["ex",     {Ex command}]
    ["normal", {Normal mode command}]
    ["expr",   {expression}, {number}]
    ["expr",   {expression}]
    ["call",   {func name}, {argument list}, {number}]
    ["call",   {func name}, {argument list}]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .9
@item ["redraw", @{forced@}]
@item ["ex",     @{Ex コマンド@}]
@item ["normal", @{ノーマルモードコマンド@}]
@item ["eval",   @{式@}, @{数値@}]
@item ["expr",   @{式@}]
@item ["call",   @{関数名@}, @{引数リスト@}, @{数値@}]
@item ["call",   @{関数名@}, @{引数リスト@}]
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
With all of these: Be careful what these commands do!  You can easily
interfere with what the user is doing.  To avoid trouble use |mode()| to check
that the editor is in the expected state.  E.g., to send keys that must be
inserted as text, not executed as a command:
    ["ex","if mode() == 'i' | call feedkeys('ClassName') | endif"] ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらを使うときは、これらのコマンドが何をするかに十分気をつけてください！ユーザーが何をしているかによっては容易に干渉してしまいます。トラブルを避けるには |@ref{mode()}| を使い、エディタが期待した状態にあるかチェックしてください。例えば、コマンド実行ではなくテキストとして入力させたい文字列を送るには、以下のようにします:
@verbatim
["ex","if mode() == 'i' | call feedkeys('ClassName') | endif"]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Errors in these commands are normally not reported to avoid them messing up
the display.  If you do want to see them, set the 'verbose' option to 3 or
higher.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのコマンドのエラーは、表示が乱れないようにするため、通常は報告されません。表示したい場合は、'@option{verbose}' オプションを 3 以上に設定してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Command "redraw" ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex コマンド "redraw"
@unnumberedsubsec コマンド "redraw"
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The other commands do not explicitly update the screen, so that you can send a
sequence of commands without the cursor moving around.  A redraw can happen as
a side effect of some commands.  You must end with the "redraw" command to
show any changed text and show the cursor where it belongs.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
他のコマンドは明示的に画面を更新しないので、カーソルを動かさずに一連のコマンドを送ることができます。再描画は他のコマンドの副作用として発生することがあります。変更されたテキストを表示し、それが属する場所にカーソルを表示するには、"@command{redraw}" コマンドで終了する必要があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The argument is normally an empty string:
	["redraw", ""] ~
To first clear the screen pass "force":
	["redraw", "force"] ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数は通常は空の文字列です:
@verbatim
["redraw", ""]
@end verbatim
最初に画面をクリアするには "force" を渡してください:
@verbatim
["redraw", "force"]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Command "ex" ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex コマンド "ex"
@unnumberedsubsec コマンド "ex"
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "ex" command is executed as any Ex command.  There is no response for
completion or error.  You could use functions in an |autoload| script:
	["ex","call myscript#MyFunc(arg)"]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"ex" コマンドは Ex コマンドを実行します。完了やエラーの応答はありません。|@ref{autoload}| スクリプトの中の関数を使えます:
@verbatim
["ex","call myscript#MyFunc(arg)"]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can also use "call |feedkeys()|" to insert any key sequence.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"call |@ref{feedkeys()}|" を使用してキーシーケンスを挿入することもできます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When there is an error a message is written to the channel log, if it exists,
and v:errmsg is set to the error.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
エラーが発生すると、チャネルログにメッセージが書き込まれ、存在する場合は v:errmsg にエラーが設定されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Command "normal" ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex コマンド "normal"
@unnumberedsubsec コマンド "normal"
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "normal" command is executed like with ":normal!", commands are not
mapped.  Example to open the folds under the cursor:
	["normal" "zO"]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"normal" コマンドは ":normal!" のように実行され、コマンドはマップされません。カーソルの下の折畳を開く例:
@verbatim
["normal" "zO"]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Command "expr"  with response ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex コマンド "expr" (応答あり)
@unnumberedsubsec コマンド "expr" (応答あり)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The "expr" command can be used to get the result of an expression.  For
example, to get the number of lines in the current buffer:
	["expr","line('$')", -2] ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"expr" コマンドは、式の結果を得るために使うことができます。たとえば、現在のバッファ内の行数を取得するには、次のようにします:
@verbatim
["expr","line('$')", -2]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It will send back the result of the expression:
	[-2, "last line"] ~
The format is:
	[{number}, {result}]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
式の結果を返します:
@verbatim
[-2, "last line"]
@end verbatim
形式は次のとおりです:
@verbatim
[{number}, {result}]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here {number} is the same as what was in the request.  Use a negative number
to avoid confusion with message that Vim sends.  Use a different number on
every request to be able to match the request with the response.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{number@} は、リクエストに指定したのと同じものです。Vim が送信するメッセージとの混乱を避けるには、負の数を使用します。リクエストとレスポンスを一致させるには、リクエストごとに異なる番号を使用します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{result} is the result of the evaluation and is JSON encoded.  If the
evaluation fails or the result can't be encoded in JSON it is the string
"ERROR".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{result@} は評価の結果であり、JSON エンコードされています。評価が失敗したり、結果を JSON でエンコードできない場合は、文字列 "ERROR" となります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Command "expr" without a response ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex コマンド "expr" (応答なし)
@unnumberedsubsec コマンド "expr" (応答なし)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This command is similar to "expr" above, but does not send back any response.
Example:
	["expr","setline('$', ['one', 'two', 'three'])"] ~
There is no third argument in the request.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このコマンドは上記の "expr" に近いのですが、応答を返信しません。例:
@verbatim
["expr","setline('$', ['one', 'two', 'three'])"]
@end verbatim
リクエストに第 3 引数はありません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Command "call" ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex コマンド "call"
@unnumberedsubsec コマンド "call"
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This is similar to "expr", but instead of passing the whole expression as a
string this passes the name of a function and a list of arguments.  This
avoids the conversion of the arguments to a string and escaping and
concatenating them.  Example:
	["call", "line", ["$"], -2] ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは "expr" に似ていますが、式全体を文字列として渡す代わりに、関数の名前と引数のリストを渡します。これは、引数の文字列への変換を避け、エスケープして連結します。例:
@verbatim
["call", "line", ["$"], -2]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Leave out the fourth argument if no response is to be sent:
	["call", "setline", ["$", ["one", "two", "three"]]] ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
応答が送信されない場合は、第 4 引数を省いてください:
@verbatim
["call", "setline", ["$", ["one", "two", "three"]]]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
6. Using a RAW or NL channel				*channel-raw*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{channel-raw}
@cindex channel-raw
@cindex RAW, NL チャネルを使う
@section 6. RAW、NL チャネルを使う
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If mode is RAW or NL then a message can be sent like this: >
    let response = ch_evalraw(channel, {string})
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
モードが RAW か NL の場合には、以下のようにしてメッセージを送信します:
@verbatim
let response = ch_evalraw(channel, {string})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The {string} is sent as-is.  The response will be what can be read from the
channel right away.  Since Vim doesn't know how to recognize the end of the
message you need to take care of it yourself.  The timeout applies for reading
the first byte, after that it will not wait for anything more.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{string@} はそのまま送信されます。受信した応答メッセージは直ちにチャネルから読み込み可能になります。この時、Vim にはメッセージの終了をどう判断するかがわかりませんから、あなた自身が面倒を見る必要があります。タイムアウトは、最初のバイトを読み取るために適用され、その後は何も待つことはありません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If mode is "nl" you can send a message in a similar way.  You are expected
to put in the NL after each message.  Thus you can also send several messages
ending in a NL at once.  The response will be the text up to and including the
first NL.  This can also be just the NL for an empty response.
If no NL was read before the channel timeout an empty string is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
mode が "nl" の場合、同様の方法でメッセージを送信できます。あなたは各メッセージの後に NL に入れなければなりません。したがって、一度に NL で終わる複数のメッセージを送信することもできます。応答は最初の NL までのテキストとなります。これは空のレスポンスの NL だけでもかまいません。チャネルタイムアウトの前に NL が読み取られなかった場合、空の文字列が返されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To send a message, without expecting a response: >
    call ch_sendraw(channel, {string})
The process can send back a response, the channel handler will be called with
it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
応答を必要としないメッセージを送信するには以下のようにします:
@verbatim
call ch_sendraw(channel, {string})
@end verbatim
プロセス @{訳注: サーバーのこと@} はレスポンスを返し、チャネルのハンドラーに渡されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To send a message and letting the response handled by a specific function,
asynchronously: >
    call ch_sendraw(channel, {string}, {'callback': 'MyHandler'})
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
メッセージを送信し、レスポンスを特定の関数で非同期的に取り扱うには以下のようにします:
@verbatim
call ch_sendraw(channel, {string}, {'callback': 'MyHandler'})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This {string} can also be JSON, use |json_encode()| to create it and
|json_decode()| to handle a received JSON message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この @{string@} は JSON にもできます。その場合、|@ref{json_encode()}| でそれを作成し |@ref{json_decode()}| で受信した JSON メッセージを取り扱います。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It is not possible to use |ch_evalexpr()| or |ch_sendexpr()| on a raw channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
生のチャネルで |@ref{ch_evalexpr()}| または |@ref{ch_sendexpr()}| を使用することはできません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A String in Vim cannot contain NUL bytes.  To send or receive NUL bytes read
or write from a buffer.  See |in_io-buffer| and |out_io-buffer|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim の文字列に NUL バイトを含めることはできません。NUL バイトを送受信するには、バッファから読み書きしてください。|@ref{in_io-buffer}| と |@ref{out_io-buffer}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
7. More channel functions				*channel-more*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{channel-more}
@cindex channel-more
@cindex その他のチャネル機能
@section 7. その他のチャネル機能
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To obtain the status of a channel: ch_status(channel).  The possible results
are:
	"fail"		Failed to open the channel.
	"open"		The channel can be used.
	"buffered"	The channel was closed but there is data to read.
	"closed"	The channel was closed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
チャネルのステータスを取得するには、ch_status(channel) を使用します。ありうる結果は次のとおりです:
@multitable @columnfractions .2 .8
@item "fail" @tab チャネルを開くことができませんでした。
@item "open" @tab チャネルを使用することができます。
@item "buffered" @tab チャネルは閉じられましたが読み込むデータがあります。
@item "closed" @tab チャネルが閉じられました。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To obtain the job associated with a channel: ch_getjob(channel)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
チャネルに関連付けられたジョブを取得するには: ch_getjob(channel)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To read one message from a channel: >
	let output = ch_read(channel)
This uses the channel timeout.  To read without a timeout, just get any
message that is available: >
	let output = ch_read(channel, {'timeout': 0})
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
チャネルから 1 つのメッセージを読むには:
@verbatim
let output = ch_read(channel)
@end verbatim
これは、チャネルのタイムアウトを使用します。タイムアウトなしで読むには、利用可能なメッセージを取得するだけです:
@verbatim
let output = ch_read(channel, {'timeout': 0})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
When no message was available then the result is v:none for a JSON or JS mode
channels, an empty string for a RAW or NL channel.  You can use |ch_canread()|
to check if there is something to read.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
メッセージが利用できなかった場合、結果は JSON またはJSモードのチャネルでは v:none, RAW または NL チャネルでは空の文字列です。|@ref{ch_canread()}| を使用して、何かがあるかどうかを調べることができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that when there is no callback, messages are dropped.  To avoid that add
a close callback to the channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
コールバックメッセージがない場合、メッセージは破棄されます。これを回避するには、チャネルにコールバックを追加します。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To read all output from a RAW channel that is available: >
	let output = ch_readraw(channel)
To read the error output: >
	let output = ch_readraw(channel, {"part": "err"})
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
使用可能なRAWチャネルからすべての出力を読み込むには:
@verbatim
let output = ch_readraw(channel)
@end verbatim
エラー出力を読むには:
@verbatim
let output = ch_readraw(channel, {"part": "err"})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_read() and ch_readraw() use the channel timeout.  When there is nothing to
read within that time an empty string is returned.  To specify a different
timeout in msec use the "timeout" option:
	{"timeout": 123} ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ch_read() と ch_readraw() はチャネルタイムアウトを使用します。その時間内に何も読み込めない場合、空の文字列が返されます。別のタイムアウトをミリ秒で指定するには、"timeout" オプションを使用します:
@verbatim
{"timeout": 123}
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
To read from the error output use the "part" option:
	{"part": "err"} ~
To read a message with a specific ID, on a JS or JSON channel:
	{"id": 99} ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
エラー出力から読み込むには、"part" オプションを使用します:
@verbatim
{"part": "err"}
@end verbatim
特定の ID を持つメッセージを JS または JSON チャネルで読み取るには:
@verbatim
{"id": 99}
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
When no ID is specified or the ID is -1, the first message is returned. This
overrules any callback waiting for this message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ID が指定されていないか、または ID が -1 の場合、最初のメッセージが返されます。これは、このメッセージを待っているコールバックをすべて無効にします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For a RAW channel this returns whatever is available, since Vim does not know
where a message ends.
For a NL channel this returns one message.
For a JS or JSON channel this returns one decoded message.
This includes any sequence number.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
RAW チャネルの場合、Vim はメッセージの終わりを知らないので、利用可能なものを返します。

NL チャネルの場合、これは 1 つのメッセージを返します。

JS または JSON チャネルの場合、これは 1 つのデコードされたメッセージを返します。

これには、任意のシーケンス番号が含まれます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
8. Channel functions details			*channel-functions-details*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{channel-functions-details}
@cindex channel-functions-details
@section 8. チャネル関数の詳細
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_canread({handle})						*ch_canread()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{ch_canread()}
@findex ch_canread()
@item ch_canread(@{handle@})
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Return non-zero when there is something to read from {handle}.
		{handle} can be a Channel or a Job that has a Channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{handle@} から何か読むものがあれば非ゼロを返します。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		This is useful to read from a channel at a convenient time,
		e.g. from a timer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはチャネルから、都合のよいときに読むのに便利です。例えば、タイマーから。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Note that messages are dropped when the channel does not have
		a callback.  Add a close callback to avoid that.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
チャンルがコールバックを持っていない場合、メッセージはドロップされることに注意してください。それを防ぐには close コールバックを追加してください。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetChannel()->ch_canread()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetChannel()->ch_canread()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_close({handle})						*ch_close()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_close()}
@findex ch_close()
@item ch_close(@{handle@})
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Close {handle}.  See |channel-close|.
		{handle} can be a Channel or a Job that has a Channel.
		A close callback is not invoked.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{handle@} を閉じます。|@ref{channel-close}| を参照してください。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。閉じられたコールバックは呼び出されません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetChannel()->ch_close()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetChannel()->ch_close()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_close_in({handle})						*ch_close_in()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_close_in()}
@findex ch_close_in()
@item ch_close_in(@{handle@})
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Close the "in" part of {handle}.  See |channel-close-in|.
		{handle} can be a Channel or a Job that has a Channel.
		A close callback is not invoked.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{handle@} の "入力" を閉じる。|@ref{channel-close-in}| を参照してください。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。閉じられたコールバックは呼び出されません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetChannel()->ch_close_in()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetChannel()->ch_close_in()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ch_evalexpr({handle}, {expr} [, {options}])			*ch_evalexpr()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_evalexpr()}
@findex ch_evalexpr()
ch_evalexpr(@{handle@}, @{expr@} [, @{options@}])
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Send {expr} over {handle}.  The {expr} is encoded
		according to the type of channel.  The function cannot be used
		with a raw channel.  See |channel-use|.
		{handle} can be a Channel or a Job that has a Channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{handle@} へ @{expr@} を送信します。@{expr@} はチャネル側と同じ型にエンコードされる。この関数は生のチャネルでは使用できません。|@ref{channel-use}| を参照してください。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
								*E917*
		{options} must be a Dictionary.  It must not have a "callback"
		entry.  It can have a "timeout" entry to specify the timeout
		for this specific request.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E917}
@erindex E917
@{options@} は辞書でなければなりません。また "callback" のエントリを持ってはなりません。また個別のリクエストに対して "timeout" を持つ事ができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		ch_evalexpr() waits for a response and returns the decoded
		expression.  When there is an error or timeout it returns an
		empty string.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ch_evalexpr() は応答を待ち、式をデコードした物が返されます。エラーもしくはタイムアウトの場合は空文字列を返します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Note that while waiting for the response, Vim handles other
		messages.  You need to make sure this doesn't cause trouble.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
応答を待っている間、Vim は他のメッセージを処理することに注意してください。これがトラブルを引き起こさないことを確認する必要があります。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetChannel()->ch_evalexpr(expr)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetChannel()->ch_evalexpr(expr)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ch_evalraw({handle}, {string} [, {options}])		*ch_evalraw()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_evalraw()}
@findex ch_evalraw()
@item ch_evalraw(@{handle@}, @{string@} [, @{options@}])
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Send {string} over {handle}.
		{handle} can be a Channel or a Job that has a Channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{handle@} へ @{string@} を送信します。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Works like |ch_evalexpr()|, but does not encode the request or
		decode the response.  The caller is responsible for the
		correct contents.  Also does not add a newline for a channel
		in NL mode, the caller must do that.  The NL in the response
		is removed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{ch_evalexpr()}| と同様に動作します。しかしリクエストをエンコードしたり応答をデコードしたりはしません。呼び出しは正しいコンテンツである事が保証されます。また NL モードでは改行が行われますが、ここでは改行が付与されません。NL は応答から削除されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that Vim does not know when the text received on a raw
		channel is complete, it may only return the first part and you
		need to use |ch_readraw()| to fetch the rest.
		See |channel-use|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
Vim は Raw チャネル上で受け取るテキストがいつ完了するのか分からないことに注意してください。最初の部分だけを返す可能性もあり、残りを取り出すために |@ref{ch_readraw()}| を使う必要があります。|@ref{channel-use}| を参照してください。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetChannel()->ch_evalraw(rawstring)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetChannel()->ch_evalraw(rawstring)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_getbufnr({handle}, {what})				 *ch_getbufnr()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_getbufnr()}
@findex ch_getbufnr()
@item ch_getbufnr(@{handle@}, @{what@})
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Get the buffer number that {handle} is using for {what}.
		{handle} can be a Channel or a Job that has a Channel.
		{what} can be "err" for stderr, "out" for stdout or empty for
		socket output.
		Returns -1 when there is no buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
l@{what@} に使用されている @{handle@} のバッファ番号を得ます。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。@{what@} は標準エラーのための "err"、標準出力のための "out"、もしくはソケット出力のための空文字列を指定できます。バッファが存在しない場合は -1 を返します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetChannel()->ch_getbufnr(what)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetChannel()->ch_getbufnr(what)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
ch_getjob({channel})						*ch_getjob()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_getjob()}
@findex ch_getjob()
@item ch_getjob(@{channel@})
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Get the Job associated with {channel}.
		If there is no job calling |job_status()| on the returned Job
		will result in "fail".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{channel@} に関連付けられた Job を得ます。もしジョブが無い場合、戻り値の Job で |@ref{job_status()}| を呼び出すと "fail" が返されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetChannel()->ch_getjob()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetChannel()->ch_getjob()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ch_info({handle})						*ch_info()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_info()}
@findex ch_info()
@item ch_info(@{handle@})
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Returns a Dictionary with information about {handle}.  The
		items are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{handle@} に関する情報を辞書で返します。アイテムは:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "id"		  number of the channel
		   "status"	  "open", "buffered" or "closed", like
				  ch_status()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item "id" @tab チャネル番号
@item "status" @tab ch_status() と同様に "open", "buffered" または "closed"
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When opened with ch_open():
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@strong{ch_open() で開いた場合:}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "hostname"	  the hostname of the address
		   "port"	  the port of the address
		   "sock_status"  "open" or "closed"
		   "sock_mode"	  "NL", "RAW", "JSON" or "JS"
		   "sock_io"	  "socket"
		   "sock_timeout" timeout in msec
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item "hostname" @tab アドレスのホスト名
@item "port" @tab アドレスのポート
@item "sock_status" @tab "open" または "closed"
@item "sock_mode" @tab "NL", "RAW", "JSON" または "JS"
@item "sock_io" @tab "socket"
@item "sock_timeout" @tab タイムアウト (ミリ秒)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When opened with job_start():
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@strong{job_start() で開いた場合:}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "out_status"	  "open", "buffered" or "closed"
		   "out_mode"	  "NL", "RAW", "JSON" or "JS"
		   "out_io"	  "null", "pipe", "file" or "buffer"
		   "out_timeout"  timeout in msec
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item "out_status" @tab "open", "buffered" または "closed"
@item "out_mode" @tab "NL", "RAW", "JSON" または "JS"
@item "out_io" @tab "null", "pipe", "file" または "buffer"
@item "out_timeout" @tab タイムアウト (ミリ秒)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "err_status"	  "open", "buffered" or "closed"
		   "err_mode"	  "NL", "RAW", "JSON" or "JS"
		   "err_io"	  "out", "null", "pipe", "file" or "buffer"
		   "err_timeout"  timeout in msec
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "err_status" @tab "open", "buffered" または "closed"
@item "err_mode" @tab "NL", "RAW", "JSON" または "JS"
@item "err_io" @tab "out", "null", "pipe", "file" または "buffer"
@item "err_timeout" @tab タイムアウト (ミリ秒)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "in_status"	  "open" or "closed"
		   "in_mode"	  "NL", "RAW", "JSON" or "JS"
		   "in_io"	  "null", "pipe", "file" or "buffer"
		   "in_timeout"	  timeout in msec
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "in_status" @tab "open" または "closed"
@item "in_mode" @tab "NL", "RAW", "JSON" または "JS"
@item "in_io" @tab "null", "pipe", "file" または "buffer"
@item "in_timeout" @tab タイムアウト (ミリ秒)
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetChannel()->ch_info()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetChannel()->ch_info()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ch_log({msg} [, {handle}])					*ch_log()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_log()}
@findex ch_log()
@item ch_log(@{msg@} [, @{handle@}])
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Write {msg} in the channel log file, if it was opened with
		|ch_logfile()|.
		When {handle} is passed the channel number is used for the
		message.
		{handle} can be a Channel or a Job that has a Channel.  The
		Channel must be open for the channel number to be used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{ch_logfile()}| によってログファイルが開かれている場合は、チャネルのログファイルに @{msg@} を書き込みます。@{handle@} が渡されている場合はチャネル番号がメッセージの中で使われます。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。使用されるチャネル番号のチャネルは開いていなければなりません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			'did something'->ch_log()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
'did something'->ch_log()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ch_logfile({fname} [, {mode}])					*ch_logfile()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_logfile()}
@findex ch_logfile()
@item ch_logfile(@{fname@} [, @{mode@}])
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Start logging channel activity to {fname}.
		When {fname} is an empty string: stop logging.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{fname@} へチャネルの挙動ログ出力を開始します。@{fname@} が空の場合、ロギングは停止します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {mode} is omitted or "a" append to the file.
		When {mode} is "w" start with an empty file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{mode@} が省略されるか "a" の場合、ファイルへの追加になります。@{mode@} が "w" の場合、空のファイルへで開始されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Use |ch_log()| to write log messages.  The file is flushed
		after every message, on Unix you can use "tail -f" to see what
		is going on in real time.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ログメッセージを書き込むには |@ref{ch_log()}| を使用します。UNIX で "tail -f" にてリアルタイムで何が行われているかが見える様に、ファイルはメッセージ毎にフラッシュされます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		This function is not available in the |sandbox|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この関数は |@ref{sandbox}| 内では無効です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		NOTE: the channel communication is stored in the file, be
		aware that this may contain confidential and privacy sensitive
		information, e.g. a password you type in a terminal window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
チャネルとの通信はファイルに格納されます。これには、あなたが端末ウィンドウ上でタイプしたパスワードのような、機密やプライバシーに関する情報を含むことがあることに注意してください。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			'logfile'->ch_logfile('w')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
'logfile'->ch_logfile('w')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ch_open({address} [, {options}])				*ch_open()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_open()}
@findex ch_open()
@item ch_open(@{address@} [, @{options@}])
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Open a channel to {address}.  See |channel|.
		Returns a Channel.  Use |ch_status()| to check for failure.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{address@} へのチャネルを開きます。|@ref{channel}| を参照してください。チャネルを返します。失敗をチェックするには |@ref{ch_status()}| を使用します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{address} has the form "hostname:port", e.g.,
		"localhost:8765".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{address@} は "localhost:8765" のように "ホスト名:ポート" の形式です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {options} is given it must be a |Dictionary|.
		See |channel-open-options|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{options@} が与えられる場合は辞書でなければなりません。|@ref{channel-open-options}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetAddress()->ch_open()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetAddress()->ch_open()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ch_read({handle} [, {options}])					*ch_read()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_read()}
@findex ch_read()
@item ch_read(@{handle@} [, @{options@}])
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Read from {handle} and return the received message.
		{handle} can be a Channel or a Job that has a Channel.
		For a NL channel this waits for a NL to arrive, except when
		there is nothing more to read (channel was closed).
		See |channel-more|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{handle@} から読み込みメッセージを受信します。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。NL チャネルの場合、何も読み込むものがない (チャネルが閉じられた) 場合を除いて NL を受信するまで待ちます。|@ref{channel-more}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetChannel()->ch_read()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetChannel()->ch_read()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ch_readblob({handle} [, {options}])			*ch_readblob()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_readblob()}
@findex ch_readblob()
@item ch_readblob(@{handle@} [, @{options@}])
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Like ch_read() but reads binary data and returns a |Blob|.
		See |channel-more|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ch_read() と同様に動作しますが、バイナリデータを読み込んで |@ref{Blob}| を返します。|@ref{channel-more}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetChannel()->ch_readblob()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
			GetChannel()->ch_readblob()
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ch_readraw({handle} [, {options}])			*ch_readraw()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_readraw()}
@findex ch_readraw()
@item ch_readraw(@{handle@} [, @{options@}])
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Like ch_read() but for a JS and JSON channel does not decode
		the message.  For a NL channel it does not block waiting for
		the NL to arrive, but otherwise works like ch_read().
		See |channel-more|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ch_read() と同様に動作しますが JS や JSON の場合でもメッセージはデコードされません。NL チャネルの場合、NL を受信するまで待つことはありませんが、それ以外は ch_read() と同様に動作します。|@ref{channel-more}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetChannel()->ch_readraw()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetChannel()->ch_readraw()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ch_sendexpr({handle}, {expr} [, {options}])			*ch_sendexpr()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_sendexpr()}
@findex ch_sendexpr()
@item ch_sendexpr(@{handle@}, @{expr@} [, @{options@}])
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Send {expr} over {handle}.  The {expr} is encoded
		according to the type of channel.  The function cannot be used
		with a raw channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{handle@} へ @{expr@} を送信します。@{expr@} はチャネル側と同じ型にエンコードされます。この関数は生のチャネルでは使用できません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		See |channel-use|.				*E912*
		{handle} can be a Channel or a Job that has a Channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{channel-use}| を参照してください。
@anchor{E912}
@erindex E912
@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetChannel()->ch_sendexpr(expr)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetChannel()->ch_sendexpr(expr)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ch_sendraw({handle}, {expr} [, {options}])		*ch_sendraw()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_sendraw()}
@findex ch_sendraw()
@item ch_sendraw(@{handle@}, @{expr@} [, @{options@}])
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Send |String| or |Blob| {expr} over {handle}.
		Works like |ch_sendexpr()|, but does not encode the request or
		decode the response.  The caller is responsible for the
		correct contents.  Also does not add a newline for a channel
		in NL mode, the caller must do that.  The NL in the response
		is removed.
		See |channel-use|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
文字列 |@ref{String}| または |@ref{Blob}| @{expr@} を @{handle@} に送ります。|@ref{ch_sendexpr()}| と同様に動作しますが、リクエストをエンコードしたり応答をデコードしたりはしません。呼び出しは正しいコンテンツである事が保証されます。また NL モードでは改行が行われますが、ここでは改行が付与されません。NL は応答から削除されます。|@ref{channel-use}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetChannel()->ch_sendraw(rawexpr)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetChannel()->ch_sendraw(rawexpr)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ch_setoptions({handle}, {options})			*ch_setoptions()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ch_setoptions()}
@findex ch_setoptions()
@item ch_setoptions(@{handle@}, @{options@})
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Set options on {handle}:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{handle@} にオプションを設定します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			"callback"	the channel callback
			"timeout"	default read timeout in msec
			"mode"		mode for the whole channel
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item "callback" @tab チャネルのコールバック
@item "timeout" @tab デフォルトの読み込みタイムアウト (ミリ秒)
@item "mode" @tab チャネル全体のモード
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		See |ch_open()| for more explanation.
		{handle} can be a Channel or a Job that has a Channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
より詳しい説明は |@ref{ch_open()}| を参照してください。@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Note that changing the mode may cause queued messages to be
		lost.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
モードの変更はキューイングされているメッセージを失ってしまうかもしれないことに注意してください。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		These options cannot be changed:
			"waittime"	only applies to |ch_open()|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下のオプションは変更できません:
@multitable @columnfractions .3 .7
@item "waittime" @tab |@ref{ch_open()}| のみに適用できる
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetChannel()->ch_setoptions(options)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetChannel()->ch_setoptions(options)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
ch_status({handle} [, {options}])				*ch_status()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ch_status(@{handle@} [, @{options@}])
@anchor{ch_status()}
@findex ch_status()
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Return the status of {handle}:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{handle@} の状態を返します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			"fail"		failed to open the channel
			"open"		channel can be used
			"buffered"	channel can be read, not written to
			"closed"	channel can not be used
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item "fail" @tab チャネルのオープンに失敗
@item "open" @tab チャネルは利用可能
@item "buffered" @tab チャネルは読込可能、または書き込まれていない
@item "closed" @tab チャネルは利用不可
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{handle} can be a Channel or a Job that has a Channel.
		"buffered" is used when the channel was closed but there is
		still data that can be obtained with |ch_read()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{handle@} はチャネルもしくはチャネルを持つジョブであっても良い。チャネルは閉じられているが |@ref{ch_read()}| を使って残ったデータをまだ読み取る事ができる場合には "buffered" が利用できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If {options} is given it can contain a "part" entry to specify
		the part of the channel to return the status for: "out" or
		"err".  For example, to get the error status: >
			ch_status(job, {"part": "err"})
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{options@} が指定された場合、"part" 要素でチャネルのどのパート ("out" または "err") の状態を返すかを指定できます。例えば、エラーの状態を得るには:
@verbatim
ch_status(job, {"part": "err"})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Can also be used as a |method|: >
			GetChannel()->ch_status()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetChannel()->ch_status()
@end verbatim               
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
9. Starting a job with a channel			*job-start* *job*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-start}
@anchor{job}
@cindex job-start
@cindex job
@cindex チャネルでジョブを開始する
@section 9. チャネルでジョブを開始する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To start a job and open a channel for stdin/stdout/stderr: >
    let job = job_start(command, {options})
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブを開始し、stdin/stdout/stderr のチャネルを開くには:
@verbatim
let job = job_start(command, {options})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can get the channel with: >
    let channel = job_getchannel(job)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
チャネルを得るには:
@verbatim
let channel = job_getchannel(job)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The channel will use NL mode.  If you want another mode it's best to specify
this in {options}.  When changing the mode later some text may have already
been received and not parsed correctly.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
チャネルは NL モードを使用します。別のモードが必要な場合は、@{options@} でこれを指定することをお勧めします。後でモードを変更すると、一部のテキストがすでに受信され、正しく解析されていない可能性があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the command produces a line of output that you want to deal with, specify
a handler for stdout: >
    let job = job_start(command, {"out_cb": "MyHandler"})
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドが処理したい出力行を生成する場合は、stdout のハンドラを指定します:
@verbatim
let job = job_start(command, {"out_cb": "MyHandler"})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The function will be called with the channel and a message. You would define
it like this: >
    func MyHandler(channel, msg)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この関数は、チャネルとメッセージで呼び出されます。あなたはこれをこのように定義します:
@verbatim
func MyHandler(channel, msg)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Without the handler you need to read the output with |ch_read()| or
|ch_readraw()|. You can do this in the close callback, see |read-in-close-cb|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ハンドラがなければ、|@ref{ch_read()}| または |@ref{ch_readraw()}| で出力を読み取る必要があります。クローズコールバックでこれを行うことができます。|@ref{read-in-close-cb}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that if the job exits before you read the output, the output may be lost.
This depends on the system (on Unix this happens because closing the write end
of a pipe causes the read end to get EOF).  To avoid this make the job sleep
for a short while before it exits.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
出力を読み取る前にジョブが終了すると、出力が失われる可能性があることに注意してください。これはシステムによって異なります (Unix 上では、パイプの書き込み終了を閉じると EOF が得られます)。これを避けるには、ジョブが終了する前にそれをしばらくスリープさせること。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The handler defined for "out_cb" will not receive stderr.  If you want to
handle that separately, add an "err_cb" handler: >
    let job = job_start(command, {"out_cb": "MyHandler",
	    \			  "err_cb": "ErrHandler"})
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"out_cb" に定義されたハンドラは stderr を受け取りません。もし個別に扱いたい場合は、"err_cb" ハンドラを追加します:
@verbatim
let job = job_start(command, {"out_cb": "MyHandler",
        \			  "err_cb": "ErrHandler"})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to handle both stderr and stdout with one handler use the
"callback" option: >
    let job = job_start(command, {"callback": "MyHandler"}) 
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
1 つのハンドラで stderr と stdout の両方を処理する場合は、"callback" オプションを使用します:
@verbatim
let job = job_start(command, {"callback": "MyHandler"})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Depending on the system, starting a job can put Vim in the background, the
started job gets the focus.  To avoid that, use the `foreground()` function.
This might not always work when called early, put in the callback handler or
use a timer to call it after the job has started.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
システムによっては、ジョブを開始するとVimをバックグラウンドに移動することがあり、開始されたジョブはフォーカスを取得します。これを避けるには `foreground()` 関数を使用してください。これは、早く呼び出されたとき、コールバックハンドラ内に置いたとき、またはジョブが開始した後にタイマーを使用して呼び出すときは、必ずしも機能しない場合があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can send a message to the command with ch_evalraw().  If the channel is in
JSON or JS mode you can use ch_evalexpr().
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ch_evalraw() でコマンドにメッセージを送ることができます。チャネルが JSON または JS モードの場合、ch_evalexpr() を使用できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are several options you can use, see |job-options|.
For example, to start a job and write its output in buffer "dummy": >
	let logjob = job_start("tail -f /tmp/log",
			     \ {'out_io': 'buffer', 'out_name': 'dummy'})
	sbuf dummy
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
使用できるオプションがいくつかあります。|@ref{job-options}| 参照。

例えば、ジョブを開始し、その出力をバッファ "dummy" に書き込むには:
@verbatim
let logjob = job_start("tail -f /tmp/log",
                     \ {'out_io': 'buffer', 'out_name': 'dummy'})
sbuf dummy
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Job input from a buffer ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex バッファからのジョブ入力
@unnumberedsubsec バッファからのジョブ入力
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*in_io-buffer*
To run a job that reads from a buffer: >
	let job = job_start({command},
	    \ {'in_io': 'buffer', 'in_name': 'mybuffer'})
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{in_io-buffer}
@cindex in_io-buffer
バッファから読み取るジョブを実行するには:
@verbatim
let job = job_start({command},
    \ {'in_io': 'buffer', 'in_name': 'mybuffer'})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*E915* *E918*
The buffer is found by name, similar to |bufnr()|. The buffer must exist and
be loaded when job_start() is called.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E915}
@anchor{E918}
@erindex E915
@erindex E918
バッファは、|@ref{bufnr()}| と同様の名前で見つけられます。バッファは、job_start() が呼び出されたときに存在し、ロードされていなければなりません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
By default this reads the whole buffer.  This can be changed with the "in_top"
and "in_bot" options.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デフォルトでは、これはバッファ全体を読み込みます。これは "in_top" と "in_bot" オプションで変更できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A special mode is when "in_top" is set to zero and "in_bot" is not set: Every
time a line is added to the buffer, the last-but-one line will be sent to the
job stdin.  This allows for editing the last line and sending it when pressing
Enter.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
特殊モードは、"in_top" が 0 に設定され、"in_bot" が設定されていない場合です。バッファに行が追加されるたびに、最後の 1 行がジョブ stdin に送信されます。これにより、最後の行を編集し、Enter を押したときに送信することができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*channel-close-in*
When not using the special mode the pipe or socket will be closed after the
last line has been written.  This signals the reading end that the input
finished.  You can also use |ch_close_in()| to close it sooner.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{channel-close-in}
@cindex channel-close-in
特殊モードを使用しないときは、最後の行が書き込まれた後にパイプまたはソケットが閉じられます。これは、入力が終了した読み取り終了を知らせます。|@ref{ch_close_in()}| を使用すると、より早く終了することもできます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
NUL bytes in the text will be passed to the job (internally Vim stores these
as NL bytes).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
テキストの NUL バイトはジョブに渡されます (内部では Vim はこれらを NL バイトとして格納します)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Reading job output in the close callback ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex クローズコールバックでジョブ出力を読み込む
@unnumberedsubsec クローズコールバックでジョブ出力を読み込む
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*read-in-close-cb*
If the job can take some time and you don't need intermediate results, you can
add a close callback and read the output there: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{read-in-close-cb}
@cindex read-in-close-cb
ジョブに時間がかかり、中間結果が必要ない場合は、クローズコールバックを追加してそこの出力を読み取ることができます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	func! CloseHandler(channel)
	  while ch_status(a:channel, {'part': 'out'}) == 'buffered'
	    echomsg ch_read(a:channel)
	  endwhile
	endfunc
	let job = job_start(command, {'close_cb': 'CloseHandler'})
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
func! CloseHandler(channel)
  while ch_status(a:channel, {'part': 'out'}) == 'buffered'
    echomsg ch_read(a:channel)
  endwhile
endfunc
let job = job_start(command, {'close_cb': 'CloseHandler'})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You will want to do something more useful than "echomsg".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
あなたは "echomsg" よりも役に立つ何かをしたいでしょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
10. Starting a job without a channel			*job-start-nochannel*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-start-nochannel}
@cindex job-start-nochannel
@cindex チャネルなしでジョブを開始する
@section 10. チャネルなしでジョブを開始する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To start another process without creating a channel: >
    let job = job_start(command,
	\ {"in_io": "null", "out_io": "null", "err_io": "null"})
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
チャネルを作成せずに別のプロセスを開始するには:
@verbatim
let job = job_start(command,
    \ {"in_io": "null", "out_io": "null", "err_io": "null"})
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This starts {command} in the background, Vim does not wait for it to finish.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはバックグラウンドで @{command@} を開始し、Vim はそれが完了するのを待ちません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When Vim sees that neither stdin, stdout or stderr are connected, no channel
will be created.  Often you will want to include redirection in the command to
avoid it getting stuck.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim が stdin、stdout、stderr のいずれも接続されていないと判断すると、チャネルは作成されません。コマンドが停止するのを避けるために、リダイレクションをコマンドに含めることがよくあります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are several options you can use, see |job-options|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
使用できるオプションがいくつかあります。|@ref{job-options}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*job-start-if-needed*
To start a job only when connecting to an address does not work, do something
like this: >
	let channel = ch_open(address, {"waittime": 0})
	if ch_status(channel) == "fail"
	  let job = job_start(command)
	  let channel = ch_open(address, {"waittime": 1000})
	endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-start-if-needed}
@cindex job-start-if-needed
アドレスへの接続が動作しない時にのみジョブを開始するには、次のような操作を行います:
@verbatim
let channel = ch_open(address, {"waittime": 0})
if ch_status(channel) == "fail"
  let job = job_start(command)
  let channel = ch_open(address, {"waittime": 1000})
endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that the waittime for ch_open() gives the job one second to make the port
available.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ch_open() の待ち時間は、ポートを利用可能にするためにジョブに 1 秒を与えることに注意してください。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
11. Job functions					*job-functions-details*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-functions-details}
@cindex job-functions-details
@section 11. Job 関数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
job_getchannel({job})					 *job_getchannel()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{job_getchannel()}
@findex job_getchannel()
@item job_getchannel(@{job@})
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Get the channel handle that {job} is using.
		To check if the job has no channel: >
			if string(job_getchannel()) == 'channel fail'
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{job@} が使用しているチャネルハンドルを取得します。ジョブにチャネルがないかどうかを確認するには:
@verbatim
if string(job_getchannel()) == 'channel fail'
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Can also be used as a |method|: >
			GetJob()->job_getchannel()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetJob()->job_getchannel()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
job_info([{job}])					*job_info()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job_info()}
@findex job_info()
@item job_info([@{job@}])
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Returns a Dictionary with information about {job}:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{job@} に関する情報を持つ辞書を返します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "status"	what |job_status()| returns
		   "channel"	what |job_getchannel()| returns
		   "cmd"	List of command arguments used to start the job
		   "process"	process ID
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item "status" @tab |@ref{job_status()}| が返すもの
@item "channel" @tab |@ref{job_getchannel()}| が返すもの
@item "cmd" @tab ジョブを開始するのに使われるコマンド引数のリスト
@item "process" @tab プロセス ID
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "tty_in"	terminal input name, empty when none
		   "tty_out"	terminal output name, empty when none
		   "exitval"	only valid when "status" is "dead"
		   "exit_cb"	function to be called on exit
		   "stoponexit"	|job-stoponexit|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "tty_in" @tab 端末入力名、何もないときには空
@item "tty_out" @tab 端末出力名、何もないときには空
@item "exitval" @tab "status" が "dead" のときのみ有効
@item "exit_cb" @tab 終了時に呼び出される関数
@item "stoponexit" @tab |@ref{job-stoponexit}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		   Only in Unix:
		   "termsig"	the signal which terminated the process
				(See |job_stop()| for the values)
				only valid when "status" is "dead"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@strong{Unix のみ:}
@multitable @columnfractions .3 .7
@item "termsig" @tab プロセスを終了させたシグナル (値については |@ref{job_stop()}| を参照してください)

"status"が "dead" の場合にのみ有効で
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		   Only in MS-Windows:
		   "tty_type"	Type of virtual console in use.
				Values are "winpty" or "conpty".
				See 'termwintype'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@strong{MS-Windows のみ:}
@multitable @columnfractions .3 .7
@item "tty_type" @tab 使用している仮想コンソールのタイプ。値は "winpty" または "conpty"。

'@option{termwintype}' を参照してください。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Without any arguments, returns a List with all Job objects.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数なしの場合、すべてのジョブオブジェクトのリストを返します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetJob()->job_info()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetJob()->job_info()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
job_setoptions({job}, {options})			*job_setoptions()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job_setoptions()}
@findex job_setoptions()
@item job_setoptions(@{job@}, @{options@})
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Change options for {job}.  Supported are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{job@} のオプションを変更します。サポートされているものは:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "stoponexit"	|job-stoponexit|
		   "exit_cb"	|job-exit_cb|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .5 .5
@item "stoponexit" @tab |@ref{job-stoponexit}|
@item "exit_cb" @tab |@ref{job-exit_cb}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetJob()->job_setoptions(options)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetJob()->job_setoptions(options)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
job_start({command} [, {options}])			*job_start()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job_start()}
@findex job_start()
@item job_start(@{command@} [, @{options@}])
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Start a job and return a Job object.  Unlike |system()| and
		|:!cmd| this does not wait for the job to finish.
		To start a job in a terminal window see |term_start()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブを開始し、ジョブオブジェクトを返します。|@ref{system()}| と |@ref{:!cmd}| とは異なり、これはジョブが終了するのを待つことはありません。端末ウィンドウ内でジョブを開始する方法については |@ref{term_start()}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If the job fails to start then |job_status()| on the returned
		Job object results in "fail" and none of the callbacks will be
		invoked.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブが起動に失敗した場合、返されたジョブオブジェクトの |@ref{job_status()}| は "fail" となり、どのコールバックも呼び出されません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{command} can be a String.  This works best on MS-Windows.  On
		Unix it is split up in white-separated parts to be passed to
		execvp().  Arguments in double quotes can contain white space.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{command@} は文字列にすることができます。これは MS-Windows 上で最も効果的です。Unix では、それは execvp() に渡すために空白で区切られたパーツに分割されます。二重引用符で囲まれた引数には空白を含めることができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{command} can be a List, where the first item is the executable
		and further items are the arguments.  All items are converted
		to String.  This works best on Unix.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{command@} はリストにすることができ、最初の項目は実行可能ファイルで、残りの項目は引数です。すべての項目は文字列に変換されます。これ は Unix で最も効果的です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		On MS-Windows, job_start() makes a GUI application hidden. If
		want to show it, Use |:!start| instead.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
MS-Windows では、|@ref{job_start()}| は GUI アプリケーションを隠します。それを表示したい場合は、|@ref{:!start}| を代わりに使用してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The command is executed directly, not through a shell, the
		'shell' option is not used.  To use the shell: >
	let job = job_start(["/bin/sh", "-c", "echo hello"])
<		Or: >
	let job = job_start('/bin/sh -c "echo hello"')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンドはシェルではなく直接実行され、'@option{shell}' オプションは使用されません。シェルを使用するには:
@verbatim
let job = job_start(["/bin/sh", "-c", "echo hello"])
@end verbatim
または:
@verbatim
let job = job_start('/bin/sh -c "echo hello"')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		Note that this will start two processes, the shell and the
		command it executes.  If you don't want this use the "exec"
		shell command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
これは 2 つのプロセス、シェルとそれが実行するコマンドを開始することに注意してください。これを望まない場合は、"exec" シェルコマンドを使用します。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		On Unix $PATH is used to search for the executable only when
		the command does not contain a slash.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Unix では @env{$PATH} は、コマンドにスラッシュが含まれていない場合にのみ、実行可能ファイルを検索するために使用されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The job will use the same terminal as Vim.  If it reads from
		stdin the job and Vim will be fighting over input, that
		doesn't work.  Redirect stdin and stdout to avoid problems: >
	let job = job_start(['sh', '-c', "myserver </dev/null >/dev/null"])
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブは Vim と同じ端末を使用します。ジョブが stdin を読む場合、ジョブと Vim が入力を奪い合うことになるのでうまく動作しません。問題を避けるために stdin と stdout をリダイレクトします:
@verbatim
let job = job_start(['sh', '-c', "myserver </dev/null >/dev/null"])
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The returned Job object can be used to get the status with
		|job_status()| and stop the job with |job_stop()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
返されたジョブオブジェクトを使用して、|@ref{job_status()}| でステータスを取得し、|@ref{job_stop()}| でジョブを停止することができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Note that the job object will be deleted if there are no
		references to it.  This closes the stdin and stderr, which may
		cause the job to fail with an error.  To avoid this keep a
		reference to the job.  Thus instead of: >
	call job_start('my-command')
<		use: >
	let myjob = job_start('my-command')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ジョブオブジェクトは、それを参照するものがない場合削除されることに注意してください。これは stdin および stdout を閉じ、エラーによるジョブの失敗を引き起こします。これを回避するにはジョブへの参照を維持します。
そのため、次の代わりに:
@verbatim
call job_start('my-command')
@end verbatim
以下のようにします:
@verbatim
let myjob = job_start('my-command')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		and unlet "myjob" once the job is not needed or is past the
		point where it would fail (e.g. when it prints a message on
		startup).  Keep in mind that variables local to a function
		will cease to exist if the function returns.  Use a
		script-local variable if needed: >
	let s:myjob = job_start('my-command')
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
さらに、ジョブが必要なくなったとき、もしくは (開始時にメッセージが表示されたときのように) ジョブが失敗した後に、"myjob" を unlet します。関数のローカル変数は、関数が終了すると消滅することに注意してください。必要であればスクリプトローカルな変数を使用することができます:
@verbatim
let s:myjob = job_start('my-command')
@end verbatim
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		{options} must be a Dictionary.  It can contain many optional
		items, see |job-options|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{options@} は辞書でなければなりません。多くのオプション項目を含めることができます。|@ref{job-options}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			BuildCommand()->job_start()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
BuildCommand()->job_start()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
job_status({job})					*job_status()* *E916*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job_status()}
@anchor{E916}
@pindex job_status()
@erindex E916
@item job_status(@{job@})
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Returns a String with the status of {job}:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{job@} のステータスを String で返します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			"run"	job is running
			"fail"	job failed to start
			"dead"	job died or was stopped after running
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item "run" @tab ジョブが実行中
@item "fail" @tab ジョブを開始できなかった
@item "dead" @tab ジョブが死んだか実行後にジョブが停止した
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		On Unix a non-existing command results in "dead" instead of
		"fail", because a fork happens before the failure can be
		detected.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Unix では存在しないコマンドは、失敗が検出される前にフォークが発生するため、"fail" ではなく "dead" になります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If an exit callback was set with the "exit_cb" option and the
		job is now detected to be "dead" the callback will be invoked.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
exit コールバックが "exit_cb" オプションで設定され、ジョブが "dead" と検出された場合、コールバックが呼び出されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		For more information see |job_info()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
詳細は |@ref{job_info()}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetJob()->job_status()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetJob()->job_status()
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
job_stop({job} [, {how}])					*job_stop()*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job_stop()}
@findex job_stop()
@item job_stop(@{job@} [, @{how@}])
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Stop the {job}.  This can also be used to signal the job.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{job@} を停止します。これはジョブを通知するためにも使用できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When {how} is omitted or is "term" the job will be terminated.
		For Unix SIGTERM is sent.  On MS-Windows the job will be
		terminated forcedly (there is no "gentle" way).
		This goes to the process group, thus children may also be
		affected.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{how@} が省略されたり "term" の場合、ジョブは終了します。Unix では SIGTERM が送信されます。MS-Windows では、ジョブは強制的に終了します ("優しい"方法は存在しません)。これはプロセスグループに行くので、子プロセスにも影響を受けるかもしれません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Effect for Unix:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@strong{UNIX への影響:}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			"term"	 SIGTERM (default)
			"hup"	 SIGHUP
			"quit"	 SIGQUIT
			"int"	 SIGINT
			"kill"	 SIGKILL (strongest way to stop)
			number	 signal with that number
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item "term" @tab SIGTERM (既定)
@item "hup" @tab SIGHUP
@item "quit" @tab SIGQUIT
@item "int" @tab SIGINT
@item "kill" @tab SIGKILL (停止するための最も強い方法)
@item number @tab その番号の信号
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Effect for MS-Windows:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@strong{MS-Windows への影響:}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			"term"	 terminate process forcedly (default)
			"hup"	 CTRL_BREAK
			"quit"	 CTRL_BREAK
			"int"	 CTRL_C
			"kill"	 terminate process forcedly
			Others	 CTRL_BREAK
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item "term" @tab プロセスを強制終了 (既定)
@item "hup" @tab CTRL_BREAK
@item "quit" @tab CTRL_BREAK
@item "int" @tab CTRL_C
@item "kill" @tab プロセスを強制終了
@item Others @tab CTRL_BREAK
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		On Unix the signal is sent to the process group.  This means
		that when the job is "sh -c command" it affects both the shell
		and the command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Unix では、シグナルはプロセスグループに送られます。これは、ジョブが "sh -c command" であるときにシェルとコマンドの両方に影響を与えることを意味します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The result is a Number: 1 if the operation could be executed,
		0 if "how" is not supported on the system.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
結果は数値で、操作が実行できる場合は 1、システムで "how" がサポートされていない場合は 0。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that even when the operation was executed, whether the
		job was actually stopped needs to be checked with
		|job_status()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ジョブが実際に停止したかどうかは、操作が実行された場合でも、|@ref{job_status()}| でチェックする必要があることに注意してください。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If the status of the job is "dead", the signal will not be
		sent.  This is to avoid to stop the wrong job (esp. on Unix,
		where process numbers are recycled).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブのステータスが "dead" の場合、シグナルは送られません。これは、(特にプロセス番号が再利用される Unix において) 間違ったジョブを停止することを防ぐためです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		When using "kill" Vim will assume the job will die and close
		the channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"kill" を使用したとき、Vim はジョブが死ぬと想定し、チャネルを閉じます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Can also be used as a |method|: >
			GetJob()->job_stop()
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{method}| としても使用できます:
@verbatim
GetJob()->job_stop()
@end verbatim
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
==============================================================================
12. Job options						*job-options*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-options}
@cindex job-options
@cindex ジョブオプション
@section 12. ジョブオプション
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The {options} argument in job_start() is a dictionary.  All entries are
optional.  Some options can be used after the job has started, using
job_setoptions(job, {options}).  Many options can be used with the channel
related to the job, using ch_setoptions(channel, {options}).
See |job_setoptions()| and |ch_setoptions()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
job_start() の @{options@} 引数は辞書です。すべての入力はオプションです。job_setoptions(job, @{options@}) を使用して、ジョブの開始後にいくつかのオプションを使用できます。ch_setoptions(channel, @{options@}) を使用して、ジョブに関連するチャネルで多くのオプションを使用できます。|@ref{job_setoptions()}| および |@ref{ch_setoptions()}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*in_mode* *out_mode* *err_mode*
"in_mode"		mode specifically for stdin, only when using pipes
"out_mode"		mode specifically for stdout, only when using pipes
"err_mode"		mode specifically for stderr, only when using pipes
			See |channel-mode| for the values.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{in_mode}
@anchor{out_mode}
@anchor{err_mode}
@cindex in_mode
@cindex out_mode
@cindex err_mode
@item "in_mode"
stdin 用のモード、パイプを使用している場合にのみ。
@item "out_mode"
stdout 用のモード、パイプを使用している場合にのみ。
@item "err_mode"
stderr 用のモード、パイプを使用している場合にのみ。
@end table
値については、|@ref{channel-mode}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			Note: when setting "mode" the part specific mode is
			overwritten.  Therefore set "mode" first and the part
			specific mode later.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"mode" を設定すると、パーツ固有のモードが上書きされます。したがって、最初に "mode" を、後でパーツ固有のモードを設定します。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			Note: when writing to a file or buffer and when
			reading from a buffer NL mode is used by default.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ファイルやバッファに書き込むときやバッファから読み込むときは、NL モードがデフォルトで使用されます。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*job-noblock*
"noblock": 1		When writing use a non-blocking write call.  This
			avoids getting stuck if Vim should handle other
			messages in between, e.g. when a job sends back data
			to Vim.  It implies that when `ch_sendraw()` returns
			not all data may have been written yet.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{job-noblock}
@cindex job-noblock
@item "noblock": 1
書き込み時にノンブロッキング書き込み呼び出しを使う。これは、もしも Vim が他のメッセージを扱うべき場合に、スタックするのを回避する。例えばジョブがバックデータを Vim の送る時など。まだすべてを書き込まれていないデータを `ch_sendraw()` が返す時を意味する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			This option was added in patch 8.1.0350, test with: >
				if has("patch-8.1.350")
				  let options['noblock'] = 1
				endif
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
このオプションはパッチ 8.1.0350 にて追加された。次でテストしよう:
@verbatim
if has("patch-8.1.350")
  let options['noblock'] = 1
endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*job-callback*
"callback": handler	Callback for something to read on any part of the
			channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-callback}
@cindex job-callback
@item "callback": handler
チャネルの任意の部分で何かを読むためのコールバック。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*job-out_cb* *out_cb*
"out_cb": handler	Callback for when there is something to read on
			stdout.  Only for when the channel uses pipes.  When
			"out_cb" wasn't set the channel callback is used.
			The two arguments are the channel and the message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-out_cb}
@anchor{out_cb}
@cindex job-out_cb
@cindex out_cb
@item "out_cb": handler
stdout で読み込むべきものがあるときのコールバック。チャネルがパイプを使用している場合のみ。"out_cb" が設定されていない場合は、チャネルコールバックが使用されます。2 つの引数はチャネルとメッセージです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*job-err_cb* *err_cb*
"err_cb": handler	Callback for when there is something to read on
			stderr.  Only for when the channel uses pipes.  When
			"err_cb" wasn't set the channel callback is used.
			The two arguments are the channel and the message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-err_cb}
@anchor{err_cb}
@cindex job-err_cb
@cindex err_cb
@item "err_cb": handler
stderr で読み込むべきものがあるときのコールバック。チャネルがパイプを使用している場合のみ。"err_cb" が設定されていない場合は、チャネルコールバックが使用されます。2 つの引数はチャネルとメッセージです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*job-close_cb*
"close_cb": handler	Callback for when the channel is closed.  Same as
			"close_cb" on |ch_open()|, see |close_cb|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-close_cb}
@cindex job-close_cb
@item "close_cb": handler
チャネルが閉じられるときのコールバック。|@ref{ch_open()}| の "close_cb" と同じです。|@ref{close_cb}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*job-drop*
"drop": when		Specifies when to drop messages.  Same as "drop" on
			|ch_open()|, see |channel-drop|.  For "auto" the
			exit_cb is not considered.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-drop}
@cindex job-drop
@item "drop": when
メッセージをいつドロップするかを指定します。|@ref{ch_open()}| の "drop" と同様 (|@ref{channel-drop}| 参照)。"auto" の場合、exit_cb は考慮されません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*job-exit_cb*
"exit_cb": handler	Callback for when the job ends.  The arguments are the
			job and the exit status.
			Vim checks up to 10 times per second for jobs that
			ended.  The check can also be triggered by calling
			|job_status()|, which may then invoke the exit_cb
			handler.
			Note that data can be buffered, callbacks may still be
			called after the process ends.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-exit_cb}
@cindex job-exit_cb
@item "exit_cb": handler
ジョブが終了したときのコールバック。引数はジョブと終了ステータスです。

Vim は、終了したジョブに対して最大 10 回/秒をチェックします。チェックは、|@ref{job_status()}| を呼び出すことによってトリガーすることもでき、exit_cb ハンドラを呼び出すことができます。
@quotation
@strong{Note:} @*
データがバッファリングされ、プロセスが終了した後もコールバックが呼び出されることに注意してください。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*job-timeout*
"timeout": time		The time to wait for a request when blocking, E.g.
			when using ch_evalexpr().  In milliseconds.  The
			default is 2000 (2 seconds).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-timeout}
@cindex job-timeout
@item "timeout": time
ブロッキング時にリクエストを待つ時間 (例: ch_evalexpr() を使用するとき。ミリ秒単位。デフォルトは 2000(2 秒) です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*out_timeout* *err_timeout*
"out_timeout": time	Timeout for stdout.  Only when using pipes.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{out_timeout}
@cindex out_timeout
@item "out_timeout": time
stdout のタイムアウト。パイプ使用時のみ。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"err_timeout": time	Timeout for stderr.  Only when using pipes.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{err_timeout}
@cindex err_timeout
@item "err_timeout": time
stderr のタイムアウト。パイプ使用時のみ。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Note: when setting "timeout" the part specific mode is
			overwritten.  Therefore set "timeout" first and the
			part specific mode later.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"timeout" を設定すると、パーツ固有のモードが上書きされます。したがって、最初に "timeout" を設定し、後でパーツ固有のモードを設定します。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*job-stoponexit*
"stoponexit": {signal}	Send {signal} to the job when Vim exits.  See
			|job_stop()| for possible values.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@anchor{job-stoponexit}
@cindex job-stoponexit
@item "stoponexit": @{signal@}
Vim が終了すると @{signal@} をジョブに送ります。可能な値については、|@ref{job_stop()}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"stoponexit": ""	Do not stop the job when Vim exits.
			The default is "term".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "stoponexit": ""
Vim が終了してもジョブを停止しません。デフォルトは "term" です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*job-term*
"term": "open"		Start a terminal in a new window and connect the job
			stdin/stdout/stderr to it.  Similar to using
			`:terminal`.
			NOTE: Not implemented yet!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-term}
@cindex job-term
@item "term": "open"
新しいウィンドウでターミナルを起動し、ジョブ stdin/stdout/stderr を接続します。`:terminal` を使用することと同じです。
@quotation
@strong{Note:} @*
まだ実装されていません！
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
"channel": {channel}	Use an existing channel instead of creating a new one.
			The parts of the channel that get used for the new job
			will be disconnected from what they were used before.
			If the channel was still used by another job this may
			cause I/O errors.
			Existing callbacks and other settings remain.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "channel": @{channel@}
新しいチャネルを作成する代わりに、既存のチャネルを使用します。新しいジョブに使用されるチャネルの部分は、以前使用された部分から切り離されます。チャネルが別のジョブで引き続き使用されていた場合、I/O エラーが発生する可能性があります。

既存のコールバックやその他の設定が残っています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
"pty": 1		Use a pty (pseudo-tty) instead of a pipe when
			possible.  This is most useful in combination with a
			terminal window, see |terminal|.
			{only on Unix and Unix-like systems}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "pty": 1
可能であれば、パイプのかわりに pty (pseudo-tty) を使います。これは端末ウィンドウとの組み合せで最も便利です。|@ref{terminal}| を参照。

@{Unix と Unix系 のシステムでのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*job-in_io* *in_top* *in_bot* *in_name* *in_buf*
"in_io": "null"		disconnect stdin (read from /dev/null)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-in_io}
@cindex job-in_io
@item "in_io": "null"
stdin を切断する (/dev/null から読み込む)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"in_io": "pipe"		stdin is connected to the channel (default)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "in_io": "pipe"
標準入力がチャネルに接続されている (デフォルト)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"in_io": "file"		stdin reads from a file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "in_io": "file"
stdin はファイルから読み込む
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"in_io": "buffer"	stdin reads from a buffer
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "in_io": "buffer"
stdin はバッファから読み込む
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"in_top": number	when using "buffer": first line to send (default: 1)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{in_top}
@cindex in_top
@item "in_top": number
"buffer" を使用する場合: 送信する最初の行 (デフォルト: 1)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"in_bot": number	when using "buffer": last line to send (default: last)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{in_bot}
@cindex in_bot
@item "in_bot": number
"buffer" を使用する場合: 送信する最後の行 (デフォルト:最後)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"in_name": "/path/file"	the name of the file or buffer to read from
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{in_name}
@cindex in_name
@item "in_name": "/path/file"
読み込むファイルまたはバッファの名前
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"in_buf": number	the number of the buffer to read from
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{in_buf}
@cindex in_buf
@item "in_buf": number
読み込むバッファの番号
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*job-out_io* *out_name* *out_buf*
"out_io": "null"	disconnect stdout (goes to /dev/null)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-out_io}
@cindex job-out_io
@item "out_io": "null"
stdout を切断する (/dev/null に行く)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"out_io": "pipe"	stdout is connected to the channel (default)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item"out_io": "pipe"
stdout がチャネルに接続されている (デフォルト)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"out_io": "file"	stdout writes to a file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "out_io": "file"
stdout がファイルに書き込む
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"out_io": "buffer"	stdout appends to a buffer (see below)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "out_io": "buffer"
stdout はバッファに追加する (下記参照)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"out_name": "/path/file" the name of the file or buffer to write to
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{out_name}
@cindex out_name
@item "out_name": "/path/file"
書き込むファイルまたはバッファの名前
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"out_buf": number	the number of the buffer to write to
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{out_buf}
@cindex out_buf
@item "out_buf": number
書き込むバッファの番号
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"out_modifiable": 0	when writing to a buffer, 'modifiable' will be off
			(see below)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "out_modifiable": 0
バッファに書き込むときに、'@option{modifiable}' はオフになる (下記参照)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"out_msg": 0		when writing to a new buffer, the first line will be
			set to "Reading from channel output..."
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "out_msg": 0
新しいバッファに書き込むとき、最初の行は "Reading from channel output..." に設定される
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
				*job-err_io* *err_name* *err_buf*
"err_io": "out"		stderr messages to go to stdout
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-err_io}
@cindex job-err_io
@item "err_io": "out"
stderr のメッセージは stdout に行く
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"err_io": "null"	disconnect stderr  (goes to /dev/null)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "err_io": "null"
stderr を切断する (/dev/null に行く)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"err_io": "pipe"	stderr is connected to the channel (default)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "err_io": "pipe"
stderr がチャネルに接続されている (デフォルト)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"err_io": "file"	stderr writes to a file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "err_io": "file"
stderr はファイルに書き込む
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"err_io": "buffer"	stderr appends to a buffer (see below)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "err_io": "buffer"
stderr はバッファに追加する (下記参照)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"err_name": "/path/file" the name of the file or buffer to write to
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{err_name}
@cindex err_name
@item "err_name": "/path/file"
書き込むファイルまたはバッファの名前
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"err_buf": number	the number of the buffer to write to
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{err_buf}
@cindex err_buf
@item "err_buf": number
書き込むバッファの番号
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"err_modifiable": 0	when writing to a buffer, 'modifiable' will be off
			(see below)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "err_modifiable": 0
バッファに書き込むときに、'@option{modifiable}' はオフになる (下記参照)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"err_msg": 0		when writing to a new buffer, the first line will be
			set to "Reading from channel error..."
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "err_msg": 0
新しいバッファに書き込むとき、最初の行は "Reading from channel error..." に設定される
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
"block_write": number	only for testing: pretend every other write to stdin
			will block
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "block_write": number
テストのためにのみ: stdin への他のすべての書き込みをブロックするふりをする
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
"env": dict		environment variables for the new process
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "env": dict
新しいプロセスのための環境変数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
"cwd": "/path/to/dir"	current working directory for the new process;
			if the directory does not exist an error is given
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "cwd": "/path/to/dir"
新しいプロセスのためのカレント作業ディレクトリ。ディレクトリが存在しない場合は、エラーが発生します。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Writing to a buffer ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex バッファへの書き込み
@unnumberedsubsec バッファへの書き込み
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*out_io-buffer*
When the out_io or err_io mode is "buffer" and there is a callback, the text
is appended to the buffer before invoking the callback.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{out_io-buffer}
@cindex out_io-buffer
out_io または err_io モードが "buffer" で、コールバックがある場合、コールバックを呼び出す前にテキストがバッファに追加されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When a buffer is used both for input and output, the output lines are put
above the last line, since the last line is what is written to the channel
input.  Otherwise lines are appended below the last line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
入力と出力の両方にバッファが使用されている場合、最後の行はチャネル入力に書き込まれたものなので、出力行は最後の行の上に置かれます。それ以外の場合は最後の行の下に行が追加されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When using JS or JSON mode with "buffer", only messages with zero or negative
ID will be added to the buffer, after decoding + encoding.  Messages with a
positive number will be handled by a callback, commands are handled as usual.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"buffer" を指定して JS または JSON モードを使用すると、デコード + エンコーディング後に、ゼロまたは負の ID を持つメッセージのみがバッファに追加されます。正の数を持つメッセージはコールバックによって処理され、コマンドは通常通り処理されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The name of the buffer from "out_name" or "err_name" is compared the full name
of existing buffers, also after expanding the name for the current directory.
E.g., when a buffer was created with ":edit somename" and the buffer name is
"somename" it will use that buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"out_name" または "err_name" のバッファ名は、現在のディレクトリの名前を拡張した後も、既存のバッファの完全名と比較されます。たとえば、"@command{:edit somename}" でバッファが作成され、バッファ名が "somename" の場合、そのバッファが使用されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If there is no matching buffer a new buffer is created.  Use an empty name to
always create a new buffer.  |ch_getbufnr()| can then be used to get the
buffer number.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
一致するバッファがない場合、新しいバッファが作成されます。新しいバッファを常に作成するには、空の名前を使用します。|@ref{ch_getbufnr()}| を使用してバッファ番号を取得できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For a new buffer 'buftype' is set to "nofile" and 'bufhidden' to "hide".  If
you prefer other settings, create the buffer first and pass the buffer number.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しいバッファの場合、'@option{buftype}' は "nofile" に設定され、'@option{bufhidden}' は "hide" に設定されます。他の設定が必要な場合は、まずバッファを作成し、バッファ番号を渡します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*out_modifiable* *err_modifiable*
The "out_modifiable" and "err_modifiable" options can be used to set the
'modifiable' option off, or write to a buffer that has 'modifiable' off.  That
means that lines will be appended to the buffer, but the user can't easily
change the buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{out_modifiable}
@anchor{err_modifiable}
@cindex out_modifiable
@cindex err_modifiable
"out_modifiable" と "err_modifiable" オプションは、'@option{modifiable}' オプションをオフにするか、'@option{modifiable}' になっているバッファに書き込むために使用できます。つまり、行がバッファに追加されますが、ユーザーはバッファを簡単に変更できません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
					*out_msg* *err_msg*
The "out_msg" option can be used to specify whether a new buffer will have the
first line set to "Reading from channel output...".  The default is to add the
message.  "err_msg" does the same for channel error.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{out_msg}
@anchor{err_msg}
@cindex out_msg
@cindex err_msg
"out_msg" オプションは、新しいバッファが最初の行を "Reading from channel output..." に設定するかどうかを指定するために使用できます。デフォルトではメッセージを追加します。"err_msg" はチャネルエラーでも同じです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When an existing buffer is to be written where 'modifiable' is off and the
"out_modifiable" or "err_modifiable" options is not zero, an error is given
and the buffer will not be written to.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
既存のバッファに '@option{modifiable}' が指定されておらず、"out_modifiable" または "err_modifiable" オプションがゼロでない場合、エラーが発生し、バッファに書き込まれません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the buffer written to is displayed in a window and the cursor is in the
first column of the last line, the cursor will be moved to the newly added
line and the window is scrolled up to show the cursor if needed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
書き込まれたバッファがウィンドウに表示され、カーソルが最後の行の最初の列にある場合、カーソルは新しく追加された行に移動され、ウィンドウは必要に応じてカーソルを表示するために上にスクロールされます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Undo is synced for every added line.  NUL bytes are accepted (internally Vim
stores these as NL bytes).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
追加されたすべての行に対して、取り消しが同期されます。NUL バイトは受け入れられます (内部では Vim はこれらを NL バイトとして格納します)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Writing to a file ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex ファイルへの書き込み
@unnumberedsubsec ファイルへの書き込み
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*E920*
The file is created with permissions 600 (read-write for the user, not
accessible for others).  Use |setfperm()| to change this.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E920}
@erindex E920
ファイルはアクセス許可 600 (ユーザーに対しては読み書き可能、他のユーザーはアクセス不可) で作成されます。これを変更するには、|@ref{setfperm()}| を使用してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the file already exists it is truncated.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルがすでに存在する場合は切り捨てられます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
13. Controlling a job					*job-control*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{job-control}
@cindex job-control
@cindex ジョブを制御する
@section 13. ジョブを制御する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To get the status of a job: >
	echo job_status(job)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブの状態を取得するには:
@verbatim
echo job_status(job)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To make a job stop running: >
	job_stop(job)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブの実行を停止するには:
@verbatim
job_stop(job)
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This is the normal way to end a job. On Unix it sends a SIGTERM to the job.
It is possible to use other ways to stop the job, or even send arbitrary
signals.  E.g. to force a job to stop, "kill it": >
	job_stop(job, "kill")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これはジョブを終了させる通常の方法です。Unix では、ジョブに SIGTERM を送信します。他の方法でジョブを停止したり、任意の信号を送信したりすることもできます。例えば、ジョブを強制的に停止させるには、"kill it":
@verbatim
job_stop(job, "kill")
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For more options see |job_stop()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
他のオプションについては、|@ref{job_stop()}| 参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
14. Using a prompt buffer				*prompt-buffer*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{prompt-buffer}
@cindex prompt-buffer
@section 14. プロンプトバッファを使う
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to type input for the job in a Vim window you have a few options:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim のウィンドウでジョブのための入力をタイプしたい場合、いくつかのオプションがあります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Use a normal buffer and handle all possible commands yourself.
  This will be complicated, since there are so many possible commands.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item 通常のバッファを使用して、すべての起こりうるコマンドを自分で処理します。たくさんの起こりうるコマンドが存在するので、これは複雑になります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Use a terminal window.  This works well if what you type goes directly to
  the job and the job output is directly displayed in the window.
  See |terminal-window|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 端末ウィンドウを使用します。入力した内容がジョブに送られ、ジョブの出力がウィンドウに直接表示される場合は、これはうまく機能します。|@ref{terminal-window}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Use a prompt window. This works well when entering a line for the job in Vim
  while displaying (possibly filtered) output from the job.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item プロンプトウィンドウを使用します。これは、Vim でジョブからの出力 (フィルタリングされている可能性もある) を表示している間に、ジョブのための行を入力しているときにうまく動作します。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A prompt buffer is created by setting 'buftype' to "prompt". You would
normally only do that in a newly created buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プロンプトバッファは '@option{buftype}' を "@var{prompt}" に設定することによって作成されます。通常は新規作成バッファでのみおこないます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The user can edit and enter one line of text at the very last line of the
buffer.  When pressing Enter in the prompt line the callback set with
|prompt_setcallback()| is invoked.  It would normally send the line to a job.
Another callback would receive the output from the job and display it in the
buffer, below the prompt (and above the next prompt).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザーは、バッファの最後の行に 1 行のテキストを編集して入力することができます。プロンプト行で @key{Enter} キーを押すと、|@ref{prompt_setcallback()}| で設定されたコールバックが呼び出されます。通常は、その行をジョブに送信します。別のコールバックは、ジョブからの出力を受け取り、バッファ内のプロンプトの下 (次のプロンプトの上) に表示します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Only the text in the last line, after the prompt, is editable. The rest of the
buffer is not modifiable with Normal mode commands.  It can be modified by
calling functions, such as |append()|.  Using other commands may mess up the
buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プロンプトの後の最後の行のテキストのみが編集可能です。残りのバッファはノーマルモードのコマンドでは変更できません。|@ref{append()}| などの関数を呼び出すことで変更できます。他のコマンドを使用すると、バッファを壊す可能性があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
After setting 'buftype' to "prompt" Vim does not automatically start Insert
mode, use `:startinsert` if you want to enter Insert mode, so that the user
can start typing a line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{buftype}' を "@var{prompt}" に設定した後、Vim は自動的に挿入モードを開始しません。挿入モードに入るには `@command{:startinsert}` を使います。これにより、ユーザーは行の入力を開始できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The text of the prompt can be set with the |prompt_setprompt()| function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
プロンプトのテキストは |@ref{prompt_setprompt()}| 関数で設定することができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The user can go to Normal mode and navigate through the buffer.  This can be
useful see older output or copy text.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ユーザーはノーマルモードに移行し、バッファ内を移動できます。これは、古い出力の参照やテキストのコピーに便利です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The CTRL-W key can be used to start a window command, such as CTRL-W w to
switch to the next window.  This also works in Insert mode (use Shift-CTRL-W
to delete a word). When leaving the window Insert mode will be stopped.  When
coming back to the prompt window Insert mode will be restored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-W} キーを使用して次のウィンドウに切り替えるための @kbd{CTRL-W w} などのウィンドウコマンドを開始できます。これは挿入モードでも機能します (単語を削除するには @kbd{Shift-CTRL-W} を使用します)。ウィンドウを離れたとき挿入モードは停止します。プロンプトウィンドウに戻ると、挿入モードが復元されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Any command that starts Insert mode, such as "a", "i", "A" and "I", will move
the cursor to the last line.  "A" will move to the end of the line, "I" to the
start of the line.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"a", "i", "A" や "I" などの挿入モードを開始するコマンドは、最終行にカーソルを移動します。"A" は 行末に移動し、"I" は行頭に移動します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
 vim:tw=78:ts=8:noet:ft=help:norl:
@end ifset
