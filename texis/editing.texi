@ifset JA  @c ----------- v -----------  JA  -*- tab-width: 8 -*-
@node editing.txt, , , 目次
@unnumbered ファイルの編集と保存
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*editing.txt*   For Vim version 8.1.  Last change: 2019 Jun 10


		  VIM REFERENCE MANUAL    by Bram Moolenaar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
*editing.txt*   For Vim バージョン 8.1.  Last change: 2019 Jun 10


		  VIMリファレンスマニュアル    by Bram Moolenaar
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Editing files						*edit-files*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{edit-files}
@cindex edit-files
@cindex ファイルの編集
@section ファイルの編集
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1.  Introduction		|edit-intro|
2.  Editing a file		|edit-a-file|
3.  The argument list		|argument-list|
4.  Writing			|writing|
5.  Writing and quitting	|write-quit|
6.  Dialogs			|edit-dialogs|
7.  The current directory	|current-directory|
8.  Editing binary files	|edit-binary|
9.  Encryption			|encryption|
10. Timestamps			|timestamps|
11. File Searching		|file-searching|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .5 .5
@item 1. はじめに @tab |@ref{edit-intro}|
@item 2. ファイルの編集 @tab |@ref{edit-a-file}|
@item 3. 引数リスト @tab |@ref{argument-list}|
@item 4. 書き込み @tab |@ref{writing}|
@item 5. 書き込みと終了 @tab |@ref{write-quit}|
@item 6. ダイアログ @tab |@ref{edit-dialogs}|
@item 7. カレントディレクトリ @tab |@ref{current-directory}|
@item 8. バイナリファイルの編集 @tab |@ref{edit-binary}|
@item 9. 暗号化 @tab |@ref{encryption}|
@item 10. タイムスタンプ @tab |@ref{timestamps}|
@item 11. ファイル検索 @tab |@ref{file-searching}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
1. Introduction						*edit-intro*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{edit-intro}
@cindex edit-intro
@section 1. はじめに
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Editing a file with Vim means:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
「Vim でファイルを編集する」とは、以下のことを表します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. reading the file into a buffer
2. changing the buffer with editor commands
3. writing the buffer into a file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item バッファへファイルを読み込む
@item 編集コマンドによりバッファの内容を変更する
@item バッファをファイルへ書き込む
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*current-file*
As long as you don't write the buffer, the original file remains unchanged.
If you start editing a file (read a file into the buffer), the file name is
remembered as the "current file name".  This is also known as the name of the
current buffer.  It can be used with "%" on the command line |:_%|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{current-file}
@cindex current-file
バッファを書き込まない限り、元のファイルは変更を受けないままで残っています。ファイルの編集を始める (バッファにファイルを読み込む) と、そのファイルの名前は「カレントファイル名」として記憶されます。これをカレントバッファの名前とも呼びます。コマンドラインでは "%" で表せます |@ref{:_%}|。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*alternate-file*
If there already was a current file name, then that one becomes the alternate
file name.  It can be used with "#" on the command line |:_#| and you can use
the |CTRL-^| command to toggle between the current and the alternate file.
However, the alternate file name is not changed when |:keepalt| is used.
An alternate file name is remembered for each window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{alternate-file}
@cindex alternate-file
カレントファイル名が既に存在したときは、前の方は「代替ファイル名」になります。これはコマンドラインでは "#" で表され |@ref{:_#}|、|@ref{CTRL-^}| を使うとカレントファイルと代替ファイルを切り替えることができます。ただし |@ref{:keepalt}| を使ったときは代替ファイル名は変わりません。代替ファイル名はウィンドウごとに記憶されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:keepalt* *:keepa*
:keepalt {cmd}		Execute {cmd} while keeping the current alternate file
			name.  Note that commands invoked indirectly (e.g.,
			with a function) may still set the alternate file
			name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:keepalt}
@anchor{:keepa}
@pindex :keepalt
@pindex :keepa
@table @asis
@item :keepalt @{cmd@}
現在の代替ファイル名を変えずに @{cmd@} を実行します。
@quotation
@strong{Note:} @*
間接的に呼び出されるコマンド (例えば関数によって) は代替ファイル名を変えてしまうことに注意してください。
@end quotation
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
All file names are remembered in the buffer list.  When you enter a file name,
for editing (e.g., with ":e filename") or writing (e.g., with ":w filename"),
the file name is added to the list.  You can use the buffer list to remember
which files you edited and to quickly switch from one file to another (e.g.,
to copy text) with the |CTRL-^| command.  First type the number of the file
and then hit CTRL-^.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
全てのファイル名はバッファリストに記憶されます。編集 (例えば "@command{:e filename}") や保存 (例えば "@command{:w filename}") のためにファイル名を入力すると、そのファイル名がリストに追加されます。このリストを使えば、どのファイルを編集したかを覚えておいたり、コマンド @kbd{CTRL-^} によってあるファイルから別のファイルへ素早く移行することができます (例えばテキストをコピーするとき)。まずファイルの番号を、次に @kbd{CTRL-^} を打ち込みます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
CTRL-G		or				*CTRL-G* *:f* *:fi* *:file*
:f[ile]			Prints the current file name (as typed, unless ":cd"
			was used), the cursor position (unless the 'ruler'
			option is set), and the file status (readonly,
			modified, read errors, new file).  See the 'shortmess'
			option about how to make this message shorter.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{CTRL-G}
@anchor{:f}
@anchor{:fi}
@anchor{:file}
@kindex CTRL-G
@pindex :f
@pindex :fi
@pindex :file
@table @asis
@item CTRL-G または
@itemx :f[ile]
カレントファイル名 (これは "@command{:cd}" が使われたとき以外は打ち込まれた通り @{訳注: 普通、カレントディレクトリのファイルを編集するときはパスを省いて打ち込むと思いますが、そうするとパスなしのファイル名になります@})、カーソル位置 (これはオプション '@option{ruler}' がオフのとき) とファイルの状態 (読込専用、変更あり、読込エラー、新規ファイル) を表示します。このメッセージを短くする方法については、オプション '@option{shortmess}' を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:f[ile]!		like |:file|, but don't truncate the name even when
			'shortmess' indicates this.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :f[ile]!
|@ref{:file}| と同様ですが、'@option{shortmess}' が設定されているときでも名前を切り詰めません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{count}CTRL-G		Like CTRL-G, but prints the current file name with
			full path.  If the count is higher than 1 the current
			buffer number is also given.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @{count@}CTRL-G
@kbd{CTRL-G} と同様ですが、カレントファイル名をフルパスで表示します。@{count@} が 2 以上なら、カレントバッファの番号も表示します。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*g_CTRL-G* *word-count* *byte-count*
g CTRL-G		Prints the current position of the cursor in five
			ways: Column, Line, Word, Character and Byte.  If the
			number of Characters and Bytes is the same then the
			Character position is omitted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g_CTRL-G}
@anchor{word-count}
@anchor{byte-count}
@kindex g_CTRL-G
@cindex word-count
@cindex byte-count
@table @asis
@item g CTRL-G
カーソルの現在の位置を、列、行、単語、文字、バイト、の 5 種類の単位で表示します。文字数とバイト数が同じのときは文字位置が省略されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			If there are characters in the line that take more
			than one position on the screen (<Tab> or special
			character), both the "real" column and the screen
			column are shown, separated with a dash.
			Also see the 'ruler' option and the |wordcount()|
			function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

行の中に画面上で 1 文字分以上の幅を占める文字 (<Tab> または特殊文字) があるときは、「実際」の列番号と画面上の列番号の両方が、ダッシュで区切られて表示されます @{訳注: 例えば、タブ幅 '@option{tabstop}' が 8 のとき、行頭の <Tab> の次では「実際」の列番号は 2、画面上の列番号は 9 となり、"1-8" と表示されます@}。オプション '@option{ruler}' と |@ref{wordcount()}| 関数も参照してください。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_g_CTRL-G*
{Visual}g CTRL-G	Similar to "g CTRL-G", but Word, Character, Line, and
			Byte counts for the visually selected region are
			displayed.
			In Blockwise mode, Column count is also shown.  (For
			{Visual} see |Visual-mode|.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_g_CTRL-G}
@kindex v_g_CTRL-G
@table @asis
@item @{Visual@}g CTRL-G
"g CTRL-G" と似ていますが、単語、文字、行、バイトの項目はビジュアル選択領域内で数えられて表示されます。矩形ビジュアルモードでは、何列目かも表示されます。

矩形ビジュアルモードでは桁数も表示されます (@{Visual@} については |@ref{Visual-mode}| を参照してください。)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:file_f*
:f[ile][!] {name}	Sets the current file name to {name}.  The optional !
			avoids truncating the message, as with |:file|.
			If the buffer did have a name, that name becomes the
			|alternate-file| name.  An unlisted buffer is created
			to hold the old name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:file_f}
@pindex :file_f
@item :f[ile][!] @{name@}
カレントファイル名を @{name@} に設定します。! をつけると |@ref{:file}| のようにメッセージを切り詰めなくなります。

バッファが名前を持つならその名前が代替ファイル名 |@ref{alternate-file}| になります。元の名前を保持するためにリストされない (unlisted) バッファが作成されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:0file*
:0f[ile][!]		Remove the name of the current buffer.  The optional !
			avoids truncating the message, as with |:file|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:0file}
@pindex :0file
@item :0f[ile][!]
カレントバッファの名前を削除します。! をつけると |@ref{:file}| のようにメッセージを切り詰めなくなります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:buffers
:files
:ls			List all the currently known file names.  See
			'windows.txt' |:files| |:buffers| |:ls|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :buffers
@itemx :files
@itemx :ls
現在認識しているファイル名を全て一覧表示します。|@ref{windows.txt}| |@ref{:files}| |@ref{:buffers}| |@ref{:ls}| を参照してください。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim will remember the full path name of a file name that you enter.  In most
cases when the file name is displayed only the name you typed is shown, but
the full path name is being used if you used the ":cd" command |:cd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は入力したファイル名のフルパス名を記憶しています。ファイル名が表示されるとき、大抵は打ち込んだ名前だけが表示されますが、コマンド |@ref{:cd}| でディレクトリを移動した後では、フルパス名が使われます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*home-replace*
If the environment variable $HOME is set, and the file name starts with that
string, it is often displayed with HOME replaced with "~".  This was done to
keep file names short.  When reading or writing files the full name is still
used, the "~" is only used when displaying file names.  When replacing the
file name would result in just "~", "~/" is used instead (to avoid confusion
between options set to $HOME with 'backupext' set to "~").
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{home-replace}
@cindex home-replace
環境変数 @env{$HOME} が設定されていて、ファイル名がその文字列で始まっているなら、ファイル名のその部分は "~" に置き換えられて表示されます。これはファイル名を短くするためです。ファイルを読み書きするときはフルパス名が使われ、"~" はファイル名を表示するときだけに使われます。ファイル名の置き換えを行ったところ "~" だけになってしまうときは、代わりに "~/" が使われます (オプション '@option{backupext}' が "~" に設定されたときに混乱を防ぐため)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When writing the buffer, the default is to use the current file name.  Thus
when you give the "ZZ" or ":wq" command, the original file will be
overwritten.  If you do not want this, the buffer can be written into another
file by giving a file name argument to the ":write" command.  For example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バッファを書き出すとき、既定ではカレントファイル名を用います。そのため、コマンド "@kbd{ZZ}" や "@command{:wq}" を使うと、元のファイルは上書きされてしまうことになります。これを望まないなら、コマンド "@command{:write}" の引数にファイル名を与えることで、バッファを別のファイルに書き出せます。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	vim testfile
	[change the buffer with editor commands]
	:w newfile
	:q
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
vim テスト用 {訳注: これはシェルに対して}
[コマンドでバッファを編集する]
:w 新ファイル
:q
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This will create a file "newfile", that is a modified copy of "testfile".
The file "testfile" will remain unchanged.  Anyway, if the 'backup' option is
set, Vim renames or copies the original file before it will be overwritten.
You can use this file if you discover that you need the original file.  See
also the 'patchmode' option.  The name of the backup file is normally the same
as the original file with 'backupext' appended.  The default "~" is a bit
strange to avoid accidentally overwriting existing files.  If you prefer ".bak"
change the 'backupext' option.  Extra dots are replaced with '_' on MS-DOS
machines, when Vim has detected that an MS-DOS-like filesystem is being used
(e.g., messydos or crossdos) or when the 'shortname' option is on.  The
backup file can be placed in another directory by setting 'backupdir'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
こうすると "新ファイル" が生成されますが、これは "テスト用" を編集してコピーしたものです。ファイル "テスト用" は変更されないまま残ります。しかしどちらにしろ、オプション '@option{backup}' がオンのときは、Vim は元のファイルを上書きする前に、元のファイルの名前を変更するかコピーします。元のファイルが必要なことに気づいたときは、このファイルを使えます。'@option{patchmode}' も参照してください。

普通、バックアップファイルの名前は元のファイル名に '@option{backupext}' を追加したものになります。既定値は "~" という妙なものですが、これはたまたま存在しているファイルに上書きするのを避けるためなのです。".bak" の方がよければ、'@option{backupext}' を変更してください。MS-DOS 機等で、MS-DOS 系のファイルシステム (例えば、messydos や crossdos ) が使われていることが検出されたときや、'@option{shortname}' がオンのときには、余分なドットは '_' に置き換えられます。'@option{backupdir}' を設定することで、バックアップファイルを他のディレクトリに置くことができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*auto-shortname*
Technical: On the Amiga you can use 30 characters for a file name.  But on an
	   MS-DOS-compatible filesystem only 8 plus 3 characters are
	   available.  Vim tries to detect the type of filesystem when it is
	   creating the .swp file.  If an MS-DOS-like filesystem is suspected,
	   a flag is set that has the same effect as setting the 'shortname'
	   option.  This flag will be reset as soon as you start editing a
	   new file.  The flag will be used when making the file name for the
	   ".swp" and ".~" files for the current file.  But when you are
	   editing a file in a normal filesystem and write to an MS-DOS-like
	   filesystem the flag will not have been set.  In that case the
	   creation of the ".~" file may fail and you will get an error
	   message.  Use the 'shortname' option in this case.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{auto-shortname}
@cindex auto-shortname
@quotation
@strong{技術的情報:} @*
Amiga ではファイル名に 30 文字まで使えます。しかし MS-DOS 互換のファイルシステムで有効なのは 8 文字＋ 3 文字に過ぎません。Vim は ".swp" ファイルを生成するときにファイルシステムの判別を試みます。MS-DOS 系のファイルシステムと思われるときは、'@option{shortname}' をオンにするのと同じ効果を持つフラグがオンになります。このフラグは新ファイルの編集を開始するとすぐにオフにされます。このフラグはカレントファイルのための ".swp" ファイルと ".~" ファイルの名前を作るときに使われます。しかし、ユーザーが普通のファイルシステムで編集作業を行い、MS-DOS 系のファイルシステムに保存するときには、フラグはオンにはなりません。そのときは、".~" ファイルの生成が失敗してエラーメッセージが表示されます。そのときはオプション '@option{shortname}' を使ってくさだい。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When you started editing without giving a file name, "No File" is displayed in
messages.  If the ":write" command is used with a file name argument, the file
name for the current file is set to that file name.  This only happens when
the 'F' flag is included in 'cpoptions' (by default it is included) |cpo-F|.
This is useful when entering text in an empty buffer and then writing it to a
file.  If 'cpoptions' contains the 'f' flag (by default it is NOT included)
|cpo-f| the file name is set for the ":read file" command.  This is useful
when starting Vim without an argument and then doing ":read file" to start
editing a file.
When the file name was set and 'filetype' is empty the filetype detection
autocommands will be triggered.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイル名を指定せずに編集を始めたときは、メッセージ欄に "[無題]" と表示されます。コマンド "@command{:write}" がファイル名引数付きで使われたときは、そのファイル名がカレントファイルのファイル名に設定されます。

こうなるのはフラグ '@var{F}' |@ref{cpo-F}| がオプション '@option{cpoptions}' に含まれているときだけです (既定では含まれています)。これは空のバッファにテキストを入力してから、それをファイルに保存するときに便利です。

'@option{cpoptions}' が '@var{f}' |@ref{cpo-f}| を含んでいるときは (既定では含まれて「いません」)、"@command{:read file}" でファイル名が設定されます。これは引数なしで Vim を起動してから、"@command{:read file}" でファイルの編集を開始するときに便利です。

ファイル名が設定されていて '@option{filetype}' が空のとき、ファイルタイプ判別自動コマンドが発生します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*not-edited*
Because the file name was set without really starting to edit that file, you
are protected from overwriting that file.  This is done by setting the
"notedited" flag.  You can see if this flag is set with the CTRL-G or ":file"
command.  It will include "[Not edited]" when the "notedited" flag is set.
When writing the buffer to the current file name (with ":w!"), the "notedited"
flag is reset.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{not-edited}
@cindex not-edited
ファイル名が設定されるのはその名前のファイルの編集を本当に始めるより前なので、そのファイルを誤って上書きしないようになっています。これはフラグ "@var{notedited}" を設定することで可能になります。このフラグの状態はコマンド @kbd{CTRL-G} か "@command{:file}" で確認できます。フラグ "@var{notedited}" がオンのときは "[Not edited]" と表示されます。カレントファイルの名前でバッファ内容を書き出すとき ("@command{:w!}" で)、フラグ "@var{notedited}" はオフに設定されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*abandon*
Vim remembers whether you have changed the buffer.  You are protected from
losing the changes you made.  If you try to quit without writing, or want to
start editing another file, Vim will refuse this.  In order to overrule this
protection, add a '!' to the command.  The changes will then be lost.  For
example: ":q" will not work if the buffer was changed, but ":q!" will.  To see
whether the buffer was changed use the "CTRL-G" command.  The message includes
the string "[Modified]" if the buffer has been changed, or "+" if the 'm' flag
is in 'shortmess'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{abandon}
@cindex abandon
Vim はバッファが変更されたかどうかを記憶していて、変更点が誤って失われないようになっています。保存せずに終了しようとしたり、別のファイルの編集を開始しようとすると、Vim は拒否します。この保護を無効にするためには、コマンドに '!' を追加してください。この場合、変更は失われます。例えばバッファの内容が変更されているとき、"@command{:q}" は使えませんが "@command{:q!}" は使えます。バッファの内容が変更されたかどうかを見るためにはコマンド @kbd{CTRL-G} を使ってください。バッファが変更されていたときは、メッセージに文字列 "[変更あり]"、'@var{m}' フラグが '@option{shortmess}' のときは "+" が含まれます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to automatically save the changes without asking, switch on the
'autowriteall' option.  'autowrite' is the associated Vi-compatible option
that does not work for all commands.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
確認なしで変更を保存してほしいなら、オプション '@option{autowriteall}' をオンにしてください。関連するオプションには '@option{autowrite}' がありますが、これは Vi 互換で、全てのコマンドに対して動作するわけではありません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you want to keep the changed buffer without saving it, switch on the
'hidden' option.  See |hidden-buffer|.  Some commands work like this even when
'hidden' is not set, check the help for the command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
変更されたバッファを保存せずにそのままにしておきたいなら、オプション '@option{hidden}' をオンにしてください。|@ref{hidden-buffer}| を参照してください。いくつかのコマンドは '@option{hidden}' がオンになっていなくてもこのように振る舞うので、コマンドについてはヘルプを参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
2. Editing a file					*edit-a-file*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{edit-a-file}
@cindex edit-a-file
@cindex ファイルの編集
@section 2. ファイルの編集
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:e* *:edit* *reload*
:e[dit] [++opt] [+cmd]	Edit the current file.  This is useful to re-edit the
			current file, when it has been changed outside of Vim.
			This fails when changes have been made to the current
			buffer and 'autowriteall' isn't set or the file can't
			be written.
			Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:e}
@anchor{:edit}
@anchor{reload}
@pindex :e
@pindex :edit
@cindex reload
@table @asis
@item :e[dit] [++opt] [+cmd]
カレントファイルを開きます。これは Vim 外部でカレントファイルに変更が加えられたとき、開き直すのに便利です。カレントバッファに変更が加えられているのに、オプション '@option{autowriteall}' がオフであるか、ファイルが書き込み可能でないときは、実行に失敗します。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:edit!* *discard*
:e[dit]! [++opt] [+cmd]
			Edit the current file always.  Discard any changes to
			the current buffer.  This is useful if you want to
			start all over again.
			Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:edit!}
@anchor{discard}
@pindex :edit!
@cindex discard
@item :e[dit]! [++opt] [+cmd]
どのような場合でもカレントファイルを開きます。カレントバッファに対する変更は全て失われます。これは編集作業をもう一度最初からやり直したいときに便利です。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:edit_f*
:e[dit] [++opt] [+cmd] {file}
			Edit {file}.
			This fails when changes have been made to the current
			buffer, unless 'hidden' is set or 'autowriteall' is
			set and the file can be written.
			Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:edit_f}
@pindex :edit_f
@item :e[dit] [++opt] [+cmd] @{file@}
@{file@} を開きます。

カレントバッファに変更が加えられていると実行に失敗します。ただしオプション '@option{hidden}' がオンであるときと、'@option{autowriteall}' がオンであり、かつファイルが書き込み可能なときには実行できます。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:edit!_f*
:e[dit]! [++opt] [+cmd] {file}
			Edit {file} always.  Discard any changes to the
			current buffer.
			Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:edit!_f}
@pindex :edit!_f
@item :e[dit]! [++opt] [+cmd] @{file@}
どのような場合でも @{file@} を開きます。カレントバッファに対する変更は全て失われます。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:e[dit] [++opt] [+cmd] #[count]
			Edit the [count]th buffer (as shown by |:files|).
			This command does the same as [count] CTRL-^.  But ":e
			#" doesn't work if the alternate buffer doesn't have a
			file name, while CTRL-^ still works then.
			Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :e[dit] [++opt] [+cmd] #[count]
[count] 番目のバッファ (コマンド |@ref{:files}| で表示されるもの) を開きます。このコマンドは [count] @kbd{CTRL-^} と同じです。しかし代替バッファがファイル名を持たないと "@command{:e #}" は機能しませんが、@kbd{CTRL-^} はそのときも機能します。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:ene* *:enew*
:ene[w]			Edit a new, unnamed buffer.  This fails when changes
			have been made to the current buffer, unless 'hidden'
			is set or 'autowriteall' is set and the file can be
			written.
			If 'fileformats' is not empty, the first format given
			will be used for the new buffer.  If 'fileformats' is
			empty, the 'fileformat' of the current buffer is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:ene}
@anchor{:enew}
@pindex :ene
@pindex :enew
@item :ene[w]
無名のバッファの編集を新規に開始します。カレントバッファに変更が加えられていると実行に失敗します。ただしオプション '@option{hidden}' がオンであるときと、'@option{autowriteall}' がオンであり、かつファイルが書き込み可能なときには実行できます。

'@option{fileformats}' の値が空でないとき、その先頭の形式が新バッファに適用されます。'@option{fileformats}' の値が空のときは、カレントバッファの '@option{fileformat}' の値が使われます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:ene!* *:enew!*
:ene[w]!		Edit a new, unnamed buffer.  Discard any changes to
			the current buffer.
			Set 'fileformat' like |:enew|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:ene!}
@anchor{:enew!}
@pindex :ene!
@pindex :enew!
@item :ene[w]!
無名のバッファの編集を新規に開始します。カレントバッファに対する変更は全て失われます。

オプション '@option{fileformat}' の値はコマンド |@ref{:enew}| と同様に設定されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:fin* *:find*
:fin[d][!] [++opt] [+cmd] {file}
			Find {file} in 'path' and then |:edit| it.
			{not available when the |+file_in_path| feature was
			disabled at compile time}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:fin}
@anchor{:find}
@pindex :fin
@pindex :find
@item :fin[d][!] [++opt] [+cmd] @{file@}
オプション '@option{path}' 内のディレクトリから @{file@} を探し、それを編集 |@ref{:edit}| します。

@{Vim が |@ref{+file_in_path}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:{count}fin[d][!] [++opt] [+cmd] {file}
			Just like ":find", but use the {count} match in
			'path'.  Thus ":2find file" will find the second
			"file" found in 'path'.  When there are fewer matches
			for the file in 'path' than asked for, you get an
			error message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :@{count@}fin[d][!] [++opt] [+cmd] @{file@}
コマンド "@command{:find}" と同様ですが、オプション '@option{path}' 内のディレクトリで @{count@} にマッチしたファイルを編集します。つまり "@command{:2find file}" とすると '@option{path}' 内で 2 番目に見つかった "file" を編集します。'@option{path}' 内で見つかったマッチが @{count@} より少ないと、エラーメッセージが表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:ex*
:ex [++opt] [+cmd] [file]
			Same as |:edit|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:ex}
@pindex :ex
@item :ex [++opt] [+cmd] [file]
|@ref{:edit}| と同じです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:vi* *:visual*
:vi[sual][!] [++opt] [+cmd] [file]
			When used in Ex mode: Leave |Ex-mode|, go back to
			Normal mode.  Otherwise same as |:edit|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:vi}
@anchor{:visual}
@pindex :vi
@pindex :visual
@item :vi[sual][!] [++opt] [+cmd] [file]
Ex モード内では: Ex モード (|@ref{Ex-mode}|) からノーマルモードに戻ります。それ以外はコマンド |@ref{:edit}| と同じです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:vie* *:view*
:vie[w][!] [++opt] [+cmd] file
			When used in Ex mode: Leave |Ex-mode|, go back to
			Normal mode.  Otherwise same as |:edit|, but set
			'readonly' option for this buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:vie}
@anchor{:view}
@pindex :vie
@pindex :view
@item :vie[w][!] [++opt] [+cmd] file
Ex モード内では: Ex モード (|@ref{Ex-mode}|) からノーマルモードに戻ります。それ以外はコマンド |@ref{:edit}| と同じですが、そのバッファに対してオプション '@option{readonly}' をオンにします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*CTRL-^* *CTRL-6*
CTRL-^			Edit the alternate file.  Mostly the alternate file is
			the previously edited file.  This is a quick way to
			toggle between two files.  It is equivalent to ":e #",
			except that it also works when there is no file name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{CTRL-^}
@anchor{CTRL-6}
@kindex CTRL-^
@kindex CTRL-6
@item CTRL-^
代替ファイルを編集します。たいていの場合、代替ファイルは前に編集したファイルです。これを使うと 2 つのファイル間を素早く切り替えることができます。これは "@command{:e #}" と同じですが、対象のファイル名が無い場合も機能します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			If the 'autowrite' or 'autowriteall' option is on and
			the buffer was changed, write it.
			Mostly the ^ character is positioned on the 6 key,
			pressing CTRL and 6 then gets you what we call CTRL-^.
			But on some non-US keyboards CTRL-^ is produced in
			another way.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{autowrite}' か '@option{autowriteall}' がオンならば、バッファを移動するときに書き込みをします。

たいていは "^" と "6" は同じキーです。@key{CTRL} を押しながら @key{6} のキーを押せば @kbd{CTRL-^} を押したのと同じ効果を得られます。しかし英語配列でないキーボードでは他のキーが割り当てられます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{count}CTRL-^		Edit [count]th file in the buffer list (equivalent to
			":e #[count]").  This is a quick way to switch between
			files.
			See |CTRL-^| above for further details.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @{count@}CTRL-^
[count] 番目の代替ファイルを編集します (コマンド "@command{:e #[count]}" と同じ)。[count] が指定されないと、前に編集したファイルを編集します。これを使うと 2 つ (かそれ以上) のファイル間を素早く行き来できます。

さらに詳しくは上の |@ref{CTRL-^}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
[count]]f						*]f* *[f*
[count][f		Same as "gf".  Deprecated.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{]f}
@anchor{[f}
@kindex ]f
@kindex [f
@item [count]]f
@itemx [count][f
コマンド "gf" と同じです。推奨されません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*gf* *E446* *E447*
[count]gf		Edit the file whose name is under or after the cursor.
			Mnemonic: "goto file".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gf}
@anchor{E446}
@anchor{E447}
@kindex gf
@erindex E446
@erindex E447
@item [count]gf
カーソルの下か後ろの名前のファイルを編集します。覚え方: "goto file"。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Uses the 'isfname' option to find out which characters
			are supposed to be in a file name.  Trailing
			punctuation characters ".,:;!" are ignored. Escaped
			spaces "\ " are reduced to a single space.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

オプション '@option{isfname}' により、どの文字がファイル名に使われるはずなのかを調べます。ファイル名に続く句読点の ".,:;!" は無視されます。エスケープされた複数のスペース "\ " は 1 つのスペースに減らされます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Uses the 'path' option as a list of directory names to
			look for the file.  See the 'path' option for details
			about relative directories and wildcards.
			Uses the 'suffixesadd' option to check for file names
			with a suffix added.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

'@option{path}' により、ファイルを探すディレクトリ名のリストを調べます。カレントファイルに対して相対的なファイルも探されます。

'@option{suffixesadd}' により、拡張子を補ったファイル名を調べます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			If the file can't be found, 'includeexpr' is used to
			modify the name and another attempt is done.
			If a [count] is given, the count'th file that is found
			in the 'path' is edited.
			This command fails if Vim refuses to |abandon| the
			current file.
			If you want to edit the file in a new window use
			|CTRL-W_CTRL-F|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルが見つからないと、'@option{includeexpr}' によってファイル名を修正し、再びファイルを探します。

[count] が指定されると、'@option{path}' 内で見つかった [count] 番目のファイルを編集します。

Vim がカレントファイルの破棄 |@ref{abandon}| を拒否したときは、このコマンドの実行は失敗します。

このファイルを新しいウィンドウで編集したいときは |@ref{CTRL-W_CTRL-F}| を使ってください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			If you do want to edit a new file, use: >
				:e <cfile>
<			To make gf always work like that: >
				:map gf :e <cfile><CR>
<			If the name is a hypertext link, that looks like
			"type://machine/path", you need the |netrw| plugin.
			For Unix the '~' character is expanded, like in
			"~user/file".  Environment variables are expanded too
			|expand-env|.
			{not available when the |+file_in_path| feature was
			disabled at compile time}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しいファイルを編集したいなら次のようにします。
@verbatim
:e <cfile>
@end verbatim
どのような場合でもコマンド gf を機能させるには次のようにします。
@verbatim
:map gf :e <cfile><CR>
@end verbatim
カーソル下のファイル名が "type://machine/path" のようなハイパーテキストリンクであるなら、プラグイン |@ref{netrw}| が必要になります。

Unix では、文字 '~' は "~user/file" のように展開されます。環境変数も展開されます |@ref{expand-env}|。

@{Vimが |@ref{+file_in_path}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_gf*
{Visual}[count]gf	Same as "gf", but the highlighted text is used as the
			name of the file to edit.  'isfname' is ignored.
			Leading blanks are skipped, otherwise all blanks and
			special characters are included in the file name.
			(For {Visual} see |Visual-mode|.)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_gf}
@kindex v_gf
@item @{Visual@}[count]gf
コマンド "gf" と同じですが、編集するファイルの名前にはビジュアル選択されたテキストが使われます。オプション '@option{isfname}' の値は無視されます。先頭の空白は無視されますが、それ以外の空白や特殊文字はファイル名に含まれます。(@{Visual@} については |@ref{Visual-mode}| を参照してください。)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*gF*
[count]gF		Same as "gf", except if a number follows the file
			name, then the cursor is positioned on that line in
			the file. The file name and the number must be
			separated by a non-filename (see 'isfname') and
			non-numeric character. White space between the
			filename, the separator and the number are ignored.
			Examples:
				eval.c:10 ~
				eval.c @ 20 ~
				eval.c (30) ~
				eval.c 40 ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gF}
@kindex gF
@item [count]gF
"gf" と同じですが、ファイル名の後に番号があるときは、その行へカーソルが移動する点が異なります。ファイル名と行番号は、ファイル名ではない文字 ('@option{isfname}' を参照してください) かつ数字ではない文字で区切られてなければなりません。ファイル名、区切り文字、番号の間の空白文字は無視されます。

例:
@verbatim
eval.c:10
eval.c @ 20
eval.c (30)
eval.c 40
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*v_gF*
{Visual}[count]gF	Same as "v_gf".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{v_gF}
@kindex v_gF
@item @{Visual@}[count]gF
"v_gf" と同じです。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
These commands are used to start editing a single file.  This means that the
file is read into the buffer and the current file name is set.  The file that
is opened depends on the current directory, see |:cd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以上のコマンドは 1 つのファイルの編集を開始するために使用されます。これはファイルがバッファに読み込まれ、カレントファイル名が設定されることを意味します。開かれるファイルはカレントディレクトリに依存します。コマンド |@ref{:cd}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
See |read-messages| for an explanation of the message that is given after the
file has been read.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルが読み込まれた後に表示されるメッセージの説明については |@ref{read-messages}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use the ":e!" command if you messed up the buffer and want to start
all over again.  The ":e" command is only useful if you have changed the
current file name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バッファ内がめちゃめちゃになって最初からもう 1 度やり直したいときには、コマンド "@command{:e!}" が使えます。コマンド "@command{:e}" が便利なのは、カレントファイル名を変更したときだけです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:filename* *{file}*
Besides the things mentioned here, more special items for where a filename is
expected are mentioned at |cmdline-special|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:filename}
@anchor{@{file@}}
@pindex :filename
@cindex @{file@}
ファイル名を指定する場所で使える特殊なアイテムについては、この節で書かれていることの他に |@ref{cmdline-special}| に書かれています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note for systems other than Unix: When using a command that accepts a single
file name (like ":edit file") spaces in the file name are allowed, but
trailing spaces are ignored.  This is useful on systems that regularly embed
spaces in file names (like MS-Windows and the Amiga).  Example: The command
":e   Long File Name " will edit the file "Long File Name".  When using a
command that accepts more than one file name (like ":next file1 file2")
embedded spaces must be escaped with a backslash.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
Unix と MS-DOS 以外に対する注意: 1 つのファイル名を受け付けるコマンド ("@command{:edit file}" 等) では、ファイル名に空白が入っていても構いませんが、ファイル名末尾の空白は無視されます。これは、空白を含むファイル名が普通にあるシステム (MS-Windows, Amiga 等) では便利です。例: "@command{:e   Long File Name }" を実行すると、ファイル "Long File Name" を開きます。

2 つ以上のファイル名を受け付けるコマンド ("@command{:next file1 file2}" 等) では、ファイル名内の空白は '\' でエスケープしなければなりません。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*wildcard* *wildcards*
Wildcards in {file} are expanded, but as with file completion, 'wildignore'
and 'suffixes' apply.  Which wildcards are supported depends on the system.
These are the common ones:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{wildcard}
@anchor{wildcards}
@cindex wildcard
@cindex wildcards
@cindex ワイルドカード
@{file@} 内のワイルドカードは展開されます。ただし、ファイル名補完と同様に '@option{wildignore}' と '@option{suffixes}' が適用されます。使用できるワイルドカードの種類はシステムによって異なります。標準的なものは以下です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	?	matches one character
	*	matches anything, including nothing
	**	matches anything, including nothing, recurses into directories
	[abc]	match 'a', 'b' or 'c'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .15 .85
@item ? @tab あらゆる 1 文字にマッチ
@item * @tab 何もないのも含め、全てにマッチ
@item ** @tab 何もないのも含め、全てにマッチ。ディレクトリを再帰的にたどる。
@item [abc] @tab 'a', 'b' または 'c' にマッチ
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To avoid the special meaning of the wildcards prepend a backslash.  However,
on MS-Windows the backslash is a path separator and "path\[abc]" is still seen
as a wildcard when "[" is in the 'isfname' option.  A simple way to avoid this
is to use "path\[[]abc]", this matches the file "path\[abc]".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ワイルドカードとしての特別な意味を無効にするには、前に '\' を置いてください。しかし MS-Windows では '\' がパスの区切り文字なので、オプション '@option{isfname}' の値に "[" が含まれていると、"path\[abc]" はワイルドカード扱いになってしまいます。これを避ける単純な方法は、"path\[[]abc]" とすることです。こうすると文字通りのファイル "path[abc]" を編集できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*starstar-wildcard*
Expanding "**" is possible on Unix, Win32, Mac OS/X and a few other systems.
This allows searching a directory tree.  This goes up to 100 directories deep.
Note there are some commands where this works slightly differently, see
|file-searching|.
Example: >
	:n **/*.txt
Finds files:
	aaa.txt ~
	subdir/bbb.txt ~
	a/b/c/d/ccc.txt ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{starstar-wildcard}
@cindex starstar-wildcard
"**" の展開は、Unix, Win32, Mac OS/X、その他数種類のシステムでのみ使用できます。"**" はディレクトリツリーを再帰的に検索します。深さの上限は 100 ディレクトリです。
@quotation
@strong{Note:} @*
いくつかのコマンドでは、この挙動が少し異なることに注意してください。|@ref{file-searching}| を参照してください。
@end quotation
例:
@verbatim
:n **/*.txt
@end verbatim
これは次のファイルにマッチします:
@verbatim
aaa.txt
subdir/bbb.txt
a/b/c/d/ccc.txt
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
When non-wildcard characters are used right before or after "**" these are
only matched in the top directory.  They are not used for directories further
down in the tree. For example: >
	:n /usr/inc**/types.h
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"**" の直前または直後にワイルドカード以外の文字が使用されている場合、これらはトップディレクトリでのみマッチします。これらは、ツリーのさらに下のディレクトリには使用されません。例:
@verbatim
:n /usr/inc**/types.h
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Finds files:
	/usr/include/types.h ~
	/usr/include/sys/types.h ~
	/usr/inc/old/types.h ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは次のファイルにマッチします:
@verbatim
/usr/include/types.h
/usr/include/sys/types.h
/usr/inc/old/types.h
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Note that the path with "/sys" is included because it does not need to match
"/inc".  Thus it's like matching "/usr/inc*/*/*...", not
"/usr/inc*/inc*/inc*".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
"/inc" とマッチする必要がないため、"/sys" を含むパスが含まれていることに注意してください。したがって、"/usr/inc*/inc*/inc*" ではなく、"/usr/inc*/*/*..." にマッチするようなものです。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
					*backtick-expansion* *`-expansion*
On Unix and a few other systems you can also use backticks for the file name
argument, for example: >
	:next `find . -name ver\\*.c -print`
	:view `ls -t *.patch  \| head -n1`
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{backtick-expansion}
@anchor{`-expansion}
@cindex backtick-expansion
@cindex `-expansion
Unix などではファイル名の引数にバッククォート '`' も使えます。例:
@verbatim
:next `find . -name ver\\*.c -print`
:view `ls -t *.patch  \| head -n1`
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Vim will run the command in backticks using the 'shell' and use the standard
output as argument for the given Vim command (error messages from the shell
command will be discarded).
To see what shell command Vim is running, set the 'verbose' option to 4. When
the shell command returns a non-zero exit code, an error message will be
displayed and the Vim command will be aborted. To avoid this make the shell
always return zero like so: >
       :next `find . -name ver\\*.c -print \|\| true`
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim はバッククォート内のコマンドをシェルで実行し、その標準出力を Vim コマンドの引数とします (シェルからのエラーメッセージは破棄されます)。

Vim が何のシェルコマンドを実行しているのか確認するためには、'@option{verbose}' オプションに 4 を設定します。シェルコマンドが 0 以外の終了コードを返した場合、エラーメッセージが表示され Vim コマンドは中断されます。これを防ぐためには、次のようにしてシェルが常に 0 を返すようにします:
@verbatim
:next `find . -name ver\\*.c -print \|\| true`
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The backslashes before the star are required to prevent the shell from
expanding "ver*.c" prior to execution of the find program.  The backslash
before the shell pipe symbol "|" prevents Vim from parsing it as command
termination.
This also works for most other systems, with the restriction that the
backticks must be around the whole item.  It is not possible to have text
directly before the first or just after the last backtick.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
アスタリスク '*' の前の '\' は、シェルが find を実行する前に "ver*.c" を展開してしまうのを防ぐために必要となります。シェルのパイプ記号 "|" の前のバックスラッシュは Vim がコマンドの終わりとしてパースするのを防ぎます。

これは、必ず項目全体がバッククォートで括られているという制限付きで、他の多くのシステムでも機能します。最初のバッククォートの直前や最後のバッククォートの直後に文字列を書くことはできません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*`=*
You can have the backticks expanded as a Vim expression, instead of as an
external command, by putting an equal sign right after the first backtick,
e.g.: >
	:e `=tempname()`
The expression can contain just about anything, thus this can also be used to
avoid the special meaning of '"', '|', '%' and '#'.  However, 'wildignore'
does apply like to other wildcards.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{`=}
@cindex `=
バッククォート内を、外部コマンドとしてではなく Vim の式として展開させることもできます。そのためには初めのバッククォートのすぐ後に等号を置きます。例:
@verbatim
:e `=tempname()`
@end verbatim
この式はほとんど何でも含むことができます。そのため、これを使って '"', '|', '%', '#' の特別な意味を打ち消すこともできます。ただし、他のワイルドカードと同様に '@option{wildignore}' は適用されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Environment variables in the expression are expanded when evaluating the
expression, thus this works: >
	:e `=$HOME . '/.vimrc'`
This does not work, $HOME is inside a string and used literally: >
	:e `='$HOME' . '/.vimrc'`
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この式の中の環境変数は式が評価される時に展開されます。したがってこれは機能します:
@verbatim
:e `=$HOME . '/.vimrc'`
@end verbatim
これは機能しません。@env{$HOME} は文字列内にあり、文字通りに用いられます:
@verbatim
:e `='$HOME' . '/.vimrc'`
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the expression returns a string then names are to be separated with line
breaks.  When the result is a |List| then each item is used as a name.  Line
breaks also separate names.
Note that such expressions are only supported in places where a filename is
expected as an argument to an Ex-command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
式が文字列を返したときは名前は改行で区切られます。式の結果がリスト (|@ref{List}|) のときは各要素が名前として扱われます。改行によっても名前は区切られます。
@quotation
@strong{Note:} @*
そのような式はファイル名が Ex コマンドの引数として期待される場所でのみサポートされることに注意してください。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*++opt* *[++opt]*
The [++opt] argument can be used to force the value of 'fileformat',
'fileencoding' or 'binary' to a value for one command, and to specify the
behavior for bad characters.  The form is: >
	++{optname}
Or: >
	++{optname}={value}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{++opt}
@anchor{[++opt]}
@cindex ++opt
@cindex [++opt]
引数のうち [++opt] はオプション '@option{fileformat}', '@option{fileencoding}' または '@option{binary}' の値を、そのコマンドに限ってある値に指定し、不正な文字への対応を指定するために使われます。指定の形式は次の通りです。
@verbatim
++{optname}
@end verbatim
または
@verbatim
++{optname}={value}
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Where {optname} is one of:	    *++ff* *++enc* *++bin* *++nobin* *++edit*
    ff     or  fileformat   overrides 'fileformat'
    enc    or  encoding	    overrides 'fileencoding'
    bin    or  binary	    sets 'binary'
    nobin  or  nobinary	    resets 'binary'
    bad			    specifies behavior for bad characters
    edit		    for |:read| only: keep option values as if editing
			    a file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{++ff}
@anchor{++enc}
@anchor{++bin}
@anchor{++nobin}
@anchor{++edit}
@cindex ++ff
@cindex ++enc
@cindex ++bin
@cindex ++nobin
@cindex ++edit
@{optname@} は次のうちのどれかです:
@multitable @columnfractions .4 .6
@item ff または fileformat @tab '@option{fileformat}' を指定
@item enc または encoding @tab '@option{fileencoding}' を指定
@item bin または binary @tab '@option{binary}' を指定
@item nobin または nobinary @tab '@option{binary}' を無効にする
@item bad @tab 不正な文字への対応を指定する
@item edit @tab |@ref{:read}| 用。ファイルを編集するときと同じようにオプションの値を保つ
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{value} cannot contain white space.  It can be any valid value for these
options.  Examples: >
	:e ++ff=unix
This edits the same file again with 'fileformat' set to "unix". >

	:w ++enc=latin1 newfile
This writes the current buffer to "newfile" in latin1 format.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{value@} に空白を含めてはいけません。値は、そのオプションに対して適切なものなら何でもよい。例:
@verbatim
:e ++ff=unix
@end verbatim
こうすると '@option{fileformat}' を "@var{unix}" に設定して同じファイルを編集し直します。
@verbatim
:w ++enc=latin1 newfile
@end verbatim
こうするとカレントバッファの内容を latin1 の文字コードで "newfile" に書き出します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There may be several ++opt arguments, separated by white space.  They must all
appear before any |+cmd| argument.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
空白で区切られた複数の [++opt] 引数になるかもしれません。それらはみな |@ref{+cmd}| 引数よりも前に指定しなければなりません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
								*++bad*
The argument of "++bad=" specifies what happens with characters that can't be
converted and illegal bytes.  It can be one of three things:
    ++bad=X      A single-byte character that replaces each bad character.
    ++bad=keep   Keep bad characters without conversion.  Note that this may
		 result in illegal bytes in your text!
    ++bad=drop   Remove the bad characters.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{++bad}
@cindex ++bad
"++bad=" の引数は、変換できない文字と不正なバイトをどうするかを指定します。とりうる値は次の 3 つのうちどれかです:
@multitable @columnfractions .2 .8
@item ++bad=X @tab 不正な文字をこの 1 バイト文字で置き換える
@item ++bad=keep @tab 不正な文字を変換せずにそのままにしておく
@quotation
@strong{Note:} @*
これを使うとテキスト中に不正なバイトが現れることになることに注意してください！
@end quotation
@item ++bad=drop @tab 不正な文字を削除する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The default is like "++bad=?": Replace each bad character with a question
mark.  In some places an inverted question mark is used (0xBF).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
既定値は "++bad=?" のようになっています。つまり、不正な文字をそれぞれクエスチョンマーク ? で置き換えます。逆クエスチョンマーク ¿ (latin-1 の 0xBF) が使われる場所もあります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that not all commands use the ++bad argument, even though they do not
give an error when you add it.  E.g. |:write|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
++bad をつけてエラーにならなかったとしても、すべてのコマンドが ++bad に対応しているわけではないことに注意してください。例 |@ref{:write}|。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that when reading, the 'fileformat' and 'fileencoding' options will be
set to the used format.  When writing this doesn't happen, thus a next write
will use the old value of the option.  Same for the 'binary' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
読み込み時に上の方法で '@option{fileformat}' と '@option{fileencoding}' を指定すると、それらは以後その値に設定されることに注意してください。書き込み時に設定してもそうはならず、次に書き込むときには以前の値が使われます。'@option{binary}' オプションも同様です。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
							*+cmd* *[+cmd]*
The [+cmd] argument can be used to position the cursor in the newly opened
file, or execute any other command:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{+cmd}
@anchor{[+cmd]}
@cindex +cmd
@cindex [+cmd]
引数 [+cmd] は、新しく開いたファイルでカーソルの位置を指定したり、他のあらゆるコマンドを実行するために使われます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	+		Start at the last line.
	+{num}		Start at line {num}.
	+/{pat}		Start at first line containing {pat}.
	+{command}	Execute {command} after opening the new file.
			{command} is any Ex command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .25 .75
@item + @tab 最後の行で編集を開始する
@item +@{num@} @tab @{num@} 行目で編集を開始する
@item +/@{pat@} @tab @{pat@} を含んだ最初の行で編集を開始する
@item +@{command@} @tab 新しいファイルを開いた後に @{command@} を実行する。@{command@} には任意の Ex コマンドが使える
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
To include a white space in the {pat} or {command}, precede it with a
backslash.  Double the number of backslashes. >
	:edit  +/The\ book	     file
	:edit  +/dir\ dirname\\      file
	:edit  +set\ dir=c:\\\\temp  file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{pat@} や @{command@} に空白を含めるためには、その前に '\' を付けます。'\' そのものを使うには 2 回ずつ繰り返してください。
@verbatim
:edit  +/The\ book           ファイル
:edit  +/dir\ dirname\\      ファイル
:edit  +set\ dir=c:\\\\temp  ファイル
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Note that in the last example the number of backslashes is halved twice: Once
for the "+cmd" argument and once for the ":set" command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
最後の例では '\' の繰り返しが 2 回行われていることに注意してください。"+cmd" の引数なので 1 回、コマンド "@command{:set}" のためにもう 1 回です。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*file-formats*
The 'fileformat' option sets the <EOL> style for a file:
'fileformat'    characters	   name				~
  "dos"		<CR><NL> or <NL>   DOS format		*DOS-format*
  "unix"	<NL>		   Unix format		*Unix-format*
  "mac"		<CR>		   Mac format		*Mac-format*
Previously 'textmode' was used.  It is obsolete now.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{file-formats}
@cindex file-formats
オプション '@option{fileformat}' はファイルに対して <EOL> の形式を設定します:
@multitable @columnfractions .3 .45 .25
@headitem '@option{fileformat}' @tab <EOL> の文字 @tab 形式の名称
@anchor{DOS-format}
@cindex DOS-format
@item "dos" @tab <CR><NL> または <NL> @tab DOS 形式
@anchor{Unix-format}
@cindex Unix-format
@item "unix" @tab <NL> @tab Unix 形式
@anchor{Mac-format}
@cindex Mac-format
@item "mac" @tab <CR> @tab Mac 形式
@end multitable
以前はオプション '@option{textmode}' が使われていました。現在ではそれはもはや使われていません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When reading a file, the mentioned characters are interpreted as the <EOL>.
In DOS format (default for MS-DOS, OS/2 and Win32), <CR><NL> and <NL> are both
interpreted as the <EOL>.  Note that when writing the file in DOS format,
<CR> characters will be added for each single <NL>.  Also see |file-read|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルを読み込むときに、上で述べた文字は <EOL> として解釈されます。DOS 形式 (MS-DOS、OS/2 と Win32 での既定値) では、<CR><NL> と <NL> の両方が <EOL> と解釈されます。
@quotation
@strong{Note:} @*
DOS 形式でファイルを保存するときには、<NL> 1 個ごとに対して <CR> が追加されることに注意してください。|@ref{file-read}| も参照してください。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When writing a file, the mentioned characters are used for <EOL>.  For DOS
format <CR><NL> is used.  Also see |DOS-format-write|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルを書き込むときには、上で述べた文字が <EOL> として使われます。DOS 形式では <CR><NL> が使われます。|@ref{DOS-format-write}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can read a file in DOS format and write it in Unix format.  This will
replace all <CR><NL> pairs by <NL> (assuming 'fileformats' includes "dos"): >
	:e file
	:set fileformat=unix
	:w
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
DOS 形式でファイルを読み込んで、Unix 形式でそれを保存することも可能です。('@option{fileformats}' が "dos" を含んでいると仮定すると) 以下の操作は全ての <CR><NL> を <NL> で置き換えることになります。
@verbatim
:e ファイル
:set fileformat=unix
:w
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
If you read a file in Unix format and write with DOS format, all <NL>
characters will be replaced with <CR><NL> (assuming 'fileformats' includes
"unix"): >
	:e file
	:set fileformat=dos
	:w
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
('@option{fileformats}' の値に "unix" が含まれているとき) Unix 形式でファイルを読み込んで、DOS 形式で保存すると、<NL> は全て <CR><NL> で置き換えられます。
@verbatim
:e ファイル
:set fileformat=dos
:w
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you start editing a new file and the 'fileformats' option is not empty
(which is the default), Vim will try to detect whether the lines in the file
are separated by the specified formats.  When set to "unix,dos", Vim will
check for lines with a single <NL> (as used on Unix and Amiga) or by a <CR>
<NL> pair (MS-DOS).  Only when ALL lines end in <CR><NL>, 'fileformat' is set
to "dos", otherwise it is set to "unix".  When 'fileformats' includes "mac",
and no <NL> characters are found in the file, 'fileformat' is set to "mac".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しいファイルの編集を開始したときオプション '@option{fileformats}' の値が空でないなら (それがデフォルト)、Vim はファイルが指定された形式で改行されているかどうか検出を試みます。値が "@var{unix},@var{dos}" であるときは、Vim は 1 個の <NL> (Unix と Amiga 形式) か <CR><NL> の組 (MS-DOS 形式) が使われるものとして行を調べます。全ての行が <CR><NL> で終わっているときだけ、'@option{fileformat}' の値は "@var{dos}" に設定され、そうでなければ "@var{unix}" に設定されます。'@option{fileformats}' の値が "@var{mac}" を含んでいて、ファイルに <NL> が 1 個も見つからないときは、'@option{fileformat}' の値は "@var{mac}" に設定されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the 'fileformat' option is set to "dos" on non-MS-DOS systems the message
"[dos format]" is shown to remind you that something unusual is happening.  On
MS-DOS systems you get the message "[unix format]" if 'fileformat' is set to
"unix".  On all systems but the Macintosh you get the message "[mac format]"
if 'fileformat' is set to "mac".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{fileformat}' の値が MS-DOS 以外のシステム上で "@var{dos}" に設定されると、普通でないことが起きていることを気づかせるために、メッセージ "[dosフォーマット]" が表示されます。'@option{fileformat}' の値が "@var{unix}" であると、MS-DOSシステムでは "[unixフォーマット]" のメッセージが表示されます。'@option{fileformat}' の値が "@var{mac}" であると、Macintosh 以外の全てのシステムでは、メッセージ "[macフォーマット]" が表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the 'fileformats' option is empty and DOS format is used, but while reading
a file some lines did not end in <CR><NL>, "[CR missing]" will be included in
the file message.
If the 'fileformats' option is empty and Mac format is used, but while reading
a file a <NL> was found, "[NL missing]" will be included in the file message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{fileformats}' の値が空で、DOS 形式が使用されているけれども、ファイルを読み込んでいるときにいくつかの行が <CR><NL> で終わっていなかったならば、ファイルのメッセージ内に "[CR無]" が含まれます。

'@option{fileformats}' の値が空で、Mac 形式が使用されているけれども、ファイルを読み込んでいるときに <NL> が見つかったならば、ファイルのメッセージ内に "[NL無]" が含まれます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the new file does not exist, the 'fileformat' of the current buffer is used
when 'fileformats' is empty.  Otherwise the first format from 'fileformats' is
used for the new file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しいファイルが存在しないと、'@option{fileformats}' の値が空のときにはカレントバッファの '@option{fileformat}' の値が使われます。そうでなければ、'@option{fileformats}' 内の 1 番目の形式が新しいファイルに対して用いられます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Before editing binary, executable or Vim script files you should set the
'binary' option.  A simple way to do this is by starting Vim with the "-b"
option.  This will avoid the use of 'fileformat'.  Without this you risk that
single <NL> characters are unexpectedly replaced with <CR><NL>.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
実行可能ファイルやバイナリファイル、Vim script ファイルを編集する前には、オプション '@option{binary}' をオンに設定するべきです。これにはオプション "-b" を付けて Vim を起動するのが簡単です。こうすると '@option{fileformat}' が使われなくなります。こうしないと 1 個の <NL> が不意に <CR><NL> で置き換えられてしまうことを覚悟しなければなりません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can encrypt files that are written by setting the 'key' option.  This
provides some security against others reading your files. |encryption|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{key}' をオンに設定することで、保存されるファイルを暗号化できます。これは他人がユーザーのファイルを読むことに対して、ある程度の安全を保証します。|@ref{encryption}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
==============================================================================
3. The argument list				*argument-list* *arglist*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{argument-list}
@anchor{arglist}
@cindex argument-list
@cindex arglist
@cindex 引数リスト
@section 3. 引数リスト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you give more than one file name when starting Vim, this list is remembered
as the argument list.  You can jump to each file in this list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim の開始時に複数のファイル名を与えると、それらは引数リストとして記憶されます。リスト内のファイルにはどれでも移動できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Do not confuse this with the buffer list, which you can see with the
|:buffers| command.  The argument list was already present in Vi, the buffer
list is new in Vim.  Every file name in the argument list will also be present
in the buffer list (unless it was deleted with |:bdel| or |:bwipe|).  But it's
common that names in the buffer list are not in the argument list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これをコマンド |@ref{:buffers}| で表示されるバッファリストと混同してはいけません。引数リストは Vi から既にありましたが、バッファリストは Vim で新たに導入されました。引数リスト内のファイルはバッファリストにも含まれます (コマンド |@ref{:bdel}| や |@ref{:bwipe}| で消去されない限り)。逆にバッファリスト内のファイルが引数リストに含まれないことは普通にあります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This subject is introduced in section |07.2| of the user manual.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この話題はユーザーマニュアルの第 |@ref{07.2}| 章で紹介されています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There is one global argument list, which is used for all windows by default.
It is possible to create a new argument list local to a window, see
|:arglocal|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
グローバルな引数リストが 1 個あり、これは既定では全てのウィンドウに使われます。ウィンドウについてローカルな引数リストを新たに創ることもできます。|@ref{:arglocal}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use the argument list with the following commands, and with the
expression functions |argc()| and |argv()|.  These all work on the argument
list of the current window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数リストは以下のコマンド及び expression 用関数 |@ref{argc()}| と |@ref{argv()}| で利用することができます。これらはみなカレントウィンドウの引数リストに対して働きます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:ar* *:arg* *:args*
:ar[gs]			Print the argument list, with the current file in
			square brackets.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:ar}
@anchor{:arg}
@anchor{:args}
@pindex :ar
@pindex :arg
@pindex :args
@table @asis
@item :ar[gs]
引数リストを表示します。カレントファイルは '[' ']' で挟まれて表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:ar[gs] [++opt] [+cmd] {arglist}			*:args_f*
			Define {arglist} as the new argument list and edit
			the first one.  This fails when changes have been made
			and Vim does not want to |abandon| the current buffer.
			Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:args_f}
@pindex :args_f
@item :ar[gs] [++opt] [+cmd] @{arglist@}
@{arglist@} を新たな引数リストとして定義し、そのうち最初のファイルの編集を始めます。変更点があり、Vim がカレントバッファを放棄 |@ref{abandon}| したくないときには失敗します。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:ar[gs]! [++opt] [+cmd] {arglist}			*:args_f!*
			Define {arglist} as the new argument list and edit
			the first one.  Discard any changes to the current
			buffer.
			Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:args_f!}
@pindex :args_f!
@item :ar[gs]! [++opt] [+cmd] @{arglist@}
@{arglist@} を新たな引数リストとして定義し、そのうち最初のファイルの編集を始めます。カレントバッファに対する変更点は全て失われます。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[count]arge[dit][!] [++opt] [+cmd] {name} ..		*:arge* *:argedit*
			Add {name}s to the argument list and edit it.
			When {name} already exists in the argument list, this
			entry is edited.
			This is like using |:argadd| and then |:edit|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:arge}
@anchor{:argedit}
@pindex :arge
@pindex :argedit
@item :[count]arge[dit][!] [++opt] [+cmd] @{name@} ..
引数リストに @{name@}s を追加し、その編集を始めます。@{name@} が既に引数リスト内にあるときは、その編集を始めます。これはコマンド |@ref{:argadd}| を使い、次に |@ref{:edit}| を使うのと同じです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Spaces in filenames have to be escaped with "\".
			[count] is used like with |:argadd|.
			If the current file cannot be |abandon|ed {name}s will
			still be added to the argument list, but won't be
			edited. No check for duplicates is done.
			Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

ファイル名中のスペースは "\" でエスケープされなければなりません。

[count] は |@ref{:argadd}| と同様に使われます。

もしもカレントファイルが放棄 |@ref{abandon}| することができないなら、編集されていないことを除いて、引数リストに @{name@}s が加えられます。複製の終了はチェックしません。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[count]arga[dd] {name} ..			*:arga* *:argadd* *E479*
:[count]arga[dd]
			Add the {name}s to the argument list.  When {name} is
			omitted add the current buffer name to the argument
			list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:arga}
@anchor{:argadd}
@anchor{E479}
@pindex :arga
@pindex :argadd
@erindex E479
@item :[count]arga[dd] @{name@} ..
@itemx :[count]arga[dd]
引数リストに @{name@} を追加します。@{name@} が省略された時は引数リストに現在のバッファ名を追加します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			If [count] is omitted, the {name}s are added just
			after the current entry in the argument list.
			Otherwise they are added after the [count]'th file.
			If the argument list is "a b c", and "b" is the
			current argument, then these commands result in:
				command		new argument list ~
				:argadd x	a b x c
				:0argadd x	x a b c
				:1argadd x	a x b c
				:$argadd x	a b c x
			And after the last one:
				:+2argadd y	a b c x y
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[count] が省かれると @{name@} は引数リストの現在の項目の次に挿入されます。指定されると [count] 番目の項目の次に挿入されます。引数リストが "a b c" で "b" が現在の引数の場合のコマンドの結果一覧:
@multitable @columnfractions .5 .5
@headitem コマンド @tab 新たな引数リスト
@item :argadd x @tab a b x c
@item :0argadd x @tab x a b c
@item :1argadd x @tab a x b c
@item :$argadd x @tab a b c x
@end multitable
最後の 1 つの後に:
@multitable @columnfractions .5 .5
@item :+2argadd y @tab a b c x y
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			There is no check for duplicates, it is possible to
			add a file to the argument list twice.
			The currently edited file is not changed.
			Note: you can also use this method: >
				:args ## x
<			This will add the "x" item and sort the new list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
重複検査はないので、1 個のファイルを引数リストに 2 回加えることもできます。現在編集中のファイルは変更されません。
@quotation
@strong{Note:} @*
次の方法が使えることに注意してください。
@verbatim
:args ## x
@end verbatim
これは項目 "x" を追加して新たなリストを並び替えます。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:argd[elete] {pattern} ..			*:argd* *:argdelete* *E480*
			Delete files from the argument list that match the
			{pattern}s.  {pattern} is used like a file pattern,
			see |file-pattern|.  "%" can be used to delete the
			current entry.
			This command keeps the currently edited file, also
			when it's deleted from the argument list.
			Example: >
				:argdel *.obj
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:argd}
@anchor{:argdelete}
@anchor{E480}
@pindex :argd
@pindex :argdelete
@erindex E480
@item :argd[elete] @{pattern@} ..
@{pattern@} にマッチするファイルを引数リストから削除します。@{pattern@} の意味はファイルパターンと同様なので、|@ref{file-pattern}| を参照してください。現在の項目を削除するには "%" が使えます。

このコマンドは現在編集中のファイルが引数リストから削除されたときでも、それをそのままに保ちます。

例:
@verbatim
:argdel *.obj
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]argd[elete]	Delete the {range} files from the argument list.
			Example: >
				:10,$argdel
<			Deletes arguments 10 and further, keeping 1-9. >
				:$argd
<			Deletes just the last one. >
				:argd
				:.argd
<			Deletes the current argument. >
				:%argd
<			Removes all the files from the arglist.
			When the last number in the range is too high, up to
			the last argument is deleted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[range]argd[elete]
引数リストから @{range@} の範囲のファイルを削除します。

例:
@verbatim
:10,$argdel
@end verbatim
10 以降が削除され、1 から 9 は残ります。
@verbatim
:$argd
@end verbatim
最後の引数を削除します。
@verbatim
:argd
:.argd
@end verbatim
現在の引数を削除します。
@verbatim
:%argd
@end verbatim
引数リストから全てのファイルを削除します。範囲の上限が大きすぎるときは、最後の引数までが削除されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:argu* *:argument*
:[count]argu[ment] [count] [++opt] [+cmd]
			Edit file [count] in the argument list.  When [count]
			is omitted the current entry is used.  This fails
			when changes have been made and Vim does not want to
			|abandon| the current buffer.
			Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:argu}
@anchor{:argument}
@pindex :argu
@pindex :argument
@item :[count]argu[ment] [count] [++opt] [+cmd]
引数リスト内で [count] 番目のファイルを編集します。[count] が省かれると現在の項目を編集します。変更点があり、Vim がカレントバッファを放棄 |@ref{abandon}| したくないときには失敗します。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[count]argu[ment]! [count] [++opt] [+cmd]
			Edit file [count] in the argument list, discard any
			changes to the current buffer.  When [count] is
			omitted the current entry is used.
			Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[count]argu[ment]! [count] [++opt] [+cmd]
引数リスト内で [count] 番目のファイルを編集します。カレントバッファに対するいかなる変更も失われます。[count] が省かれると現在の項目を編集します。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[count]n[ext] [++opt] [+cmd]			*:n* *:ne* *:next* *E165* *E163*
			Edit [count] next file.  This fails when changes have
			been made and Vim does not want to |abandon| the
			current buffer.  Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:n}
@anchor{:ne}
@anchor{:next}
@anchor{E165}
@anchor{E163}
@pindex :n
@pindex :ne
@pindex :next
@erindex E165
@erindex E163
@item :[count]n[ext] [++opt] [+cmd]
引数リストの中で [count] 個次のファイルを編集します。変更点があり、Vim がカレントバッファを放棄 |@ref{abandon}| したくないときには失敗します。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[count]n[ext]! [++opt] [+cmd]
			Edit [count] next file, discard any changes to the
			buffer.  Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[count]n[ext]! [++opt] [+cmd]
引数リストの中で [count] 個次のファイルを編集します。カレントバッファに対するいかなる変更も失われます。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:n[ext] [++opt] [+cmd] {arglist}			*:next_f*
			Same as |:args_f|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:next_f}
@pindex :next_f
@item :n[ext] [++opt] [+cmd] @{arglist@}
コマンド |@ref{:args_f}| と同じです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:n[ext]! [++opt] [+cmd] {arglist}
			Same as |:args_f!|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :n[ext]! [++opt] [+cmd] @{arglist@}
コマンド |@ref{:args_f!}| と同じです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[count]N[ext] [count] [++opt] [+cmd]			*:Next* *:N* *E164*
			Edit [count] previous file in argument list.  This
			fails when changes have been made and Vim does not
			want to |abandon| the current buffer.
			Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:Next}
@anchor{:N}
@anchor{E164}
@pindex :Next
@pindex :N
@erindex E164
@item :[count]N[ext] [count] [++opt] [+cmd]
引数リストの中で [count] 個前のファイルを編集します。変更点があり、Vim がカレントバッファを破棄 |@ref{abandon}| したくないときには失敗します。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[count]N[ext]! [count] [++opt] [+cmd]
			Edit [count] previous file in argument list.  Discard
			any changes to the buffer.  Also see |++opt| and
			|+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[count]N[ext]! [count] [++opt] [+cmd]
引数リスト内で [count] 個前のファイルを編集します。カレントバッファに対するいかなる変更も失われます。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[count]prev[ious] [count] [++opt] [+cmd]		*:prev* *:previous*
			Same as :Next.  Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:prev}
@anchor{:previous}
@pindex :prev
@pindex :previous
@item :[count]prev[ious] [count] [++opt] [+cmd]
コマンド |@ref{:Next}| と同じです。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:rew* *:rewind*
:rew[ind] [++opt] [+cmd]
			Start editing the first file in the argument list.
			This fails when changes have been made and Vim does
			not want to |abandon| the current buffer.
			Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:rew}
@anchor{:rewind}
@pindex :rew
@pindex :rewind
@item :rew[ind] [++opt] [+cmd]
引数リスト内で最初のファイルの編集を始めます。変更点があり、Vim がカレントバッファを放棄 |@ref{abandon}| したくないときには失敗します。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:rew[ind]! [++opt] [+cmd]
			Start editing the first file in the argument list.
			Discard any changes to the buffer.  Also see |++opt|
			and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :rew[ind]! [++opt] [+cmd]
引数リスト内で最初のファイルを編集します。カレントバッファに対するいかなる変更も失われます。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:fir* *:first*
:fir[st][!] [++opt] [+cmd]
			Other name for ":rewind".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:fir}
@anchor{:first}
@pindex :fir
@pindex :first
@item :fir[st][!] [++opt] [+cmd]
コマンド |@ref{:rewind}| の別名。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:la* *:last*
:la[st] [++opt] [+cmd]
			Start editing the last file in the argument list.
			This fails when changes have been made and Vim does
			not want to |abandon| the current buffer.
			Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:la}
@anchor{:last}
@pindex :la
@pindex :last
@item :la[st] [++opt] [+cmd]
引数リスト内で最後のファイルの編集を始めます。変更点があり、Vim がカレントバッファを放棄 |@ref{abandon}| したくないときには失敗します。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:la[st]! [++opt] [+cmd]
			Start editing the last file in the argument list.
			Discard any changes to the buffer.  Also see |++opt|
			and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :la[st]! [++opt] [+cmd]
引数リスト内で最初のファイルを編集します。カレントバッファに対するいかなる変更も失われます。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:wn* *:wnext*
:[count]wn[ext] [++opt]
			Write current file and start editing the [count]
			next file.  Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:wn}
@anchor{:wnext}
@pindex :wn
@pindex :wnext
@item :[count]wn[ext] [++opt]
カレントファイルを書き込み、引数リスト内で [count] 個次のファイルの編集を始めます。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[count]wn[ext] [++opt] {file}
			Write current file to {file} and start editing the
			[count] next file, unless {file} already exists and
			the 'writeany' option is off.  Also see |++opt| and
			|+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[count]wn[ext] [++opt] @{file@}
カレントファイルを @{file@} に書き込み、引数リスト内で [count] 個次のファイルの編集を始めます。ただし @{file@} が既に存在し、オプション '@option{writeany}' がオフのときは失敗します。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[count]wn[ext]! [++opt] {file}
			Write current file to {file} and start editing the
			[count] next file.  Also see |++opt| and |+cmd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[count]wn[ext]! [++opt] @{file@}
カレントファイルを @{file@} に書き込み、引数リスト内で [count] 個次のファイルの編集を始めます。

|@ref{++opt}| と |@ref{+cmd}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[count]wN[ext][!] [++opt] [file]		*:wN* *:wNext*
:[count]wp[revious][!] [++opt] [file]		*:wp* *:wprevious*
			Same as :wnext, but go to previous file instead of
			next.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:wN}
@anchor{:wNext}
@anchor{:wp}
@anchor{:wprevious}
@pindex :wN
@pindex :wNext
@pindex :wp
@pindex :wprevious
@item :[count]wN[ext][!] [++opt] [file]
@itemx :[count]wp[revious][!] [++opt] [file]
コマンド |@ref{:wnext}| と同じですが、次でなく前のファイルに移ります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The [count] in the commands above defaults to one.  For some commands it is
possible to use two counts.  The last one (rightmost one) is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上のコマンドの [count] の既定値は 1 です。[count] を 2 回使えるコマンドもあります。最後 (最も右) のものが使われます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If no [+cmd] argument is present, the cursor is positioned at the last known
cursor position for the file.  If 'startofline' is set, the cursor will be
positioned at the first non-blank in the line, otherwise the last know column
is used.  If there is no last known cursor position the cursor will be in the
first line (the last line in Ex mode).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数 [+cmd] が存在しないなら、カーソルはそのファイルに対して最後に認識された位置に置かれます。オプション '@option{startofline}' がオンのときは、カーソルは行の最初の非空白文字に置かれ、オフのときは最後に認識された列が使われます。最後に認識されたカーソル位置がないときは、カーソルは最初の行 (Ex モードでは最後の行) に置かれます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*{arglist}*
The wildcards in the argument list are expanded and the file names are sorted.
Thus you can use the command "vim *.c" to edit all the C files.  From within
Vim the command ":n *.c" does the same.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{@{arglist@}}
@cindex @{arglist@}
引数リスト内のワイルドカードは展開され、ファイル名は並び替えられます。ですから C のソースファイルを全て編集するには、コマンド "vim *.c" が使えます。Vim の中でコマンド ":n *.c" としても同じです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
White space is used to separate file names.  Put a backslash before a space or
tab to include it in a file name.  E.g., to edit the single file "foo bar": >
	:next foo\ bar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイル名は空白文字によって区切られます。ファイル名にスペースまたはタブを含めるには、その前にバックスラッシュを書いてください。例えば、"foo bar" という 1 つのファイルを開くにはこうします:
@verbatim
:next foo\ bar
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
On Unix and a few other systems you can also use backticks, for example: >
	:next `find . -name \\*.c -print`
The backslashes before the star are required to prevent "*.c" to be expanded
by the shell before executing the find program.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Unix およびその他いくつかのシステムではバッククォートも使えます。例:
@verbatim
:n `find . -name \\*.c -print`
@end verbatim
アスタリスクの前の '\' は、"*.c" がプログラム find を実行する前にシェルで展開されるのを防ぐために必要となります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*arglist-position*
When there is an argument list you can see which file you are editing in the
title of the window (if there is one and 'title' is on) and with the file
message you get with the "CTRL-G" command.  You will see something like
	(file 4 of 11)
If 'shortmess' contains 'f' it will be
	(4 of 11)
If you are not really editing the file at the current position in the argument
list it will be
	(file (4) of 11)
This means that you are position 4 in the argument list, but not editing the
fourth file in the argument list.  This happens when you do ":e file".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{arglist-position}
@cindex arglist-position
引数リストがあるときは、ウィンドウのタイトル (それがあって、オプション '@option{title}' オンならば) やコマンド @kbd{CTRL-G} で出るファイルメッセージで編集しているファイルを知ることができます。次のようなものが表示されるでしょう。
@verbatim
(file 4 of 11)
@end verbatim
オプション '@option{shortmess}' の値が '@var{f}' を含んでいるときは以下のようになります。
@verbatim
(4 of 11)
@end verbatim
実際は引数リスト内の現在の位置でないファイルを編集しているなら、以下のようになります。
@verbatim
(file (4) of 11)
@end verbatim
これは、引数リストの中の 4 番目にいるけれども、編集中のファイルは引数リストの中の 4 番目でないことを意味します。これは "@command{:e file}" をするときに起こります。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
LOCAL ARGUMENT LIST
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex ローカルな引数リスト
@unnumberedsubsec ローカルな引数リスト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:arglocal*
:argl[ocal]		Make a local copy of the global argument list.
			Doesn't start editing another file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:arglocal}
@pindex :arglocal
@table @asis
@item :argl[ocal]
グローバルな引数リストのローカルなコピーを作ります。別のファイルの編集は始めません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:argl[ocal][!] [++opt] [+cmd] {arglist}
			Define a new argument list, which is local to the
			current window.  Works like |:args_f| otherwise.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :argl[ocal][!] [++opt] [+cmd] @{arglist@}
カレントウィンドウについてローカルな、新たな引数リストを定義します。ウィンドウが 1 個のときは |@ref{:args_f}| と同じです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:argglobal*
:argg[lobal]		Use the global argument list for the current window.
			Doesn't start editing another file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:argglobal}
@pindex :argglobal
@item :argg[lobal]
カレントウィンドウにグローバルな引数リストを使います。別のファイルの編集は始めません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:argg[lobal][!] [++opt] [+cmd] {arglist}
			Use the global argument list for the current window.
			Define a new global argument list like |:args_f|.
			All windows using the global argument list will see
			this new list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :argg[lobal][!] [++opt] [+cmd] @{arglist@}
カレントウィンドウにグローバルな引数リストを使います。コマンド |@ref{:args_f}| と同様、グローバルな引数リストを新たに定義します。グローバルな引数リストを使っているウィンドウは全てこの新しいリストを参照するようになります。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There can be several argument lists.  They can be shared between windows.
When they are shared, changing the argument list in one window will also
change it in the other window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
複数の引数リストが存在可能であり、それらはウィンドウ同士で共有できます。共有されているときは、あるウィンドウ内で引数リストに変更を加えると、別のウィンドウの引数リストも影響を受けます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When a window is split the new window inherits the argument list from the
current window.  The two windows then share this list, until one of them uses
|:arglocal| or |:argglobal| to use another argument list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ウィンドウが分割されると、新しいウィンドウはカレントウィンドウから引数リストを受け継ぎます。すると 2 個のウィンドウは、片方でコマンド |@ref{:arglocal}| か |@ref{:argglobal}| を使って別の引数リストを使うようになるまで、そのリストを共有することになります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
USING THE ARGUMENT LIST
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@cindex 引数リストを使う
@unnumberedsubsec 引数リストを使う
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:argdo*
:[range]argdo[!] {cmd}	Execute {cmd} for each file in the argument list or
			if [range] is specified only for arguments in that
			range.  It works like doing this: >
				:rewind
				:{cmd}
				:next
				:{cmd}
				etc.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:argdo}
@pindex :argdo
@table @asis
@item :[range]argdo[!] @{cmd@}
引数リスト内の全てのファイルで @{cmd@} を実行します。または [range] が指定された場合、その範囲内の引数のみで実行します。以下と同様の動作になります。
@verbatim
:rewind
:{cmd}
:next
:{cmd}
etc.
@end verbatim
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<			When the current file can't be |abandon|ed and the [!]
			is not present, the command fails.
			When an error is detected on one file, further files
			in the argument list will not be visited.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カレントファイルを放棄 |@ref{abandon}| できず、'!' も付けられていないときは、実行は失敗します。どれかのファイル内でエラーが検出されると、引数リスト内の以降のファイルには進みません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			The last file in the argument list (or where an error
			occurred) becomes the current file.
			{cmd} can contain '|' to concatenate several commands.
			{cmd} must not change the argument list.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数リスト末尾のファイル (またはエラーの起きたファイル) がカレントファイルになります。@{cmd@} の中では '|' で複数のコマンドを連結できます。@{cmd@} は引数リストに変更を加えてはいけません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Note: While this command is executing, the Syntax
			autocommand event is disabled by adding it to
			'eventignore'.  This considerably speeds up editing
			each file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
このコマンドの実行中、オプション '@option{eventignore}' で自動コマンドのイベント Syntax を指定することでそれを無効化することができます。こうすると各ファイルの処理がかなり高速になります。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Also see |:windo|, |:tabdo|, |:bufdo|, |:cdo|, |:ldo|,
			|:cfdo| and |:lfdo|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

|@ref{:windo}|, |@ref{:tabdo}|, |@ref{:bufdo}|, |@ref{:cdo}|, |@ref{:ldo}|, |@ref{:cfdo}|, |@ref{:lfdo}| も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Example: >
	:args *.c
	:argdo set ff=unix | update
This sets the 'fileformat' option to "unix" and writes the file if it is now
changed.  This is done for all *.c files.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@verbatim
:args *.c
:argdo set ff=unix | update
@end verbatim
こうするとオプション '@option{fileformat}' の値を "unix" に設定し、変更があったファイルを保存します。それが全ての *.c ファイルについて行われます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Example: >
	:args *.[ch]
	:argdo %s/\<my_foo\>/My_Foo/ge | update
This changes the word "my_foo" to "My_Foo" in all *.c and *.h files.  The "e"
flag is used for the ":substitute" command to avoid an error for files where
"my_foo" isn't used.  ":update" writes the file only if changes were made.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@verbatim
:args *.[ch]
:argdo %s/\<my_foo\>/My_Foo/ge | update
@end verbatim
こうすると全ての *.c ファイルと *.h ファイルで単語 "my_foo" を "My_Foo" に変えます。コマンド "@command{:substitute}" でフラグ "e" を使って "my_foo" という単語の使われていないファイルでエラーが起きるのを防いでいます。コマンド "@command{:update}" は変更のあったファイルのみを保存します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
4. Writing					*writing* *save-file*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{writing}
@anchor{save-file}
@cindex writing
@cindex save-file
@cindex 書き込み
@section 4. 書き込み
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: When the 'write' option is off, you are not able to write any file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:}@*
オプション '@option{write}' がオフのときは、どのファイルも書き込めないことに注意してください。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:w* *:write*
					*E502* *E503* *E504* *E505*
					*E512* *E514* *E667* *E796* *E949*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:w}
@anchor{:write}
@anchor{E502}
@anchor{E503}
@anchor{E504}
@anchor{E505}
@anchor{E512}
@anchor{E514}
@anchor{E667}
@anchor{E796}
@pindex :w
@pindex :write
@erindex E502
@erindex E503
@erindex E504
@erindex E505
@erindex E512
@erindex E514
@erindex E667
@erindex E796
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
:w[rite] [++opt]	Write the whole buffer to the current file.  This is
			the normal way to save changes to a file.  It fails
			when the 'readonly' option is set or when there is
			another reason why the file can't be written.
			For ++opt see |++opt|, but only ++bin, ++nobin, ++ff
			and ++enc are effective.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item :w[rite] [++opt]
バッファ全体をカレントファイルに書き込みます。これはファイルに対する変更点を保存するときの普通の方法です。オプション '@option{readonly}' がオンであるかファイルに書き込めない理由が何かあるときには実行に失敗します。

++opt については |@ref{++opt}| を参照してください。ただし ++bin, ++nobin, ++ff, ++enc だけが有効です。@{訳注: 他に ++bad, ++edit もあるけれど、この 2 つは @command{:w} のオプションに使えないということ@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:w[rite]! [++opt]	Like ":write", but forcefully write when 'readonly' is
			set or there is another reason why writing was
			refused.
			Note: This may change the permission and ownership of
			the file and break (symbolic) links.  Add the 'W' flag
			to 'cpoptions' to avoid this.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :w[rite]! [++opt]
"@command{:write}" と似ていますが、'@option{readonly}' がオンであったり書き込みが拒否される理由があっても無理矢理書き込みを行います。
@quotation
@strong{Note:} @*
これはファイルの権限や所属を変更したり、(シンボリック) リンクを途切れさせるかもしれないことに注意してください。それを避けるには '@option{cpoptions}' にフラグ '@var{W}' を追加してください。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]w[rite][!] [++opt]
			Write the specified lines to the current file.  This
			is unusual, because the file will not contain all
			lines in the buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[range]w[rite][!] [++opt]
指定された範囲の行をカレントファイルに書き出します。これは普通の操作ではありません。ファイルがバッファ内の全ての行を含むようにならないからです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:w_f* *:write_f*
:[range]w[rite] [++opt]	{file}
			Write the specified lines to {file}, unless it
			already exists and the 'writeany' option is off.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:w_f}
@anchor{:write_f}
@pindex :w_f
@pindex :write_f
@item :[range]w[rite] [++opt] @{file@}
指定された範囲の行をファイル @{file@} に書き出します。ただしそれが既に存在し、かつオプション '@option{writeany}' がオフのときは失敗します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:w!*
:[range]w[rite]! [++opt] {file}
			Write the specified lines to {file}.  Overwrite an
			existing file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:w!}
@pindex :w!
@item :[range]w[rite]! [++opt] @{file@}
指定された範囲の行をファイル @{file@} に書き出します。既存のファイルは上書きされます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:w_a* *:write_a* *E494*
:[range]w[rite][!] [++opt] >>
			Append the specified lines to the current file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:w_a}
@anchor{:write_a}
@anchor{E494}
@pindex :w_a
@pindex :write_a
@erindex E494
@item :[range]w[rite][!] [++opt] >>
指定された範囲の行をカレントファイルに追加します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]w[rite][!] [++opt] >> {file}
			Append the specified lines to {file}.  '!' forces the
			write even if file does not exist.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[range]w[rite][!] [++opt] >> @{file@}
指定された範囲の行をファイル @{file@} に追加します。'!' を付けるとそのファイルがまだ存在しなくても書き込みを行います。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:w_c* *:write_c*
:[range]w[rite] [++opt] !{cmd}
			Execute {cmd} with [range] lines as standard input
			(note the space in front of the '!').  {cmd} is
			executed like with ":!{cmd}", any '!' is replaced with
			the previous command |:!|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:w_c}
@anchor{:write_c}
@pindex :w_c
@pindex :write_c
@item :[range]w[rite] [++opt] !@{cmd@}
[range] の行を標準入力として @{cmd@} を実行します ('!' の前の空白に注意)。@{cmd@} は ":!@{cmd@}" のように実行され、全ての '!' は前回のコマンドに置き換えられます |@ref{:!}。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The default [range] for the ":w" command is the whole buffer (1,$).  If you
write the whole buffer, it is no longer considered changed.  When you
write it to a different file with ":w somefile" it depends on the "+" flag in
'cpoptions'.  When included, the write command will reset the 'modified' flag,
even though the buffer itself may still be different from its file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
コマンド "@command{:w}" での [range] の既定値はバッファ全体 (1,$) です。バッファ全体を書き込むと、そのバッファは変更されていないとみなされるようになります。

"@command{:w somefile}" によって別のファイルに書き出した場合は、'@option{cpoptions}' の "+" フラグに依存します。"+" が含まれている場合は、バッファがまだ元のファイルと異なっていたとしても、書き込みコマンドによって '@option{modified}' フラグがオフになります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If a file name is given with ":w" it becomes the alternate file.  This can be
used, for example, when the write fails and you want to try again later with
":w #".  This can be switched off by removing the 'A' flag from the
'cpoptions' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"@command{:w}" にファイル名が与えられるとそれが代替ファイルになります。これは例えば書き込みに失敗した後に "@command{:w #}" でもう一度試したいときに使えます。オプション '@option{cpoptions}' からフラグ '@var{A}' を取り除くとこれを無効化できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that the 'fsync' option matters here.  If it's set it may make writes
slower (but safer).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
書き込みには '@option{fsync}' オプションが関係してきます。設定されている場合には書き込みがより遅くなるかもしれません。(しかしより安全です。)
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:sav* *:saveas*
:sav[eas][!] [++opt] {file}
			Save the current buffer under the name {file} and set
			the filename of the current buffer to {file}.  The
			previous name is used for the alternate file name.
			The [!] is needed to overwrite an existing file.
			When 'filetype' is empty filetype detection is done
			with the new name, before the file is written.
			When the write was successful 'readonly' is reset.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:sav}
@anchor{:saveas}
@pindex :sav
@pindex :saveas
@item :sav[eas][!] [++opt] @{file@}
カレントファイルをファイル名 @{file@} として保存し、カレントバッファのファイル名を @{file@} に変えます。それまでのカレントファイルの名前は代替ファイルの名前になります。既存のファイルを上書きするには [!] が必要になります。

'@option{filetype}' が空の場合、保存の前に新しいファイル名に対してファイルタイプ検出が行われます。保存が成功すると '@option{readonly}' がオフになります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:up* *:update*
:[range]up[date][!] [++opt] [>>] [file]
			Like ":write", but only write when the buffer has been
			modified.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:up}
@anchor{:update}
@pindex :up
@pindex :update
@item :[range]up[date][!] [++opt] [>>] [file]
"@command{:write}" と似ていますが、バッファに変更点があるときのみ書き込みを行います。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
WRITING WITH MULTIPLE BUFFERS				*buffer-write*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{buffer-write}
@cindex buffer-write
@unnumberedsubsec 複数バッファでの書き込み
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:wa* *:wall*
:wa[ll]			Write all changed buffers.  Buffers without a file
			name cause an error message.  Buffers which are
			readonly are not written.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:wa}
@anchor{:wall}
@pindex :wa
@pindex :wall
@table @asis
@item :wa[ll]
変更点のあるバッファを全て書き込みます。ファイル名を持たないバッファに対してはエラーメッセージが表示されます。読み込み専用のバッファは書き込まれません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:wa[ll]!		Write all changed buffers, even the ones that are
			readonly.  Buffers without a file name are not
			written and cause an error message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :wa[ll]!
変更点のあるバッファを、読み込み専用であっても全て書き込みます。ファイル名を持たないバッファは書き込まれず、エラーメッセージが表示されます。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Vim will warn you if you try to overwrite a file that has been changed
elsewhere.  See |timestamp|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は別の場所で変更を受けたファイルを上書きしようとしたときには警告します。|@ref{timestamp}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			    *backup* *E207* *E506* *E507* *E508* *E509* *E510*
If you write to an existing file (but do not append) while the 'backup',
'writebackup' or 'patchmode' option is on, a backup of the original file is
made.  The file is either copied or renamed (see 'backupcopy').  After the
file has been successfully written and when the 'writebackup' option is on and
the 'backup' option is off, the backup file is deleted.  When the 'patchmode'
option is on the backup file may be renamed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{backup}
@anchor{E207}
@anchor{E506}
@anchor{E507}
@anchor{E508}
@anchor{E509}
@anchor{E510}
@cindex backup
@erindex E207
@erindex E506
@erindex E507
@erindex E508
@erindex E509
@erindex E510
オプション '@option{backup}', '@option{writebackup}' または '@option{patchmode}' がオンのときに既存のファイルに (追加でなく) 書き込もうとすると、元のファイルのバックアップが作られます。ファイルは元のコピーかリネームしたものです ('@option{backupcopy}' を参照してください)。ファイルの書き込みに成功したとき '@option{writebackup}' がオンで '@option{backup}' がオフだと、バックアップファイルは削除されます。'@option{patchmode}' がオンのときはバックアップファイルはリネームされるかも知れません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*backup-table*
'backup' 'writebackup'	action	~
   off	     off	no backup made
   off	     on		backup current file, deleted afterwards (default)
   on	     off	delete old backup, backup current file
   on	     on		delete old backup, backup current file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{backup-table}
@cindex backup-table
@multitable @columnfractions .15 .20 .65
@item 'backup' @tab 'writebackup' @tab 動作
@item off @tab off @tab バックアップは作られない
@item off @tab on @tab カレントファイルをバックアップし、後で消去する (既定)
@item on @tab off @tab 古いバックアップを消去し、カレントファイルをバックアップする
@item on @tab on @tab 古いバックアップを消去し、カレントファイルをバックアップする
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the 'backupskip' pattern matches with the name of the file which is
written, no backup file is made.  The values of 'backup' and 'writebackup' are
ignored then.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{backupskip}' に指定したパターンが書き込まれるファイルの名前にマッチしたときは、バックアップファイルは作られません。その場合 '@option{backup}' と '@option{writebackup}' の値は無視されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the 'backup' option is on, an old backup file (with the same name as the
new backup file) will be deleted.  If 'backup' is not set, but 'writebackup'
is set, an existing backup file will not be deleted.  The backup file that is
made while the file is being written will have a different name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{backup}' がオンのときは、古いバックアップファイル (新しいバックアップファイルと同名) は削除されます。'@option{backup}' がオフだが '@option{writebackup}' がオンのときは、既存のバックアップファイルは削除されません。ファイルの書き込み中に作られたバックアップファイルは別の名前になります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
On some filesystems it's possible that in a crash you lose both the backup and
the newly written file (it might be there but contain bogus data).  In that
case try recovery, because the swap file is synced to disk and might still be
there. |:recover|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルシステムによってはクラッシュで新しいファイルとバックアップを両方失うこともあり得ます (新しいファイルは存在はしても中身が滅茶苦茶になっていたり)。その場合は復帰機能を試してください。スワップファイルがまだディスクに残っているかもしれないからです。|@ref{:recover}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The directories given with the 'backupdir' option are used to put the backup
file in.  (default: same directory as the written file).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{backupdir}' で指定されたディレクトリはバックアップファイルをしまうのに使われます。(既定値: 書き込まれたファイルと同じディレクトリ)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Whether the backup is a new file, which is a copy of the original file, or the
original file renamed depends on the 'backupcopy' option.  See there for an
explanation of when the copy is made and when the file is renamed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バックアップが、元のファイルのコピーである新規のファイルになるか、元のファイルがリネームされたものになるかは、オプション '@option{backupcopy}' で決まります。コピーが作られるのがいつでファイルがリネームされるのがいつかについてはその箇所を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the creation of a backup file fails, the write is not done.  If you want
to write anyway add a '!' to the command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バックアップファイルの生成に失敗すると、書き込みは行われません。それでも書き込みたいときにはコマンドに '!' を追加してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*write-permissions*
When writing a new file the permissions are read-write.  For unix the mask is
0666 with additionally umask applied.  When writing a file that was read Vim
will preserve the permissions, but clear the s-bit.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{write-permissions}
@cindex write-permissions
新しいファイルを書き込むときは読み書きの権限が付きます。unix ではマスクの値は 0666 に umask を適用させたものになります。Vim で開いたファイルに書き込むときは権限は維持されますが、s ビットはクリアされます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*write-readonly*
When the 'cpoptions' option contains 'W', Vim will refuse to overwrite a
readonly file.  When 'W' is not present, ":w!" will overwrite a readonly file,
if the system allows it (the directory must be writable).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{write-readonly}
@cindex write-readonly
オプション '@option{cpoptions}' の値にフラグ '@var{W}' が含まれるときは、Vim は読み込み専用ファイルの上書きを拒否します。'@var{W}' が含まれないと、システムが許可すれば (ディレクトリは書き込み可能でなければなりません) "@command{:w!}" は読込専用ファイルを上書きします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*write-fail*
If the writing of the new file fails, you have to be careful not to lose
your changes AND the original file.  If there is no backup file and writing
the new file failed, you have already lost the original file!  DON'T EXIT VIM
UNTIL YOU WRITE OUT THE FILE!  If a backup was made, it is put back in place
of the original file (if possible).  If you exit Vim, and lose the changes
you made, the original file will mostly still be there.  If putting back the
original file fails, there will be an error message telling you that you
lost the original file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{write-fail}
@cindex write-fail
新ファイルの書き込みに失敗したときは、変更点と元のファイルを同時に失わないよう注意しなければなりません。バックアップファイルがないときに書き込みに失敗すると、その時点で元のファイルはなくなっているのです！@strong{ファイルを書き出すまで Vim を終了してはいけません！} バックアップが作られていたら、(可能ならば) それが元のファイルの所に戻されます。Vim を終了して変更点が失われても、大抵は元のファイルはそこに残っています。Vim が元のファイルを戻すのに失敗すると、元のファイルが失われた旨のエラーメッセージが出ます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*DOS-format-write*
If the 'fileformat' is "dos", <CR> <NL> is used for <EOL>.  This is default
for MS-DOS, Win32 and OS/2.  On other systems the message "[dos format]" is
shown to remind you that an unusual <EOL> was used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{DOS-format-write}
@cindex DOS-format-write
オプション '@option{fileformat}' の値が "@var{dos}" のときは、<EOL> には <CR> <NL> が使われます。これは MS-DOS, Win32 と OS/2 での既定値です。その他のシステムでは "[dos format]" というメッセージが表示され、普通でない <EOL> が使われていることを知らせてくれます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*Unix-format-write*
If the 'fileformat' is "unix", <NL> is used for <EOL>.  On MS-DOS, Win32 and
OS/2 the message "[unix format]" is shown.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Unix-format-write}
@cindex Unix-format-write
'@option{fileformat}' の値が "@var{unix}" のときは、<EOL> には <NL> が使われます。MS-DOS, Win32 と OS/2 では "[unix format]" というメッセージが表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*Mac-format-write*
If the 'fileformat' is "mac", <CR> is used for <EOL>.  On non-Mac systems the
message "[mac format]" is shown.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Mac-format-write}
@cindex Mac-format-write
'@option{fileformat}' の値が "@var{mac}" のときは、<EOL> には <CR> が使われます。Mac 以外のシステムでは "[mac format]" というメッセージが表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
See also |file-formats| and the 'fileformat' and 'fileformats' options.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{file-formats}| やオプション '@option{fileformat}' 及び '@option{fileformats}' も参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*ACL*
ACL stands for Access Control List.  It is an advanced way to control access
rights for a file.  It is used on new MS-Windows and Unix systems, but only
when the filesystem supports it.
   Vim attempts to preserve the ACL info when writing a file.  The backup file
will get the ACL info of the original file.
   The ACL info is also used to check if a file is read-only (when opening the
file).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ACL}
@cindex ACL
ACL は Access Control List を表します。これはファイルのアクセス権を制御するための先進的な手段です。新しい MS-Windows と Unix システムで使われますが、ファイルシステムがそれをサポートするときのみです。

Vim はファイルを書き込むときに ACL 情報を保とうとします。バックアップファイルは元のファイルの ACL 情報を受け継ぎます。

ACL 情報は (ファイルを開くときに) ファイルが読込専用かどうか調べるのにも使われます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*read-only-share*
When MS-Windows shares a drive on the network it can be marked as read-only.
This means that even if the file read-only attribute is absent, and the ACL
settings on NT network shared drives allow writing to the file, you can still
not write to the file.  Vim on Win32 platforms will detect read-only network
drives and will mark the file as read-only.  You will not be able to override
it with |:write|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{read-only-share}
@cindex read-only-share
MS-Windows がネットワーク上でドライブを共有するとき、そこは読込専用にすることができます。つまりファイルに読込専用の属性がなく、NC ネットワーク共有ドライブ上の ACL 設定が書き込みを許可していても、そのファイルには書き込みができません。Win32 プラットフォーム上の Vim は読込専用のネットワークドライブを判別し、ファイルを読込専用とマークします。そのファイルは |@ref{:write}| で上書きすることができません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*write-device*
When the file name is actually a device name, Vim will not make a backup (that
would be impossible).  You need to use "!", since the device already exists.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{write-device}
@cindex write-device
ファイル名が実際はデバイス名のとき、Vim はバックアップを作ろうとはしません (無理な話)。デバイスは既に存在するので、保存にはフラグ "!" が必要です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Example for Unix: >
	:w! /dev/lpt0
and for MS-DOS or MS-Windows: >
	:w! lpt0
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

Unixでの例:
@verbatim
:w! /dev/lpt0
@end verbatim
MS-DOS や MS-Windows での例:
@verbatim
:w! lpt0
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
For Unix a device is detected when the name doesn't refer to a normal file or
a directory.  A fifo or named pipe also looks like a device to Vim.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Unix では、ファイル名が通常ファイルやディレクトリを指していないときにデバイスと判断されます。Vim は fifo 及び名前付きパイプもデバイスと判断します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
For MS-DOS and MS-Windows the device is detected by its name:
	AUX
	CON
	CLOCK$
	NUL
	PRN
	COMn	n=1,2,3... etc
	LPTn	n=1,2,3... etc
The names can be in upper- or lowercase.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

MS-DOS と MS-Windows では、デバイスは名前から判断されます:
@verbatim
AUX
CON
CLOCK$
NUL
PRN
COMn	n=1,2,3... 等
LPTn	n=1,2,3... 等
@end verbatim
ファイル名は大文字でも小文字でもよい。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
5. Writing and quitting					*write-quit*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{write-quit}
@cindex write-quit
@cindex 書き込みと終了
@section 5. 書き込みと終了
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:q* *:quit*
:q[uit]			Quit the current window.  Quit Vim if this is the last
			window.  This fails when changes have been made and
			Vim refuses to |abandon| the current buffer, and when
			the last file in the argument list has not been
			edited.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:q}
@anchor{:quit}
@pindex :q
@pindex :quit
@table @asis
@item :q[uit]
カレントウィンドウを閉じます。最後のウィンドウで使うと Vim を終了させます。変更点があって Vim がカレントバッファを放棄 |@ref{abandon}| しようとしないときや、引数リストの最後のファイルが編集されていないときは失敗します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			If there are other tab pages and quitting the last
			window in the current tab page the current tab page is
			closed |tab-page|.
			Triggers the |QuitPre| autocommand event.
			See |CTRL-W_q| for quitting another window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

他のタブページが存在するとき、カレントタブページ内の最後のウィンドウを閉じるとカレントタブページ |@ref{tab-page}| が閉じられます。

|@ref{QuitPre}| 自動コマンドイベントが発行されます。

他のウィンドウを終了するには |@ref{CTRL-W_q}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:conf[irm] q[uit]	Quit, but give prompt when changes have been made, or
			the last file in the argument list has not been
			edited.  See |:confirm| and 'confirm'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :conf[irm] q[uit]
終了しますが、変更点があるときや、引数リスト内で末尾にないファイルを編集しているときにはプロンプトを表示します。コマンド |@ref{:confirm}| やオプション '@option{confirm}' を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:q[uit]!		Quit without writing, also when the current buffer has
			changes.  The buffer is unloaded, also when it has
			'hidden' set.
			If this is the last window and there is a modified
			hidden buffer, the current buffer is abandoned and the
			first changed hidden buffer becomes the current
			buffer.
			Use ":qall!" to exit always.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :q[uit]!
現在のバッファに変更点があっても、書き込まずに Vim を終了します。バッファは、'@option{hidden}' が設定されているときにも読み込まれません。

そのウィンドウが最後の 1 つで、変更点のある隠しバッファがある場合には、終了せずにカレントバッファを破棄したあとで、最初の変更点がある隠しバッファを新たな現在のバッファとします。

必ず終了するにはコマンド "@command{:qall!}" を使ってください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:cq[uit]		Quit always, without writing, and return an error
			code.  See |:cq|.  Used for Manx's QuickFix mode (see
			|quickfix|).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :cq[uit]
書き込みをせずに必ず終了し、エラーコードを返します。コマンド |@ref{:cq}| を参照してください。Manx の QuickFix モードで使われます (|@ref{quickfix}| を参照してください)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:wq*
:wq [++opt]		Write the current file and quit.  Writing fails when
			the file is read-only or the buffer does not have a
			name.  Quitting fails when the last file in the
			argument list has not been edited.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:wq}
@pindex :wq
@item :wq [++opt]
カレントファイルを書き込んで Vim を終了します。ファイルが読込専用であるときや、バッファに名前が付いていないときには書き込みに失敗します。引数リスト内の末尾のファイルがまだ編集されていないときには終了に失敗します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:wq! [++opt]		Write the current file and quit.  Writing fails when
			the current buffer does not have a name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :wq! [++opt]
カレントファイルを書き込んで Vim を終了します。バッファに名前が付いていないときには書き込みに失敗します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:wq [++opt] {file}	Write to {file} and quit.  Quitting fails when the
			last file in the argument list has not been edited.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :wq [++opt] @{file@}
@{file@} に書き込んで Vim を終了します。引数リスト内の末尾のファイルがまだ編集されていないときには終了に失敗します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:wq! [++opt] {file}	Write to {file} and quit.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :wq! [++opt] @{file@}
@{file@} に書き込んで Vim を終了します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]wq[!] [++opt] [file]
			Same as above, but only write the lines in [range].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[range]wq[!] [++opt] [file]
上と同様ですが、[range] の範囲内の行のみを書き込みます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:x* *:xit*
:[range]x[it][!] [++opt] [file]
			Like ":wq", but write only when changes have been
			made.
			When 'hidden' is set and there are more windows, the
			current buffer becomes hidden, after writing the file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:x}
@anchor{:xit}
@pindex :x
@pindex :xit
@item :[range]x[it][!] [++opt] [file]
|@ref{:wq}| と似ていますが、変更点があるときのみ書き込みます。オプション '@option{hidden}' がオンで複数のウィンドウが存在するとき、ファイルを書き込んだ後はカレントバッファは隠れバッファになります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:exi* *:exit*
:[range]exi[t][!] [++opt] [file]
			Same as :xit.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:exi}
@anchor{:exit}
@pindex :exi
@pindex :exit
@item :[range]exi[t][!] [++opt] [file]
|@ref{:xit}| と同じです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*ZZ*
ZZ			Write current file, if modified, and quit (same as
			":x").  (Note: If there are several windows for the
			current file, the file is written if it was modified
			and the window is closed).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ZZ}
@kindex ZZ
@item ZZ
変更点があればカレントファイルを書き込んで Vim を終了します (コマンド |@ref{:x}| と同じです)。

@quotation
@strong{Note:} @*
カレントファイルを複数のウィンドウで開いているときは、ファイルに変更点があれば書き込まれ、そしてウィンドウが閉じられることに注意してください。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*ZQ*
ZQ			Quit without checking for changes (same as ":q!").
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ZQ}
@kindex ZQ
@item ZQ
変更点を確かめずに終了します (コマンド "@command{:q!}" と同じです)。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MULTIPLE WINDOWS AND BUFFERS				*window-exit*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{window-exit}
@cindex window-exit
@cindex 複数のウィンドウとバッファ
@unnumberedsubsec 複数のウィンドウとバッファ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:qa* *:qall*
:qa[ll]		Exit Vim, unless there are some buffers which have been
		changed.  (Use ":bmod" to go to the next modified buffer).
		When 'autowriteall' is set all changed buffers will be
		written, like |:wqall|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:qa}
@anchor{:qall}
@pindex :qa
@pindex :qall
@table @asis
@item :qa[ll]
変更点のあるバッファがない限り、Vim を終了します (変更点のある次のバッファに移動するにはコマンド "@command{:bmod}" を使ってください)。オプション '@option{autowriteall}' がオンのときは、|@ref{:wqall}| と同様に変更点のあるバッファが全て書き込まれます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:conf[irm] qa[ll]
		Exit Vim.  Bring up a prompt when some buffers have been
		changed.  See |:confirm|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :conf[irm] qa[ll]
Vim を終了します。変更点のあるバッファがあるときはプロンプトを表示します。コマンド |@ref{:confirm}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:qa[ll]!	Exit Vim.  Any changes to buffers are lost.
		Also see |:cquit|, it does the same but exits with a non-zero
		value.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :qa[ll]!
Vim を終了します。バッファの変更点は全て失われます。

終了コードを非ゼロにしたい場合は |@ref{:cquit}| を使ってください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:quita* *:quitall*
:quita[ll][!]	Same as ":qall".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:quita}
@anchor{:quitall}
@pindex :quita
@pindex :quitall
@item :quita[ll][!]
コマンド |@ref{:qall}| と同じです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:wqa[ll] [++opt]				*:wqa* *:wqall* *:xa* *:xall*
:xa[ll]		Write all changed buffers and exit Vim.  If there are buffers
		without a file name, which are readonly or which cannot be
		written for another reason, Vim will not quit.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:wqa}
@anchor{:wqall}
@anchor{:xa}
@anchor{:xall}
@pindex :wqa
@pindex :wqall
@pindex :xa
@pindex :xall
@item :wqa[ll] [++opt]
@itemx :xa[ll]
変更点のあるバッファを全て書き込んで Vim を終了します。ファイル名のないバッファや読込専用または何らかの理由で書き込めないバッファ、またはジョブが実行中の端末があるときは、Vim を終了しません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:conf[irm] wqa[ll] [++opt]
:conf[irm] xa[ll]
		Write all changed buffers and exit Vim.  Bring up a prompt
		when some buffers are readonly or cannot be written for
		another reason.  See |:confirm|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :conf[irm] wqa[ll] [++opt]
@itemx :conf[irm] xa[ll]
変更点のあるバッファを全て書き込んで Vim を終了します。読込専用または何らかの理由で書き込めないバッファがあるときは、プロンプトを表示します。コマンド |@ref{:confirm}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:wqa[ll]! [++opt]
:xa[ll]!	Write all changed buffers, even the ones that are readonly,
		and exit Vim.  If there are buffers without a file name or
		which cannot be written for another reason, or there is a
		terminal with a running job, Vim will not quit.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :wqa[ll]! [++opt] or :xa[ll]!
変更点のあるバッファを、読込専用であっても全て書き込んで Vim を終了します。ファイル名のないバッファや何らかの理由で書き込めないバッファがあるとき、もしくは、ジョブが動作しているターミナルがあるときは、Vim を終了しません。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
6. Dialogs						*edit-dialogs*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{edit-dialogs}
@cindex edit-dialogs
@cindex ダイアログ
@section 6. ダイアログ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:confirm* *:conf*
:conf[irm] {command}	Execute {command}, and use a dialog when an
			operation has to be confirmed.  Can be used on the
			|:q|, |:qa| and |:w| commands (the latter to override
			a read-only setting), and any other command that can
			fail in such a way, such as |:only|, |:buffer|,
			|:bdelete|, etc.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:confirm}
@anchor{:conf}
@pindex :confirm
@pindex :conf
@table @asis
@item :conf[irm] @{command@}
@{command@} を実行する際、確認が必要ならばダイアログを表示します。コマンド |@ref{:q}|, |@ref{:qa}| や |@ref{:w}| あるいは、|@ref{:only}|, |@ref{:buffer}|, |@ref{:bdelete}| など、同様に失敗しうるコマンドと共に使えます (|@ref{:w}| では読み取り専用属性を無視するかどうかを尋ねます)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Examples: >
  :confirm w foo
<	Will ask for confirmation when "foo" already exists. >
  :confirm q
<	Will ask for confirmation when there are changes. >
  :confirm qa
<	If any modified, unsaved buffers exist, you will be prompted to save
	or abandon each one.  There are also choices to "save all" or "abandon
	all".

If you want to always use ":confirm", set the 'confirm' option.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例:
@verbatim
:confirm w foo
@end verbatim
ファイル "foo" が既に存在するときに確認を取ります。
@verbatim
:confirm q
@end verbatim
バッファに修正個所があるときに確認を取ります。
@verbatim
:confirm qa
@end verbatim
修正個所があり、保存されていないバッファがあるとき、各バッファについて保存するか破棄するか尋ねます。「全て保存」や「全て破棄」という選択肢もあります。

常に "@command{:confirm}" を使いたいなら、代わりにオプション '@option{confirm}' をオンにしてください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			*:browse* *:bro* *E338* *E614* *E615* *E616*
:bro[wse] {command}	Open a file selection dialog for an argument to
			{command}.  At present this works for |:e|, |:w|,
			|:wall|, |:wq|, |:wqall|, |:x|, |:xall|, |:exit|,
			|:view|, |:sview|, |:r|, |:saveas|, |:sp|, |:mkexrc|,
			|:mkvimrc|, |:mksession|, |:mkview|, |:split|,
			|:vsplit|, |:tabe|, |:tabnew|, |:cfile|, |:cgetfile|,
			|:caddfile|, |:lfile|, |:lgetfile|, |:laddfile|,
			|:diffsplit|, |:diffpatch|, |:open|, |:pedit|,
			|:redir|, |:source|, |:update|, |:visual|, |:vsplit|,
			and |:qall| if 'confirm' is set.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:browse}
@anchor{:bro}
@anchor{E338}
@anchor{E614}
@anchor{E615}
@anchor{E616}
@pindex :browse
@pindex :bro
@erindex E338
@erindex E614
@erindex E615
@erindex E616
@item :bro[wse] @{command@}
@{command@} の引数のためにファイル選択ダイアログを開きます。現在の所、これらのコマンドと共に使えます |@ref{:e}|, |@ref{:w}|, |@ref{:wall}|, |@ref{:wq}|, |@ref{:wqall}|, |@ref{:x}|, |@ref{:xall}|, |@ref{:exit}|, |@ref{:view}|, |@ref{:sview}|, |@ref{:r}|, |@ref{:saveas}|, |@ref{:sp}|, |@ref{:mkexrc}|, |@ref{:mkvimrc}|, |@ref{:mksession}|, |@ref{:mkview}|, |@ref{:split}|, |@ref{:vsplit}|, |@ref{:tabe}|, |@ref{:tabnew}|, |@ref{:cfile}|, |@ref{:cgetfile}|, |@ref{:caddfile}|, |@ref{:lfile}|, |@ref{:lgetfile}|, |@ref{:laddfile}|, |@ref{:diffsplit}|, |@ref{:diffpatch}|, |@ref{:open}|, |@ref{:pedit}|, |@ref{:redir}|, |@ref{:source}|, |@ref{:update}|, |@ref{:visual}|, |@ref{:vsplit}|, '@option{confirm}' がオンのときは |@ref{:qall}| も使えます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			{only in Win32, Athena, Motif, GTK and Mac GUI}
			When ":browse" is not possible you get an error
			message.  If the |+browse| feature is missing or the
			{command} doesn't support browsing, the {command} is
			executed without a dialog.
			":browse set" works like |:options|.
			See also |:oldfiles| for ":browse oldfiles".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@{Vim の Win32 版, Motif, Athena, GTK や Mac の GUI 版でのみ利用可能@}

"@command{:browse}" が使えない時はエラーが表示されます。|@ref{+browse}| の機能がなかったり、@{command@} が @command{:browse} に対応していない場合、@{command@} はダイアログなしで実行されます。"@command{:browse oldfiles}" については |@ref{:oldfiles}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The syntax is best shown via some examples: >
	:browse e $vim/foo
<		Open the browser in the $vim/foo directory, and edit the
		file chosen. >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
使用法については、例をいくつか見るのが一番分かりやすいでしょう。
@verbatim
:browse e $vim/foo
@end verbatim
ファイル選択ダイアログをディレクトリ $vim/foo 内で開き、選択されたファイルを編集します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:browse e
<		Open the browser in the directory specified with 'browsedir',
		and edit the file chosen. >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:browse e
@end verbatim
ファイル選択ダイアログを '@option{browsedir}' で指定されたディレクトリ内で開き、選択されたファイルを編集します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:browse w
<		Open the browser in the directory of the current buffer,
		with the current buffer filename as default, and save the
		buffer under the filename chosen. >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:browse w
@end verbatim        
ファイル選択ダイアログをカレントファイルのディレクトリ内で、カレントファイルの名前を既定値として開き、選択されたファイル名を使ってバッファを保存します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	:browse w C:/bar
<		Open the browser in the C:/bar directory, with the current
		buffer filename as default, and save the buffer under the
		filename chosen.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
:browse w C:/bar
@end verbatim
ファイル選択ダイアログをディレクトリ C:/bar 内で、カレントファイルの名前を既定値として開き、選択されたファイル名を使ってバッファを保存します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Also see the |'browsedir'| option.
For versions of Vim where browsing is not supported, the command is executed
unmodified.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

オプション |@ref{'browsedir'}| も参照してください。

Vim のファイル選択ダイアログをサポートしないバージョンでは、コマンドはそのまま実行されます。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*browsefilter*
For MS Windows and GTK, you can modify the filters that are used in the browse
dialog.  By setting the g:browsefilter or b:browsefilter variables, you can
change the filters globally or locally to the buffer.  The variable is set to
a string in the format "{filter label}\t{pattern};{pattern}\n" where {filter
label} is the text that appears in the "Files of Type" comboBox, and {pattern}
is the pattern which filters the filenames.  Several patterns can be given,
separated by ';'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{browsefilter}
@cindex browsefilter
MS-Windows と GTK では、ファイル選択ダイアログで使われるフィルタを指定することができます。グローバル変数 @var{g:browsefilter} かローカル変数 @var{b:browsefilter} を設定すると、フィルタをグローバルにまたはバッファについてローカルに変更することができます。この変数を指定する際の書式は "@{filter label@}\t@{pattern@};@{pattern@}\n" で、@{filter label@} はコンボボックス「ファイルの種類」に使われるテキスト、@{pattern@} はファイル名を選別するフィルタです。';' で区切れば複数のパターンを指定することができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For Motif the same format is used, but only the very first pattern is actually
used (Motif only offers one pattern, but you can edit it).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Motif 上の Vim では同じ書式が使えますが、実際には 1 番目のパターンだけが使われます (Motif ではパターンは 1 種類しか使えませんが、それをユーザーが編集できます)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For example, to have only Vim files in the dialog, you could use the following
command: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例えばダイアログで Vim 関連ファイルだけを表示するには、以下のコマンドを使います。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
     let g:browsefilter = "Vim Scripts\t*.vim\nVim Startup Files\t*vimrc\n"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
let g:browsefilter = "Vim Scripts\t*.vim\nVim Startup Files\t*vimrc\n"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can override the filter setting on a per-buffer basis by setting the
b:browsefilter variable.  You would most likely set b:browsefilter in a
filetype plugin, so that the browse dialog would contain entries related to
the type of file you are currently editing.  Disadvantage: This makes it
difficult to start editing a file of a different type.  To overcome this, you
may want to add "All Files\t*.*\n" as the final filter, so that the user can
still access any desired file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
フィルタは、変数 @var{b:browsefilter} を設定することでバッファ毎に設定することができます。@var{b:browsefilter} はファイルタイププラグインで設定することが一番多いでしょう。するとファイルブラウザーダイアログには現在編集中のファイルのタイプに関連した候補が表示されます。
@quotation
@strong{弊害:} @*
別の種類のファイルの編集が始め辛くなります。対策は、フィルタの最後の項目に "All Files\t*.*\n" を加え、ユーザーが望みのファイルにアクセスできる道を残すことです。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To avoid setting browsefilter when Vim does not actually support it, you can
use has("browsefilter"): >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim が browsefilter をサポートしていないときにそれを設定しないようにするには、has("browsefilter") が使えます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	if has("browsefilter")
	   let g:browsefilter = "whatever"
	endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
if has("browsefilter")
let g:browsefilter = "whatever"
endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
7. The current directory				*current-directory*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{current-directory}
@cindex current-directory
@cindex カレントディレクトリ
@section 7. カレントディレクトリ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use the |:cd|, |:tcd| and |:lcd| commands to change to another
directory, so you will not have to type that directory name in front of the
file names.  It also makes a difference for executing external commands, e.g.
":!ls".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:cd}|, |@ref{:lcd}| や |@ref{:tcd}| コマンドを使って別のディレクトリに移ることができます。すると @{訳注: そのディレクトリ内のファイルを編集するとき@} そのディレクトリ名をファイル名の前に付けなくても良くなります。また、違いは "@command{:!ls}" 等の外部コマンドの実行の際にも現れます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Changing directory fails when the current buffer is modified, the '.' flag is
present in 'cpoptions' and "!" is not used in the command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{cpoptions}' にフラグ '.' が含まれている場合、カレントバッファが変更されていると、"!" をつけない限りディレクトリ変更は失敗します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:cd* *E747* *E472*
:cd[!]			On non-Unix systems: Print the current directory
			name.  On Unix systems: Change the current directory
			to the home directory.  Use |:pwd| to print the
			current directory on all systems.
			On Unix systems: clear any window-local directory.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:cd}
@anchor{E747}
@anchor{E472}
@cpindex :cd
@erindex E747
@erindex E472
@table @asis
@item :cd[!]
Unix 以外のシステムでは: カレントディレクトリ名を表示します。Unix システムでは: カレントディレクトリをホームディレクトリに変更します。全てのシステムで、カレントディレクトリの表示にはコマンド |@ref{:pwd}| が使えます。

Unix システムでは: ウィンドウローカルディレクトリを消去します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:cd[!] {path}		Change the current directory to {path}.
			If {path} is relative, it is searched for in the
			directories listed in |'cdpath'|.
			Clear any window-local directory.
			Does not change the meaning of an already opened file,
			because its full path name is remembered.  Files from
			the |arglist| may change though!
			On MS-DOS this also changes the active drive.
			To change to the directory of the current file: >
				:cd %:h
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :cd[!] @{path@}
カレントディレクトリを @{path@} に変更します。@{path@} が相対的な指定なら、オプション '@option{cdpath}' 内に列挙されたディレクトリを基準に判断されます。

ウィンドウローカルディレクトリを消去します。

既に開かれたファイルについては、フルパスが把握されているので変化はありません。しかし引数リスト |@ref{arglist}| 内のファイルの意味は変わるかもしれません！

MS-DOS ではアクティブなドライブも変更します。カレントファイルのディレクトリに移るにはこうします。
@verbatim
:cd %:h
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:cd-* *E186*
:cd[!] -		Change to the previous current directory (before the
			previous ":cd {path}" command).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:cd-}
@anchor{E186}
@pindex :cd-
@erindex E186
@item :cd[!] -
前のカレントディレクトリ (前にコマンド "@command{:cd @{path@}}" で移った所) に移動します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:chd* *:chdir*
:chd[ir][!] [path]	Same as |:cd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:chd}
@anchor{:chdir}
@pindex :chd
@pindex :chdir
@item :chd[ir][!] [path]
コマンド |@ref{:cd}| と同じです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:tcd*
:tcd[!] {path}		Like |:cd|, but only set the directory for the current
			tab.  The current window will also use this directory.
			The current directory is not changed for windows in
			other tabs and for windows in the current tab that
			have their own window-local directory.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:tcd}
@pindex :tcd
@item :tcd[!] @{path@}
|@ref{:cd}| と似ていますが、カレントタブページのディレクトリを設定するだけです。カレントウィンドウもこのディレクトリを使用します。カレントディレクトリは、他のタブページ内のウィンドウやカレントタブページ内のウィンドウ固有のウィンドウローカルディレクトリに対しては変更されません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:tch* *:tchdir*
:tch[dir][!]		Same as |:tcd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:tch}
@anchor{:tchdir}
@pindex :tch
@pindex :tchdir
@item :tch[dir][!]
|@ref{:tcd}| と同じです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:lc* *:lcd*
:lc[d][!] {path}	Like |:cd|, but only set the current directory when
			the cursor is in the current window.  The current
			directory for other windows is not changed, switching
			to another window will stop using {path}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:lc}
@anchor{:lcd}
@pindex :lc
@pindex :lcd
@item :lc[d][!] @{path@}
コマンド |@ref{:cd}| と似ていますが、カーソルがカレントウィンドウにある時にカレントディレクトリのみを変更します。別のウィンドウのカレントディレクトリは変更されず、別のウィンドウへの移動すると @{path@} の使用を止めます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:lch* *:lchdir*
:lch[dir][!]		Same as |:lcd|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:lch}
@anchor{:lchdir}
@pindex :lch
@pindex :lchdir
@item :lch[dir][!]
|@ref{:lcd}| と同じです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:pw* *:pwd* *E187*
:pw[d]			Print the current directory name.
			Also see |getcwd()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:pw}
@anchor{:pwd}
@anchor{E187}
@pindex :pw
@pindex :pwd
@erindex E187
@item :pw[d]
カレントディレクトリ名を表示します。

|@ref{getcwd()}| も参照してください。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
So long as no |:lcd| or |:tcd| command has been used, all windows share the
same current directory.  Using a command to jump to another window doesn't
change anything for the current directory.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:lcd}| か |@ref{:tcd}| コマンドが使われない限り、全てのウィンドウは同じカレントディレクトリを共有します。別のウィンドウに移るコマンドを使ってもカレントディレクトリについての変化は何もありません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When a |:lcd| command has been used for a window, the specified directory
becomes the current directory for that window.  Windows where the |:lcd|
command has not been used stick to the global or tab-local current directory.
When jumping to another window the current directory will become the last
specified local current directory.  If none was specified, the global or
tab-local current directory is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:lcd}| コマンドがあるウィンドウ内で使われると、指定されたディレクトリがそのウィンドウに対してのカレントディレクトリになります。|@ref{:lcd}| コマンドが使われたことのないウィンドウはグローバルまたはタブローカルなカレントディレクトリを使い続けます。別のウィンドウに移ったときは、カレントディレクトリは @{訳注: 移動先に対して@} 最後に指定されたローカルなカレントディレクトリになります。何も指定されていなければ、グローバルまたはタブローカルなカレントディレクトリが使われます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When a |:tcd| command has been used for a tab page, the specified directory
becomes the current directory for the current tab page and the current window.
The current directory of other tab pages is not affected.  When jumping to
another tab page, the current directory will become the last specified local
directory for that tab page. If the current tab has no local current directory
the global current directory is used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
タブページに |@ref{:tcd}| コマンドが使われると、指定されたディレクトリはカレントタブページとカレントウィンドウのカレントディレクトリになります。他のタブページのカレントディレクトリは影響を受けません。別のタブページに移動すると、カレントディレクトリがそのタブページで最後に指定されたローカルディレクトリになります。カレントタブページにローカルのカレントディレクトリがない場合は、グローバルなカレントディレクトリが使用されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When a |:cd| command is used, the current window and tab page will lose the
local current directory and will use the global current directory from now on.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:cd}| コマンドが使われると、カレントウィンドウとカレントタブページは固有のローカルなカレントディレクトリを失い、グローバルなカレントディレクトリを使うようになります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
After using |:cd| the full path name will be used for reading and writing
files.  On some networked file systems this may cause problems.  The result of
using the full path name is that the file names currently in use will remain
referring to the same file.  Example: If you have a file a:test and a
directory a:vim the commands ":e test" ":cd vim" ":w" will overwrite the file
a:test and not write a:vim/test.  But if you do ":w test" the file a:vim/test
will be written, because you gave a new file name and did not refer to a
filename before the ":cd".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:cd}| を使った後は、ファイルの読み書きにはフルパス名が使われます。ネットワーク接続されたファイルシステムではこれが問題を起こすことがあります。フルパス名を使った結果、現在使用中のファイル名は同じファイルを指し続けることになります。

例: ファイル @file{a:test} とディレクトリ a:vim があるとき、"@command{:e test}" "@command{:cd vim}" "@command{:w}" とするとファイル @file{a:test} を上書きし、a:vim/test には書き込みません。しかし "@command{:w test}" とするとファイル @file{a:vim/test} が書き込まれます。それは新しいファイル名が指定され、"@command{:cd}" 以前のファイル名には言及していないからです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
8. Editing binary files					*edit-binary*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{edit-binary}
@cindex edit-binary
@cindex バイナリファイルの編集
@section 8. バイナリファイルの編集
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Although Vim was made to edit text files, it is possible to edit binary
files.  The |-b| Vim argument (b for binary) makes Vim do file I/O in binary
mode, and sets some options for editing binary files ('binary' on, 'textwidth'
to 0, 'modeline' off, 'expandtab' off).  Setting the 'binary' option has the
same effect.  Don't forget to do this before reading the file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim はテキストファイルの編集のために作られましたが、バイナリファイルを編集することもできます。

Vim の引数 |@ref{-b}| (バイナリ "binary" の 'b') は Vim にファイル入出力をバイナリモードで行わせ、バイナリファイルの編集のためにいくつかのオプションを設定します ('@option{binary}' をオン、'@option{textwidth}' を 0、'@option{modeline}' をオフ、'@option{expandtab}' をオフにします)。

オプション '@option{binary}' をオンにすることも同じ効果を持ちます。これはファイルの読み込み前にするということを忘れてはなりません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are a few things to remember when editing binary files:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バイナリファイルを編集するときに忘れてはならないことがいくつかあります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- When editing executable files the number of characters must not change.
  Use only the "R" or "r" command to change text.  Do not delete characters
  with "x" or by backspacing.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item 実行可能ファイルを編集するときには、文字数が変わってはなりません。テキストを変更するには "R" か "r" だけを使用してください。"x" やバックスペースで文字を削除してはなりません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Set the 'textwidth' option to 0.  Otherwise lines will unexpectedly be
  split in two.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item オプション '@option{textwidth}' の値を 0 に設定します。そうしないと行が不意に 2 つに分割されてしまいます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- When there are not many <EOL>s, the lines will become very long.  If you
  want to edit a line that does not fit on the screen reset the 'wrap' option.
  Horizontal scrolling is used then.  If a line becomes too long (more than
  about 32767 characters on the Amiga, much more on 32-bit systems, see
  |limits|) you cannot edit that line.  The line will be split when reading
  the file.  It is also possible that you get an "out of memory" error when
  reading the file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item <EOL> の数があまり多くないときは、1 行は非常に長くなります。スクリーンに収まりきらない行を編集したいならば、オプション '@option{wrap}' をオフにしてください。その時には水平スクロールが使われます。行が余りにも長いならば (Amiga では約 32767 文字以上、32bit システムではそれ以上、|@ref{limits}| を参照してください)、その行は編集できません。ファイルを読み込むときに、その行は分割されます。ファイルを読み込むときに "out of memory" エラーが出る可能性もあります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Make sure the 'binary' option is set BEFORE loading the
  file.  Otherwise both <CR> <NL> and <NL> are considered to end a line
  and when the file is written the <NL> will be replaced with <CR> <NL>.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ファイルを読み込む前にオプション '@option{binary}' がオンになっていることを確かめてください。さもないと <CR> <NL> と <NL> の両方が行末とみなされ、ファイルが保存されるときに <NL> が <CR> <NL> で置き換えられてしまいます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- <Nul> characters are shown on the screen as ^@.  You can enter them with
  "CTRL-V CTRL-@" or "CTRL-V 000"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item <Nul> 文字はスクリーンでは ^@@ として表示されます。それは "CTRL-V CTRL-@@" か "CTRL-V 000" で入力することができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- To insert a <NL> character in the file split a line.  When writing the
  buffer to a file a <NL> will be written for the <EOL>.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item <NL> 文字を挿入すると行が分割されます。バッファをファイルに保存するときには、<NL> が <EOL> として保存されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Vim normally appends an <EOL> at the end of the file if there is none.
  Setting the 'binary' option prevents this.  If you want to add the final
  <EOL>, set the 'endofline' option.  You can also read the value of this
  option to see if there was an <EOL> for the last line (you cannot see this
  in the text).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ファイルの終わりに <EOL> が 1 つもないとき、通常 Vim はそれを追加します。これを防ぐにはオプション '@option{binary}' をオンにしてください。最後の <EOL> を追加したいならば、オプション '@option{endofline}' をオンにします。最後の行に <EOL> があったかどうかを知るために、このオプションの値を見てもよいでしょう (テキストからは判断できません)。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
9. Encryption						*encryption*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{encryption}
@cindex encryption
@cindex 暗号化
@section 9. 暗号化
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim is able to write files encrypted, and read them back.  The encrypted text
cannot be read without the right key.
{only available when compiled with the |+cryptv| feature}  *E833*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim はファイルを暗号化して保存し、再び読み取ることができます。暗号化されたテキストは正しい鍵がないと読むことができません。
@anchor{E833}
@erindex E833
@{Vim が |@ref{+cryptv}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The text in the swap file and the undo file is also encrypted.  *E843*
However, this is done block-by-block and may reduce the time needed to crack a
password.  You can disable the swap file, but then a crash will cause you to
lose your work.  The undo file can be disabled without too much disadvantage. >
	:set noundofile
	:noswapfile edit secrets
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E843}
@erindex E843
スワップファイルやアンドゥファイル内のテキストも暗号化されます。

しかしながら、これはブロック単位で実行されるので、より少ない時間でパスワードがクラックされる可能性があります。スワップファイルを無効化することもできますが、クラッシュ時には作業内容が失われることになります。アンドゥファイルは無効化してもそれほどの不利益はありません。
@verbatim
:set noundofile
:noswapfile edit secrets
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note: The text in memory is not encrypted.  A system administrator may be able
to see your text while you are editing it.  When filtering text with
":!filter" or using ":w !command" the text is also not encrypted, this may
reveal it to others.  The 'viminfo' file is not encrypted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
メモリ内のテキストは暗号化されません。ユーザーがテキストを編集している間、システム管理者はそれを見ることができます。"@command{:!filter}" や "@command{:w !command}" によってフィルタに通しているときもテキストは暗号化されておらず、他人に見られる可能性があります。'@option{viminfo}' ファイルは暗号化されません。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You could do this to edit very secret text: >
	:set noundofile viminfo=
	:noswapfile edit secrets.txt
Keep in mind that without a swap file you risk losing your work in the event
of a crash or a power failure.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
機密テキストを編集するときは次のように設定するという手もあります:
@verbatim
:set noundofile viminfo=
:noswapfile edit secrets.txt
@end verbatim
スワップファイルを無効化するとクラッシュまたは停電の時に編集内容が失われてしまうことを心にとめておきましょう。。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
WARNING: If you make a typo when entering the key and then write the file and
exit, the text will be lost!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{警告:} @*
鍵の入力時にタイプミスをしてファイルを保存して Vim を終了すると、テキストは失われてしまいます！
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The normal way to work with encryption, is to use the ":X" command, which will
ask you to enter a key.  A following write command will use that key to
encrypt the file.  If you later edit the same file, Vim will ask you to enter
a key.  If you type the same key as that was used for writing, the text will
be readable again.  If you use a wrong key, it will be a mess.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
暗号化を利用する通常の方法は、コマンド |@ref{:X}| を使うことです。これは鍵を入力するよう求めます。次の保存コマンドでファイルを暗号化するためにその鍵が使われます。後で同じファイルを編集するときは、Vim は鍵の入力を求めます。保存に使われたものと同じ鍵を打ち込むと、再びテキストを読み込むことができます。間違ったキーを使うと、テキストはめちゃめちゃになって表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:X*
:X	Prompt for an encryption key.  The typing is done without showing the
	actual text, so that someone looking at the display won't see it.
	The typed key is stored in the 'key' option, which is used to encrypt
	the file when it is written.  The file will remain unchanged until you
	write it.  See also |-x|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:X}
@pindex :X
@table @asis
@item :X
暗号化キーを入力するよう求めます。ディスプレイを見ている誰かが鍵を見ないように、打ち込むときには実際のテキストは表示されません。

打ち込まれた鍵はオプション '@option{key}' に保存されます。これはファイルを書き込むときの暗号化に使われます。Vim の引数 |@ref{-x}| も参照してください。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The value of the 'key' options is used when text is written.  When the option
is not empty, the written file will be encrypted, using the value as the
encryption key.  A magic number is prepended, so that Vim can recognize that
the file is encrypted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{key}' の値はテキストが書き込まれるときに使われます。値が空でないとき、書き込まれたファイルは、その値を鍵として暗号化されています。Vim がファイルが暗号化されていることを認識できるよう、ファイル先頭に特殊な数が付加されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To disable the encryption, reset the 'key' option to an empty value: >
	:set key=
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
暗号化を無効にするには、オプション '@option{key}' に空の値を入れてリセットします。
@verbatim
:set key=
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use the 'cryptmethod' option to select the type of encryption, use one
of these: >
	:setlocal cm=zip        " weak method, backwards compatible
	:setlocal cm=blowfish   " method with flaws
	:setlocal cm=blowfish2  " medium strong method
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{cryptmethod}' オプションを設定することで暗号化メソッドを選択することができます。次の中から選択できます:
@verbatim
:setlocal cm=zip        " 弱いメソッド。後方互換
:setlocal cm=blowfish   " 脆弱性ありのメソッド
:setlocal cm=blowfish2  " 中強度のメソッド
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Do this before writing the file.  When reading an encrypted file it will be
set automatically to the method used when that file was written.  You can
change 'cryptmethod' before writing that file to change the method.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルを保存する前に設定します。暗号化されたファイルを読み込んだとき、このオプションは自動的にファイル保存時に使われたメソッドに設定されます。ファイルを保存する前に '@option{cryptmethod}' を変更することで使用するメソッドを変更することができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To set the default method, used for new files, use this in your |vimrc| 
file: >
	set cm=blowfish2
Using "blowfish2" is highly recommended.  Only use another method if you
must use an older Vim version that does not support it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しいファイルに使われるデフォルトのメソッドを設定したい場合は |@ref{vimrc}| ファイルで次を設定してください:
@verbatim
set cm=blowfish2
@end verbatim
"blowfish2" の使用が強く推奨されます。"blowfish2" をサポートしていない古いバージョンの Vim を使わなければならない場合のみ、他のメソッドを使用します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The message given for reading and writing a file will show "[crypted]" when
using zip, "[blowfish]" when using blowfish, etc.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルを読み込んだり書き込んだりしたとき、zip なら "[crypted]"、blowfish なら "[blowfish]" とメッセージが表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When writing an undo file, the same key and method will be used for the text
in the undo file. |persistent-undo|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
アンドゥファイルが保存されるとき、同じキーとメソッドがアンドゥファイル内のテキストに適用されます。|@ref{persistent-undo}|。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To test for blowfish support you can use these conditions: >
	has('crypt-blowfish')
	has('crypt-blowfish2')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"blowfish" をサポートしているかどうかテストするには下記の条件を使います:
@verbatim
has('crypt-blowfish')
has('crypt-blowfish2')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This works since Vim 7.4.1099 while blowfish support was added earlier.
Thus the condition failing doesn't mean blowfish is not supported. You can
test for blowfish with: >
	v:version >= 703
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上記の条件が利用できるのは Vim 7.4.1099 からですが、"blowfish" のサポート自体はもっと古くからあります。よって上記の条件が偽になったとしても "blowfish" をサポートしていることがあります。"blowfish" を使えるかどうかは次の条件でテストすることができます:
@verbatim
v:version >= 703
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
And for blowfish2 with: >
	v:version > 704 || (v:version == 704 && has('patch401'))
If you are sure Vim includes patch 7.4.237 a simpler check is: >
	has('patch-7.4.401')
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
また "blowfish2" については次の条件でテストすることができます:
@verbatim
v:version > 704 || (v:version == 704 && has('patch401'))
@end verbatim
Vim にパッチ 7.4.237 が含まれていることが分かっているなら、次の条件で簡単にチェックすることができます:
@verbatim
has('patch-7.4.401')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
						*E817* *E818* *E819* *E820*
When encryption does not work properly, you would be able to write your text
to a file and never be able to read it back.  Therefore a test is performed to
check if the encryption works as expected.  If you get one of these errors
don't write the file encrypted!  You need to rebuild the Vim binary to fix
this.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E817}
@anchor{E818}
@anchor{E819}
@anchor{E820}
@erindex E817
@erindex E818
@erindex E819
@erindex E820
暗号化が正しく機能しないと、保存したファイルが後で読めなくなってしまいます。そのため、暗号化が期待したとおりに機能しているかどうかを確認するための検査が実行されます。これらのエラーが表示されたときはファイルを暗号化して保存しないでください。これを直すためには Vim を再ビルドする必要があるでしょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
*E831* This is an internal error, "cannot happen".  If you can reproduce it,
please report to the developers.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E831}
@erindex E831
内部エラーの *E831* は普通は発生しません。このエラーの再現手順を見つけた方は開発者へ連絡してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When reading a file that has been encrypted and the 'key' option is not empty,
it will be used for decryption.  If the value is empty, you will be prompted
to enter the key.  If you don't enter a key, or you enter the wrong key, the
file is edited without being decrypted.  There is no warning about using the
wrong key (this makes brute force methods to find the key more difficult).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
暗号化されたファイルを読み込んだとき、'@option{key}' オプションの値が空でなければその値が復号に使われます。空のときは入力プロンプトが表示されます。キーを入力しないか間違ったキーを入力するとファイルは復号されずに開かれます。キーが間違っていても警告は表示されません (総当たり攻撃を難しくするため)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If want to start reading a file that uses a different key, set the 'key'
option to an empty string, so that Vim will prompt for a new one.  Don't use
the ":set" command to enter the value, other people can read the command over
your shoulder.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
異なる鍵で暗号化したファイルの読み込みを始めたいときは、オプション '@option{key}' の値に空文字列を設定してください。すると Vim が新しい値の入力を求めます。値の入力にコマンド "@command{:set}" を使ってはなりません。他の人が肩越しにコマンドの入力を読むことができるからです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Since the value of the 'key' option is supposed to be a secret, its value can
never be viewed.  You should not set this option in a vimrc file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
オプション '@option{key}' の値は秘密であることになっているので、その値は決して見られてはなりません。@file{vimrc} ファイル内でこのオプションを設定してはいけません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An encrypted file can be recognized by the "file" command, if you add these
lines to "/etc/magic", "/usr/share/misc/magic" or wherever your system has the
"magic" file: >
     0	string	VimCrypt~	Vim encrypted file
     >9	string	01	- "zip" cryptmethod
     >9	string	02	- "blowfish" cryptmethod
     >9	string	03	- "blowfish2" cryptmethod
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"/etc/magic", "/usr/share/misc/magic" 等、システムの持っている "magic" ファイルならどれでもよいですが、下の行を追加すると、暗号化されたファイルが "file" コマンドに認識されるようになります:
@verbatim
0   string  VimCrypt~       Vim encrypted file
>9  string  01      - "zip" cryptmethod
>9  string  02      - "blowfish" cryptmethod
>9  string  03      - "blowfish2" cryptmethod
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Notes:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Notes:}
@itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Encryption is not possible when doing conversion with 'charconvert'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item オプション '@option{charconvert}' でコード変換をしているときには暗号化はできません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Text you copy or delete goes to the numbered registers.  The registers can
  be saved in the .viminfo file, where they could be read.  Change your
  'viminfo' option to be safe.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item コピーや削除したテキストは番号付きレジスタに格納されます。レジスタの内容は @file{.viminfo} ファイル内に保存することができますが、ここからは読み出されるかもしれません。安全のためオプション '@option{viminfo}' を変更してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Someone can type commands in Vim when you walk away for a moment, he should
  not be able to get the key.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item コンピュータからしばらく離れているときには誰かが Vim にコマンドを入力できますが、鍵を入手できるようになっていてはいけません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- If you make a typing mistake when entering the key, you might not be able to
  get your text back!
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item キーを入力しているときにタイプミスをすると、テキストを復元できなくなってしまうでしょう！
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- If you type the key with a ":set key=value" command, it can be kept in the
  history, showing the 'key' value in a viminfo file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item コマンド "@command{:set key=value}" で鍵を入力すると、それは履歴の中に保存され、viminfo ファイル内に '@option{key}' の値を晒すことになります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- There is never 100% safety.  The encryption in Vim has not been tested for
  robustness.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 100 パーセント安全ということは決してありません。Vim の暗号化は強度についてはテストされていません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The algorithm used for 'cryptmethod' "zip" is breakable.  A 4 character key
  in about one hour, a 6 character key in one day (on a Pentium 133 PC).  This
  requires that you know some text that must appear in the file.  An expert
  can break it for any key.  When the text has been decrypted, this also means
  that the key can be revealed, and other files encrypted with the same key
  can be decrypted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item '@option{cryptmethod}' が "zip" のときに使用されるアルゴリズムは簡単に破れます。4 文字の鍵なら約 1 時間以内、6 文字の鍵なら 1 日以内で破れます (Pentium 133 PC で)。これにはファイル内に必ず現れるはずのテキストをいくつか知っている必要があります。暗号破りの熟練者はどのような鍵であっても破ることができます。テキストが復号化されたということは鍵も明らかになったということであり、同じ鍵で暗号化された他のテキストも復号化できてしまいます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Pkzip uses the same encryption as 'cryptmethod' "zip", and US Govt has no
  objection to its export.  Pkzip's public file APPNOTE.TXT describes this
  algorithm in detail.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item Pkzip は '@option{cryptmethod}' の "zip" と同じ暗号化を用いており、合衆国政府はその輸出に対して異議を唱えていません。Pkzip の公開ファイル @file{APPNOTE.TXT} にはこのアルゴリズムが詳細に記述されています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The implementation of 'cryptmethod' "blowfish" has a flaw.  It is possible
  to crack the first 64 bytes of a file and in some circumstances more of the
  file. Use of it is not recommended, but it's still the strongest method
  supported by Vim 7.3 and 7.4.  The "zip" method is even weaker.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item '@option{cryptmethod}' の "blowfish" の実装には脆弱性があります。ファイルの最初の 64 バイト (条件によってはもっと) はクラック可能です。これの使用は推奨されませんが、Vim 7.3 と 7.4 でサポートされている中ではそれが一番強度のあるメソッドです。"zip" メソッドはさらに弱いです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Vim originates from the Netherlands.  That is where the sources come from.
  Thus the encryption code is not exported from the USA.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item Vim はオランダに起源を持ちます。そこがソースの出処です。従って、暗号化コードはアメリカ合衆国から輸出されてはいません。
@end itemize
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
10. Timestamps					*timestamp* *timestamps*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{timestamp}
@anchor{timestamps}
@cindex timestamp
@cindex timestamps
@cindex タイムスタンプ
@section 10. タイムスタンプ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim remembers the modification timestamp, mode and size of a file when you
begin editing it.  This is used to avoid that you have two different versions
of the same file (without you knowing this).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は編集を始めたときのファイルの修正タイムスタンプとモードとサイズを覚えています。これは同じファイルの別のバージョンを (知らずに) 作ってしまうのを防ぐためです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
After a shell command is run (|:!cmd| |suspend| |:read!| |K|) timestamps,
file modes and file sizes are compared for all buffers in a window.   Vim will
run any associated |FileChangedShell| autocommands or display a warning for
any files that have changed.  In the GUI this happens when Vim regains input
focus.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シェルコマンド (|@ref{:!cmd}| |@ref{suspend}| |@ref{:read!}| |@ref{K}|) の実行後、ウィンドウ内の全てのバッファでタイムスタンプとファイルモードとファイルサイズが比較されます。Vim は変更を受けたファイルに関して、イベント |@ref{FileChangedShell}| に関連付けられた任意の自動コマンドを実行するか、警告を表示します。GUI を使っているときは、それらは Vim に入力フォーカスが戻ってきたときに行われます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*E321* *E462*
If you want to automatically reload a file when it has been changed outside of
Vim, set the 'autoread' option.  This doesn't work at the moment you write the
file though, only when the file wasn't changed inside of Vim.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E321}
@anchor{E462}
@erindex E321
@erindex E462
ファイルが Vim の外部で変更を受けたときに自動的に読み直して欲しいなら、オプション '@option{autoread}' をオンにしてください。しかしこれはファイルを書き込んだ時点では機能しません。ファイルが Vim 内部で変更されていないときだけです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you do not want to be asked or automatically reload the file, you can use
this: >
	set buftype=nofile

Or, when starting gvim from a shell: >
	gvim file.log -c "set buftype=nofile"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もしも質問されたくなかったり、ファイルを自動的に再読み込みをしたいのなら、次の設定を使うことができます:
@verbatim
set buftype=nofile
@end verbatim
もしくは、シェルから gvim を起動する時に
@verbatim
gvim file.log -c "set buftype=nofile"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Note that if a FileChangedShell autocommand is defined you will not get a
warning message or prompt.  The autocommand is expected to handle this.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
イベント |@ref{FileChangedShell}| に自動コマンドが定義されていると、警告メッセージやプロンプトは表示されません。その自動コマンドが対処するものとされています。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There is no warning for a directory (e.g., with |netrw-browse|).  But you do
get warned if you started editing a new file and it was created as a directory
later.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ディレクトリに関する警告はありません (例えば |@ref{netrw-browse}| で)。しかし新しいファイルの編集を始めた後、同名のディレクトリが作られたときには警告されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When Vim notices the timestamp of a file has changed, and the file is being
edited in a buffer but has not changed, Vim checks if the contents of the file
is equal.  This is done by reading the file again (into a hidden buffer, which
is immediately deleted again) and comparing the text.  If the text is equal,
you will get no warning.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルのタイムスタンプが変更されたことに Vim が気づいたとき、そのファイルがバッファ内で編集されているけれどもまだ変更されていないなら、Vim はファイルの中身が同じかどうかを調べます。このためにはファイルを読み直し、テキストを比較します (隠れバッファに読み込みますが、これはすぐに削除されます)。内容が同じならば警告は出ません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you don't get warned often enough you can use the following command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
自動警告では足りないと思ったなら、以下のコマンドが使えます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*:checkt* *:checktime*
:checkt[ime]		Check if any buffers were changed outside of Vim.
			This checks and warns you if you would end up with two
			versions of a file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:checkt}
@anchor{:checktime}
@pindex :checkt
@pindex :checktime
@table @asis
@item :checkt[ime]
Vim の外部で変更を受けたバッファがないかどうか調べます。これはファイルのバージョンが 2 個になってしまわないかどうかを調べて警告します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			If this is called from an autocommand, a ":global"
			command or is not typed the actual check is postponed
			until a moment the side effects (reloading the file)
			would be harmless.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

これが自動コマンドや "@command{:global}" コマンドから呼ばれたときや、直に打ち込まれたのではないときは、実際に調べるのは副作用 (ファイルの再読み込み) が無害となる時点まで延期されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Each loaded buffer is checked for its associated file
			being changed.  If the file was changed Vim will take
			action.  If there are no changes in the buffer and
			'autoread' is set, the buffer is reloaded.  Otherwise,
			you are offered the choice of reloading the file.  If
			the file was deleted you get an error message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

読み込まれているバッファそれぞれについて関連付けられたファイルが変更を受けていないか調べます。変更を受けていたら、Vim は対処動作を行います。すなわちバッファに変更点が無く、かつオプション '@option{autoread}' がオンのときは、バッファは読み直されます。そうでなければ、ファイルを読み直すかどうかの選択肢が与えられます。ファイルが削除されていたら、エラーメッセージが表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			If the file previously didn't exist you get a warning
			if it exists now.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

以前には存在しなかったファイルが存在していたら、エラーメッセージが表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			Once a file has been checked the timestamp is reset,
			you will not be warned again.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

一度ファイルが調べられるとタイムスタンプ情報が更新され、再び警告されることはありません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[N]checkt[ime] {filename}
:[N]checkt[ime] [N]
			Check the timestamp of a specific buffer.  The buffer
			may be specified by name, number or with a pattern.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item :[N]checkt[ime] @{filename@}
@itemx :[N]checkt[ime] [N]
特定のバッファのタイムスタンプを調べます。バッファの指定は名前、番号またはパターンでもよい。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
							*E813* *E814*
Vim will reload the buffer if you chose to.  If a window is visible that
contains this buffer, the reloading will happen in the context of this window.
Otherwise a special window is used, so that most autocommands will work.  You
can't close this window.  A few other restrictions apply.  Best is to make
sure nothing happens outside of the current buffer.  E.g., setting
window-local options may end up in the wrong window.  Splitting the window,
doing something there and closing it should be OK (if there are no side
effects from other autocommands).  Closing unrelated windows and buffers will
get you into trouble.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E813}
@anchor{E814}
@erindex E813
@erindex E814
ここでユーザーがバッファを再読み込みすることを選ぶと、再読み込みされます。そのバッファを含むウィンドウが表示されている場合、再読み込みはそのウィンドウの中で行われます。そのようなウィンドウがなければ、自動コマンドが正常に動作するよう、特殊なウィンドウが使われます。このウィンドウを閉じることはできません。他にもいくつかの制限が適用されます。カレントバッファの外では何も起こらないようにするのがベストです。

例えば、ウィンドウローカルなオプションをセットすると、間違ったウィンドウの中でセットされてしまいます。ウィンドウを分割し、そこで何かをして、閉じることは大丈夫です (他の自動コマンドによる副作用が何もなければ)。無関係なウィンドウやバッファを閉じると問題を引き起こすでしょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Before writing a file the timestamp is checked.  If it has changed, Vim will
ask if you really want to overwrite the file:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
書き込み前にはタイムスタンプが調べられます。もし変更されていたら、Vim はそのファイルを本当に上書きするかどうかを尋ねます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	WARNING: The file has been changed since reading it!!!
	Do you really want to write to it (y/n)?
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@display
警告: 読込んだ後にファイルに変更がありました！！！
本当に上書きしますか (y/n)？
@end display
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you hit 'y' Vim will continue writing the file.  If you hit 'n' the write is
aborted.  If you used ":wq" or "ZZ" Vim will not exit, you will get another
chance to write the file.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'y' を打ち込むと、Vim は続けて書き込みを行います。'n' を打ち込むと、書き込みは中止されます。コマンド "@command{:wq}" や "@command{ZZ}" を使った場合には Vim は終了せず、書き込む機会が再び得られます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The message would normally mean that somebody has written to the file after
the edit session started.  This could be another person, in which case you
probably want to check if your changes to the file and the changes from the
other person should be merged.  Write the file under another name and check for
differences (the "diff" program can be used for this).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
普通、メッセージは編集セッションが始まった後に誰かがファイルに書き込んだことを示しています。それは別の人物かもしれません。この場合、あなたの行った変更とその人物が行った変更が合併されるべきか調べたいことでしょう。ファイルを別の名前で書き込み、差分を調べてください (これにはプログラム "diff" が使える)。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
It is also possible that you modified the file yourself, from another edit
session or with another command (e.g., a filter command).  Then you will know
which version of the file you want to keep.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
別の編集セッションや別のコマンドで (例えばフィルタコマンド) そのファイルに自分自身で変更を加えたということもあり得ます。その場合、どちらのバージョンを保管したいかは自分でわかっているでしょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There is one situation where you get the message while there is nothing wrong:
On a Win32 system on the day daylight saving time starts.  There is something
in the Win32 libraries that confuses Vim about the hour time difference.  The
problem goes away the next day.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
何も間違ったことはしていないのにこのメッセージが現れる場合が 1 つあります: Win32 でサマータイムが始まる日です。Win32 ライブラリにより、Vim が時間の差を混乱してしまうのです。この問題は次の日には直ります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
11. File Searching					*file-searching*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{file-searching}
@cindex file-searching
@cindex ファイル検索
@section 11. ファイル検索
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{not available when compiled without the |+path_extra| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{Vim が |@ref{+path_extra}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The file searching is currently used for the 'path', 'cdpath' and 'tags'
options, for |finddir()| and |findfile()|.  Other commands use |wildcards|
which is slightly different.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
現在のところ、オプション '@option{path}', '@option{cdpath}', '@option{tags}' と |@ref{finddir()}|, |@ref{findfile()}| で、本節で説明する「ファイル検索」にしたがってワイルドカードの展開が行われます。それ以外のコマンドでは |@ref{wildcards}| という少し異なるルールに従います。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are three different types of searching:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイル検索には以下の 3 種類があります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1) Downward search:					*starstar*
   Downward search uses the wildcards '*', '**' and possibly others
   supported by your operating system.  '*' and '**' are handled inside Vim,
   so they work on all operating systems.  Note that "**" only acts as a
   special wildcard when it is at the start of a name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{starstar}
@cindex starstar
@cindex **
@table @asis
@item 1) 下向き検索:
下向き検索にはワイルドカード '*' と '**' 及びユーザーの OS がサポートするその他のものが使えます。'*' と '**' は Vim 内部で処理されるので、全ての OS で機能します。
@quotation
@strong{Note:}@*
"**" はパス名の先頭で使われた場合のみ特別なワイルドカードとなります。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
   The usage of '*' is quite simple: It matches 0 or more characters.  In a
   search pattern this would be ".*".  Note that the "." is not used for file
   searching.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'*' の使用法はきわめて単純です: 0 個以上の文字にマッチします。正規表現パターンでいうと ".*" と同じです。正規表現と異なり "." は必要ないことに注意してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
   '**' is more sophisticated:
      - It ONLY matches directories.
      - It matches up to 30 directories deep by default, so you can use it to
	search an entire directory tree
      - The maximum number of levels matched can be given by appending a number
	to '**'.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'**' はもっとすばらしい。
@itemize
@item これはディレクトリのみにマッチします。
@item これはデフォルトで 30 段階までの深さのディレクトリにマッチするので、ディレクトリツリー全体の検索に使えます。
@item マッチする深さの最大値は '**' の後に数字を付け加えて指定することができます。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	Thus '/usr/**2' can match: >
		/usr
		/usr/include
		/usr/include/sys
		/usr/include/g++
		/usr/lib
		/usr/lib/X11
		....
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ですから '/usr/**2' は下のようにマッチします。
@verbatim
/usr
/usr/include
/usr/include/sys
/usr/include/g++
/usr/lib
/usr/lib/X11
....
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<	It does NOT match '/usr/include/g++/std' as this would be three
	levels.
	The allowed number range is 0 ('**0' is removed) to 100
	If the given number is smaller than 0 it defaults to 30, if it's
	bigger than 100 then 100 is used.  The system also has a limit on the
	path length, usually 256 or 1024 bytes.
      - '**' can only be at the end of the path or be followed by a path
	separator or by a number and a path separator.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'/usr/include/g++/std' には、深さが 3 なのでマッチしません。

指定可能な範囲は 0 ('**0' は無視される) から 100 です。負数を指定すると 30 を、100 より大きい数を指定すると 100 を指定したものとされます。システムにもパスの長さの限界が存在する場合があります。通常は 256 または 1024 バイトです。
@itemize
@item '**' はパスの末尾にのみ使えます。後ろにパス区切り文字か、数字とパス区切り文字の組み合わせを付けてもよい。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
   You can combine '*' and '**' in any order: >
	/usr/**/sys/*
	/usr/*tory/sys/**
	/usr/**2/sys/*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'*' と '**' を組み合わせる順番は自由です。
@verbatim
/usr/**/sys/*
/usr/*tory/sys/**
/usr/**2/sys/*
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
2) Upward search:
   Here you can give a directory and then search the directory tree upward for
   a file.  You could give stop-directories to limit the upward search.  The
   stop-directories are appended to the path (for the 'path' option) or to
   the filename (for the 'tags' option) with a ';'.  If you want several
   stop-directories separate them with ';'.  If you want no stop-directory
   ("search upward till the root directory) just use ';'. >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 2) 上向き検索:
この方法ではディレクトリを指定すると、そのディレクトリから上に遡ってファイルを探します。上向き探索の上限となるディレクトリを指定できます。それはパス (オプション '@option{path}') かファイル名 (オプション '@option{tags}') の末尾に ';' で区切って指定します。複数のディレクトリを指定したいときはそれらを ';' で区切ります。上限ディレクトリを指定したくないときは (ルートディレクトリまで上向き検索したいとき) ';' だけを付けます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	/usr/include/sys;/usr
<   will search in: >
	   /usr/include/sys
	   /usr/include
	   /usr
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
/usr/include/sys;/usr
@end verbatim
で検索されるディレクトリは:
@verbatim
/usr/include/sys
/usr/include
/usr
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   If you use a relative path the upward search is started in Vim's current
   directory or in the directory of the current file (if the relative path
   starts with './' and 'd' is not included in 'cpoptions').
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
相対パスを使うと上向き検索は Vim のカレントディレクトリから始まります。相対パスの指定が './' で始まり、'@option{cpoptions}' にフラグ '@var{d}' が含まれていないときはカレントファイルのディレクトリから始まります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
   If Vim's current path is /u/user_x/work/release and you do >
	:set path=include;/u/user_x
<  and then search for a file with |gf| the file is searched in: >
	/u/user_x/work/release/include
	/u/user_x/work/include
	/u/user_x/include
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim のカレントパスが /u/user_x/work/release のときに
@verbatim
:set path=include;/u/user_x
@end verbatim
とすると、コマンド |@ref{gf}| でファイルを探す範囲は:
@verbatim
/u/user_x/work/release/include
/u/user_x/work/include
/u/user_x/include
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
3) Combined up/downward search:
   If Vim's current path is /u/user_x/work/release and you do >
	set path=**;/u/user_x
<  and then search for a file with |gf| the file is searched in: >
	/u/user_x/work/release/**
	/u/user_x/work/**
	/u/user_x/**
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 3) 複合検索:
Vim のカレントパスが /u/user_x/work/release のときに
@verbatim
set path=**;/u/user_x
@end verbatim
とすると、コマンド |@ref{gf}| でファイルを探す範囲は:
@verbatim
/u/user_x/work/release/**
/u/user_x/work/**
/u/user_x/**
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
   BE CAREFUL!  This might consume a lot of time, as the search of
   '/u/user_x/**' includes '/u/user_x/work/**' and
   '/u/user_x/work/release/**'.  So '/u/user_x/work/release/**' is searched
   three times and '/u/user_x/work/**' is searched twice.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{注意！} @*
これはかなりの時間を食うかもしれません。'/u/user_x/**' は '/u/user_x/work/**' や '/u/user_x/work/release/**' を含むからです。つまり '/u/user_x/work/release/**' は 3 回、'/u/user_x/work/**' は 2 回繰り返して検索されます。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
   In the above example you might want to set path to: >
	:set path=**,/u/user_x/**
<  This searches:
	/u/user_x/work/release/** ~
	/u/user_x/** ~
   This searches the same directories, but in a different order.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
上の例では次のように設定したほうがいいかもしれません:
@verbatim
:set path=**,/u/user_x/**
@end verbatim
これに含まれる範囲は
@verbatim
/u/user_x/work/release/**
/u/user_x/**
@end verbatim
となり、同じディレクトリですが順番が違います。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
   Note that completion for ":find", ":sfind", and ":tabfind" commands do not
   currently work with 'path' items that contain a URL or use the double star
   with depth limiter (/usr/**2) or upward search (;) notations.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
現在 "@command{:find}", "@command{:sfind}", "@command{:tabfind}" コマンドは、'@option{path}' アイテムに URL や深さ制限付きのダブルスター (/usr/**2) や 上方検索 (;) などが含まれていると機能しないことに注意してください。
@end quotation
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 vim:tw=78:ts=8:noet:ft=help:norl:
@end ifset
