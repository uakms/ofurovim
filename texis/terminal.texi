@ifset JA  @c ----------- v -----------  JA  -*- tab-width: 8 -*-
@node terminal.txt, , , 目次
@unnumbered ターミナルウィンドウのサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
*terminal.txt*	For Vim version 8.1.  Last change: 2019 Jul 04


		  VIM REFERENCE MANUAL	  by Bram Moolenaar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
*terminal.txt*  For Vim バージョン 8.1.  Last change: 2019 Jul 04


                VIMリファレンスマニュアル    by Bram Moolenaar
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Terminal window support				*terminal* *terminal-window*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal}
@anchor{terminal-window}
@cindex terminal
@cindex terminal-window
端末ウィンドウサポート
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
The terminal feature is optional, use this to check if your Vim has it: >
	echo has('terminal')
If the result is "1" you have it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末機能はオプションなので、あなたの Vim が対応しているかは次のコマンドを使って確認できます:
@verbatim
echo has('terminal')
@end verbatim
結果が "1" ならば対応しています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
1. Basic use				|terminal-use|
      Typing					|terminal-typing|
      Size and color				|terminal-size-color|
      Command syntax				|:terminal|
      Resizing					|terminal-resizing|
      Terminal Modes				|Terminal-mode|
      Cursor style				|terminal-cursor-style|
      Session					|terminal-session|
      Special keys				|terminal-special-keys|
      Unix					|terminal-unix|
      MS-Windows				|terminal-ms-windows|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .6 .4
@item 1. 基本的な使い方 @tab |@ref{terminal-use}|
@item @ @ @ @ キー入力 @tab |@ref{terminal-typing}|
@item @ @ @ @ サイズと色 @tab |@ref{terminal-size-color}|
@item @ @ @ @ コマンドの文法 @tab |@ref{:terminal}|
@item @ @ @ @ サイズ変更 @tab |@ref{terminal-resizing}|
@item @ @ @ @ ターミナルモード @tab |@ref{Terminal-mode}|
@item @ @ @ @ カーソルスタイル @tab |@ref{terminal-cursor-style}|
@item @ @ @ @ セッション @tab |@ref{terminal-session}|
@item @ @ @ @ 特別なキー @tab |@ref{terminal-special-keys}|
@item @ @ @ @ Unix @tab |@ref{terminal-unix}|
@item @ @ @ @ MS-Windows @tab |@ref{terminal-ms-windows}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
2. Terminal functions			|terminal-function-details|
3. Terminal communication		|terminal-communication|
      Vim to job: term_sendkeys()		|terminal-to-job|
      Job to Vim: JSON API			|terminal-api|
      Using the client-server feature		|terminal-client-server|
4. Remote testing			|terminal-testing|
5. Diffing screen dumps			|terminal-diff|
      Writing a screen dump test for Vim  	|terminal-dumptest|
      Creating a screen dump		  	|terminal-screendump|
      Comparing screen dumps		  	|terminal-diffscreendump|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 2. Terminal 関数 @tab |@ref{terminal-function-details}|
@item 3. 端末通信 @tab |@ref{terminal-communication}|
@item @ @ @ @ Vim からジョブへ: term_sendkeys() @tab |@ref{terminal-to-job}|
@item @ @ @ @ ジョブから Vim へ: JSON API @tab |@ref{terminal-api}|
@item @ @ @ @ クライアントサーバー機能を使う @tab |@ref{terminal-client-server}|
@item 4. リモートテスト @tab |@ref{terminal-testing}|
@item 5. 画面ダンプの差分 @tab |@ref{terminal-diff}|
@item @ @ @ @ Vim の画面ダンプテストを書く@tab |@ref{terminal-dumptest}|
@item @ @ @ @ 画面ダンプを作成する @tab |@ref{terminal-screendump}|
@item @ @ @ @ 画面ダンプを比較する @tab |@ref{terminal-diffscreendump}|
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
6. Debugging				|terminal-debug|
      Starting					|termdebug-starting|
      Example session				|termdebug-example|
      Stepping through code			|termdebug-stepping|
      Inspecting variables			|termdebug-variables|
      Other commands				|termdebug-commands|
      Prompt mode				|termdebug-prompt|
      Communication				|termdebug-communication|
      Customizing				|termdebug-customizing|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item 6. デバッグ @tab |@ref{terminal-debug}|
@item @ @ @ @ はじめに @tab |@ref{termdebug-starting}|
@item @ @ @ @ セッション例 @tab |@ref{termdebug-example}|
@item @ @ @ @ コードをステップ実行する @tab |@ref{termdebug-stepping}|
@item @ @ @ @ 変数を検査する @tab |@ref{termdebug-variables}|
@item @ @ @ @ その他のコマンド @tab |@ref{termdebug-commands}|
@item @ @ @ @ プロンプトモード @tab |@ref{termdebug-prompt}|
@item @ @ @ @ 通信 @tab |@ref{termdebug-communication}|
@item @ @ @ @ カスタマイズ @tab |@ref{termdebug-customizing}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The terminal feature requires the |+job| and |+channel| features.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末機能を使うには |@ref{+job}| そして |@ref{+channel}| 機能が必要です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
1. Basic use						*terminal-use*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-use}
@cindex terminal-use
@section 1. 基本的な使い方
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This feature is for running a terminal emulator in a Vim window.  A job can be
started connected to the terminal emulator. For example, to run a shell: >
     :term bash
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは Vim のウィンドウ内で端末エミュレーターを実行する機能です。端末エミュレーターに接続すると 1 つのジョブが開始されます。例としてシェルを実行するならば以下のようになります:
@verbatim
:term bash
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Or to run build command: >
     :term make myprogram
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
またビルドコマンドを実行するにはこうなります:
@verbatim
:term make myprogram
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The job runs asynchronously from Vim, the window will be updated to show
output from the job, also while editing in another window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブは Vim とは非同期的に動作し、他のウィンドウで編集中であってもジョブからの出力は随時端末ウィンドウに反映されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Typing ~
							*terminal-typing*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-typing}
@cindex terminal-typing
@unnumberedsubsec キー入力
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
When the keyboard focus is in the terminal window, typed keys will be sent to
the job.  This uses a pty when possible.  You can click outside of the
terminal window to move keyboard focus elsewhere.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末ウィンドウにキーボードのフォーカスがある時には、入力したキーはジョブに送られます。これには可能ならば pty を使用します。端末ウィンドウ外をクリックすれば、キーボードフォーカスを外に動かせます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*t_CTRL-W_CTRL-W* *t_CTRL-W_:*
CTRL-W can be used to navigate between windows and other CTRL-W commands, e.g.:
	CTRL-W CTRL-W	move focus to the next window
	CTRL-W :	enter an Ex command
See |CTRL-W| for more commands.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{t_CTRL-W_CTRL-W}
@anchor{t_CTRL-W_:}
@kindex t_CTRL-W_CTRL-W
@kindex t_CTRL-W_:
ウィンドウや他の @kbd{CTRL-W} コマンドを操作するために @kbd{CTRL-W} を使えます。例えば:
@multitable @columnfractions .4 .6
@item @kbd{CTRL-W CTRL-W} @tab 次のウィンドウにフォーカスを移動する
@item @kbd{CTRL-W :} @tab Ex コマンドに入る
@end multitable
他のコマンドについては |@ref{CTRL-W}| 参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Special in the terminal window:			*t_CTRL-W_.*  *t_CTRL-W_N* 
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{t_CTRL-W_.}
@anchor{t_CTRL-W_N}
@kindex t_CTRL-W_.
@kindex t_CTRL-W_N
@unnumberedsubsubsec 端末ウィンドウでの特別な操作:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	CTRL-W .	send a CTRL-W to the job in the terminal
	CTRL-W CTRL-\	send a CTRL-\ to the job in the terminal
	CTRL-W N	go to Terminal-Normal mode, see |Terminal-mode|
	CTRL-\ CTRL-N   go to Terminal-Normal mode, see |Terminal-mode|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item @kbd{CTRL-W .} @tab 端末内のジョブに @kbd{CTRL-W} を送る
@item @kbd{CTRL-W} @kbd{CTRL-\} @tab 端末内のジョブに @kbd{CTRL-\} を送る
@item @kbd{CTRL-W N} @tab Terminal-Normal モードに移行, |@ref{Terminal-mode}| を参照
@item @kbd{CTRL-\ CTRL-N} @tab Terminal-Normal モードに移行, |@ref{Terminal-mode}| を参照
@anchor{t_CTRL-W_quote}
@kindex t_CTRL-W_quote
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	CTRL-W " {reg}  paste register {reg}		*t_CTRL-W_quote*
			Also works with the = register to insert the result of
			evaluating an expression.
	CTRL-W CTRL-C	ends the job, see below |t_CTRL-W_CTRL-C|
	CTRL-W gt	go to next tabpage, same as `gt`	*t_CTRL-W_gt*
	CTRL-W gT	go to previous tabpage, same as `gT`	*t_CTRL-W_gT*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item @kbd{CTRL-W "} @{reg@} @tab レジスタ @{reg@} の内容を貼り付け式の評価結果を挿入するためのレジスタ = も機能する
@item @kbd{CTRL-W CTRL-C} @tab ジョブを停止する, 下記の |@ref{t_CTRL-W_CTRL-C}| を参照
@anchor{t_CTRL-W_gt}
@kindex t_CTRL-W_gt
@item @kbd{CTRL-W gt} @tab 次のタブページに移動する。`@command{gt}` と同じ
@anchor{t_CTRL-W_gT}
@kindex t_CTRL-W_gT
@item @kbd{CTRL-W gT} @tab 前のタブページに移動する。`@command{gT}` と同じ
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
See option 'termwinkey' for specifying another key instead of CTRL-W that
will work like CTRL-W.  However, typing 'termwinkey' twice sends 'termwinkey'
to the job.  For example:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-W} の代わりに別のキーを使うにはオプション '@option{termwinkey}' を参照してください。ただし '@option{termwinkey}' を 2 回タイプすると '@option{termwinkey}' がジョブへ送信されます。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	'termwinkey' CTRL-W    move focus to the next window
	'termwinkey' :	       enter an Ex command
	'termwinkey' 'termwinkey' send 'termwinkey' to the job in the terminal
	'termwinkey' .	       send 'termwinkey' to the job in the terminal
	'termwinkey' CTRL-\    send a CTRL-\ to the job in the terminal
	'termwinkey' N	       go to terminal Normal mode, see below
	'termwinkey' CTRL-N    same as CTRL-W N |t_CTRL-W_N|
	'termwinkey' CTRL-C    same as CTRL-W CTRL-C |t_CTRL-W_CTRL-C|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .4 .6
@item '@option{termwinkey}' @kbd{CTRL-W} @tab 次のウィンドウにフォーカスを移動する
@item '@option{termwinkey}' @key{:} @tab Ex コマンドに入る
@item '@option{termwinkey}' '@option{termwinkey}' @tab 端末内のジョブに '@option{termwinkey}' を送信する
@item '@option{termwinkey}' @key{.} @tab 端末内のジョブに '@option{termwinkey}' を送信する
@item '@option{termwinkey}' @key{CTRL-\} @tab 端末内のジョブに @kbd{CTRL-W} を送信する
@item '@option{termwinkey}' @key{N} @tab Terminal-Normal モードへ移行する。以下を参照
@item '@option{termwinkey}' @kbd{CTRL-N} @tab @kbd{CTRL-W N} と同じ |@ref{t_CTRL-W_N}|
@item '@option{termwinkey}' @kbd{CTRL-C} @tab @kbd{CTRL-W CTRL-C} と同じ |@ref{t_CTRL-W_CTRL-C}|
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*t_CTRL-\_CTRL-N*
The special key combination CTRL-\ CTRL-N can be used to switch to Normal
mode, just like this works in any other mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{t_CTRL-\_CTRL-N}
@kindex t_CTRL-\_CTRL-N
他のモードと同じように、ノーマルモードへ移行するための特別なキーの組み合わせである @kbd{CTRL-\ CTRL-N} が利用できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*t_CTRL-W_CTRL-C*
CTRL-W CTRL-C can be typed to forcefully end the job.  On MS-Windows a
CTRL-BREAK will also kill the job.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{t_CTRL-W_CTRL-C}
@kindex t_CTRL-W_CTRL-C
ジョブを強制停止するのに @kbd{CTRL-W CTRL-C} を使えます。MS-Windows では @kbd{CTRL-BREAK} でも同様にジョブを停止できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If you type CTRL-C the effect depends on what the pty has been configured to
do.  For simple commands this causes a SIGINT to be sent to the job, which
would end it.  Other commands may ignore the SIGINT or handle the CTRL-C
themselves (like Vim does).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-C} を入力した場合、その効果は pty がどのように構成されているかに従います。シンプルなコマンドにおいては SIGINT がジョブに送られ、結果的にジョブが停止するでしょう。中には SIGINT を無視するコマンドもあるでしょうし、また (Vim がそうしているように) @kbd{CTRL-C} をプログラム自身で取り扱うものもあるでしょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To change the keys you type use terminal mode mappings, see |:tmap|.
These are defined like any mapping, but apply only when typing keys that are
sent to the job running in the terminal.  For example, to make F1 switch
to Terminal-Normal mode: >
   tnoremap <F1> <C-W>N
You can use Esc, but you need to make sure it won't cause other keys to
break (cursor keys start with an Esc, so they may break): >
   tnoremap <Esc> <C-W>N
   set notimeout ttimeout timeoutlen=100
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
入力したキーを別のものに読み返させるには端末モードマッピング、詳細は |@ref{:tmap}| を使用してください。これはどのようなマッピングでも定義できますが、端末内で実行されているジョブに送信されるキー入力にのみ作用します。例えば、F1 キーで Terminal-Normal モードに切り替えるには:
@verbatim
tnoremap <F1> <C-W>N
@end verbatim
Esc を使うこともできますが、他のキーが壊れないようにする必要があります (カーソルキーは Esc で始まるので、それらは壊れるかもしれません):
@verbatim
tnoremap <Esc> <C-W>N
set notimeout ttimeout timeoutlen=100
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN

@ifset EN
You can also create menus similar to terminal mode mappings, but you have to
use |:tlmenu| instead of |:tmenu|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
あなたはまた、Terminal モードマッピング用に同じようなメニューを作成することができますが、|@ref{:tmenu}| の代わりに |@ref{:tlmenu}| を使用しなければなりません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

<							*options-in-terminal*
After opening the terminal window and setting 'buftype' to "terminal" the
TerminalOpen autocommand event is triggered.  This makes it possible to set
options specifically for the window and buffer.  Example: >
   au TerminalOpen * if &buftype == 'terminal' | setlocal bufhidden=hide | endif
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{options-in-terminal}
@cindex options-in-terminal
端末ウィンドウを開いて '@option{buftype}' を "@var{terminal}" に設定すると、TerminalOpen 自動コマンドイベントが発生します。これにより、ウィンドウとバッファ専用のオプションを設定することが可能です。例:
@verbatim
au TerminalOpen * if &buftype == 'terminal' | setlocal bufhidden=hide | endif
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The <abuf> is set to the terminal buffer, but if there is no window (hidden
terminal) then setting options will happen in the wrong buffer, therefore the
check for &buftype in the example.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
<abuf> は端末バッファに設定されていますが、ウィンドウが存在しない場合 (隠された端末) は間違ったバッファにオプションが設定されるため、この例では &buftype のチェックが行われます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Mouse events (click and drag) are passed to the terminal.  Mouse move events
are only passed when Vim itself is receiving them.  For a terminal that is
when 'balloonevalterm' is enabled.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
マウスイベント (クリックやドラッグ) は端末に渡されます。マウス移動イベントは Vim 自身が受け取ったときのみ渡されます。'@option{balloonevalterm}' が有効になっている端末の場合です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Size and color ~
							*terminal-size-color*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-size-color}
@cindex terminal-size-color
@unnumberedsubsec サイズと色
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
See option 'termwinsize' for controlling the size of the terminal window.
(TODO: scrolling when the terminal is larger than the window)
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末ウィンドウのサイズを制御するにはオプション '@option{termwinsize}' を参照してください。(TODO: 端末がウィンドウよりも大きい場合にはスクロールすることを記述する)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The job running in the terminal can change the colors.  The default foreground
and background colors are taken from Vim, the Normal highlight group.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末内のジョブは端末の色を変更できます。デフォルトの前景色及び背景色は Vim の Normal ハイライトグループにより決定されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For a color terminal the 'background' option is used to decide whether the
terminal window will start with a white or black background.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カラー端末を開始する際に、背景に白と黒どちらの系統の色を使用するかは、オプション '@option{background}' を用いて決定します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To use a different color the Terminal highlight group can be used, for
example: >
    hi Terminal ctermbg=lightgrey ctermfg=blue guibg=lightgrey guifg=blue
<
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
異なる色を使う場合には Terminal ハイライトグループを利用できます。例:
@verbatim
hi Terminal ctermbg=lightgrey ctermfg=blue guibg=lightgrey guifg=blue
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*g:terminal_ansi_colors*
In GUI mode or with 'termguicolors', the 16 ANSI colors used by default in new
terminal windows may be configured using the variable
`g:terminal_ansi_colors`, which should be a list of 16 color names or
hexadecimal color codes, similar to those accepted by |highlight-guifg|.  When
not using GUI colors, the terminal window always uses the 16 ANSI colors of
the underlying terminal.
The |term_setansicolors()| function can be used to change the colors, and
|term_getansicolors()| to get the currently used colors.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{g:terminal_ansi_colors}
@vindex g:terminal_ansi_colors
新しい端末ウィンドウでデフォルトで使用される 16 個のANSI カラーは、変数 `@var{g:terminal_ansi_colors}` を使用して設定することができます。これは、16 個の色名または 16 進数の色コードのリストでなければなりません。これは、|@ref{highlight-guifg}| で受け入れられるものと同様です。 GUI カラーを使用しない場合、端末ウィンドウは常に端末基礎の 16 個の ANSI カラーを使用します。

|@ref{term_setansicolors()}| 関数を使用して色を変更したり、|@ref{term_getansicolors()}| を使用して現在使用されている色を取得することができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Command syntax ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:ter}
@anchor{:terminal}
@pindex :ter
@pindex :terminal
@unnumberedsubsec コマンドの文法
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
:[range]ter[minal] [options] [command]			*:ter* *:terminal*
			Open a new terminal window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item :[range]ter[minal] [options] [command]
新しい端末ウィンドウを開きます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			If [command] is provided run it as a job and connect
			the input and output to the terminal.
			If [command] is not given the 'shell' option is used.
			if [command] is NONE no job is started, the pty of the
			terminal can be used by a command like gdb.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[command] が指定された場合、それをジョブとして実行し、端末の入出力を接続します。

[command] が指定されなかった場合、オプション '@option{shell}' を使用します。

[command] が NONE の場合ジョブは開始されず、端末の pty は gdb のようなコマンドによって利用できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			If [command] is missing the default behavior is to
			close the terminal when the shell exits.  This can be
			changed with the ++noclose argument.
			If [command] is present the default behavior is to
			keep the terminal open in Terminal-Normal mode.  This
			can be changed with the ++close argument.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[command] がない場合、デフォルトの動作はシェルが終了したときに端末を閉じます。この動作は ++noclose 引数で変更できます。

[command] が指定されている場合、デフォルトの動作は端末を端末ノーマルモードで開いたままにします。この動作は ++close 引数で変更できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			A new buffer will be created, using [command] or
			'shell' as the name, prefixed with a "!".  If a buffer
			by this name already exists a number is added in
			parentheses.  E.g. if "gdb" exists the second terminal
			buffer will use "!gdb (1)".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しいバッファが作られ、 [command] もしくは '@option{shell}' に "!" が前置された名前が与えられます。すでに同じ名前のバッファが存在する場合には、カッコに囲まれた番号が付与されます。例えば "gdb" が存在するなら 2 つ目の端末には "!gdb (1)" という名前が使われます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			If [range] is given the specified lines are used as
			input for the job.  It will not be possible to type
			keys in the terminal window.  For MS-Windows see the
			++eof argument below.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[range] が与えられた場合は、指定された範囲の行がジョブの入力として使われます。その際の端末ウィンドウではキー入力ができなくなります。MS-Windows においては以下の ++eof オプションも参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*term++close* *term++open*
			Supported [options] are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term++close}
@anchor{term++open}
@cindex term++close
@cindex term++open
サポートされる [options] は以下の通り:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			++close		The terminal window will close
					automatically when the job terminates.
			++noclose	The terminal window will NOT close
					automatically when the job terminates.
			++open		When the job terminates and no window
					shows it, a window will be opened.
					Note that this can be interruptive.
				The last of ++close, ++noclose and ++open
				matters and rules out earlier arguments.

			++curwin	Open the terminal in the current
					window, do not split the current
					window.  Fails if the current buffer
					cannot be |abandon|ed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item ++close @tab ジョブが終了した際には自動的に端末ウィンドウを閉じる。
@item ++noclose @tab ジョブが終了しても自動的に端末ウィンドウを@strong{閉じ}ません。
@item ++open @tab ジョブが終了した際にウィンドウが表示されていない場合に、ウィンドウを表示する。
@quotation
@strong{Note:} @*
割り込み的に発生しうることに留意。
@end quotation
++close, ++noclose と ++open は最後に指定されたものが有効です。
@item ++curwin @tab 現在のウィンドウで端末を開き、現在のウィンドウを分割しない。現在のバッファを放棄( |@ref{abandon}| )できない場合は失敗する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			++hidden	Open the terminal in a hidden buffer,
					no window will be used.
			++norestore	Do not include this terminal window
					in a session file.
			++kill={how}	When trying to close the terminal
					window kill the job with {how}.  See
					|term_setkill()| for the values.
			++rows={height} Use {height} for the terminal window
					height.  If the terminal uses the full
					Vim height (no window above or below
					the terminal window) the command line
					height will be reduced as needed.
			++cols={width}  Use {width} for the terminal window
					width. If the terminal uses the full
					Vim width (no window left or right of
					the terminal window) this value is
					ignored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ++hidden @tab 端末を隠しバッファとして開く。ウィンドウは使用されない。
@item ++norestore @tab セッションファイルに端末ウィンドウを含めません。
@item ++kill=@{how@} @tab 端末ウィンドウを閉じるときに @{how@} でジョブを終了させます。値については |@ref{term_setkill()}| を参照してください。
@item ++rows=@{height@} @tab 端末ウィンドウの高さとして @{height@} を使います。もし、端末が Vim の完全な高さ (端末ウィンドウの上や下にウィンドウがない) を使用する場合、必要に応じてコマンドラインの高さが現象します。
@item ++cols=@{width@} @tab 端末ウィンドウの幅として @{width@} を使います。もし、端末が Vim の完全な幅 (端末ウィンドウの左や右にウィンドウがない) を使用する場合、この値は無視されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			++eof={text}	When using [range]: text to send after
					the last line was written. Cannot
					contain white space.  A CR is
					appended.  For MS-Windows the default
					is to send CTRL-D.
					E.g. for a shell use "++eof=exit" and
					for Python "++eof=exit()".  Special
					codes can be used like with `:map`,
					e.g. "<C-Z>" for CTRL-Z.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ++eof=@{text@} @tab [range] を使った場合: 最後の行を送信したあとに指定したテキストが送られる。空白を含むことはできない。 CR が 1 つ付け加えられる。MS-Windows ではデフォルトでは CTRL-D が送られる。

例: シェルには "++eof=exit" を、Python には "++eof=exit()" を指定する。特殊 コードが `@command{:map}` と同様に利用できる。例: "<C-Z>" は CTRL-Z を示す。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			++type={pty}	(MS-Windows only): Use {pty} as the
					virtual console.  See 'termwintype'
					for the values.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item ++type=@{pty@} @tab (MS-Windows のみ): 仮想コンソールとして @{pty@} を使用する。値については '@option{termwintype}' を参照。
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
			If you want to use more options use the |term_start()|
			function.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
より詳細なオプションを使いたいならば |@ref{term_start()}| 関数を使ってください。
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			If you want to split the window vertically, use: >
				:vertical terminal
<			Or short: >
				:vert ter
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ウィンドウを垂直に分割したいなら、次を使います:
@verbatim
:vertical terminal
@end verbatim
もしくは短く:
@verbatim
:vert ter
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the buffer associated with the terminal is forcibly unloaded or wiped out
the job is killed, similar to calling `job_stop(job, "kill")` .
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末に関連付けられたバッファが強制的にアンロードもしくは削除された場合には、`@command{job_stop(job, "kill")}` を呼んだのと同じようにそのジョブが殺されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Closing the window normally results in |E947|.  When a kill method was set
with "++kill={how}" or |term_setkill()| then closing the window will use that
way to kill or interrupt the job.  For example: >
	:term ++kill=term tail -f /tmp/log
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
普通にウィンドウを閉じると |@ref{E947}| が返ります。kill メソッドが "++kill=@{how@}" か |@ref{term_setkill()}| で設定されている時にウィンドウを閉じると、その方法でジョブを強制停止または中断します。例:
@verbatim
:term ++kill=term tail -f /tmp/log
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
So long as the job is running the window behaves like it contains a modified
buffer.  Trying to close the window with `CTRL-W :quit` fails.  When using
`CTRL-W :quit!` the job is ended.  The text in the window is lost.  The buffer
still exists, but getting it in a window with `:buffer` will show an empty
buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブが実行され続けるとウィンドウはそのバッファが変更されたかのように振る舞います。 `@command{CTRL-W :quit}` でウィンドウを閉じようとしても失敗します。`@command{CTRL-W :quit!}` を使うとジョブは終了します。ウィンドウのテキストは失われます。バッファは依然存在しますが、`@command{:buffer}` でウィンドウに割り当てても空のバッファが表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Trying to close the window with `CTRL-W :close` also fails.   Using
`CTRL-W :close!` will close the window and make the buffer hidden.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
`@command{CTRL-W :close}` で閉じようとしてもまた失敗します。`@command{CTRL-W :close!}` はウィンドウを閉じ、バッファを隠し状態にします。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use `CTRL-W :hide` to close the terminal window and make the buffer
hidden, the job keeps running.  The `:buffer` command can be used to turn the
current window into a terminal window.  If there are unsaved changes this
fails, use ! to force, as usual.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
`@command{CTRL-W :hide}` を使うとジョブを実行したまま、端末ウィンドウを閉じバッファを隠し状態にできます。`@command{:buffer}` コマンドで現在のウィンドウを端末ウィンドウにすることができます。未保存の変更があった場合にはこれは失敗しますが、通常と同じように ! で強制できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To have a background job run without a window, and open the window when it's
done, use options like this: >
	:term ++hidden ++open make
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バックグラウンドジョブをウィンドウ無しで実行し、終了したらウィンドウに表示するには、次のようにオプションを指定します:
@verbatim
:term ++hidden ++open make
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Note that the window will open at an unexpected moment, this will interrupt
what you are doing.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ウィンドウが予期せぬタイミングで開かれ、あなたが行っている操作に割り込む可能性があることに留意してください。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*E947* *E948*
So long as the job is running, the buffer is considered modified and Vim
cannot be quit easily, see |abandon|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{E947}
@anchor{E948}
@erindex E947
@erindex E948
ジョブが実行され続けると、バッファが変更されたとみなされ Vim を簡単には終了できなくなります。|@ref{abandon}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the job has finished and no changes were made to the buffer: closing the
window will wipe out the buffer.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブが終了しバッファになんの変更も及ぼさなかった場合、そのウィンドウを閉じるとバッファは削除されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Before changes can be made to a terminal buffer, the 'modifiable' option must
be set.  This is only possible when the job has finished.  At the first change
the buffer will become a normal buffer and the highlighting is removed.
You may want to change the buffer name with |:file| to be able to write, since
the buffer name will still be set to the command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末バッファを変更するにはオプション '@option{modifiable}' をセットする必要があります。これはジョブが終了した後にのみ行なえます。バッファを最初に変更した瞬間に普通のバッファになりハイライトは削除されます。バッファを保存可能にするために |@ref{:file}| でバッファの名前を、コマンド名から変更することもできます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Resizing ~
							*terminal-resizing*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-resizing}
@cindex terminal-resizing
@unnumberedsubsec サイズ変更
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The size of the terminal can be in one of three modes:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末のサイズは 3 つのモードのいずれか 1 つで決まります:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
1. The 'termwinsize' option is empty: The terminal size follows the window
   size.  The minimal size is 2 screen lines with 10 cells.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item オプション '@option{termwinsize}' が空の場合: 端末サイズはウィンドウのサイズに従う。最小で 2 行、10 桁。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
2. The 'termwinsize' option is "rows*cols", where "rows" is the minimal number
   of screen rows and "cols" is the minimal number of cells.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item オプション '@option{termwinsize}' が "@var{rows*cols}" の場合、"@var{rows}" を最小行数、"@var{cols}" を最小桁数とする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
3. The 'termwinsize' option is "rowsXcols" (where the x is upper or lower
   case).  The terminal size is fixed to the specified number of screen lines
   and cells.  If the window is bigger there will be unused empty space.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item オプション '@option{termwinsize}' が "@var{rowsXcols}" ("X" は大文字小文字を問わない) の場合: 端末サイズは指定された行数と桁数で固定される。もしもウィンドウがそれよりも大きい場合には、使用されない空の領域ができる。
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the window is smaller than the terminal size, only part of the terminal can
be seen (the lower-left part).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ウィンドウサイズが端末サイズよりも小さい場合、端末の一部の領域 (左下に相当する部分) のみが描画されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The |term_getsize()| function can be used to get the current size of the
terminal.  |term_setsize()| can be used only when in the first or second mode,
not when 'termwinsize' is "rowsXcols".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末の現在のサイズを取得するのに関数 |@ref{term_getsize()}| が使えます。|@ref{term_setsize()}| は 1 か 2 のモードの時にだけ、すなわち '@option{termwinsize}' が "@var{rowsXcols}" 形式ではない時に使えます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Terminal-Job and Terminal-Normal mode ~
						*Terminal-mode* *Terminal-Job*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Terminal-mode}
@anchor{Terminal-Job}
@cindex Terminal-mode
@cindex Terminal-Job
@unnumberedsubsec Terminal-Job と Terminal-Normal モード
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
When the job is running the contents of the terminal is under control of the
job.  That includes the cursor position.  Typed keys are sent to the job.
The terminal contents can change at any time.  This is called Terminal-Job
mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブが実行中には端末の内容はジョブの制御下にあります。それにはカーソルの位置も含まれます。入力したキーはジョブに送られます。端末の内容はいつでも更新されえます。これを Terminal-Job モードと呼びます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Use CTRL-W N (or 'termwinkey' N) to switch to Terminal-Normal mode.  Now the
contents of the terminal window is under control of Vim, the job output is
suspended.  CTRL-\ CTRL-N does the same.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-W N} (もしくは 'termwinkey' N) を入力すると Terminal-Normal モードに遷移します。このモードでは端末ウィンドウのコンテンツは Vim の制御下に置かれ、ジョブの出力は一時保留されます。@kbd{CTRL-\ CTRL-N} でも同じようになります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Terminal-Job mode is where |:tmap| mappings are applied. Keys sent by
|term_sendkeys()| are not subject to tmap, but keys from |feedkeys()| are.

It is not possible to enter Insert mode from Terminal-Job mode.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{:tmap}| のマッピングは Terminal-Job モードにおいて作用します。|@ref{term_sendkeys()}| で送ったキーには tmap は適用されませんが、|@ref{feedkeys()}| で送ったキーには適用されます。

Terminal-Job モードから挿入モードに移る方法はありません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*Terminal-Normal* *E946*
In Terminal-Normal mode you can move the cursor around with the usual Vim
commands, Visually mark text, yank text, etc.  But you cannot change the
contents of the buffer.  The commands that would start insert mode, such as
'i' and 'a', return to Terminal-Job mode.  The window will be updated to show
the contents of the terminal. |:startinsert| is ineffective.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{Terminal-Normal}
@anchor{E946}
@cindex Terminal-Normal
@erindex E946
Terminal-Normal モードでは、Vim の普通のコマンドでカーソルを自由に動かせます。視覚的にテキストをマークしたり、テキストをヤンクしたり思いのままです。しかしバッファの内容を変更することはできません。'i' や 'a' など挿入モードを開始するコマンドを使うと Terminal-Job モードに戻ります。結果としてウィンドウは端末のコンテンツを反映させるために更新されます。|@ref{:startinsert}| は無効です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In Terminal-Normal mode the statusline and window title show "(Terminal)".  If
the job ends while in Terminal-Normal mode this changes to
"(Terminal-finished)".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Terminal-Normal モードではステータスラインとウィンドウタイトルには "(Terminal)" と表示されます。Terminal-Normal モード中にジョブが終了してしまった場合にはそれが "(Terminal-finished)" に変わります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the job outputs lines in the terminal, such that the contents scrolls off
the top, those lines are remembered and can be seen in Terminal-Normal mode.
The number of lines is limited by the 'termwinscroll' option. When going over
this limit, the first 10% of the scrolled lines are deleted and are lost.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブが端末内で行を出力し内容がスクロールすると、それらの行は記憶され Terminal-Normal モードで表示されます。行数は '@option{'termwinscroll}' オプションによって制限されます。この制限を超えると、スクロールされた行の最初の 10% が削除され失われます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Cursor style ~
							*terminal-cursor-style*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-cursor-style}
@cindex terminal-cursor-style
@unnumberedsubsec カーソルスタイル
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
By default the cursor in the terminal window uses a not blinking block.  The
normal xterm escape sequences can be used to change the blinking state and the
shape.  Once focus leaves the terminal window Vim will restore the original
cursor.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デフォルトでは端末ウィンドウのカーソルには点滅しないブロックが使われます。カーソルの点滅状態や形を変更するのに、普通の xterm のエスケープシーケンスが使われます。端末ウィンドウからフォーカスが外れる際に Vim は元々のカーソルを復元します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
An exception is when xterm is started with the "-bc" argument, or another way
that causes the cursor to blink.  This actually means that the blinking flag
is inverted.  Since Vim cannot detect this, the terminal window cursor
blinking will also be inverted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
xterm を "-bc" 引数で起動した場合、または他の方法でカーソルの点滅を発生させた場合、が1つの例外となります。それらにより点滅フラグが逆転したことが問題の引き金となります。なぜなら Vim はその逆転を検出できず、端末ウィンドウのカーソルの点滅も逆転します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Session ~
							*terminal-session*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-session}
@cindex terminal-session
@unnumberedsubsec セッション
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
A terminal window will be restored when using a session file, if possible and
wanted.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
可能かつ必要であれば、セッションファイルを使用する歳に端末ウィンドウが復元されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If "terminal" was removed from 'sessionoptions' then no terminal windows will
be restored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"terminal" が '@option{sessionoptions}' から削除された場合、端末ウィンドウは復元されません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the job in the terminal was finished the window will not be restored.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末内のジョブが終了した場合、ウィンドウは復元されません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the terminal can be restored, the command that was used to open it will be
used again.  To change this use the |term_setrestore()| function.  This can
also be used to not restore a specific terminal by setting the command to
"NONE".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末を復元できる場合は、その端末を開くために使われたコマンドが再び使われます。これを変更するには |@ref{term_setrestore()}| 関数を使用します。これは、コマンドを "NONE" に設定して特定の端末を復元しない場合にも使用できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Special keys ~
							*terminal-special-keys*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-special-keys}
@cindex terminal-special-keys
@unnumberedsubsec 特別なキー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Since the terminal emulator simulates an xterm, only escape sequences that
both Vim and xterm recognize will be available in the terminal window.  If you
want to pass on other escape sequences to the job running in the terminal you
need to set up forwarding.  Example: >
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末エミュレーターは xterm をシミュレートするので、Vim と xterm の両方が認識するエスケープシーケンスのみが端末ウィンドウで利用可能になります。もし、端末で実行中のジョブに他のエスケープシーケンスを渡したい場合は、転送を設定する必要があります。例:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
	tmap <expr> <Esc>]b SendToTerm("\<Esc>]b")
	func SendToTerm(what)
	  call term_sendkeys('', a:what)
	  return ''
	endfunc
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
tmap <expr> <Esc>]b SendToTerm("\<Esc>]b")
func SendToTerm(what)
  call term_sendkeys('', a:what)
  return ''
endfunc
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Unix ~
							*terminal-unix*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-unix}
@cindex terminal-unix
@unnumberedsubsec Unix
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
On Unix a pty is used to make it possible to run all kinds of commands.  You
can even run Vim in the terminal!  That's used for debugging, see below.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
UNIX ではすべての種類のコマンドを実行可能とするために pty を用いています。端末内で Vim ですら実行できるのです！これは以下のようにデバッグに利用できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Environment variables are used to pass information to the running job:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
実行中のジョブに情報を伝えるのに以下の環境変数が利用できます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
    TERM		the name of the terminal, from the 'term' option or
			$TERM in the GUI; falls back to "xterm" if it does not
			start with "xterm"
    ROWS		number of rows in the terminal initially
    LINES		same as ROWS
    COLUMNS		number of columns in the terminal initially
    COLORS		number of colors, 't_Co' (256*256*256 in the GUI)
    VIM_SERVERNAME	v:servername
    VIM_TERMINAL	v:version
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item TERM @tab 端末の名前、'@option{term}' オプションまたは GUI では @var{$TERM} から。"xterm" で始まらなければ "xterm" にフォールバックする
@item ROWS @tab 端末の初期行数
@item LINES @tab ROWS と同じ
@item COLUMNS @tab 端末の初期桁数
@item COLORS @tab 色数 '@option{t_Co}' (GUIでは 256*256*256)
@item VIM_SERVERNAME @tab v:servername
@item VIM_TERMINAL @tab v:version
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
MS-Windows ~
							*terminal-ms-windows*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-ms-windows}
@cindex terminal-ms-windows
@unnumberedsubsec MS-Windows
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
On MS-Windows winpty is used to make it possible to run all kind of commands.
Obviously, they must be commands that run in a terminal, not open their own
window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
MS-Windows ではすべての種類のコマンドを実行可能とするために winpty を用いています。あたりまえのことですが、ここで実行するコマンドは端末の中で動くもので、独自のウィンドウを開くものであってはいけません。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You need the following two files from winpty:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
winpty 内の以下の 2 つのファイルが必要です:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
    winpty.dll
    winpty-agent.exe
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
winpty.dll
winpty-agent.exe
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can download them from the following page:

    https://github.com/rprichard/winpty
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらは以下のページからダウンロードできます:

@url{https://github.com/rprichard/winpty}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Just put the files somewhere in your PATH.  You can set the 'winptydll' option
to point to the right file, if needed.  If you have both the 32-bit and 64-bit
version, rename to winpty32.dll and winpty64.dll to match the way Vim was
build.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのファイルを環境変数 PATH のいずれかに置くだけです。必要ならばオプション '@option{winptydll}' でファイルの場所を指定できます。もしも 32 ビット版と 64 ビット版を同じディレクトリに置きたいのであれば、Vim のビルドに合わせてそれぞれを winpty32.dll もしくは winpty64.dll という名前に変更してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*ConPTY* *E982*
On more recent versions of MS-Windows 10 (beginning with the "October 2018
Update"), winpty is no longer required. On those versions, |:terminal| will use
Windows' built-in support for hosting terminal applications, "ConPTY".  When
ConPTY is in use, there may be rendering artifacts regarding ambiguous-width
characters. If you encounter any such issues, install "winpty".  Until the
ConPTY problems have been fixed "winpty" will be preferred.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{ConPTY}
@anchor{E982}
@cindex ConPTY
@erindex E982
MS-Windows 10 の最新バージョン ("October 2018 Update" 以降) では、winpty は必要なくなりました。それらのバージョンでは、|@ref{:terminal}| はターミナルアプリケーションをホストするための Windows の組み込みサポート "ConPTY" を使用します。ConPTY が使用されていると、あいまいな幅の文字に関するレンダリングアーティファクトが発生する可能性があります。そのような問題に遭遇した場合は、"winpty" をインストールしてください。ConPTY の問題が修正されるまでは、"winpty" が優先されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Environment variables are used to pass information to the running job:
    VIM_SERVERNAME	v:servername
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
環境変数は実行中のジョブに情報を渡すために使用されます:
@verbatim
VIM_SERVERNAME	v:servername
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
==============================================================================
2. Terminal functions				 *terminal-function-details*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-function-details}
@cindex terminal-function-details
@section 2. Terminal 関数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*term_dumpdiff()*
term_dumpdiff({filename}, {filename} [, {options}])
		Open a new window displaying the difference between the two
		files.  The files must have been created with
		|term_dumpwrite()|.
		Returns the buffer number or zero when the diff fails.
		Also see |terminal-diff|.
		NOTE: this does not work with double-width characters yet.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_dumpdiff()}
@findex term_dumpdiff()
@table @asis
@item term_dumpdiff(@{filename@}, @{filename@} [, @{options@}])
2 ファイルの差分を表示している新しいウィンドウを開く。ファイルは |@ref{term_dumpwrite()}| で作成されていなければならない。

diff に失敗した場合はバッファ番号もしくは 0 を返す。|@ref{terminal-diff}| も参照。

@quotation
@strong{Note:} @*
これは 2 バイト文字ではまだ動作しないことに注意。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The top part of the buffer contains the contents of the first
		file, the bottom part of the buffer contains the contents of
		the second file.  The middle part shows the differences.
		The parts are separated by a line of equals.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
バッファの上部は最初のファイルの内容を含み、下部は 2 番目のファイルの内容を含む。真ん中の部分は差分を表示する。それぞれのパートはイコールのラインで区切られる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		If the {options} argument is present, it must be a Dict with
		these possible members:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
もしも @{options@} に引数があるなら、次のような要素を持つ辞書になっていなければならない:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "term_name"	     name to use for the buffer name, instead
				     of the first file name.
		   "term_rows"	     vertical size to use for the terminal,
				     instead of using 'termwinsize'
		   "term_cols"	     horizontal size to use for the terminal,
				     instead of using 'termwinsize'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item "term_name" @tab 初期ファイル名の代わりのバッファ名に使うための名前
@item "term_rows" @tab '@option{termwinsize}' を使う代わりの端末が使う高さのサイズ
@item "term_cols" @tab '@option{termwinsize}' を使う代わりの端末が使う幅のサイズ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "vertical"	     split the window vertically
		   "curwin"	     use the current window, do not split the
				     window; fails if the current buffer
				     cannot be |abandon|ed
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "vertical" @tab ウィンドウを垂直に分割する
@item "curwin" @tab カレントウィンドウを使いウィンドウは分割しない; もしもカレントバッファを破棄 |@ref{abandon}| することができないならば失敗する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "bufnr"	     do not create a new buffer, use the
				     existing buffer "bufnr".  This buffer
				     must have been previously created with
				     term_dumpdiff() or term_dumpload() and
				     visible in a window.
		   "norestore"	     do not add the terminal window to a
				     session file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "bufnr" @tab 新規バッファを作成せず、存在している "bufnr" バッファを使用します。このバッファは term_dumpdiff() や term_dumpload() で前もって作成されていて、ウィンドウ中で見えていなければなりません。
@item "norestore" @tab セッションファイルに端末ウィンドウを追加しない
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Each character in the middle part indicates a difference. If
		there are multiple differences only the first in this list is
		used:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
真ん中のそれぞれの文字は差異を示している。もしも複数の差異があるのなら、このリストの最初のものだけが使われる:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
			X	different character
			w	different width
			f	different foreground color
			b	different background color
			a	different attribute
			+	missing position in first file
			-	missing position in second file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .1 .9
@item X @tab 文字が異なる
@item w @tab 幅が異なる
@item f @tab 前景色が異なる
@item b @tab 背景色が異なる
@item a @tab 属性が異なる
@item + @tab 1 つ目のファイルの位置が欠損している
@item - @tab 2 つ目のファイルの位置が欠損している
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Using the "s" key the top and bottom parts are swapped.  This
		makes it easy to spot a difference.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"s" キーを使うと上と下の部分が交換される。これは差異を見つけやすくする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*term_dumpload()*
term_dumpload({filename} [, {options}])
		Open a new window displaying the contents of {filename}
		The file must have been created with |term_dumpwrite()|.
		Returns the buffer number or zero when it fails.
		Also see |terminal-diff|.

		For {options} see |term_dumpdiff()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_dumpload()}
@findex term_dumpload()
@item term_dumpload(@{filename@} [, @{options@}])
@{filename@} の内容を表示している新しいウィンドウを開く。ファイルは |@ref{term_dumpwrite()}| で作成されていなければならない。失敗した場合はバッファ番号もしくは 0 を返す。|@ref{terminal-diff}| も参照。

@{options@} の詳細は |@ref{term_dumpdiff()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
							*term_dumpwrite()*
term_dumpwrite({buf}, {filename} [, {options}])
		Dump the contents of the terminal screen of {buf} in the file
		{filename}.  This uses a format that can be used with
		|term_dumpload()| and |term_dumpdiff()|.
		If the job in the terminal already finished an error is given:
		*E958*
		If {filename} already exists an error is given:	*E953*
		Also see |terminal-diff|.

		{options} is a dictionary with these optional entries:
			"rows"		maximum number of rows to dump
			"columns"	maximum number of columns to dump
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_dumpwrite()}
@findex term_dumpwrite()
@item term_dumpwrite(@{buf@}, @{filename@} [, @{options@}])
ファイル @{filename@} 内の @{buf@} のターミナル画面の内容をダンプする。これは |@ref{term_dumpload()}| と |@ref{term_dumpdiff()}| で使われるフォーマットを使う。

@anchor{E958}
@erindex E958
もしもターミナル中のジョブがすでに終了しているのなら、E958 のエラーが与えられる。

@anchor{E953}
@erindex E953
もしも @{filename@} がすでに存在しているなら、E953 のエラーが与えられる。|@ref{terminal-diff}| も参照。

@{options@} は次のオプションを持つ辞書:
@multitable @columnfractions .3 .7
@item "rows" @tab ダンプする行の最大値
@item "columns" @tab ダンプする列の最大値
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getaltscreen({buf})				*term_getaltscreen()*
		Returns 1 if the terminal of {buf} is using the alternate
		screen.
		{buf} is used as with |term_getsize()|.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getaltscreen()}
@findex term_getaltscreen()
@item term_getaltscreen(@{buf@})
@{buf@} のターミナルがオルタネートスクリーンを使っているなら 1 を返す。

@{buf@} は |@ref{term_getsize()}| と同様に使われる。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getansicolors({buf})				*term_getansicolors()*
		Get the ANSI color palette in use by terminal {buf}.
		Returns a List of length 16 where each element is a String
		representing a color in hexadecimal "#rrggbb" format.
		Also see |term_setansicolors()| and |g:terminal_ansi_colors|.
		If neither was used returns the default colors.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getansicolors()}
@findex term_getansicolors()
@item term_getansicolors(@{buf@})
ターミナル @{buf@} で使われている ANSI カラーパレットを取得する。16 の長さのリストを返す。それぞれの項目は 16 進数の "#rrggbb" フォーマットで表わされているカラーです。|@ref{term_setansicolors()}| と |@ref{g:terminal_ansi_colors}| も参照。もしもどちらも使われていなければ、デフォルト色が返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{buf} is used as with |term_getsize()|.  If the buffer does not
		exist or is not a terminal window, an empty list is returned.
		{only available when compiled with the |+terminal| feature and
		with GUI enabled and/or the |+termguicolors| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{buf@} は |@ref{term_getsize()}| と同様に使われる。もしもバッファが存在しないか端末ウィンドウでなければ、空のリストが返される。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたとき、かつ GUI が有効のとき、かつ/または |@ref{+termguicolors}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getattr({attr}, {what})				*term_getattr()*
		Given {attr}, a value returned by term_scrape() in the "attr"
		item, return whether {what} is on.  {what} can be one of:
			bold
			italic
			underline
			strike
			reverse
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getattr()}
@findex term_getattr()
@item term_getattr(@{attr@}, @{what@})
与えられた @{attr@}。要素中で term_scrape() によって返された値。@{what@} がオンかどうかを返す。 @{what@} は次のうちのどれか:
@multitable @columnfractions .1 .9
@item bold @tab
@item italic @tab
@item underline @tab
@item strike @tab
@item reverse @tab
@end multitable
@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getcursor({buf})					*term_getcursor()*
		Get the cursor position of terminal {buf}. Returns a list with
		two numbers and a dictionary: [row, col, dict].
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getcursor()}
@findex term_getcursor()
@item term_getcursor(@{buf@})
ターミナル @{buf@} のカーソル位置を取得する。2 つの数値と辞書のリストを返す: [row, col, dict]。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		"row" and "col" are one based, the first screen cell is row
		1, column 1.  This is the cursor position of the terminal
		itself, not of the Vim window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"row" と "col" は原点で、1 番目のスクリーンのセルは row が 1 で column が 1。これはターミナル自身のカーソルの位置で Vim ウィンドウのものではない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		"dict" can have these members:
		   "visible"	one when the cursor is visible, zero when it
				is hidden.
		   "blink"	one when the cursor is blinking, zero when it
				is not blinking.
		   "shape"	1 for a block cursor, 2 for underline and 3
				for a vertical bar.
		   "color"	color of the cursor, e.g. "green"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
"dict" は 3 つの数値を持てる:
@multitable @columnfractions .2 .8
@item "visible" @tab カーソルが可視なら 1、不可視なら 0
@item "blink" @tab カーソルが点滅なら 1、点滅でないなら 0
@item "shape" @tab カーソルの形がブロックなら 1、アンダーラインなら 2、バーティカルなら 3。
@item "color" @tab カーソルの色。例えば "green"
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{buf} must be the buffer number of a terminal window. If the
		buffer does not exist or is not a terminal window, an empty
		list is returned.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{buf@} はターミナルウィンドウのバッファ番号でなければならない。バッファが存在しないか、ターミナルウィンドウでなければ、空のリストが返される。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getjob({buf})					*term_getjob()*
		Get the Job associated with terminal window {buf}.
		{buf} is used as with |term_getsize()|.
		Returns |v:null| when there is no job.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getjob()}
@findex term_getjob()
@item term_getjob(@{buf@})
ターミナルウィンドウの @{buf@} と関連付けられたジョブを取得する。@{buf@} は |@ref{term_getsize()}| として使われる。ジョブがない場合は |@ref{v:null}| を返す。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getline({buf}, {row})				*term_getline()*
		Get a line of text from the terminal window of {buf}.
		{buf} is used as with |term_getsize()|.

		The first line has {row} one.  When {row} is "." the cursor
		line is used.  When {row} is invalid an empty string is
		returned.

		To get attributes of each character use |term_scrape()|.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getline()}
@findex term_getline()
@item term_getline(@{buf@}, @{row@})
ターミナルウィンドウの @{buf@} からテキストの 1 行を取得する。@{buf@} は |@ref{term_getsize()}| として使われる。

1 番目の行は @{row@} を 1 つ持っている。@{row@} が "." のとき、カーソル行が使われる。@{row@} が正しくなければ、空文字列が返される。

それぞれの文字の属性を取得するには |@ref{term_scrape()}| を使う。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getscrolled({buf})					*term_getscrolled()*
		Return the number of lines that scrolled to above the top of
		terminal {buf}.  This is the offset between the row number
		used for |term_getline()| and |getline()|, so that: >
			term_getline(buf, N)
<		is equal to: >
			getline(N + term_getscrolled(buf))
<		(if that line exists).

		{buf} is used as with |term_getsize()|.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getscrolled()}
@findex term_getscrolled()
@item term_getscrolled(@{buf@})
ターミナル @{buf@} の上方にスクロールされた行数を返す。これは |@ref{term_getline()}| と |@ref{getline()}| で使われる行番号のオフセット。
そのため:
@verbatim
term_getline(buf, N)
@end verbatim
は次と同じ:
@verbatim
getline(N + term_getscrolled(buf))
@end verbatim
(その行が存在するなら)。

@{buf@} は |@ref{term_getsize()}| として使われる。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getsize({buf})					*term_getsize()*
		Get the size of terminal {buf}. Returns a list with two
		numbers: [rows, cols].  This is the size of the terminal, not
		the window containing the terminal.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getsize()}
@findex term_getsize()
@item term_getsize(@{buf@})
ターミナル @{buf@} のサイズを取得する。2 つの数値を持つリストを返す: [rows, cols]。これはターミナルのサイズであって、ターミナルを持っているウィンドウのサイズではない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{buf} must be the buffer number of a terminal window.  Use an
		empty string for the current buffer.  If the buffer does not
		exist or is not a terminal window, an empty list is returned.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{buf@} はターミナルウィンドウのバッファ番号でなければならない。カレントバッファのために空文字列を使う。バッファが存在しないか、ターミナルウィンドウでなければ、空リストが返される。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_getstatus({buf})					*term_getstatus()*
		Get the status of terminal {buf}. This returns a comma
		separated list of these items:
			running		job is running
			finished	job has finished
			normal		in Terminal-Normal mode
		One of "running" or "finished" is always present.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_getstatus()}
@findex term_getstatus()
@item term_getstatus(@{buf@})
ターミナル @{buf@} のステータスを取得する。次の項目のコンマ区切りのリストを返す:
@multitable @columnfractions .3 .7
@item running @tab ジョブは動作中
@item finished @tab ジョブは停止
@item normal @tab Terminal-Normal モード中
@end multitable
"running" もしくは "finished" のどちらかが常に存在する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{buf} must be the buffer number of a terminal window. If the
		buffer does not exist or is not a terminal window, an empty
		string is returned.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{buf@} はターミナルウィンドウのバッファ番号でなければならない。バッファが存在しないか、ターミナルウィンドウでなければ、空文字列が返される。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_gettitle({buf})					*term_gettitle()*
		Get the title of terminal {buf}. This is the title that the
		job in the terminal has set.

		{buf} must be the buffer number of a terminal window. If the
		buffer does not exist or is not a terminal window, an empty
		string is returned.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_gettitle()}
@findex term_gettitle()
@item term_gettitle(@{buf@})
ターミナル @{buf@} のタイトルを取得する。これはターミナル内で設定されたジョブのタイトル。

@{buf@} はターミナルウィンドウのバッファ番号でなければならない。バッファが存在しないか、ターミナルウィンドウでなければ、空文字列が返される。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_gettty({buf} [, {input}])				*term_gettty()*
		Get the name of the controlling terminal associated with
		terminal window {buf}.  {buf} is used as with |term_getsize()|.

		When {input} is omitted or 0, return the name for writing
		(stdout). When {input} is 1 return the name for reading
		(stdin). On UNIX, both return same name.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_gettty()}
@findex term_gettty()
@item term_gettty(@{buf@} [, @{input@}])
ターミナルウィンドウ @{buf@} に関連付けらてた制御中のターミナルの名前を取得する。@{buf@} は |@ref{term_getsize()}| として使われる。

@{input@} が省略されるか 0 なら、書き込んでいる名前を返す (stdout)。@{input@} が 1 なら、読み込んでいる名前を返す (stdin)。UNIX ではどちらも同じ名前を返す。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_list()						*term_list()*
		Return a list with the buffer numbers of all buffers for
		terminal windows.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_list()}
@findex term_list()
@item term_list()
ターミナルウィンドウのためのすべてのバッファのバッファ番号を持つリスト

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_scrape({buf}, {row})				*term_scrape()*
		Get the contents of {row} of terminal screen of {buf}.
		For {buf} see |term_getsize()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_scrape()}
@findex term_scrape()
@item term_scrape(@{buf@}, @{row@})
@{buf@} のターミナルスクリーンの @{row@} の内容を取得する。@{buf@} のためには |@ref{term_getsize()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The first line has {row} one.  When {row} is "." the cursor
		line is used.  When {row} is invalid an empty string is
		returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
1 番目の行は @{row@} を 1 つ持っている。@{row@} が "." のとき、カーソル行が使われる。@{row@} が正しくなければ、空文字列が返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Return a List containing a Dict for each screen cell:
		    "chars"	character(s) at the cell
		    "fg"	foreground color as #rrggbb
		    "bg"	background color as #rrggbb
		    "attr"	attributes of the cell, use |term_getattr()|
				to get the individual flags
		    "width"	cell width: 1 or 2
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
それぞれのスクリーンセルのための辞書を含むリストを返す:
@multitable @columnfractions .2 .8
@item "chars" @tab セルの文字
@item "fg" @tab #rrggbb 形式の前景色
@item "bg" @tab #rrggbb 形式の背景色
@item "attr" @tab セルの属性。個々のフラグを取得するには |@ref{term_getattr()}| を使う
@item "width" @tab セルの幅: 1 もしくは 2
@end multitable
@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_sendkeys({buf}, {keys})				*term_sendkeys()*
		Send keystrokes {keys} to terminal {buf}.
		{buf} is used as with |term_getsize()|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_sendkeys()}
@findex term_sendkeys()
@item term_sendkeys(@{buf@}, @{keys@})
ターミナル @{buf@} にキーストローク @{keys@} を送る。@{buf@} は |@ref{term_getsize()}| として使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{keys} are translated as key sequences. For example, "\<c-x>"
		means the character CTRL-X.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{keys@} はキーの連続として解釈される。例えば、"\<c-x>" は @kbd{CTRL-X} を意味する。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_setansicolors({buf}, {colors})			*term_setansicolors()*
		Set the ANSI color palette used by terminal {buf}.
		{colors} must be a List of 16 valid color names or hexadecimal
		color codes, like those accepted by |highlight-guifg|.
		Also see |term_getansicolors()| and |g:terminal_ansi_colors|.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_setansicolors()}
@findex term_setansicolors()
@item term_setansicolors(@{buf@}, @{colors@})
ターミナル @{buf@} で使われている ANSI カラーパレットを設定する。@{colors@} は 正しい 16 ANSI カラーか、|@ref{highlight-guifg}| で認められているような 16 進数のカラーコードのリストでなければならない。|@ref{term_getansicolors()}| と |@ref{g:terminal_ansi_colors}| も参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		The colors normally are:
			0    black
			1    dark red
			2    dark green
			3    brown
			4    dark blue
			5    dark magenta
			6    dark cyan
			7    light grey
			8    dark grey
			9    red
			10   green
			11   yellow
			12   blue
			13   magenta
			14   cyan
			15   white
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カラーは通常、以下のとおり:
@multitable @columnfractions .2 .8
@item 0 @tab black
@item 1 @tab dark red
@item 2 @tab dark green
@item 3 @tab brown
@item 4 @tab dark blue
@item 5 @tab dark magenta
@item 6 @tab dark cyan
@item 7 @tab light grey
@item 8 @tab dark grey
@item 9 @tab red
@item 10 @tab green
@item 11 @tab yellow
@item 12 @tab blue
@item 13 @tab magenta
@item 14 @tab cyan
@item 15 @tab white
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		These colors are used in the GUI and in the terminal when
		'termguicolors' is set.  When not using GUI colors (GUI mode
		or 'termguicolors'), the terminal window always uses the 16
		ANSI colors of the underlying terminal.
		{only available when compiled with the |+terminal| feature and
		with GUI enabled and/or the |+termguicolors| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これらのカラーは '@option{termguicolors}' が設定されているときに GUI と端末で使われる。GUI カラーが使われていないとき (GUI モードもしくは '@option{termguicolors}' が設定されている)、端末ウィンドウは常に、端末の根底にある 16 ANSI カラーを使う。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたとき、かつ GUI が有効のとき、かつ/または |@ref{+termguicolors}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_setkill({buf}, {how})				*term_setkill()*
		When exiting Vim or trying to close the terminal window in
		another way, {how} defines whether the job in the terminal can
		be stopped.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_setkill()}
@findex term_setkill()
@item term_setkill(@{buf@}, @{how@})
Vim を終了もしくは他の方法で端末ウィンドウを閉じようとしているとき、@{how@} は端末のジョブを停止することができるかどうか明確にする。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		When {how} is empty (the default), the job will not be
		stopped, trying to exit will result in |E947|.
		Otherwise, {how} specifies what signal to send to the job.
		See |job_stop()| for the values.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

@{how@} が空 (既定) のとき、ジョブは停止されず、終了しようとしたことは |@ref{E947}| の結果を生じる。さもなければ、@{how@} はジョブに送られたシグナルが何であるかを明示する。値については |@ref{job_stop()}| を参照。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		After sending the signal Vim will wait for up to a second to
		check that the job actually stopped.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
シグナルが送られたあと、Vim はジョブが実際に停止するのを確認するまでの時間 (秒) 待機するだろう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_setrestore({buf}, {command})			*term_setrestore()*
		Set the command to write in a session file to restore the job
		in this terminal.  The line written in the session file is: >
			terminal ++curwin ++cols=%d ++rows=%d {command}
<		Make sure to escape the command properly.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_setrestore()}
@findex term_setrestore()
@item term_setrestore(@{buf@}, @{command@})
端末内のジョブを復帰するために、セッションファイル内に書き込むコマンドを設定する。セッションファイルに書き込まれる行は:
@verbatim
terminal ++curwin ++cols=%d ++rows=%d {command}
@end verbatim
コマンドが適切にエスケープされているか確認すること。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Use an empty {command} to run 'shell'.
		Use "NONE" to not restore this window.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'shell' を実行するには 空 @{command@} を使う。

このウィンドウを復帰しないようにするには "NONE" を使う。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_setsize({buf}, {rows}, {cols})		*term_setsize()* *E955*
		Set the size of terminal {buf}. The size of the window
		containing the terminal will also be adjusted, if possible.
		If {rows} or {cols} is zero or negative, that dimension is not
		changed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_setsize()}
@anchor{E955}
@findex term_setsize()
@erindex E955
@item term_setsize(@{buf@}, @{rows@}, @{cols@})
ターミナル @{buf@} のサイズを設定する。もしも可能ならターミナルを含んでいるウィンドウのサイズも調整されるだろう。もしも @{rows@} や @{cols@} がゼロかマイナスならば、サイズは変更されない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{buf} must be the buffer number of a terminal window.  Use an
		empty string for the current buffer.  If the buffer does not
		exist or is not a terminal window, an error is given.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{buf@} は端末ウィンドウのバッファ番号でなければならない。現在のバッファに適用するには空文字列を使う。もしもバッファが存在しないか端末ウィンドウでなければ、エラーになる。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_start({cmd} [, {options}])			*term_start()*
		Open a terminal window and run {cmd} in it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{term_start()}
@findex term_start()
@item term_start(@{cmd@} [, @{options@}])
ターミナルウィンドウを開きその中で @{cmd@} を起動する。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{cmd} can be a string or a List, like with |job_start()|. The
		string "NONE" can be used to open a terminal window without
		starting a job, the pty of the terminal can be used by a
		command like gdb.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{cmd@} は文字列もしくは |@ref{job_start()}| のようなリストになりうる。文字列 "NONE" はジョブを開始することなくターミナルウィンドウを開くのに使われる。ターミナルの pty は gdb のようなコマンドによって使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Returns the buffer number of the terminal window.  If {cmd}
		cannot be executed the window does open and shows an error
		message.
		If opening the window fails zero is returned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ターミナルウィンドウのバッファ番号を返す。@{cmd@} が実行できないときは、ウィンドウを開いてエラーメッセジを表示する。

ウィンドウを開くのに失敗すると 0 が返される。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		{options} are similar to what is used for |job_start()|, see
		|job-options|.  However, not all options can be used.  These
		are supported:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@{options@} は |@ref{job_start()}| で使われるものと似ている。|@ref{job-options}| を参照。しかしながら、すべてのオプションが使われるわけではない。次のものがサポートされている:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   all timeout options
		   "stoponexit", "cwd", "env"
		   "callback", "out_cb", "err_cb", "exit_cb", "close_cb"
		   "in_io", "in_top", "in_bot", "in_name", "in_buf"
		   "out_io", "out_name", "out_buf", "out_modifiable", "out_msg"
		   "err_io", "err_name", "err_buf", "err_modifiable", "err_msg"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
すべてのタイムアウトオプション
@example
"stoponexit", "cwd", "env"
"callback", "out_cb", "err_cb", "exit_cb", "close_cb"
"in_io", "in_top", "in_bot", "in_name", "in_buf"
"out_io", "out_name", "out_buf", "out_modifiable", "out_msg"
"err_io", "err_name", "err_buf", "err_modifiable", "err_msg"
@end example
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		However, at least one of stdin, stdout or stderr must be
		connected to the terminal.  When I/O is connected to the
		terminal then the callback function for that part is not used.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
少なくとも標準入力が 1 つであるが、標準出力か標準エラーはターミナルに接続されていなければならない。I/O がターミナルに接続されているときは、その部分のコールバック関数は使われない。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		There are extra options:
		   "term_name"	     name to use for the buffer name, instead
				     of the command name.
		   "term_rows"	     vertical size to use for the terminal,
				     instead of using 'termwinsize'
		   "term_cols"	     horizontal size to use for the terminal,
				     instead of using 'termwinsize'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
特別なオプションがある:
@multitable @columnfractions .3 .7
@item "term_name" @tab バッファ名に使う名前。コマンド名の代わり
@item "term_rows" @tab ターミナルで使う高さ。'@option{termwinsize}' の代わり
@item "term_cols" @tab ターミナルで使う幅。'@option{termwinsize}' の代わり
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "vertical"	     split the window vertically; note that
				     other window position can be defined with
				     command modifiers, such as |:belowright|.
		   "curwin"	     use the current window, do not split the
				     window; fails if the current buffer
				     cannot be |abandon|ed
		   "hidden"	     do not open a window
		   "norestore"	     do not add the terminal window to a
				     session file
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "vertical" @tab ウィンドウを垂直に分割する。
@quotation
@strong{Note:} @*
その他のウィンドウ位置は |@ref{:belowright}| のようなコマンド修飾子によって定義されうることに注意。
@end quotation
@item "curwin" @tab カレントウィンドウを使う。ウィンドウは分割しない。カレントバッファを放棄 |@ref{abandon}| できなければ失敗する
@item "hidden" @tab ウィンドウを開かない
@item "norestore" @tab セッションファイルのためにターミナルウィンドウを追加しない
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "term_kill"	     what to do when trying to close the
				     terminal window, see |term_setkill()|
		   "term_finish"     What to do when the job is finished:
					"close": close any windows
					"open": open window if needed
				     Note that "open" can be interruptive.
				     See |term++close| and |term++open|.
		   "term_opencmd"    command to use for opening the window when
				     "open" is used for "term_finish"; must
				     have "%d" where the buffer number goes,
				     e.g. "10split|buffer %d"; when not
				     specified "botright sbuf %d" is used
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "term_kill" @tab 端末ウィンドウを閉じようとしたときにすること。|@ref{term_setkill()}| を参照
@item "term_finish" @tab
ジョブが終了したときの処理:
@multitable @columnfractions .2 .8
@item "close": @tab すべてウィンドウを閉じる
@item "open": @tab 必要ならばウィンドウを開く
@end multitable
@quotation
@strong{Note:} @*
"open" は中断できることに注意。
@end quotation
|@ref{term++close}| と |@ref{term++open}| を参照。
@item "term_opencmd" @tab
"term_finish" のために "open" が使われるとき、ウィンドウを開くためのコマンド。バッファ番号の先に "%d" がなければならない。例えば "10split|buffer %d"。これが指定されていなければ、"botright sbuf %d" が使われる。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		   "eof_chars"	     Text to send after all buffer lines were
				     written to the terminal.  When not set
				     CTRL-D is used on MS-Windows. For Python
				     use CTRL-Z or "exit()". For a shell use
				     "exit".  A CR is always added.
		   "ansi_colors"     A list of 16 color names or hex codes
				     defining the ANSI palette used in GUI
				     color modes.  See |g:terminal_ansi_colors|.
		   "tty_type"	     (MS-Windows only): Specify which pty to
				     use.  See 'termwintype' for the values.

		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item "eof_chars" @tab
ターミナルに書き込まれるすべてのバッファ行のあとに送られるテキスト。これが設定されていないとき、MS-Windows では CTRL-D が使われる。Python では CTRL-Z か "exit()" が使われる。シェルでは "exit" が使われる。CR は常に付加される。
@item "ansi_colors" @tab
16 ANSI カラーの名前か GUI カラーモードで使われている ANSI パレットで定義されている 16 進数のカラーコードのリスト。|@ref{g:terminal_ansi_colors}| を参照
@item "tty_type" @tab
(MS-Windows のみ): 使用する pty を明示しまう。値については '@option{termwintype}' を参照してください。
@end multitable
@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
term_wait({buf} [, {time}])					*term_wait()*
		Wait for pending updates of {buf} to be handled.
		{buf} is used as with |term_getsize()|.
		{time} is how long to wait for updates to arrive in msec.  If
		not set then 10 msec will be used.
		{only available when compiled with the |+terminal| feature}
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item term_wait(@{buf@} [, @{time@}])
@anchor{term_wait()}
@findex term_wait()
処理する @{buf@} の更新を待つ。

@{buf@} は |@ref{term_getsize()}| として使われる。

@{time@} はアップデートまでのミリ秒。設定されていなければ 10 ミリ秒が使われる。

@{Vim が |@ref{+terminal}| 機能付きでコンパイルされたときのみ有効@}
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
3. Terminal communication			 *terminal-communication*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-communication}
@cindex terminal-communication
@section 3. 端末通信
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
There are several ways to communicate with the job running in a terminal:
- Use |term_sendkeys()| to send text and escape sequences from Vim to the job.
- Use the JSON API to send encoded commands from the job to Vim.
- Use the |client-server| mechanism. This works on machines with an X server
  and on MS-Windows.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
端末内で実行中のジョブと通信するには、いくつかの方法があります:
@itemize
@item |@ref{term_sendkeys()}| でテキストやエスケープシーケンスを Vim に送信する。
@item JSON API を使用して、エンコードされたコマンドをジョブから Vim に送信する。
@item |@ref{client-server}| 機構を使います。これは X server と MS-Windows のマシンで動作します。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Vim to job: term_sendkeys() ~
							*terminal-to-job*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-to-job}
@cindex terminal-to-job
@unnumberedsubsec Vim からジョブへ: term_sendkeys()
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This allows for remote controlling the job running in the terminal.  It is a
one-way mechanism.  The job can update the display to signal back to Vim.
For example, if a shell is running in a terminal, you can do: >
	call term_sendkeys(buf, "ls *.java\<CR>")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これにより、端末内で実行中のジョブをリモート制御することができます。これは一方向の機構です。ジョブは Vim に合図することで表示を更新することができます。例えば、シェルが端末内で実行されている場合、次の操作を実行できます:
@verbatim
call term_sendkeys(buf, "ls *.java\<CR>")
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This requires for the job to be in the right state where it will do the right
thing when receiving the keys.  For the above example, the shell must be
waiting for a command to be typed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは、キーを受け取ったときに正しいことをする適切な状態になるようなジョブを必要とします。上記の例では、シェルはコマンドの入力を待つ必要があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
For a job that was written for the purpose, you can use the JSON API escape
sequence in the other direction.  E.g.: >
	call term_sendkeys(buf, "\<Esc>]51;["response"]\x07")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この目的のために作成されたジョブでは、JSON API エスケープシーケンスを別の方向で使用できます。例:
@verbatim
call term_sendkeys(buf, "\<Esc>]51;["response"]\x07")
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Job to Vim: JSON API ~
							*terminal-api*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-api}
@cindex terminal-api
@unnumberedsubsec ジョブから Vim へ: JSON API
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
The job can send JSON to Vim, using a special escape sequence.  The JSON
encodes a command that Vim understands.  Example of such a message: >
	<Esc>]51;["drop", "README.md"]<07>
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブは特殊なエスケープシーケンスを使用して JSON を Vim に送ることができます。JSON は Vim が理解できるコマンドをエンコードします。そのようなメッセージの例:
@verbatim
<Esc>]51;["drop", "README.md"]<07>
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The body is always a list, making it easy to find the end: ]<07>.
The <Esc>]51;msg<07> sequence is reserved by xterm for "Emacs shell", which is
similar to what we are doing here.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
本体は常にリストになっており、終わりを見つけやすいです: @samp{]<07>}。@samp{<Esc>]51;msg<07>} シーケエンスは "Emacs shell" のために xterm によって予約されています。私たちがここでやっていることに似ています。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Currently supported commands:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsubsec 現在サポートされているコマンド:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	call {funcname} {argument}

		Call a user defined function with {argument}.
		The function is called with two arguments: the buffer number
		of the terminal and {argument}, the decoded JSON argument. 
		The function name must start with "Tapi_" to avoid
		accidentally calling a function not meant to be used for the
		terminal API.
		The user function should sanity check the argument.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@table @asis
@item call @{funcname@} @{argument@}
ユーザー定義関数を @{argument@} で呼び出します。関数は 2 つの引数で呼び出されます: 端末のバッファ番号とデコードされた JSON 引数 @{argument@} です。

関数名は端末 API 用に意図されていない関数を誤って呼び出すのを避けるため、"Tapi_" で始まる必要があります。

ユーザー関数は引数の正常性チェックをする必要があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		The function can use |term_sendkeys()| to send back a reply.
		Example in JSON: >
			["call", "Tapi_Impression", ["play", 14]]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
関数は |@ref{term_sendkeys()}| を使って返信を送り返すことができます。

JSON での例:
@verbatim
["call", "Tapi_Impression", ["play", 14]]
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		Calls a function defined like this: >
			function Tapi_Impression(bufnum, arglist)
			  if len(a:arglist) == 2
			    echomsg "impression " . a:arglist[0]
			    echomsg "count " . a:arglist[1]
			  endif
			endfunc
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次のように定義された関数を呼び出します:
@verbatim
function Tapi_Impression(bufnum, arglist)
  if len(a:arglist) == 2
    echomsg "impression " . a:arglist[0]
    echomsg "count " . a:arglist[1]
  endif
endfunc
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<		Output from `:echo` may be erased by a redraw, use `:echomsg`
		to be able to see it with `:messages`.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
`@command{:echo}` からの出力は再描画によって消去されかもしれません。`@command{:echomsg}` を使い、`@command{:messages}` でそれを見ることができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
	drop {filename} [options]

		Let Vim open a file, like the `:drop` command.  If {filename}
		is already open in a window, switch to that window.  Otherwise
		open a new window to edit {filename}.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item drop @{filename@} [options]
Vim に `@command{:drop}` コマンドのようにファイルを開かせます。もし、@{filename@} が既にウィンドウで開かれていたら、そのウィンドウに切り替えます。それ以外の場合は、@{filename@} を編集するための新しいウィンドウを開きます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		Note that both the job and Vim may change the current
		directory, thus it's best to use the full path.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@quotation
@strong{Note:} @*
ジョブと Vim の両方がカレントディレクトリを変更する可能性があるので、フルパスを使用することをお勧めします。
@end quotation
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		[options] is only used when opening a new window.  If present,
		it must be a Dict.  Similarly to |++opt|, These entries are
		recognized:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
[options] は新しくウィンドウを開いた時にだけ使われます。与える場合、それは辞書でなければなりません。|@ref{++opt}| と同様に、これらのエントリは認識されます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
		  "ff"		file format: "dos", "mac" or "unix"
		  "fileformat"	idem
		  "enc"		overrides 'fileencoding'
		  "encoding"	idem
		  "bin"		sets 'binary'
		  "binary"	idem
		  "nobin"	resets 'binary'
		  "nobinary"	idem
		  "bad"		specifies behavior for bad characters, see
				|++bad|
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item "ff" @tab ファイルフォーマット: "dos", "mac" もしくは "unix"
@item "fileformat" @tab 同上
@item "enc" @tab '@option{fileencoding}' を上書きします
@item "encoding" @tab 同上
@item "bin" @tab '@option{binary}' を設定します
@item "binary" @tab 同上
@item "nobin" @tab '@option{binary}' をリセットします
@item "nobinary" @tab 同上
@item "bad" @tab 不正な文字のための振る舞いを指定します。|@ref{++bad}| を参照
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
		Example in JSON: >
			["drop", "path/file.txt", {"ff": "dos"}]
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

JSON での例:
@verbatim
["drop", "path/file.txt", {"ff": "dos"}]
@end verbatim
@end table
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
A trick to have Vim send this escape sequence: >
	exe "set t_ts=\<Esc>]51; t_fs=\x07"
	let &titlestring = '["call","Tapi_TryThis",["hello",123]]'
	redraw
	set t_ts& t_fs&
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim にこのエスケープシーケエンスを送信させるトリック:
@verbatim
exe "set t_ts=\<Esc>]51; t_fs=\x07"
let &titlestring = '["call","Tapi_TryThis",["hello",123]]'
redraw
set t_ts& t_fs&
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Rationale: Why not allow for any command or expression?  Because that might
create a security problem.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
論理的根拠: コマンドや式を許可しないのはなぜですか？セキュリティ上の問題が生じる可能性があるためです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Using the client-server feature ~
						*terminal-client-server*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-client-server}
@cindex terminal-client-server
@unnumberedsubsec クライアントサーバー機能を使う
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This only works when v:servername is not empty.  If needed you can set it,
before opening the terminal, with: >
	call remote_startserver('vim-server')
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは v:servername が空ではない場合にのみ機能します。必要に応じて、端末を開く前に次のように設定することができます:
@verbatim
call remote_startserver('vim-server')
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
$VIM_SERVERNAME is set in the terminal to pass on the server name.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@env{$VIM_SERVERNAME} はサーバー名を渡すために端末内に設定されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In the job you can then do something like: >
	vim --servername $VIM_SERVERNAME --remote +123 some_file.c
This will open the file "some_file.c" and put the cursor on line 123.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ジョブでは、次のようなことをおこなうことができます:
@verbatim
vim --servername $VIM_SERVERNAME --remote +123 some_file.c
@end verbatim
これによりファイル "@file{some_file.c}" が開き、123 行目にカーソルが置かれます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
4. Remote testing					*terminal-testing*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-testing}
@cindex terminal-testing
@section 4. リモートテスト
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Most Vim tests execute a script inside Vim.  For some tests this does not
work, running the test interferes with the code being tested.  To avoid this
Vim is executed in a terminal window.  The test sends keystrokes to it and
inspects the resulting screen state.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim のほとんどのテストは Vim のなかでスクリプトを実行しています。テスト対象のコードと干渉してしまうような、幾つかのテストではこれは機能しません。これを避けるために端末ウィンドウ内でさらに Vim を実行しています。そのテストではキーストロークを端末に送信し、その結果として端末画面の状態が変わるのを検査します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Functions ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec 関数
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|term_sendkeys()|	send keystrokes to a terminal (not subject to tmap)
|term_wait()|		wait for screen to be updated
|term_scrape()|		inspect terminal screen
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item |@ref{term_sendkeys()}| @tab 端末にキーストロークを送信する (tmap の影響を受けない)
@item |@ref{term_wait()}| @tab 端末画面が更新されるのを待つ
@item |@ref{term_scrape()}| @tab 端末画面の内容を検査する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
==============================================================================
5. Diffing screen dumps					*terminal-diff*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-diff}
@cindex terminal-diff
@section 5. 画面ダンプの差分
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
In some cases it can be bothersome to test that Vim displays the right
characters on the screen.  E.g. with syntax highlighting.  To make this
simpler it is possible to take a screen dump of a terminal and compare it to
an expected screen dump.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
場合によっては、Vim が正しい文字を画面に表示するかどうかテストするのは面倒かもしれません。例えば、構文の強調表示。これを簡単にするために、端末の画面ダンプを取ってそれを予想される画面ダンプと比較することが可能です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Vim uses the window size, text, color and other attributes as displayed.  The
Vim screen size, font and other properties do not matter.  Therefore this
mechanism is portable across systems.  A conventional screenshot would reflect
all differences, including font size and family.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim はウィンドウのサイズ、テキスト、色、その他の属性を表示します。 Vim の画面サイズ、フォント、その他のプロパティは関係ありません。したがって、この機構はシステム間で移植可能です。従来のスクリーンショットでは、フォントサイズやフォントファミリーなど、すべての違いが反映されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Writing a screen dump test for Vim ~
							*terminal-dumptest*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-dumptest}
@cindex terminal-dumptest
@unnumberedsubsec Vim の画面ダンプテストを書く
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
For an example see the Test_syntax_c() function in
src/testdir/test_syntax.vim.  The main parts are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
例については、src/testdir/test_syntax.vim の Test_syntax_c() 関数を参照してください。主要な部分は:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Write a file you want to test with. This is useful for testing syntax
  highlighting.  You can also start Vim with en empty buffer.
- Run Vim in a terminal with a specific size.  The default is 20 lines of 75
  characters.  This makes sure the dump is always this size.  The function
  RunVimInTerminal() takes care of this.  Pass it the arguments for the Vim
  command.
- Send any commands to Vim using |term_sendkeys()|.  For example: >
	call term_sendkeys(buf, ":echo &lines &columns\<CR>")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item テストするファイルを作成します。構文のハイライトをテストするのに便利です。空のバッファで Vim を起動することもできます。
@item 特定のサイズの端末で Vim を実行します。デフォルトは 75 桁で 20 行です。これはダンプが常にこのサイズであることを確認します。RunVimInTerminal() 関数がこれを処理します。Vim コマンドの引数を渡します。
@item |@ref{term_sendkeys()}| を使用して任意のコマンドを Vim に送信します。例えば:
@verbatim
call term_sendkeys(buf, ":echo &lines &columns\<CR>")
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- Check that the screen is now in the expected state, using
  VerifyScreenDump().  This expects the reference screen dump to be in the
  src/testdir/dumps/ directory.  Pass the name without ".dump".  It is
  recommended to use the name of the test function and a sequence number, so
  that we know what test is using the file.
- Repeat sending commands and checking the state.
- Finally stop Vim by calling StopVimInTerminal().
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item VerifyScreenDump() を使用して、画面が期待どおりの状態になっていることを確認します。これは、参照する画面ダンプが src/testdir/dumps/ ディレクトリに存在することを前提としています。 ".dump" なしの名前を渡します。テスト関数の名前とシーケンス番号を使用してファイルがどのようなテストで使用されているかを知ることができます。
@item コマンド送信と状態の確認を繰り返します。
@item 最後に StopVimInTerminal() を呼び出して Vim を停止します。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The first time you do this you won't have a screen dump yet.  Create an empty
file for now, e.g.: >
	touch src/testdir/dumps/Test_function_name_01.dump
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
初めてこれを行うときにはスクリーンダンプはまだありません。空のファイルを作成します。例:
@verbatim
touch src/testdir/dumps/Test_function_name_01.dump
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The test will then fail, giving you the command to compare the reference dump
and the failed dump, e.g.: >
	call term_dumpdiff("Test_func.dump.failed", "dumps/Test_func.dump")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
テストが失敗したら、参照ダンプと失敗したダンプを比較するコマンドを提供します。例:
@verbatim
call term_dumpdiff("Test_func.dump.failed", "dumps/Test_func.dump")
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Use this command in Vim, with the current directory set to src/testdir.
Once you are satisfied with the test, move the failed dump in place of the
reference: >
	:!mv Test_func.dump.failed dumps/Test_func.dump
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
カレントディレクトリを src/testdir に設定して、Vim でこのコマンドを使用します。テストに満足したら、参照の代わりに失敗したダンプを移動します:
@verbatim
:!mv Test_func.dump.failed dumps/Test_func.dump
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Creating a screen dump ~
							*terminal-screendump*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-screendump}
@cindex terminal-screendump
@unnumberedsubsec 画面ダンプを作成する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To create the screen dump, run Vim (or any other program) in a terminal and
make it show the desired state.  Then use the |term_dumpwrite()| function to
create a screen dump file.  For example: >
	:call term_dumpwrite(77, "mysyntax.dump")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
画面ダンプを作成するには、端末で Vim (または他のプログラム) を実行し、目的の状態を表示させます。その後、|@ref{term_dumpwrite()}| 関数を使用して画面ダンプファイルを作成します。例:
@verbatim
:call term_dumpwrite(77, "mysyntax.dump")
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Here "77" is the buffer number of the terminal.  Use `:ls!` to see it.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この "77" は端末のバッファ番号です。それを見るためには `:ls!` を使用してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can view the screen dump with |term_dumpload()|: >
	:call term_dumpload("mysyntax.dump")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{term_dumpload()}| で画面ダンプを見ることができます:
@verbatim
:call term_dumpload("mysyntax.dump")
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To verify that Vim still shows exactly the same screen, run Vim again with
exactly the same way to show the desired state.  Then create a screen dump
again, using a different file name: >
	:call term_dumpwrite(88, "test.dump")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim がまったく同じ画面を表示していることを確認するには、まったく同じ方法で Vim を再度実行し、目的の状態を表示します。次に、別のファイル名を使用して画面ダンプを再度作成します:
@verbatim
:call term_dumpwrite(88, "test.dump")
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To assert that the files are exactly the same use |assert_equalfile()|: >
	call assert_equalfile("mysyntax.dump", "test.dump")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ファイルがまったく同じものであることを主張するには |@ref{assert_equalfile()}| を使います:
@verbatim
call assert_equalfile("mysyntax.dump", "test.dump")
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If there are differences then v:errors will contain the error message.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
違いがある場合、v:errors はエラーメッセージを含みます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Comparing screen dumps ~
						*terminal-diffscreendump*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-diffscreendump}
@cindex terminal-diffscreendump
@unnumberedsubsec 画面ダンプを比較する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
|assert_equalfile()| does not make it easy to see what is different.
To spot the problem use |term_dumpdiff()|: >
	call term_dumpdiff("mysyntax.dump", "test.dump")
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{assert_equalfile()}| は、何が違うのかを簡単に見分けることはできません。問題を見つけるには、|@ref{term_dumpdiff()}| を使用します:
@verbatim
call term_dumpdiff("mysyntax.dump", "test.dump")
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This will open a window consisting of three parts:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これで 3 つの部分からなるウィンドウが開きます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
1.  The contents of the first dump
2.  The difference between the first and second dump
3.  The contents of the second dump
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@enumerate
@item 1 番目のダンプの内容
@item 1 番目と 2 番目のダンプの差分
@item 2 番目のダンプの内容
@end enumerate
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can usually see what differs in the second part.  Use the 'ruler' to
relate it to the position in the first or second dump.  Letters indicate the
kind of difference:
	X	different character
	>	cursor in first but not in second
	<	cursor in second but not in first
	w	character width differs (single vs double width)
	f	foreground color differs
	b	background color differs
	a	attribute differs (bold, underline, reverse, etc.)
	?	character missing in both
	+	character missing in first
	-	character missing in second
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
通常、2 番目の部分で何が違うかを見ることができます。1 番目または 2 番目ダンプの位置に関連付けるには '@option{ruler}' を使用します。文字の意味は次のようになっている:
@multitable @columnfractions .1 .9
@item X @tab 文字の差異
@item >	@tab 1 番目にあって 2 番目にはないカーソル
@item <	@tab 2 番目にあって 1 番目にはないカーソル
@item w	@tab 文字幅の差異 (シングル対ダブル幅)
@item f	@tab 前景色の差異
@item b	@tab 背景色の差異
@item a	@tab 特徴の差異 (太字、下線、反転など)
@item ?	@tab どちらにもない文字
@item +	@tab 1 番目にはない文字
@item -	@tab 2 番目にはない文字
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Alternatively, press "s" to swap the first and second dump. Do this several
times so that you can spot the difference in the context of the text.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
あるいは、"s" を押して、1 番目と 2 番目のダンプを入れ替えます。これを何度か実行して、テキストの文脈における相違を見つけ出すことができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
==============================================================================
6. Debugging				*terminal-debug* *terminal-debugger*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{terminal-debug}
@anchor{terminal-debugger}
@cindex terminal-debug
@cindex terminal-debugger
@section 6. デバッグ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The Terminal debugging plugin can be used to debug a program with gdb and view
the source code in a Vim window.  Since this is completely contained inside
Vim this also works remotely over an ssh connection.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim のウィンドウでソースコードを表示しながらプログラムを gdb でデバッグするのに、端末デバッグプラグインが利用できます。これは Vim の中だけで完結するので、SSH 接続が 1 つあればリモートで機能します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the |+terminal| feature is missing, the plugin will use the "prompt"
buffer type, if possible.  The running program will then use a newly opened
terminal window.  See |termdebug-prompt| below for details.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{+terminal}| 機能がない場合、プラグインは可能であれば "prompt" バッファタイプを使用します。実行中のプログラムは、新しく開かれた端末ウィンドウを使用します。詳細は |@ref{termdebug-prompt}| を参照してください。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Starting ~
							*termdebug-starting*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug-starting}
@cindex termdebug-starting
@unnumberedsubsec はじめに
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Load the plugin with this command: >
	packadd termdebug
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
以下のコマンドでプラグインを読み込みます:
@verbatim
packadd termdebug
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<							*:Termdebug*
To start debugging use `:Termdebug` or `:TermdebugCommand` followed by the
command name, for example: >
	:Termdebug vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:Termdebug}
@pindex :Termdebug
デバッグを開始するには `@command{:TermDebug}` または `@command{:TermdebugCommand}` に続けてコマンド名を入力します。例:
@verbatim
:TermDebug vim
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This opens two windows:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これにより 2 つのウィンドウが開きます:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
gdb window	A terminal window in which "gdb vim" is executed.  Here you
		can directly interact with gdb.  The buffer name is "!gdb".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item gdb のウィンドウ @tab "gdb vim" を実行した端末ウィンドウ。ここでは直接 gdb とやりとりできる。バッファ名は "!gdb"
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
program window	A terminal window for the executed program.  When "run" is
		used in gdb the program I/O will happen in this window, so
		that it does not interfere with controlling gdb.  The buffer
		name is "gdb program".
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item プログラムのウィンドウ @tab 実行したプログラムの端末ウィンドウ。gdb 内で "run" をしてプログラムの I/O が発生するとこのウィンドウに反映される。その内容は gdb の制御下にない。バッファ名は "gdb program"
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The current window is used to show the source code.  When gdb pauses the
source file location will be displayed, if possible.  A sign is used to
highlight the current position, using highlight group debugPC.	 
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
現在のウィンドウはソースコードを表示するのに使われます。gdb が一時停止した際に、可能ならばその場所が表示されます。現在の位置を示すためにハイライトグループ debugPC を使ってサインが利用されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If the buffer in the current window is modified, another window will be opened
to display the current gdb position.  You can use `:Winbar` to add a window
toolbar there.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
現在のウィンドウの内容が変更されると、現在の gdb の位置を表示するために別のウィンドウが開きます。`@command{:Winbar}` を使ってウィンドウツールバーを追加することができます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Focus the terminal of the executed program to interact with it.  This works
the same as any command running in a terminal window.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
実行中のプログラムを操作するにはその端末にフォーカスを合わせます。以降の操作は普通の端末ウィンドウと同様です。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When the debugger ends, typically by typing "quit" in the gdb window, the two
opened windows are closed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デバッガの終了は、通常は gdb のウィンドウで "quit" とタイプすると、開いている 2 つのウィンドウが閉じられます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Only one debugger can be active at a time.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
一度にアクティブにできるデバッガは 1 つだけです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
							*:TermdebugCommand*
If you want to give specific commands to the command being debugged, you can
use the `:TermdebugCommand` command followed by the command name and
additional parameters. >
	:TermdebugCommand vim --clean -c ':set nu'
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:TermdebugCommand}
@pindex :TermdebugCommand
デバッグ中のコマンドに特定のコマンドを与える場合は、`@command{:TermdebugCommand}` コマンドの後にコマンド名と追加パラメータを使用できます。
@verbatim
:TermdebugCommand vim --clean -c ':set nu'
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Both the `:Termdebug` and `:TermdebugCommand` support an optional "!" bang
argument to start the command right away, without pausing at the gdb window
(and cursor will be in the debugged window).  For example: >
	:TermdebugCommand! vim --clean
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
`@command{:Termdebug}` と `@command{:TermdebugCommand}` はオプションの "!" をサポートしています。gdb ウィンドウで一時停止せずにコマンドをすぐに開始します (そしてカーソルはデバッグされたウィンドウに表示されます) 例えば:
@verbatim
:TermdebugCommand! vim --clean
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To attach gdb to an already running executable or use a core file, pass extra
arguments.  E.g.: >
	:Termdebug vim core
	:Termdebug vim 98343
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
すでに実行中の実行可能ファイルに gdb をアタッチするか、コアファイルを使用するには、追加の引数を渡します。例:
@verbatim
:Termdebug vim core
:Termdebug vim 98343
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If no argument is given, you'll end up in a gdb window, in which you need to
specify which command to run using e.g. the gdb `file` command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
引数が指定されていない場合、gdb ウィンドウが表示されます。このウィンドウでは、例えば gdb の `@command{file}` コマンドを使って、どのコマンドを実行するか指定する必要があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Example session ~
							*termdebug-example*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug-example}
@cindex termdebug-example
@unnumberedsubsec セッション例
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Start in the Vim "src" directory and build Vim: >
	% make
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim の "src" ディレクトリを起動して、Vim をビルドします:
@verbatim
% make
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Start Vim: >
	% ./vim

Load the termdebug plugin and start debugging Vim: >
	:packadd termdebug
	:Termdebug vim
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim を起動します:
@verbatim
% ./vim
@end verbatim
termdebug プラグインを読み込んで、Vim のデバッグを開始します:
@verbatim
:packadd termdebug
:Termdebug vim
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
You should now have three windows:
    source  - where you started, has a window toolbar with buttons
    gdb	    - you can type gdb commands here
    program - the executed program will use this window
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これで、3 つのウィンドウが表示されます:
@itemize
@item source  - 開始直後はボタン付きウィンドウツールバーがあります
@item gdb     - ここに gdb コマンドを入力できます
@item program - 実行されたプログラムはこのウィンドウを使用します
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can use CTRL-W CTRL-W or the mouse to move focus between windows.
Put focus on the gdb window and type: >
	break ex_help
	run
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@kbd{CTRL-W CTRL-W} またはマウスを使用して、ウィンドウ間でフォーカスを移動できます。gdbウィンドウにフォーカスを当てて、次のように入力します:
@verbatim
break ex_help
run
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Vim will start running in the program window. Put focus there and type: >
	:help gui
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim は programウィンドウで実行を開始します。そこにフォーカスを置いて入力します:
@verbatim
:help gui
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Gdb will run into the ex_help breakpoint.  The source window now shows the 
ex_cmds.c file.  A red "1 " marker will appear in the signcolumn where the
breakpoint was set.  The line where the debugger stopped is highlighted.  You
can now step through the program.  Let's use the mouse: click on the "Next"
button in the window toolbar.  You will see the highlighting move as the
debugger executes a line of source code.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Gdb は ex_help ブレークポイントまで実行します。source ウィンドウに @file{ex_cmds.c} ファイルが表示されます。ブレークポイントが設定されている目印欄に赤い "1 " のマーカーが表示されます。デバッガが停止した行が強調表示されます。今すぐプログラムを進めることができます。マウスを使いましょう: ウィンドウツールバーの "Next" ボタンをクリックしてください。デバッガがソースコードの行を実行すると、強調表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Click "Next" a few times until the for loop is highlighted.  Put the cursor on
the end of "eap->arg", then click "Eval" in the toolbar.  You will see this
displayed:
	"eap->arg": 0x555555e68855 "gui" ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
for ループが強調表示されるまで、"Next" を数回クリックします。カーソルを "eap->arg" の最後に置き、ツールバーの "Eval" をクリックします。これが表示されます:
@verbatim
"eap->arg": 0x555555e68855 "gui"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This way you can inspect the value of local variables.  You can also focus the
gdb window and use a "print" command, e.g.: >
	print *eap
If mouse pointer movements are working, Vim will also show a balloon when the
mouse rests on text that can be evaluated by gdb.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
こうすることで、ローカル変数の値を調べることができます。また、gdb ウィンドウにフォーカスを当てて、"print" コマンドを使用することもできます。例:
@verbatim
print *eap
@end verbatim
マウスポインタの動きがうまくいっていれば、マウスが gdb で評価できるテキストの上に置かれたときに Vim はバルーンを表示します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Now go back to the source window and put the cursor on the first line after
the for loop, then type: >
	:Break
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
次に、source ウィンドウに戻り、for ループの後の最初の行にカーソルを置いて、次のように入力します:
@verbatim
:Break
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
You will see a ">>" marker appear, this indicates the new breakpoint.  Now
click "Cont" in the toolbar and the code until the breakpoint will be
executed.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
新しいブレークポイントを示す ">>" マーカーが表示されます。ツールバーの "Cont" をクリックして、コードをブレークポイントまで実行させます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can type more advanced commands in the gdb window.  For example, type: >
	watch curbuf
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
より高度なコマンドを gdb ウィンドウに入力することができます。たとえば、次のように入力します:
@verbatim
watch curbuf
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Now click "Cont" in the toolbar (or type "cont" in the gdb window). Execution
will now continue until the value of "curbuf" changes, which is in do_ecmd().
To remove this watchpoint again type in the gdb window: >
	delete 3
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
ツールバーの "Cont" をクリックします (または、gdb ウィンドウで "cont" と入力します)。do_ecmd() にある "curbuf" の値が変更されるまで、実行が継続されます。このウォッチポイントを再度削除するには、gdb ウィンドウで次のように入力します:
@verbatim
delete 3
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can see the stack by typing in the gdb window: >
	where
Move through the stack frames, e.g. with: >
	frame 3
The source window will show the code, at the point where the call was made to
a deeper level.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
gdb ウィンドウに次のように入力すると、スタックが表示されます:
@verbatim
where
@end verbatim
スタックフレームを移動します。例えば:
@verbatim
frame 3
@end verbatim
source ウィンドウには、より深いレベルに呼び出された時点のコードが表示されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Stepping through code ~
							*termdebug-stepping*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug-stepping}
@cindex termdebug-stepping
@unnumberedsubsec コードをステップ実行する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
Put focus on the gdb window to type commands there.  Some common ones are:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
gdb ウィンドウにフォーカスを移しコマンドを入力します。一般的なものは以下:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- CTRL-C	interrupt the program
- next		execute the current line and stop at the next line
- step		execute the current line and stop at the next statement,
		entering functions
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item CTRL-C    プログラムを中断する
@item next      現在の行を実行し、次の行 (の手前) で停止する
@item step      現在の行を実行し、次の文 (の手前) で停止する。関数の内側に入る
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- finish	execute until leaving the current function
- where		show the stack
- frame N	go to the Nth stack frame
- continue	continue execution
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item finish    現在の関数を抜けるまで実行する
@item where     スタックを表示する
@item frame N   N 番目のスタックフレームに移動する
@item continue  実行を再開する
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*:Run* *:Arguments*
In the window showing the source code these commands can be used to control
gdb:
 `:Run` [args]	    run the program with [args] or the previous arguments
 `:Arguments` {args}  set arguments for the next `:Run`
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:Run}
@anchor{:Arguments}
@pindex :Run
@pindex :Arguments
ソースコードを表示しているウィンドウで、これらのコマンドを gdb の制御に使用できます:
@multitable @columnfractions .3 .7
@item `:Run` [args] @tab [args] または以前の引数でプログラムを実行します
@item `:Arguments` @{args@} @tab 次の `@command{:Run}` のために引数を設定します
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 *:Break*	set a breakpoint at the cursor position
 :Break {position}
		set a breakpoint at the specified position
 *:Clear*	delete the breakpoint at the cursor position
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:Break}
@pindex :Break
@item :Break @tab カーソル位置にブレークポイントを設定する
@item :Break @{position@} @tab 指定位置にブレークポイントを設定する
@anchor{:Clear}
@pindex :Clear
@item :Clear @tab カーソル位置ののブレークポイントを削除する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
 *:Step*	execute the gdb "step" command
 *:Over*	execute the gdb "next" command (`:Next` is a Vim command)
 *:Finish*	execute the gdb "finish" command
 *:Continue*	execute the gdb "continue" command
 *:Stop*	interrupt the program
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:Step}
@pindex :Step
@item :Step @tab gdb の "step" コマンドを実行する
@anchor{:Over}
@pindex :Over
@item :Over @tab gdb の "next" コマンドを実行する (`@command{:Next}` だと Vim のコマンドとかぶるので)
@anchor{:Finish}
@pindex :Finish
@item :Finish @tab gdb の "finish" コマンドを実行する
@anchor{:Continue}
@pindex :Continue
@item :Continue @tab gdb の "continue" コマンドを実行する
@anchor{:Stop}
@pindex :Stop
@item :Stop @tab プログラムを中断する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If 'mouse' is set the plugin adds a window toolbar with these entries:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{mouse}' が設定されている場合、プラグインはこれらのエントリを持つウィンドウツールバーを追加します:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
  Step		`:Step`
  Next		`:Over`
  Finish	`:Finish`
  Cont		`:Continue`
  Stop		`:Stop`
  Eval		`:Evaluate`
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@verbatim
Step          `:Step`
Next          `:Over`
Finish        `:Finish`
Cont          `:Continue`
Stop          `:Stop`
Eval          `:Evaluate`
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
This way you can use the mouse to perform the most common commands.  You need
to have the 'mouse' option set to enable mouse clicks.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
この方法で、マウスを使用して最も一般的なコマンドを実行できます。マウスのクリックを有効にするには、'@option{mouse}' オプションを設定する必要があります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
								*:Winbar*
You can add the window toolbar in other windows you open with: >
  :Winbar
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{:Winbar}
@pindex :Winbar
開いている他のウィンドウにウィンドウツールバーを追加することができます:
@verbatim
:Winbar
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
If gdb stops at a source line and there is no window currently showing the
source code, a new window will be created for the source code.  This also
happens if the buffer in the source code window has been modified and can't be
abandoned.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
gdb がソース行で停止し、現在ソースコードを表示しているウィンドウがない場合、ソースコード用の新しいウィンドウが作成されます。これは、ソースコードウィンドウのバッファが変更され、破棄できない場合でも発生します。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Gdb gives each breakpoint a number.  In Vim the number shows up in the sign
column, with a red background.  You can use these gdb commands:
- info break	list breakpoints
- delete N	delete breakpoint N
You can also use the `:Clear` command if the cursor is in the line with the
breakpoint, or use the "Clear breakpoint" right-click menu entry.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Gdb は各ブレークポイントに番号を与えます。Vim 内では、赤い背景で、目印欄に表示されます。次の gdb コマンドを使用できます。
@itemize
@item info break: ブレークポイントの一覧
@item delete N: ブレークポイント N を削除
@end itemize
また、カーソルがブレークポイントの行にある場合は `@command{:Clear}` コマンドを使うことができます。または、右クリックのメニュー項目 "Clear breakpoint" を使用することもできます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Inspecting variables ~
					*termdebug-variables* *:Evaluate*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug-variables}
@anchor{:Evaluate}
@cindex termdebug-variables
@pindex :Evaluate
@unnumberedsubsec 変数を検査する
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
 `:Evaluate`	    evaluate the expression under the cursor
 `K`		    same
 `:Evaluate` {expr}   evaluate {expr}
 `:'<,'>Evaluate`     evaluate the Visually selected text
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@item `:Evaluate` @tab カーソルの下の式を評価する
@item `K` @tab 上に同じ
@item `:Evaluate` @{expr@} @tab @{expr@} を評価する
@item `:'<,'>Evaluate` @tab ビジュアル選択したテキストを評価する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
This is similar to using "print" in the gdb window.
You can usually shorten `:Evaluate` to `:Ev`.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
これは gdb ウィンドウで "print" コマンドを使ったのに相当します。`:Evaluate` は `:Ev` に短縮できます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Other commands ~
							*termdebug-commands*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug-commands}
@cindex termdebug-commands
@unnumberedsubsec その他のコマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
 *:Gdb*	     jump to the gdb window
 *:Program*    jump to the window with the running program
 *:Source*     jump to the window with the source code, create it if there
	     isn't one
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@multitable @columnfractions .3 .7
@anchor{:Gdb}
@pindex :Gdb
@item :Gdb @tab gdb ウィンドウに移動する
@anchor{:Program}
@pindex :Program
@item :Program @tab デバッグ中のプログラムウィンドウに移動する
@anchor{:Source}
@pindex :Source
@item :Source @tab ソースコードのウィンドウに移動する。ウィンドウがなければ作成する
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Prompt mode ~
						*termdebug-prompt*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug-prompt}
@cindex termdebug-prompt
@unnumberedsubsec プロンプトモード
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
When the |+terminal| feature is not supported and on MS-Windows, gdb will run
in a buffer with 'buftype' set to "prompt".  This works slightly differently:
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
|@ref{+terminal}| 機能がサポートされていない場合や MS-Windows 上の場合、gdb は '@option{buftype}' が "@var{prompt}" に設定されたバッファで動作します。これは少し違った働きをします:
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The gdb window will be in Insert mode while typing commands.  Go to Normal
  mode with <Esc>, then you can move around in the buffer, copy/paste, etc.
  Go back to editing the gdb command with any command that starts Insert mode,
  such as `a` or `i`.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@itemize
@item コマンドを入力している間、gdb ウィンドウは挿入モードになります。<Esc> でノーマルモードにして、バッファ間を移動したり、コピー/ペーストなどをおこなうことができます。`@command{a}` や `@command{i}` のような挿入モードを開始するコマンドで gdb コマンドの編集に戻ります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
- The program being debugged will run in a separate window.  On MS-Windows
  this is a new console window.  On Unix, if the |+terminal| feature is
  available a Terminal window will be opened to run the debugged program in.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@item デバッグ中のプログラムは別のウィンドウで実行されます。MS-Windows では、これは新しいコンソールウィンドウです。Unix では、|@ref{+terminal}| 機能が利用可能な場合、端末ウィンドウが開いてデバッグされたプログラムを実行します。
@end itemize
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
						*termdebug_use_prompt*
Prompt mode can be used even when the |+terminal| feature is present with: >
	let g:termdebug_use_prompt = 1
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug_use_prompt}
@cindex termdebug_use_prompt
プロンプトモードは、|@ref{+terminal}| 機能が有効な場合でも使用できます:
@verbatim
let g:termdebug_use_prompt = 1
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Communication ~
						*termdebug-communication*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug-communication}
@cindex termdebug-communication
@unnumberedsubsec 通信
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
There is another, hidden, buffer, which is used for Vim to communicate with
gdb.  The buffer name is "gdb communication".  Do not delete this buffer, it
will break the debugger.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
Vim が gdb と通信するために他に隠されたバッファを利用します。バッファ名は "gdb communicate" です。このバッファは消さないでください。消してしまうとデバッガが動作しなくなってしまうでしょう。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
Gdb has some weird behavior, the plugin does its best to work around that.
For example, after typing "continue" in the gdb window a CTRL-C can be used to
interrupt the running program.  But after using the MI command
"-exec-continue"  pressing CTRL-C does not interrupt.  Therefore you will see
"continue" being used for the `:Continue` command, instead of using the
communication channel.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
gdb は奇妙な動作をしていますが、プラグインはその問題を回避するために最善を尽くしています。例えば、gdb ウィンドウで "continue" と入力した後に、@kbd{CTRL-C} を使用して実行中のプログラムを中断することができます。しかし、MI コマンド "-exec-continue" を使用した後、@kbd{CTRL-C} を押しても中断しません。したがって、通信チャネルを使用する代わりに、`@command{:Continue}` コマンドに "continue" が使用されていることがわかります。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Customizing ~
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@unnumberedsubsec カスタマイズ
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
GDB command						 *termdebug-customizing*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug-customizing}
@cindex termdebug-customizing
@unnumberedsubsubsec GDB コマンド
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To change the name of the gdb command, set the "termdebugger" variable before
invoking `:Termdebug`: >
	let termdebugger = "mygdb"
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
gdb コマンド以外のデバッガを使うには、 `@command{:Termdebug}` を実行する前に "@var{termdebugger}" 変数を変更してください:
@verbatim
let termdebugger = "mygdb"
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
<							*gdb-version*
Only debuggers fully compatible with gdb will work.  Vim uses the GDB/MI
interface.  The "new-ui" command  requires gdb version 7.12 or later.  if you
get this error:
	Undefined command: "new-ui". Try "help".~
Then your gdb is too old.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{gdb-version}
@cindex gdb-version
gdb と完全互換のあるデバッガのみが使えます。Vim は gdb の操作に GDB/MI インターフェイスを利用しています。"new-ui" コマンドは gdb バージョン 7.12 以降が必要です。このエラーが発生した場合:
@verbatim
Undefined command: "new-ui". Try "help".
@end verbatim
あなたの gdb が古すぎます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Colors						*hl-debugPC* *hl-debugBreakpoint*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{hl-debugPC}
@anchor{hl-debugBreakpoint}
@cindex hl-debugPC
@cindex hl-debugBreakpoint
@unnumberedsubsubsec カラー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The color of the signs can be adjusted with these highlight groups:
- debugPC		the current position
- debugBreakpoint	a breakpoint
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
サインの色は以下のハイライトグループで調整できます:
@multitable @columnfractions .4 .6
@item debugPC @tab 現在の位置
@item debugBreakpoint @tab ブレークポイント
@end multitable
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
The defaults are, when 'background' is "light":
  hi debugPC term=reverse ctermbg=lightblue guibg=lightblue
  hi debugBreakpoint term=reverse ctermbg=red guibg=red
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{background}' オプションが "@var{light}" の時のデフォルトは以下のとおりです:
@verbatim
hi debugPC term=reverse ctermbg=lightblue guibg=lightblue
hi debugBreakpoint term=reverse ctermbg=red guibg=red
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
When 'background' is "dark":
  hi debugPC term=reverse ctermbg=darkblue guibg=darkblue
  hi debugBreakpoint term=reverse ctermbg=red guibg=red
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
'@option{background}' オプションが "@var{dark}" の時は以下のとおりです:
@verbatim
hi debugPC term=reverse ctermbg=darkblue guibg=darkblue
hi debugBreakpoint term=reverse ctermbg=red guibg=red
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Shortcuts						*termdebug_shortcuts*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug_shortcuts}
@cindex termdebug_shortcuts
@unnumberedsubsubsec ショートカット
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
You can define your own shortcuts (mappings) to control gdb, that can work in
any window, using the TermDebugSendCommand() function.  Example: >
	map ,w :call TermDebugSendCommand('where')<CR>
The argument is the gdb command.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
TermDebugSendCommand() 関数を使用して、任意のウィンドウで動作する gdb を制御する独自のショートカット (マッピング) を定義できます。例:
@verbatim
map ,w :call TermDebugSendCommand('where')<CR>
@end verbatim
引数は gdb コマンドです。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Popup menu						*termdebug_popup*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug_popup}
@cindex termdebug_popup
@unnumberedsubsubsec ポップアップメニュー
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
By default the Termdebug plugin sets 'mousemodel' to "popup_setpos" and adds
these entries to the popup menu:
	Set breakpoint		`:Break`
	Clear breakpoint	`:Clear`
	Evaluate		`:Evaluate`
If you don't want this then disable it with: >
	let g:termdebug_popup = 0
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デフォルトで Termdebug プラグインは '@option{mousemodel}' を "@var{popup_setpos}" に設定し、これらのエントリをポップアップメニューに追加します:
@verbatim
Set breakpoint          `:Break`
Clear breakpoint        `:Clear`
Evaluate                `:Evaluate`
@end verbatim
あなたがこれを望まないならば、それを無効にしてください:
@verbatim
let g:termdebug_popup = 0
@end verbatim
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------


@ifset EN
Vim window width						*termdebug_wide*
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
@anchor{termdebug_wide}
@cindex termdebug_wide
@unnumberedsubsubsec Vim のウィンドウ幅
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------

@ifset EN
To change the width of the Vim window when debugging starts, and use a
vertical split: >
  let g:termdebug_wide = 163
This will set &columns to 163 when `:Termdebug` is used.  The value is restored
when quitting the debugger.
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------
デバッグを開始した際に Vim のウィンドウ幅を変更し、垂直分割を利用するには次のように設定します:
@verbatim
let g:termdebug_wide = 163
@end verbatim
これは `@command{:Termdebug}` を実行した際に &columns を 163 に設定します。元の値はデバッガが終了する際に復元されます。
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------
@ifset EN
If g:termdebug_wide is set and &columns is already larger than
g:termdebug_wide then a vertical split will be used without changing &columns.
Set it to 1 to get a vertical split without every changing &columns (useful
for when the terminal can't be resized by Vim).
@end ifset
@ifset JA  @c ----------- v -----------  JA  ----------- v -----------

g:termdebug_wide が設定されていて、&columns がすでに g:termdebug_wide より大きい場合、&columns を変更せずに垂直分割が使用されます。&columns を変更せずに垂直分割を行うには、1 に設定します。(端末が Vim によってサイズ変更できない場合に便利です)
@end ifset @c ----------- ^ -----------  JA  ----------- ^ -----------



@ifset EN
 vim:tw=78:ts=8:noet:ft=help:norl:
@end ifset
